

// SFW - Simple Framework - https://github.com/Relintai/sfw

// Simple c++ app / game framework inspired by the single file c game engines
// and libraries, especially [FWK](https://github.com/r-lyeh/FWK).

// MODULES:
// CORE + OBJECT + RENDER CORE + RENDER IMMEDIATE + RENDER OBJECTS

// LICENSES:

/*
SFW - (MIT)

Copyright (c) 2023-present Péter Magyar.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// This Library uses code from the following projects:

// Pandemonium Engine (MIT)

/*************************************************************************/
/*                     PANDEMONIUM ENGINE LICENSE                        */
/*             https://github.com/Relintai/pandemonium_engine            */
/*************************************************************************/
/* Copyright (c) 2022-present Péter Magyar.                              */
/* Copyright (c) 2014-2022 Godot Engine contributors (cf. AUTHORS.md).   */
/* Copyright (c) 2007-2022 Juan Linietsky, Ariel Manzur.                 */
/*                                                                       */
/* Permission is hereby granted, free of charge, to any person obtaining */
/* a copy of this software and associated documentation files (the       */
/* "Software"), to deal in the Software without restriction, including   */
/* without limitation the rights to use, copy, modify, merge, publish,   */
/* distribute, sublicense, and/or sell copies of the Software, and to    */
/* permit persons to whom the Software is furnished to do so, subject to */
/* the following conditions:                                             */
/*                                                                       */
/* The above copyright notice and this permission notice shall be        */
/* included in all copies or substantial portions of the Software.       */
/*                                                                       */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
/*************************************************************************/

// FWK

//https://github.com/r-lyeh/FWK

/*

Unlicense

This software is released into the [public domain](https://unlicense.org/).
Also dual-licensed as [0-BSD](https://opensource.org/licenses/0BSD) or [MIT (No Attribution)](https://github.com/aws/mit-0)
for those countries where public domain is a concern (sigh).
Any contribution to this repository is implicitly subjected to the same release conditions aforementioned.

*/

// Trantor

//inet_address.h, .cpp, socket.h and .cpp originates from trantor (they were heavily modified):

// Trantor - A non-blocking I/O based TCP network library, using C++14/17,
// Copyright (c) 2016-2021, Tao An.  All rights reserved.
// https://github.com/an-tao/trantor
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//   * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//   * Neither the name of Tao An nor the names of other contributors
// may be used to endorse or promote products derived from this software
// without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Muduo - A reactor-based C++ network library for Linux
// Copyright (c) 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//   * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//   * Neither the name of Shuo Chen nor the names of other contributors
// may be used to endorse or promote products derived from this software
// without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// PCG

// pcg.h's License:

// *Really* minimal PCG32 code / (c) 2014 M.E. O'Neill / pcg-random.org
// Licensed under Apache License 2.0 (NO WARRANTY, etc. see website)

// This library uses the glad OpenGL Loader

//https://glad.dav1d.de/

// GLFW

//https://github.com/glfw/glfw

/*************************************************************************
 * GLFW 3.3.7 - www.glfw.org
 * A library for OpenGL, window and input
 *------------------------------------------------------------------------
 * Copyright (c) 2002-2006 Marcus Geelnard
 * Copyright (c) 2006-2019 Camilla Löwy <elmindreda@glfw.org>
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would
 *    be appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 * 3. This notice may not be removed or altered from any source
 *    distribution.
 *
 *************************************************************************/

// STB Single Header Libraries

//https://github.com/nothings/stb

// 3rd_stb_image_write.h
// 3rd_stb_image.h
// 3rd_stb_truetype.h

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

// Font

// bm-mini.zip (public domain font)
// http://bitmapmania.m78.com
// cooz@m78.com

// Font Data Tables

// The data tables are coming from Dear Imgui.
// Re-licensed under permission as MIT-0.

// Original License:

// https://github.com/ocornut/imgui

/*
The MIT License (MIT)

Copyright (c) 2014-2024 Omar Cornut

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <wchar.h>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <ctime>

#if !defined(_WIN64) && !defined(_WIN32)
#include <sys/time.h>
#include <unistd.h>
#endif

#ifndef SFW_H

#ifdef __APPLE__
#ifndef _APPLE_NO_IMPL_
#define _APPLE_NO_IMPL_
#endif //_APPLE_NO_IMPL_
#endif //__APPLE__

#include "sfw.h"

#ifdef __APPLE__
#undef ONLY_GLAD
#include "sfw_3rd.m"
#endif //__APPLE__

#endif //SFW_H

// On OSX sfw_3rd.m has to be compiled manually on Objective C Mode.
#ifndef __APPLE__

#ifndef SFW_3RD_IMPL
#define SFW_3RD_IMPL

#if defined(__linux__)
//typedef XID Font;
#define Font The_Font_I_dont_care
#endif

// Note: On Windows we need to make sure that
// GLFW includes it's needed windows headers first, as it has quite a bit of setup.
// Also windows headers can define quite a bit of stuff like far and near macros
// Wee need to make sure it's safe to undo those as soon as possible
// This means that <windows.h> cannot be included in sfw.h if rendering is enabled.
// Also since it pull in lots of defines it probably shouldn't anyway.
#undef ONLY_GLAD
#include "sfw_3rd.m"

#undef CursorShape

#if defined(__linux__)
#undef Font
#undef KEY_ESC
#undef KEY_TICK
#undef KEY_1
#undef KEY_2
#undef KEY_3
#undef KEY_4
#undef KEY_5
#undef KEY_6
#undef KEY_7
#undef KEY_8
#undef KEY_9
#undef KEY_0
#undef KEY_BS
#undef KEY_TAB
#undef KEY_Q
#undef KEY_W
#undef KEY_E
#undef KEY_R
#undef KEY_T
#undef KEY_Y
#undef KEY_U
#undef KEY_I
#undef KEY_O
#undef KEY_P
#undef KEY_CAPS
#undef KEY_A
#undef KEY_S
#undef KEY_D
#undef KEY_F
#undef KEY_G
#undef KEY_H
#undef KEY_J
#undef KEY_K
#undef KEY_L
#undef KEY_ENTER
#undef KEY_LSHIFT
#undef KEY_Z
#undef KEY_X
#undef KEY_C
#undef KEY_V
#undef KEY_B
#undef KEY_N
#undef KEY_M
#undef KEY_RSHIFT
#undef KEY_UP
#undef KEY_LCTRL
#undef KEY_LALT
#undef KEY_SPACE
#undef KEY_RALT
#undef KEY_RCTRL
#undef KEY_LEFT
#undef KEY_DOWN
#undef KEY_RIGHT
#undef KEY_INS
#undef KEY_HOME
#undef KEY_PGUP
#undef KEY_DEL
#undef KEY_END
#undef KEY_PGDN
#undef KEY_LMETA
#undef KEY_RMETA
#undef KEY_MENU
#undef KEY_PRINT
#undef KEY_PAUSE
#undef KEY_SCROLL
#undef KEY_NUMLOCK
#undef KEY_MINUS
#undef KEY_EQUAL
#undef KEY_LSQUARE
#undef KEY_RSQUARE
#undef KEY_SEMICOLON
#undef KEY_QUOTE
#undef KEY_HASH
#undef KEY_BAR
#undef KEY_COMMA
#undef KEY_DOT
#undef KEY_SLASH
#undef KEY_F1
#undef KEY_F2
#undef KEY_F3
#undef KEY_F4
#undef KEY_F5
#undef KEY_F6
#undef KEY_F7
#undef KEY_F8
#undef KEY_F9
#undef KEY_F10
#undef KEY_F11
#undef KEY_F12
#undef KEY_PAD1
#undef KEY_PAD2
#undef KEY_PAD3
#undef KEY_PAD4
#undef KEY_PAD5
#undef KEY_PAD6
#undef KEY_PAD7
#undef KEY_PAD8
#undef KEY_PAD9
#undef KEY_PAD0
#undef KEY_PADADD
#undef KEY_PADSUB
#undef KEY_PADMUL
#undef KEY_PADDIV
#undef KEY_PADDOT
#undef KEY_PADENTER
#undef MOUSE_L
#undef MOUSE_M
#undef MOUSE_R
#undef GAMEPAD_CONNECTED
#undef GAMEPAD_A
#undef GAMEPAD_B
#undef GAMEPAD_X
#undef GAMEPAD_Y
#undef GAMEPAD_UP
#undef GAMEPAD_DOWN
#undef GAMEPAD_LEFT
#undef GAMEPAD_RIGHT
#undef GAMEPAD_MENU
#undef GAMEPAD_START
#undef GAMEPAD_LB
#undef GAMEPAD_RB
#undef GAMEPAD_LTHUMB
#undef GAMEPAD_RTHUMB
#undef WINDOW_BLUR
#undef WINDOW_FOCUS
#undef WINDOW_CLOSE
#undef WINDOW_MINIMIZE
#undef WINDOW_MAXIMIZE
#undef WINDOW_FULLSCREEN
#undef WINDOW_WINDOWED
#undef GAMEPAD_LPAD
#undef GAMEPAD_LPAD
#undef GAMEPAD_LPADY
#undef GAMEPAD_RPAD
#undef GAMEPAD_RPAD
#undef GAMEPAD_RPADY
#undef GAMEPAD_LT
#undef GAMEPAD_RT
#undef GAMEPAD_BATTERY
#undef MOUSE
#undef MOUSE
#undef MOUSE_Y
#undef MOUSE_W
#undef TOUCH_X1
#undef TOUCH_Y1
#undef TOUCH_X2
#undef TOUCH_Y2
#undef WINDOW_RESIZE
#undef WINDOW_RESIZE
#undef WINDOW_RESIZEY
#undef WINDOW_ORIENTATION
#undef WINDOW_BATTERY
#undef GAMEPAD_GUID
#undef GAMEPAD_NAME
#endif

#endif //SFW_3RD_IMPL

#endif // #ifndef __APPLE__

//===================  CORE SECTION  ===================

#line 1 "sfw/core/ucaps.h"

/*************************************************************************/
/*  ucaps.h                                                              */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

//satan invented unicode?
#define CAPS_LEN 666

static const int caps_table[CAPS_LEN][2] = {
	{ 0x0061, 0x0041 },
	{ 0x0062, 0x0042 },
	{ 0x0063, 0x0043 },
	{ 0x0064, 0x0044 },
	{ 0x0065, 0x0045 },
	{ 0x0066, 0x0046 },
	{ 0x0067, 0x0047 },
	{ 0x0068, 0x0048 },
	{ 0x0069, 0x0049 },
	{ 0x006A, 0x004A },
	{ 0x006B, 0x004B },
	{ 0x006C, 0x004C },
	{ 0x006D, 0x004D },
	{ 0x006E, 0x004E },
	{ 0x006F, 0x004F },
	{ 0x0070, 0x0050 },
	{ 0x0071, 0x0051 },
	{ 0x0072, 0x0052 },
	{ 0x0073, 0x0053 },
	{ 0x0074, 0x0054 },
	{ 0x0075, 0x0055 },
	{ 0x0076, 0x0056 },
	{ 0x0077, 0x0057 },
	{ 0x0078, 0x0058 },
	{ 0x0079, 0x0059 },
	{ 0x007A, 0x005A },
	{ 0x00E0, 0x00C0 },
	{ 0x00E1, 0x00C1 },
	{ 0x00E2, 0x00C2 },
	{ 0x00E3, 0x00C3 },
	{ 0x00E4, 0x00C4 },
	{ 0x00E5, 0x00C5 },
	{ 0x00E6, 0x00C6 },
	{ 0x00E7, 0x00C7 },
	{ 0x00E8, 0x00C8 },
	{ 0x00E9, 0x00C9 },
	{ 0x00EA, 0x00CA },
	{ 0x00EB, 0x00CB },
	{ 0x00EC, 0x00CC },
	{ 0x00ED, 0x00CD },
	{ 0x00EE, 0x00CE },
	{ 0x00EF, 0x00CF },
	{ 0x00F0, 0x00D0 },
	{ 0x00F1, 0x00D1 },
	{ 0x00F2, 0x00D2 },
	{ 0x00F3, 0x00D3 },
	{ 0x00F4, 0x00D4 },
	{ 0x00F5, 0x00D5 },
	{ 0x00F6, 0x00D6 },
	{ 0x00F8, 0x00D8 },
	{ 0x00F9, 0x00D9 },
	{ 0x00FA, 0x00DA },
	{ 0x00FB, 0x00DB },
	{ 0x00FC, 0x00DC },
	{ 0x00FD, 0x00DD },
	{ 0x00FE, 0x00DE },
	{ 0x00FF, 0x0178 },
	{ 0x0101, 0x0100 },
	{ 0x0103, 0x0102 },
	{ 0x0105, 0x0104 },
	{ 0x0107, 0x0106 },
	{ 0x0109, 0x0108 },
	{ 0x010B, 0x010A },
	{ 0x010D, 0x010C },
	{ 0x010F, 0x010E },
	{ 0x0111, 0x0110 },
	{ 0x0113, 0x0112 },
	{ 0x0115, 0x0114 },
	{ 0x0117, 0x0116 },
	{ 0x0119, 0x0118 },
	{ 0x011B, 0x011A },
	{ 0x011D, 0x011C },
	{ 0x011F, 0x011E },
	{ 0x0121, 0x0120 },
	{ 0x0123, 0x0122 },
	{ 0x0125, 0x0124 },
	{ 0x0127, 0x0126 },
	{ 0x0129, 0x0128 },
	{ 0x012B, 0x012A },
	{ 0x012D, 0x012C },
	{ 0x012F, 0x012E },
	{ 0x0131, 0x0049 },
	{ 0x0133, 0x0132 },
	{ 0x0135, 0x0134 },
	{ 0x0137, 0x0136 },
	{ 0x013A, 0x0139 },
	{ 0x013C, 0x013B },
	{ 0x013E, 0x013D },
	{ 0x0140, 0x013F },
	{ 0x0142, 0x0141 },
	{ 0x0144, 0x0143 },
	{ 0x0146, 0x0145 },
	{ 0x0148, 0x0147 },
	{ 0x014B, 0x014A },
	{ 0x014D, 0x014C },
	{ 0x014F, 0x014E },
	{ 0x0151, 0x0150 },
	{ 0x0153, 0x0152 },
	{ 0x0155, 0x0154 },
	{ 0x0157, 0x0156 },
	{ 0x0159, 0x0158 },
	{ 0x015B, 0x015A },
	{ 0x015D, 0x015C },
	{ 0x015F, 0x015E },
	{ 0x0161, 0x0160 },
	{ 0x0163, 0x0162 },
	{ 0x0165, 0x0164 },
	{ 0x0167, 0x0166 },
	{ 0x0169, 0x0168 },
	{ 0x016B, 0x016A },
	{ 0x016D, 0x016C },
	{ 0x016F, 0x016E },
	{ 0x0171, 0x0170 },
	{ 0x0173, 0x0172 },
	{ 0x0175, 0x0174 },
	{ 0x0177, 0x0176 },
	{ 0x017A, 0x0179 },
	{ 0x017C, 0x017B },
	{ 0x017E, 0x017D },
	{ 0x0183, 0x0182 },
	{ 0x0185, 0x0184 },
	{ 0x0188, 0x0187 },
	{ 0x018C, 0x018B },
	{ 0x0192, 0x0191 },
	{ 0x0199, 0x0198 },
	{ 0x01A1, 0x01A0 },
	{ 0x01A3, 0x01A2 },
	{ 0x01A5, 0x01A4 },
	{ 0x01A8, 0x01A7 },
	{ 0x01AD, 0x01AC },
	{ 0x01B0, 0x01AF },
	{ 0x01B4, 0x01B3 },
	{ 0x01B6, 0x01B5 },
	{ 0x01B9, 0x01B8 },
	{ 0x01BD, 0x01BC },
	{ 0x01C6, 0x01C4 },
	{ 0x01C9, 0x01C7 },
	{ 0x01CC, 0x01CA },
	{ 0x01CE, 0x01CD },
	{ 0x01D0, 0x01CF },
	{ 0x01D2, 0x01D1 },
	{ 0x01D4, 0x01D3 },
	{ 0x01D6, 0x01D5 },
	{ 0x01D8, 0x01D7 },
	{ 0x01DA, 0x01D9 },
	{ 0x01DC, 0x01DB },
	{ 0x01DF, 0x01DE },
	{ 0x01E1, 0x01E0 },
	{ 0x01E3, 0x01E2 },
	{ 0x01E5, 0x01E4 },
	{ 0x01E7, 0x01E6 },
	{ 0x01E9, 0x01E8 },
	{ 0x01EB, 0x01EA },
	{ 0x01ED, 0x01EC },
	{ 0x01EF, 0x01EE },
	{ 0x01F3, 0x01F1 },
	{ 0x01F5, 0x01F4 },
	{ 0x01FB, 0x01FA },
	{ 0x01FD, 0x01FC },
	{ 0x01FF, 0x01FE },
	{ 0x0201, 0x0200 },
	{ 0x0203, 0x0202 },
	{ 0x0205, 0x0204 },
	{ 0x0207, 0x0206 },
	{ 0x0209, 0x0208 },
	{ 0x020B, 0x020A },
	{ 0x020D, 0x020C },
	{ 0x020F, 0x020E },
	{ 0x0211, 0x0210 },
	{ 0x0213, 0x0212 },
	{ 0x0215, 0x0214 },
	{ 0x0217, 0x0216 },
	{ 0x0253, 0x0181 },
	{ 0x0254, 0x0186 },
	{ 0x0257, 0x018A },
	{ 0x0258, 0x018E },
	{ 0x0259, 0x018F },
	{ 0x025B, 0x0190 },
	{ 0x0260, 0x0193 },
	{ 0x0263, 0x0194 },
	{ 0x0268, 0x0197 },
	{ 0x0269, 0x0196 },
	{ 0x026F, 0x019C },
	{ 0x0272, 0x019D },
	{ 0x0275, 0x019F },
	{ 0x0283, 0x01A9 },
	{ 0x0288, 0x01AE },
	{ 0x028A, 0x01B1 },
	{ 0x028B, 0x01B2 },
	{ 0x0292, 0x01B7 },
	{ 0x03AC, 0x0386 },
	{ 0x03AD, 0x0388 },
	{ 0x03AE, 0x0389 },
	{ 0x03AF, 0x038A },
	{ 0x03B1, 0x0391 },
	{ 0x03B2, 0x0392 },
	{ 0x03B3, 0x0393 },
	{ 0x03B4, 0x0394 },
	{ 0x03B5, 0x0395 },
	{ 0x03B6, 0x0396 },
	{ 0x03B7, 0x0397 },
	{ 0x03B8, 0x0398 },
	{ 0x03B9, 0x0399 },
	{ 0x03BA, 0x039A },
	{ 0x03BB, 0x039B },
	{ 0x03BC, 0x039C },
	{ 0x03BD, 0x039D },
	{ 0x03BE, 0x039E },
	{ 0x03BF, 0x039F },
	{ 0x03C0, 0x03A0 },
	{ 0x03C1, 0x03A1 },
	{ 0x03C3, 0x03A3 },
	{ 0x03C4, 0x03A4 },
	{ 0x03C5, 0x03A5 },
	{ 0x03C6, 0x03A6 },
	{ 0x03C7, 0x03A7 },
	{ 0x03C8, 0x03A8 },
	{ 0x03C9, 0x03A9 },
	{ 0x03CA, 0x03AA },
	{ 0x03CB, 0x03AB },
	{ 0x03CC, 0x038C },
	{ 0x03CD, 0x038E },
	{ 0x03CE, 0x038F },
	{ 0x03E3, 0x03E2 },
	{ 0x03E5, 0x03E4 },
	{ 0x03E7, 0x03E6 },
	{ 0x03E9, 0x03E8 },
	{ 0x03EB, 0x03EA },
	{ 0x03ED, 0x03EC },
	{ 0x03EF, 0x03EE },
	{ 0x0430, 0x0410 },
	{ 0x0431, 0x0411 },
	{ 0x0432, 0x0412 },
	{ 0x0433, 0x0413 },
	{ 0x0434, 0x0414 },
	{ 0x0435, 0x0415 },
	{ 0x0436, 0x0416 },
	{ 0x0437, 0x0417 },
	{ 0x0438, 0x0418 },
	{ 0x0439, 0x0419 },
	{ 0x043A, 0x041A },
	{ 0x043B, 0x041B },
	{ 0x043C, 0x041C },
	{ 0x043D, 0x041D },
	{ 0x043E, 0x041E },
	{ 0x043F, 0x041F },
	{ 0x0440, 0x0420 },
	{ 0x0441, 0x0421 },
	{ 0x0442, 0x0422 },
	{ 0x0443, 0x0423 },
	{ 0x0444, 0x0424 },
	{ 0x0445, 0x0425 },
	{ 0x0446, 0x0426 },
	{ 0x0447, 0x0427 },
	{ 0x0448, 0x0428 },
	{ 0x0449, 0x0429 },
	{ 0x044A, 0x042A },
	{ 0x044B, 0x042B },
	{ 0x044C, 0x042C },
	{ 0x044D, 0x042D },
	{ 0x044E, 0x042E },
	{ 0x044F, 0x042F },
	{ 0x0451, 0x0401 },
	{ 0x0452, 0x0402 },
	{ 0x0453, 0x0403 },
	{ 0x0454, 0x0404 },
	{ 0x0455, 0x0405 },
	{ 0x0456, 0x0406 },
	{ 0x0457, 0x0407 },
	{ 0x0458, 0x0408 },
	{ 0x0459, 0x0409 },
	{ 0x045A, 0x040A },
	{ 0x045B, 0x040B },
	{ 0x045C, 0x040C },
	{ 0x045E, 0x040E },
	{ 0x045F, 0x040F },
	{ 0x0461, 0x0460 },
	{ 0x0463, 0x0462 },
	{ 0x0465, 0x0464 },
	{ 0x0467, 0x0466 },
	{ 0x0469, 0x0468 },
	{ 0x046B, 0x046A },
	{ 0x046D, 0x046C },
	{ 0x046F, 0x046E },
	{ 0x0471, 0x0470 },
	{ 0x0473, 0x0472 },
	{ 0x0475, 0x0474 },
	{ 0x0477, 0x0476 },
	{ 0x0479, 0x0478 },
	{ 0x047B, 0x047A },
	{ 0x047D, 0x047C },
	{ 0x047F, 0x047E },
	{ 0x0481, 0x0480 },
	{ 0x0491, 0x0490 },
	{ 0x0493, 0x0492 },
	{ 0x0495, 0x0494 },
	{ 0x0497, 0x0496 },
	{ 0x0499, 0x0498 },
	{ 0x049B, 0x049A },
	{ 0x049D, 0x049C },
	{ 0x049F, 0x049E },
	{ 0x04A1, 0x04A0 },
	{ 0x04A3, 0x04A2 },
	{ 0x04A5, 0x04A4 },
	{ 0x04A7, 0x04A6 },
	{ 0x04A9, 0x04A8 },
	{ 0x04AB, 0x04AA },
	{ 0x04AD, 0x04AC },
	{ 0x04AF, 0x04AE },
	{ 0x04B1, 0x04B0 },
	{ 0x04B3, 0x04B2 },
	{ 0x04B5, 0x04B4 },
	{ 0x04B7, 0x04B6 },
	{ 0x04B9, 0x04B8 },
	{ 0x04BB, 0x04BA },
	{ 0x04BD, 0x04BC },
	{ 0x04BF, 0x04BE },
	{ 0x04C2, 0x04C1 },
	{ 0x04C4, 0x04C3 },
	{ 0x04C8, 0x04C7 },
	{ 0x04CC, 0x04CB },
	{ 0x04D1, 0x04D0 },
	{ 0x04D3, 0x04D2 },
	{ 0x04D5, 0x04D4 },
	{ 0x04D7, 0x04D6 },
	{ 0x04D9, 0x04D8 },
	{ 0x04DB, 0x04DA },
	{ 0x04DD, 0x04DC },
	{ 0x04DF, 0x04DE },
	{ 0x04E1, 0x04E0 },
	{ 0x04E3, 0x04E2 },
	{ 0x04E5, 0x04E4 },
	{ 0x04E7, 0x04E6 },
	{ 0x04E9, 0x04E8 },
	{ 0x04EB, 0x04EA },
	{ 0x04EF, 0x04EE },
	{ 0x04F1, 0x04F0 },
	{ 0x04F3, 0x04F2 },
	{ 0x04F5, 0x04F4 },
	{ 0x04F9, 0x04F8 },
	{ 0x0561, 0x0531 },
	{ 0x0562, 0x0532 },
	{ 0x0563, 0x0533 },
	{ 0x0564, 0x0534 },
	{ 0x0565, 0x0535 },
	{ 0x0566, 0x0536 },
	{ 0x0567, 0x0537 },
	{ 0x0568, 0x0538 },
	{ 0x0569, 0x0539 },
	{ 0x056A, 0x053A },
	{ 0x056B, 0x053B },
	{ 0x056C, 0x053C },
	{ 0x056D, 0x053D },
	{ 0x056E, 0x053E },
	{ 0x056F, 0x053F },
	{ 0x0570, 0x0540 },
	{ 0x0571, 0x0541 },
	{ 0x0572, 0x0542 },
	{ 0x0573, 0x0543 },
	{ 0x0574, 0x0544 },
	{ 0x0575, 0x0545 },
	{ 0x0576, 0x0546 },
	{ 0x0577, 0x0547 },
	{ 0x0578, 0x0548 },
	{ 0x0579, 0x0549 },
	{ 0x057A, 0x054A },
	{ 0x057B, 0x054B },
	{ 0x057C, 0x054C },
	{ 0x057D, 0x054D },
	{ 0x057E, 0x054E },
	{ 0x057F, 0x054F },
	{ 0x0580, 0x0550 },
	{ 0x0581, 0x0551 },
	{ 0x0582, 0x0552 },
	{ 0x0583, 0x0553 },
	{ 0x0584, 0x0554 },
	{ 0x0585, 0x0555 },
	{ 0x0586, 0x0556 },
	{ 0x10D0, 0x10A0 },
	{ 0x10D1, 0x10A1 },
	{ 0x10D2, 0x10A2 },
	{ 0x10D3, 0x10A3 },
	{ 0x10D4, 0x10A4 },
	{ 0x10D5, 0x10A5 },
	{ 0x10D6, 0x10A6 },
	{ 0x10D7, 0x10A7 },
	{ 0x10D8, 0x10A8 },
	{ 0x10D9, 0x10A9 },
	{ 0x10DA, 0x10AA },
	{ 0x10DB, 0x10AB },
	{ 0x10DC, 0x10AC },
	{ 0x10DD, 0x10AD },
	{ 0x10DE, 0x10AE },
	{ 0x10DF, 0x10AF },
	{ 0x10E0, 0x10B0 },
	{ 0x10E1, 0x10B1 },
	{ 0x10E2, 0x10B2 },
	{ 0x10E3, 0x10B3 },
	{ 0x10E4, 0x10B4 },
	{ 0x10E5, 0x10B5 },
	{ 0x10E6, 0x10B6 },
	{ 0x10E7, 0x10B7 },
	{ 0x10E8, 0x10B8 },
	{ 0x10E9, 0x10B9 },
	{ 0x10EA, 0x10BA },
	{ 0x10EB, 0x10BB },
	{ 0x10EC, 0x10BC },
	{ 0x10ED, 0x10BD },
	{ 0x10EE, 0x10BE },
	{ 0x10EF, 0x10BF },
	{ 0x10F0, 0x10C0 },
	{ 0x10F1, 0x10C1 },
	{ 0x10F2, 0x10C2 },
	{ 0x10F3, 0x10C3 },
	{ 0x10F4, 0x10C4 },
	{ 0x10F5, 0x10C5 },
	{ 0x1E01, 0x1E00 },
	{ 0x1E03, 0x1E02 },
	{ 0x1E05, 0x1E04 },
	{ 0x1E07, 0x1E06 },
	{ 0x1E09, 0x1E08 },
	{ 0x1E0B, 0x1E0A },
	{ 0x1E0D, 0x1E0C },
	{ 0x1E0F, 0x1E0E },
	{ 0x1E11, 0x1E10 },
	{ 0x1E13, 0x1E12 },
	{ 0x1E15, 0x1E14 },
	{ 0x1E17, 0x1E16 },
	{ 0x1E19, 0x1E18 },
	{ 0x1E1B, 0x1E1A },
	{ 0x1E1D, 0x1E1C },
	{ 0x1E1F, 0x1E1E },
	{ 0x1E21, 0x1E20 },
	{ 0x1E23, 0x1E22 },
	{ 0x1E25, 0x1E24 },
	{ 0x1E27, 0x1E26 },
	{ 0x1E29, 0x1E28 },
	{ 0x1E2B, 0x1E2A },
	{ 0x1E2D, 0x1E2C },
	{ 0x1E2F, 0x1E2E },
	{ 0x1E31, 0x1E30 },
	{ 0x1E33, 0x1E32 },
	{ 0x1E35, 0x1E34 },
	{ 0x1E37, 0x1E36 },
	{ 0x1E39, 0x1E38 },
	{ 0x1E3B, 0x1E3A },
	{ 0x1E3D, 0x1E3C },
	{ 0x1E3F, 0x1E3E },
	{ 0x1E41, 0x1E40 },
	{ 0x1E43, 0x1E42 },
	{ 0x1E45, 0x1E44 },
	{ 0x1E47, 0x1E46 },
	{ 0x1E49, 0x1E48 },
	{ 0x1E4B, 0x1E4A },
	{ 0x1E4D, 0x1E4C },
	{ 0x1E4F, 0x1E4E },
	{ 0x1E51, 0x1E50 },
	{ 0x1E53, 0x1E52 },
	{ 0x1E55, 0x1E54 },
	{ 0x1E57, 0x1E56 },
	{ 0x1E59, 0x1E58 },
	{ 0x1E5B, 0x1E5A },
	{ 0x1E5D, 0x1E5C },
	{ 0x1E5F, 0x1E5E },
	{ 0x1E61, 0x1E60 },
	{ 0x1E63, 0x1E62 },
	{ 0x1E65, 0x1E64 },
	{ 0x1E67, 0x1E66 },
	{ 0x1E69, 0x1E68 },
	{ 0x1E6B, 0x1E6A },
	{ 0x1E6D, 0x1E6C },
	{ 0x1E6F, 0x1E6E },
	{ 0x1E71, 0x1E70 },
	{ 0x1E73, 0x1E72 },
	{ 0x1E75, 0x1E74 },
	{ 0x1E77, 0x1E76 },
	{ 0x1E79, 0x1E78 },
	{ 0x1E7B, 0x1E7A },
	{ 0x1E7D, 0x1E7C },
	{ 0x1E7F, 0x1E7E },
	{ 0x1E81, 0x1E80 },
	{ 0x1E83, 0x1E82 },
	{ 0x1E85, 0x1E84 },
	{ 0x1E87, 0x1E86 },
	{ 0x1E89, 0x1E88 },
	{ 0x1E8B, 0x1E8A },
	{ 0x1E8D, 0x1E8C },
	{ 0x1E8F, 0x1E8E },
	{ 0x1E91, 0x1E90 },
	{ 0x1E93, 0x1E92 },
	{ 0x1E95, 0x1E94 },
	{ 0x1EA1, 0x1EA0 },
	{ 0x1EA3, 0x1EA2 },
	{ 0x1EA5, 0x1EA4 },
	{ 0x1EA7, 0x1EA6 },
	{ 0x1EA9, 0x1EA8 },
	{ 0x1EAB, 0x1EAA },
	{ 0x1EAD, 0x1EAC },
	{ 0x1EAF, 0x1EAE },
	{ 0x1EB1, 0x1EB0 },
	{ 0x1EB3, 0x1EB2 },
	{ 0x1EB5, 0x1EB4 },
	{ 0x1EB7, 0x1EB6 },
	{ 0x1EB9, 0x1EB8 },
	{ 0x1EBB, 0x1EBA },
	{ 0x1EBD, 0x1EBC },
	{ 0x1EBF, 0x1EBE },
	{ 0x1EC1, 0x1EC0 },
	{ 0x1EC3, 0x1EC2 },
	{ 0x1EC5, 0x1EC4 },
	{ 0x1EC7, 0x1EC6 },
	{ 0x1EC9, 0x1EC8 },
	{ 0x1ECB, 0x1ECA },
	{ 0x1ECD, 0x1ECC },
	{ 0x1ECF, 0x1ECE },
	{ 0x1ED1, 0x1ED0 },
	{ 0x1ED3, 0x1ED2 },
	{ 0x1ED5, 0x1ED4 },
	{ 0x1ED7, 0x1ED6 },
	{ 0x1ED9, 0x1ED8 },
	{ 0x1EDB, 0x1EDA },
	{ 0x1EDD, 0x1EDC },
	{ 0x1EDF, 0x1EDE },
	{ 0x1EE1, 0x1EE0 },
	{ 0x1EE3, 0x1EE2 },
	{ 0x1EE5, 0x1EE4 },
	{ 0x1EE7, 0x1EE6 },
	{ 0x1EE9, 0x1EE8 },
	{ 0x1EEB, 0x1EEA },
	{ 0x1EED, 0x1EEC },
	{ 0x1EEF, 0x1EEE },
	{ 0x1EF1, 0x1EF0 },
	{ 0x1EF3, 0x1EF2 },
	{ 0x1EF5, 0x1EF4 },
	{ 0x1EF7, 0x1EF6 },
	{ 0x1EF9, 0x1EF8 },
	{ 0x1F00, 0x1F08 },
	{ 0x1F01, 0x1F09 },
	{ 0x1F02, 0x1F0A },
	{ 0x1F03, 0x1F0B },
	{ 0x1F04, 0x1F0C },
	{ 0x1F05, 0x1F0D },
	{ 0x1F06, 0x1F0E },
	{ 0x1F07, 0x1F0F },
	{ 0x1F10, 0x1F18 },
	{ 0x1F11, 0x1F19 },
	{ 0x1F12, 0x1F1A },
	{ 0x1F13, 0x1F1B },
	{ 0x1F14, 0x1F1C },
	{ 0x1F15, 0x1F1D },
	{ 0x1F20, 0x1F28 },
	{ 0x1F21, 0x1F29 },
	{ 0x1F22, 0x1F2A },
	{ 0x1F23, 0x1F2B },
	{ 0x1F24, 0x1F2C },
	{ 0x1F25, 0x1F2D },
	{ 0x1F26, 0x1F2E },
	{ 0x1F27, 0x1F2F },
	{ 0x1F30, 0x1F38 },
	{ 0x1F31, 0x1F39 },
	{ 0x1F32, 0x1F3A },
	{ 0x1F33, 0x1F3B },
	{ 0x1F34, 0x1F3C },
	{ 0x1F35, 0x1F3D },
	{ 0x1F36, 0x1F3E },
	{ 0x1F37, 0x1F3F },
	{ 0x1F40, 0x1F48 },
	{ 0x1F41, 0x1F49 },
	{ 0x1F42, 0x1F4A },
	{ 0x1F43, 0x1F4B },
	{ 0x1F44, 0x1F4C },
	{ 0x1F45, 0x1F4D },
	{ 0x1F51, 0x1F59 },
	{ 0x1F53, 0x1F5B },
	{ 0x1F55, 0x1F5D },
	{ 0x1F57, 0x1F5F },
	{ 0x1F60, 0x1F68 },
	{ 0x1F61, 0x1F69 },
	{ 0x1F62, 0x1F6A },
	{ 0x1F63, 0x1F6B },
	{ 0x1F64, 0x1F6C },
	{ 0x1F65, 0x1F6D },
	{ 0x1F66, 0x1F6E },
	{ 0x1F67, 0x1F6F },
	{ 0x1F80, 0x1F88 },
	{ 0x1F81, 0x1F89 },
	{ 0x1F82, 0x1F8A },
	{ 0x1F83, 0x1F8B },
	{ 0x1F84, 0x1F8C },
	{ 0x1F85, 0x1F8D },
	{ 0x1F86, 0x1F8E },
	{ 0x1F87, 0x1F8F },
	{ 0x1F90, 0x1F98 },
	{ 0x1F91, 0x1F99 },
	{ 0x1F92, 0x1F9A },
	{ 0x1F93, 0x1F9B },
	{ 0x1F94, 0x1F9C },
	{ 0x1F95, 0x1F9D },
	{ 0x1F96, 0x1F9E },
	{ 0x1F97, 0x1F9F },
	{ 0x1FA0, 0x1FA8 },
	{ 0x1FA1, 0x1FA9 },
	{ 0x1FA2, 0x1FAA },
	{ 0x1FA3, 0x1FAB },
	{ 0x1FA4, 0x1FAC },
	{ 0x1FA5, 0x1FAD },
	{ 0x1FA6, 0x1FAE },
	{ 0x1FA7, 0x1FAF },
	{ 0x1FB0, 0x1FB8 },
	{ 0x1FB1, 0x1FB9 },
	{ 0x1FD0, 0x1FD8 },
	{ 0x1FD1, 0x1FD9 },
	{ 0x1FE0, 0x1FE8 },
	{ 0x1FE1, 0x1FE9 },
	{ 0x24D0, 0x24B6 },
	{ 0x24D1, 0x24B7 },
	{ 0x24D2, 0x24B8 },
	{ 0x24D3, 0x24B9 },
	{ 0x24D4, 0x24BA },
	{ 0x24D5, 0x24BB },
	{ 0x24D6, 0x24BC },
	{ 0x24D7, 0x24BD },
	{ 0x24D8, 0x24BE },
	{ 0x24D9, 0x24BF },
	{ 0x24DA, 0x24C0 },
	{ 0x24DB, 0x24C1 },
	{ 0x24DC, 0x24C2 },
	{ 0x24DD, 0x24C3 },
	{ 0x24DE, 0x24C4 },
	{ 0x24DF, 0x24C5 },
	{ 0x24E0, 0x24C6 },
	{ 0x24E1, 0x24C7 },
	{ 0x24E2, 0x24C8 },
	{ 0x24E3, 0x24C9 },
	{ 0x24E4, 0x24CA },
	{ 0x24E5, 0x24CB },
	{ 0x24E6, 0x24CC },
	{ 0x24E7, 0x24CD },
	{ 0x24E8, 0x24CE },
	{ 0x24E9, 0x24CF },
	{ 0xFF41, 0xFF21 },
	{ 0xFF42, 0xFF22 },
	{ 0xFF43, 0xFF23 },
	{ 0xFF44, 0xFF24 },
	{ 0xFF45, 0xFF25 },
	{ 0xFF46, 0xFF26 },
	{ 0xFF47, 0xFF27 },
	{ 0xFF48, 0xFF28 },
	{ 0xFF49, 0xFF29 },
	{ 0xFF4A, 0xFF2A },
	{ 0xFF4B, 0xFF2B },
	{ 0xFF4C, 0xFF2C },
	{ 0xFF4D, 0xFF2D },
	{ 0xFF4E, 0xFF2E },
	{ 0xFF4F, 0xFF2F },
	{ 0xFF50, 0xFF30 },
	{ 0xFF51, 0xFF31 },
	{ 0xFF52, 0xFF32 },
	{ 0xFF53, 0xFF33 },
	{ 0xFF54, 0xFF34 },
	{ 0xFF55, 0xFF35 },
	{ 0xFF56, 0xFF36 },
	{ 0xFF57, 0xFF37 },
	{ 0xFF58, 0xFF38 },
	{ 0xFF59, 0xFF39 },
	{ 0xFF5A, 0xFF3A },
};

static const int reverse_caps_table[CAPS_LEN - 1][2] = {
	{ 0x0041, 0x0061 },
	{ 0x0042, 0x0062 },
	{ 0x0043, 0x0063 },
	{ 0x0044, 0x0064 },
	{ 0x0045, 0x0065 },
	{ 0x0046, 0x0066 },
	{ 0x0047, 0x0067 },
	{ 0x0048, 0x0068 },
	{ 0x0049, 0x0069 },
	// { 0x0049, 0x0131 }, // dotless I
	{ 0x004A, 0x006A },
	{ 0x004B, 0x006B },
	{ 0x004C, 0x006C },
	{ 0x004D, 0x006D },
	{ 0x004E, 0x006E },
	{ 0x004F, 0x006F },
	{ 0x0050, 0x0070 },
	{ 0x0051, 0x0071 },
	{ 0x0052, 0x0072 },
	{ 0x0053, 0x0073 },
	{ 0x0054, 0x0074 },
	{ 0x0055, 0x0075 },
	{ 0x0056, 0x0076 },
	{ 0x0057, 0x0077 },
	{ 0x0058, 0x0078 },
	{ 0x0059, 0x0079 },
	{ 0x005A, 0x007A },
	{ 0x00C0, 0x00E0 },
	{ 0x00C1, 0x00E1 },
	{ 0x00C2, 0x00E2 },
	{ 0x00C3, 0x00E3 },
	{ 0x00C4, 0x00E4 },
	{ 0x00C5, 0x00E5 },
	{ 0x00C6, 0x00E6 },
	{ 0x00C7, 0x00E7 },
	{ 0x00C8, 0x00E8 },
	{ 0x00C9, 0x00E9 },
	{ 0x00CA, 0x00EA },
	{ 0x00CB, 0x00EB },
	{ 0x00CC, 0x00EC },
	{ 0x00CD, 0x00ED },
	{ 0x00CE, 0x00EE },
	{ 0x00CF, 0x00EF },
	{ 0x00D0, 0x00F0 },
	{ 0x00D1, 0x00F1 },
	{ 0x00D2, 0x00F2 },
	{ 0x00D3, 0x00F3 },
	{ 0x00D4, 0x00F4 },
	{ 0x00D5, 0x00F5 },
	{ 0x00D6, 0x00F6 },
	{ 0x00D8, 0x00F8 },
	{ 0x00D9, 0x00F9 },
	{ 0x00DA, 0x00FA },
	{ 0x00DB, 0x00FB },
	{ 0x00DC, 0x00FC },
	{ 0x00DD, 0x00FD },
	{ 0x00DE, 0x00FE },
	{ 0x0100, 0x0101 },
	{ 0x0102, 0x0103 },
	{ 0x0104, 0x0105 },
	{ 0x0106, 0x0107 },
	{ 0x0108, 0x0109 },
	{ 0x010A, 0x010B },
	{ 0x010C, 0x010D },
	{ 0x010E, 0x010F },
	{ 0x0110, 0x0111 },
	{ 0x0112, 0x0113 },
	{ 0x0114, 0x0115 },
	{ 0x0116, 0x0117 },
	{ 0x0118, 0x0119 },
	{ 0x011A, 0x011B },
	{ 0x011C, 0x011D },
	{ 0x011E, 0x011F },
	{ 0x0120, 0x0121 },
	{ 0x0122, 0x0123 },
	{ 0x0124, 0x0125 },
	{ 0x0126, 0x0127 },
	{ 0x0128, 0x0129 },
	{ 0x012A, 0x012B },
	{ 0x012C, 0x012D },
	{ 0x012E, 0x012F },
	{ 0x0132, 0x0133 },
	{ 0x0134, 0x0135 },
	{ 0x0136, 0x0137 },
	{ 0x0139, 0x013A },
	{ 0x013B, 0x013C },
	{ 0x013D, 0x013E },
	{ 0x013F, 0x0140 },
	{ 0x0141, 0x0142 },
	{ 0x0143, 0x0144 },
	{ 0x0145, 0x0146 },
	{ 0x0147, 0x0148 },
	{ 0x014A, 0x014B },
	{ 0x014C, 0x014D },
	{ 0x014E, 0x014F },
	{ 0x0150, 0x0151 },
	{ 0x0152, 0x0153 },
	{ 0x0154, 0x0155 },
	{ 0x0156, 0x0157 },
	{ 0x0158, 0x0159 },
	{ 0x015A, 0x015B },
	{ 0x015C, 0x015D },
	{ 0x015E, 0x015F },
	{ 0x0160, 0x0161 },
	{ 0x0162, 0x0163 },
	{ 0x0164, 0x0165 },
	{ 0x0166, 0x0167 },
	{ 0x0168, 0x0169 },
	{ 0x016A, 0x016B },
	{ 0x016C, 0x016D },
	{ 0x016E, 0x016F },
	{ 0x0170, 0x0171 },
	{ 0x0172, 0x0173 },
	{ 0x0174, 0x0175 },
	{ 0x0176, 0x0177 },
	{ 0x0178, 0x00FF },
	{ 0x0179, 0x017A },
	{ 0x017B, 0x017C },
	{ 0x017D, 0x017E },
	{ 0x0181, 0x0253 },
	{ 0x0182, 0x0183 },
	{ 0x0184, 0x0185 },
	{ 0x0186, 0x0254 },
	{ 0x0187, 0x0188 },
	{ 0x018A, 0x0257 },
	{ 0x018B, 0x018C },
	{ 0x018E, 0x0258 },
	{ 0x018F, 0x0259 },
	{ 0x0190, 0x025B },
	{ 0x0191, 0x0192 },
	{ 0x0193, 0x0260 },
	{ 0x0194, 0x0263 },
	{ 0x0196, 0x0269 },
	{ 0x0197, 0x0268 },
	{ 0x0198, 0x0199 },
	{ 0x019C, 0x026F },
	{ 0x019D, 0x0272 },
	{ 0x019F, 0x0275 },
	{ 0x01A0, 0x01A1 },
	{ 0x01A2, 0x01A3 },
	{ 0x01A4, 0x01A5 },
	{ 0x01A7, 0x01A8 },
	{ 0x01A9, 0x0283 },
	{ 0x01AC, 0x01AD },
	{ 0x01AE, 0x0288 },
	{ 0x01AF, 0x01B0 },
	{ 0x01B1, 0x028A },
	{ 0x01B2, 0x028B },
	{ 0x01B3, 0x01B4 },
	{ 0x01B5, 0x01B6 },
	{ 0x01B7, 0x0292 },
	{ 0x01B8, 0x01B9 },
	{ 0x01BC, 0x01BD },
	{ 0x01C4, 0x01C6 },
	{ 0x01C7, 0x01C9 },
	{ 0x01CA, 0x01CC },
	{ 0x01CD, 0x01CE },
	{ 0x01CF, 0x01D0 },
	{ 0x01D1, 0x01D2 },
	{ 0x01D3, 0x01D4 },
	{ 0x01D5, 0x01D6 },
	{ 0x01D7, 0x01D8 },
	{ 0x01D9, 0x01DA },
	{ 0x01DB, 0x01DC },
	{ 0x01DE, 0x01DF },
	{ 0x01E0, 0x01E1 },
	{ 0x01E2, 0x01E3 },
	{ 0x01E4, 0x01E5 },
	{ 0x01E6, 0x01E7 },
	{ 0x01E8, 0x01E9 },
	{ 0x01EA, 0x01EB },
	{ 0x01EC, 0x01ED },
	{ 0x01EE, 0x01EF },
	{ 0x01F1, 0x01F3 },
	{ 0x01F4, 0x01F5 },
	{ 0x01FA, 0x01FB },
	{ 0x01FC, 0x01FD },
	{ 0x01FE, 0x01FF },
	{ 0x0200, 0x0201 },
	{ 0x0202, 0x0203 },
	{ 0x0204, 0x0205 },
	{ 0x0206, 0x0207 },
	{ 0x0208, 0x0209 },
	{ 0x020A, 0x020B },
	{ 0x020C, 0x020D },
	{ 0x020E, 0x020F },
	{ 0x0210, 0x0211 },
	{ 0x0212, 0x0213 },
	{ 0x0214, 0x0215 },
	{ 0x0216, 0x0217 },
	{ 0x0386, 0x03AC },
	{ 0x0388, 0x03AD },
	{ 0x0389, 0x03AE },
	{ 0x038A, 0x03AF },
	{ 0x038C, 0x03CC },
	{ 0x038E, 0x03CD },
	{ 0x038F, 0x03CE },
	{ 0x0391, 0x03B1 },
	{ 0x0392, 0x03B2 },
	{ 0x0393, 0x03B3 },
	{ 0x0394, 0x03B4 },
	{ 0x0395, 0x03B5 },
	{ 0x0396, 0x03B6 },
	{ 0x0397, 0x03B7 },
	{ 0x0398, 0x03B8 },
	{ 0x0399, 0x03B9 },
	{ 0x039A, 0x03BA },
	{ 0x039B, 0x03BB },
	{ 0x039C, 0x03BC },
	{ 0x039D, 0x03BD },
	{ 0x039E, 0x03BE },
	{ 0x039F, 0x03BF },
	{ 0x03A0, 0x03C0 },
	{ 0x03A1, 0x03C1 },
	{ 0x03A3, 0x03C3 },
	{ 0x03A4, 0x03C4 },
	{ 0x03A5, 0x03C5 },
	{ 0x03A6, 0x03C6 },
	{ 0x03A7, 0x03C7 },
	{ 0x03A8, 0x03C8 },
	{ 0x03A9, 0x03C9 },
	{ 0x03AA, 0x03CA },
	{ 0x03AB, 0x03CB },
	{ 0x03E2, 0x03E3 },
	{ 0x03E4, 0x03E5 },
	{ 0x03E6, 0x03E7 },
	{ 0x03E8, 0x03E9 },
	{ 0x03EA, 0x03EB },
	{ 0x03EC, 0x03ED },
	{ 0x03EE, 0x03EF },
	{ 0x0401, 0x0451 },
	{ 0x0402, 0x0452 },
	{ 0x0403, 0x0453 },
	{ 0x0404, 0x0454 },
	{ 0x0405, 0x0455 },
	{ 0x0406, 0x0456 },
	{ 0x0407, 0x0457 },
	{ 0x0408, 0x0458 },
	{ 0x0409, 0x0459 },
	{ 0x040A, 0x045A },
	{ 0x040B, 0x045B },
	{ 0x040C, 0x045C },
	{ 0x040E, 0x045E },
	{ 0x040F, 0x045F },
	{ 0x0410, 0x0430 },
	{ 0x0411, 0x0431 },
	{ 0x0412, 0x0432 },
	{ 0x0413, 0x0433 },
	{ 0x0414, 0x0434 },
	{ 0x0415, 0x0435 },
	{ 0x0416, 0x0436 },
	{ 0x0417, 0x0437 },
	{ 0x0418, 0x0438 },
	{ 0x0419, 0x0439 },
	{ 0x041A, 0x043A },
	{ 0x041B, 0x043B },
	{ 0x041C, 0x043C },
	{ 0x041D, 0x043D },
	{ 0x041E, 0x043E },
	{ 0x041F, 0x043F },
	{ 0x0420, 0x0440 },
	{ 0x0421, 0x0441 },
	{ 0x0422, 0x0442 },
	{ 0x0423, 0x0443 },
	{ 0x0424, 0x0444 },
	{ 0x0425, 0x0445 },
	{ 0x0426, 0x0446 },
	{ 0x0427, 0x0447 },
	{ 0x0428, 0x0448 },
	{ 0x0429, 0x0449 },
	{ 0x042A, 0x044A },
	{ 0x042B, 0x044B },
	{ 0x042C, 0x044C },
	{ 0x042D, 0x044D },
	{ 0x042E, 0x044E },
	{ 0x042F, 0x044F },
	{ 0x0460, 0x0461 },
	{ 0x0462, 0x0463 },
	{ 0x0464, 0x0465 },
	{ 0x0466, 0x0467 },
	{ 0x0468, 0x0469 },
	{ 0x046A, 0x046B },
	{ 0x046C, 0x046D },
	{ 0x046E, 0x046F },
	{ 0x0470, 0x0471 },
	{ 0x0472, 0x0473 },
	{ 0x0474, 0x0475 },
	{ 0x0476, 0x0477 },
	{ 0x0478, 0x0479 },
	{ 0x047A, 0x047B },
	{ 0x047C, 0x047D },
	{ 0x047E, 0x047F },
	{ 0x0480, 0x0481 },
	{ 0x0490, 0x0491 },
	{ 0x0492, 0x0493 },
	{ 0x0494, 0x0495 },
	{ 0x0496, 0x0497 },
	{ 0x0498, 0x0499 },
	{ 0x049A, 0x049B },
	{ 0x049C, 0x049D },
	{ 0x049E, 0x049F },
	{ 0x04A0, 0x04A1 },
	{ 0x04A2, 0x04A3 },
	{ 0x04A4, 0x04A5 },
	{ 0x04A6, 0x04A7 },
	{ 0x04A8, 0x04A9 },
	{ 0x04AA, 0x04AB },
	{ 0x04AC, 0x04AD },
	{ 0x04AE, 0x04AF },
	{ 0x04B0, 0x04B1 },
	{ 0x04B2, 0x04B3 },
	{ 0x04B4, 0x04B5 },
	{ 0x04B6, 0x04B7 },
	{ 0x04B8, 0x04B9 },
	{ 0x04BA, 0x04BB },
	{ 0x04BC, 0x04BD },
	{ 0x04BE, 0x04BF },
	{ 0x04C1, 0x04C2 },
	{ 0x04C3, 0x04C4 },
	{ 0x04C7, 0x04C8 },
	{ 0x04CB, 0x04CC },
	{ 0x04D0, 0x04D1 },
	{ 0x04D2, 0x04D3 },
	{ 0x04D4, 0x04D5 },
	{ 0x04D6, 0x04D7 },
	{ 0x04D8, 0x04D9 },
	{ 0x04DA, 0x04DB },
	{ 0x04DC, 0x04DD },
	{ 0x04DE, 0x04DF },
	{ 0x04E0, 0x04E1 },
	{ 0x04E2, 0x04E3 },
	{ 0x04E4, 0x04E5 },
	{ 0x04E6, 0x04E7 },
	{ 0x04E8, 0x04E9 },
	{ 0x04EA, 0x04EB },
	{ 0x04EE, 0x04EF },
	{ 0x04F0, 0x04F1 },
	{ 0x04F2, 0x04F3 },
	{ 0x04F4, 0x04F5 },
	{ 0x04F8, 0x04F9 },
	{ 0x0531, 0x0561 },
	{ 0x0532, 0x0562 },
	{ 0x0533, 0x0563 },
	{ 0x0534, 0x0564 },
	{ 0x0535, 0x0565 },
	{ 0x0536, 0x0566 },
	{ 0x0537, 0x0567 },
	{ 0x0538, 0x0568 },
	{ 0x0539, 0x0569 },
	{ 0x053A, 0x056A },
	{ 0x053B, 0x056B },
	{ 0x053C, 0x056C },
	{ 0x053D, 0x056D },
	{ 0x053E, 0x056E },
	{ 0x053F, 0x056F },
	{ 0x0540, 0x0570 },
	{ 0x0541, 0x0571 },
	{ 0x0542, 0x0572 },
	{ 0x0543, 0x0573 },
	{ 0x0544, 0x0574 },
	{ 0x0545, 0x0575 },
	{ 0x0546, 0x0576 },
	{ 0x0547, 0x0577 },
	{ 0x0548, 0x0578 },
	{ 0x0549, 0x0579 },
	{ 0x054A, 0x057A },
	{ 0x054B, 0x057B },
	{ 0x054C, 0x057C },
	{ 0x054D, 0x057D },
	{ 0x054E, 0x057E },
	{ 0x054F, 0x057F },
	{ 0x0550, 0x0580 },
	{ 0x0551, 0x0581 },
	{ 0x0552, 0x0582 },
	{ 0x0553, 0x0583 },
	{ 0x0554, 0x0584 },
	{ 0x0555, 0x0585 },
	{ 0x0556, 0x0586 },
	{ 0x10A0, 0x10D0 },
	{ 0x10A1, 0x10D1 },
	{ 0x10A2, 0x10D2 },
	{ 0x10A3, 0x10D3 },
	{ 0x10A4, 0x10D4 },
	{ 0x10A5, 0x10D5 },
	{ 0x10A6, 0x10D6 },
	{ 0x10A7, 0x10D7 },
	{ 0x10A8, 0x10D8 },
	{ 0x10A9, 0x10D9 },
	{ 0x10AA, 0x10DA },
	{ 0x10AB, 0x10DB },
	{ 0x10AC, 0x10DC },
	{ 0x10AD, 0x10DD },
	{ 0x10AE, 0x10DE },
	{ 0x10AF, 0x10DF },
	{ 0x10B0, 0x10E0 },
	{ 0x10B1, 0x10E1 },
	{ 0x10B2, 0x10E2 },
	{ 0x10B3, 0x10E3 },
	{ 0x10B4, 0x10E4 },
	{ 0x10B5, 0x10E5 },
	{ 0x10B6, 0x10E6 },
	{ 0x10B7, 0x10E7 },
	{ 0x10B8, 0x10E8 },
	{ 0x10B9, 0x10E9 },
	{ 0x10BA, 0x10EA },
	{ 0x10BB, 0x10EB },
	{ 0x10BC, 0x10EC },
	{ 0x10BD, 0x10ED },
	{ 0x10BE, 0x10EE },
	{ 0x10BF, 0x10EF },
	{ 0x10C0, 0x10F0 },
	{ 0x10C1, 0x10F1 },
	{ 0x10C2, 0x10F2 },
	{ 0x10C3, 0x10F3 },
	{ 0x10C4, 0x10F4 },
	{ 0x10C5, 0x10F5 },
	{ 0x1E00, 0x1E01 },
	{ 0x1E02, 0x1E03 },
	{ 0x1E04, 0x1E05 },
	{ 0x1E06, 0x1E07 },
	{ 0x1E08, 0x1E09 },
	{ 0x1E0A, 0x1E0B },
	{ 0x1E0C, 0x1E0D },
	{ 0x1E0E, 0x1E0F },
	{ 0x1E10, 0x1E11 },
	{ 0x1E12, 0x1E13 },
	{ 0x1E14, 0x1E15 },
	{ 0x1E16, 0x1E17 },
	{ 0x1E18, 0x1E19 },
	{ 0x1E1A, 0x1E1B },
	{ 0x1E1C, 0x1E1D },
	{ 0x1E1E, 0x1E1F },
	{ 0x1E20, 0x1E21 },
	{ 0x1E22, 0x1E23 },
	{ 0x1E24, 0x1E25 },
	{ 0x1E26, 0x1E27 },
	{ 0x1E28, 0x1E29 },
	{ 0x1E2A, 0x1E2B },
	{ 0x1E2C, 0x1E2D },
	{ 0x1E2E, 0x1E2F },
	{ 0x1E30, 0x1E31 },
	{ 0x1E32, 0x1E33 },
	{ 0x1E34, 0x1E35 },
	{ 0x1E36, 0x1E37 },
	{ 0x1E38, 0x1E39 },
	{ 0x1E3A, 0x1E3B },
	{ 0x1E3C, 0x1E3D },
	{ 0x1E3E, 0x1E3F },
	{ 0x1E40, 0x1E41 },
	{ 0x1E42, 0x1E43 },
	{ 0x1E44, 0x1E45 },
	{ 0x1E46, 0x1E47 },
	{ 0x1E48, 0x1E49 },
	{ 0x1E4A, 0x1E4B },
	{ 0x1E4C, 0x1E4D },
	{ 0x1E4E, 0x1E4F },
	{ 0x1E50, 0x1E51 },
	{ 0x1E52, 0x1E53 },
	{ 0x1E54, 0x1E55 },
	{ 0x1E56, 0x1E57 },
	{ 0x1E58, 0x1E59 },
	{ 0x1E5A, 0x1E5B },
	{ 0x1E5C, 0x1E5D },
	{ 0x1E5E, 0x1E5F },
	{ 0x1E60, 0x1E61 },
	{ 0x1E62, 0x1E63 },
	{ 0x1E64, 0x1E65 },
	{ 0x1E66, 0x1E67 },
	{ 0x1E68, 0x1E69 },
	{ 0x1E6A, 0x1E6B },
	{ 0x1E6C, 0x1E6D },
	{ 0x1E6E, 0x1E6F },
	{ 0x1E70, 0x1E71 },
	{ 0x1E72, 0x1E73 },
	{ 0x1E74, 0x1E75 },
	{ 0x1E76, 0x1E77 },
	{ 0x1E78, 0x1E79 },
	{ 0x1E7A, 0x1E7B },
	{ 0x1E7C, 0x1E7D },
	{ 0x1E7E, 0x1E7F },
	{ 0x1E80, 0x1E81 },
	{ 0x1E82, 0x1E83 },
	{ 0x1E84, 0x1E85 },
	{ 0x1E86, 0x1E87 },
	{ 0x1E88, 0x1E89 },
	{ 0x1E8A, 0x1E8B },
	{ 0x1E8C, 0x1E8D },
	{ 0x1E8E, 0x1E8F },
	{ 0x1E90, 0x1E91 },
	{ 0x1E92, 0x1E93 },
	{ 0x1E94, 0x1E95 },
	{ 0x1EA0, 0x1EA1 },
	{ 0x1EA2, 0x1EA3 },
	{ 0x1EA4, 0x1EA5 },
	{ 0x1EA6, 0x1EA7 },
	{ 0x1EA8, 0x1EA9 },
	{ 0x1EAA, 0x1EAB },
	{ 0x1EAC, 0x1EAD },
	{ 0x1EAE, 0x1EAF },
	{ 0x1EB0, 0x1EB1 },
	{ 0x1EB2, 0x1EB3 },
	{ 0x1EB4, 0x1EB5 },
	{ 0x1EB6, 0x1EB7 },
	{ 0x1EB8, 0x1EB9 },
	{ 0x1EBA, 0x1EBB },
	{ 0x1EBC, 0x1EBD },
	{ 0x1EBE, 0x1EBF },
	{ 0x1EC0, 0x1EC1 },
	{ 0x1EC2, 0x1EC3 },
	{ 0x1EC4, 0x1EC5 },
	{ 0x1EC6, 0x1EC7 },
	{ 0x1EC8, 0x1EC9 },
	{ 0x1ECA, 0x1ECB },
	{ 0x1ECC, 0x1ECD },
	{ 0x1ECE, 0x1ECF },
	{ 0x1ED0, 0x1ED1 },
	{ 0x1ED2, 0x1ED3 },
	{ 0x1ED4, 0x1ED5 },
	{ 0x1ED6, 0x1ED7 },
	{ 0x1ED8, 0x1ED9 },
	{ 0x1EDA, 0x1EDB },
	{ 0x1EDC, 0x1EDD },
	{ 0x1EDE, 0x1EDF },
	{ 0x1EE0, 0x1EE1 },
	{ 0x1EE2, 0x1EE3 },
	{ 0x1EE4, 0x1EE5 },
	{ 0x1EE6, 0x1EE7 },
	{ 0x1EE8, 0x1EE9 },
	{ 0x1EEA, 0x1EEB },
	{ 0x1EEC, 0x1EED },
	{ 0x1EEE, 0x1EEF },
	{ 0x1EF0, 0x1EF1 },
	{ 0x1EF2, 0x1EF3 },
	{ 0x1EF4, 0x1EF5 },
	{ 0x1EF6, 0x1EF7 },
	{ 0x1EF8, 0x1EF9 },
	{ 0x1F08, 0x1F00 },
	{ 0x1F09, 0x1F01 },
	{ 0x1F0A, 0x1F02 },
	{ 0x1F0B, 0x1F03 },
	{ 0x1F0C, 0x1F04 },
	{ 0x1F0D, 0x1F05 },
	{ 0x1F0E, 0x1F06 },
	{ 0x1F0F, 0x1F07 },
	{ 0x1F18, 0x1F10 },
	{ 0x1F19, 0x1F11 },
	{ 0x1F1A, 0x1F12 },
	{ 0x1F1B, 0x1F13 },
	{ 0x1F1C, 0x1F14 },
	{ 0x1F1D, 0x1F15 },
	{ 0x1F28, 0x1F20 },
	{ 0x1F29, 0x1F21 },
	{ 0x1F2A, 0x1F22 },
	{ 0x1F2B, 0x1F23 },
	{ 0x1F2C, 0x1F24 },
	{ 0x1F2D, 0x1F25 },
	{ 0x1F2E, 0x1F26 },
	{ 0x1F2F, 0x1F27 },
	{ 0x1F38, 0x1F30 },
	{ 0x1F39, 0x1F31 },
	{ 0x1F3A, 0x1F32 },
	{ 0x1F3B, 0x1F33 },
	{ 0x1F3C, 0x1F34 },
	{ 0x1F3D, 0x1F35 },
	{ 0x1F3E, 0x1F36 },
	{ 0x1F3F, 0x1F37 },
	{ 0x1F48, 0x1F40 },
	{ 0x1F49, 0x1F41 },
	{ 0x1F4A, 0x1F42 },
	{ 0x1F4B, 0x1F43 },
	{ 0x1F4C, 0x1F44 },
	{ 0x1F4D, 0x1F45 },
	{ 0x1F59, 0x1F51 },
	{ 0x1F5B, 0x1F53 },
	{ 0x1F5D, 0x1F55 },
	{ 0x1F5F, 0x1F57 },
	{ 0x1F68, 0x1F60 },
	{ 0x1F69, 0x1F61 },
	{ 0x1F6A, 0x1F62 },
	{ 0x1F6B, 0x1F63 },
	{ 0x1F6C, 0x1F64 },
	{ 0x1F6D, 0x1F65 },
	{ 0x1F6E, 0x1F66 },
	{ 0x1F6F, 0x1F67 },
	{ 0x1F88, 0x1F80 },
	{ 0x1F89, 0x1F81 },
	{ 0x1F8A, 0x1F82 },
	{ 0x1F8B, 0x1F83 },
	{ 0x1F8C, 0x1F84 },
	{ 0x1F8D, 0x1F85 },
	{ 0x1F8E, 0x1F86 },
	{ 0x1F8F, 0x1F87 },
	{ 0x1F98, 0x1F90 },
	{ 0x1F99, 0x1F91 },
	{ 0x1F9A, 0x1F92 },
	{ 0x1F9B, 0x1F93 },
	{ 0x1F9C, 0x1F94 },
	{ 0x1F9D, 0x1F95 },
	{ 0x1F9E, 0x1F96 },
	{ 0x1F9F, 0x1F97 },
	{ 0x1FA8, 0x1FA0 },
	{ 0x1FA9, 0x1FA1 },
	{ 0x1FAA, 0x1FA2 },
	{ 0x1FAB, 0x1FA3 },
	{ 0x1FAC, 0x1FA4 },
	{ 0x1FAD, 0x1FA5 },
	{ 0x1FAE, 0x1FA6 },
	{ 0x1FAF, 0x1FA7 },
	{ 0x1FB8, 0x1FB0 },
	{ 0x1FB9, 0x1FB1 },
	{ 0x1FD8, 0x1FD0 },
	{ 0x1FD9, 0x1FD1 },
	{ 0x1FE8, 0x1FE0 },
	{ 0x1FE9, 0x1FE1 },
	{ 0x24B6, 0x24D0 },
	{ 0x24B7, 0x24D1 },
	{ 0x24B8, 0x24D2 },
	{ 0x24B9, 0x24D3 },
	{ 0x24BA, 0x24D4 },
	{ 0x24BB, 0x24D5 },
	{ 0x24BC, 0x24D6 },
	{ 0x24BD, 0x24D7 },
	{ 0x24BE, 0x24D8 },
	{ 0x24BF, 0x24D9 },
	{ 0x24C0, 0x24DA },
	{ 0x24C1, 0x24DB },
	{ 0x24C2, 0x24DC },
	{ 0x24C3, 0x24DD },
	{ 0x24C4, 0x24DE },
	{ 0x24C5, 0x24DF },
	{ 0x24C6, 0x24E0 },
	{ 0x24C7, 0x24E1 },
	{ 0x24C8, 0x24E2 },
	{ 0x24C9, 0x24E3 },
	{ 0x24CA, 0x24E4 },
	{ 0x24CB, 0x24E5 },
	{ 0x24CC, 0x24E6 },
	{ 0x24CD, 0x24E7 },
	{ 0x24CE, 0x24E8 },
	{ 0x24CF, 0x24E9 },
	{ 0xFF21, 0xFF41 },
	{ 0xFF22, 0xFF42 },
	{ 0xFF23, 0xFF43 },
	{ 0xFF24, 0xFF44 },
	{ 0xFF25, 0xFF45 },
	{ 0xFF26, 0xFF46 },
	{ 0xFF27, 0xFF47 },
	{ 0xFF28, 0xFF48 },
	{ 0xFF29, 0xFF49 },
	{ 0xFF2A, 0xFF4A },
	{ 0xFF2B, 0xFF4B },
	{ 0xFF2C, 0xFF4C },
	{ 0xFF2D, 0xFF4D },
	{ 0xFF2E, 0xFF4E },
	{ 0xFF2F, 0xFF4F },
	{ 0xFF30, 0xFF50 },
	{ 0xFF31, 0xFF51 },
	{ 0xFF32, 0xFF52 },
	{ 0xFF33, 0xFF53 },
	{ 0xFF34, 0xFF54 },
	{ 0xFF35, 0xFF55 },
	{ 0xFF36, 0xFF56 },
	{ 0xFF37, 0xFF57 },
	{ 0xFF38, 0xFF58 },
	{ 0xFF39, 0xFF59 },
	{ 0xFF3A, 0xFF5A },
};

static int _find_upper(int ch) {
	int low = 0;
	int high = CAPS_LEN - 1;
	int middle;

	while (low <= high) {
		middle = (low + high) / 2;

		if (ch < caps_table[middle][0]) {
			high = middle - 1; //search low end of array
		} else if (caps_table[middle][0] < ch) {
			low = middle + 1; //search high end of array
		} else {
			return caps_table[middle][1];
		}
	}

	return ch;
}

static int _find_lower(int ch) {
	int low = 0;
	int high = CAPS_LEN - 2;
	int middle;

	while (low <= high) {
		middle = (low + high) / 2;

		if (ch < reverse_caps_table[middle][0]) {
			high = middle - 1; //search low end of array
		} else if (reverse_caps_table[middle][0] < ch) {
			low = middle + 1; //search high end of array
		} else {
			return reverse_caps_table[middle][1];
		}
	}

	return ch;
}

#line 0

#line 1 "sfw/core/mutex.cpp"
/*************************************************************************/
/*  mutex.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

static Mutex _global_mutex;

void _global_lock() {
	_global_mutex.lock();
}

void _global_unlock() {
	_global_mutex.unlock();
}

#ifndef NO_THREADS

template class MutexImpl<std::recursive_mutex>;
template class MutexImpl<std::mutex>;

#endif
#line 0

#line 1 "sfw/core/safe_refcount.cpp"
/*************************************************************************/
/*  safe_refcount.cpp                                                    */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#if defined(DEBUG_ENABLED) && !defined(NO_THREADS)

// On C++14 we don't have std::atomic::is_always_lockfree, so this is the best we can do
void check_lockless_atomics() {
	// Doing the check for the types we actually care about
	if (!std::atomic<uint32_t>{}.is_lock_free() || !std::atomic<uint64_t>{}.is_lock_free() || !std::atomic_bool{}.is_lock_free()) {
		LOG_WARN("Your compiler doesn't seem to support lockless atomics. Performance will be degraded. Please consider upgrading to a different or newer compiler.");
	}
}

#endif
#line 0

#line 1 "sfw/core/thread.cpp"
/*************************************************************************/
/*  thread.cpp                                                           */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#if !defined(NO_THREADS)

Error (*Thread::set_name_func)(const String &) = nullptr;
void (*Thread::set_priority_func)(Thread::Priority) = nullptr;
void (*Thread::init_func)() = nullptr;
void (*Thread::term_func)() = nullptr;

uint64_t Thread::_thread_id_hash(const std::thread::id &p_t) {
	static std::hash<std::thread::id> hasher;
	return hasher(p_t);
}

Thread::ID Thread::main_thread_id = _thread_id_hash(std::this_thread::get_id());
static thread_local Thread::ID caller_id = 0;
static thread_local bool caller_id_cached = false;

void Thread::_set_platform_funcs(
		Error (*p_set_name_func)(const String &),
		void (*p_set_priority_func)(Thread::Priority),
		void (*p_init_func)(),
		void (*p_term_func)()) {
	Thread::set_name_func = p_set_name_func;
	Thread::set_priority_func = p_set_priority_func;
	Thread::init_func = p_init_func;
	Thread::term_func = p_term_func;
}

void Thread::callback(Thread *p_self, const Settings &p_settings, Callback p_callback, void *p_userdata) {
	caller_id = _thread_id_hash(p_self->thread.get_id());
	caller_id_cached = true;

	if (set_priority_func) {
		set_priority_func(p_settings.priority);
	}
	if (init_func) {
		init_func();
	}

	p_callback(p_userdata);

	if (term_func) {
		term_func();
	}
}

void Thread::start(Thread::Callback p_callback, void *p_user, const Settings &p_settings) {
	if (id != _thread_id_hash(std::thread::id())) {
#ifdef DEBUG_ENABLED
		LOG_WARN("A Thread object has been re-started without wait_to_finish() having been called on it. Please do so to ensure correct cleanup of the thread.");
#endif
		thread.detach();
		std::thread empty_thread;
		thread.swap(empty_thread);
	}
	std::thread new_thread(&Thread::callback, this, p_settings, p_callback, p_user);
	thread.swap(new_thread);
	id = _thread_id_hash(thread.get_id());
}

bool Thread::is_started() const {
	return id != _thread_id_hash(std::thread::id());
}

void Thread::wait_to_finish() {
	if (id != _thread_id_hash(std::thread::id())) {
		ERR_FAIL_COND_MSG(id == get_caller_id(), "A Thread can't wait for itself to finish.");
		thread.join();
		std::thread empty_thread;
		thread.swap(empty_thread);
		id = _thread_id_hash(std::thread::id());
	}
}

Error Thread::set_name(const String &p_name) {
	if (set_name_func) {
		return set_name_func(p_name);
	}

	return ERR_UNAVAILABLE;
}

Thread::~Thread() {
	if (id != _thread_id_hash(std::thread::id())) {
#ifdef DEBUG_ENABLED
		LOG_WARN("A Thread object has been destroyed without wait_to_finish() having been called on it. Please do so to ensure correct cleanup of the thread.");
#endif
		thread.detach();
	}
}

Thread::ID Thread::get_caller_id() {
	if (likely(caller_id_cached)) {
		return caller_id;
	} else {
		caller_id = _thread_id_hash(std::this_thread::get_id());
		caller_id_cached = true;
		return caller_id;
	}
}
#endif
#line 0

#line 1 "sfw/core/sfw_time.cpp"
// ----------------------------------------------------------------------------
// time

#if defined(_WIN64) || defined(_WIN32)
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winnt.h>
#else
#include <sys/time.h>
#include <unistd.h>
#endif

#if 0
uint64_t SFWTime::time_gpu() {
    GLint64 t = 123456789;
    glGetInteger64v(GL_TIMESTAMP, &t);
    return (uint64_t)t;
}
#endif
uint64_t SFWTime::date() {
	//time_t epoch = time(0);
	//struct tm *ti = localtime(&epoch);
	//return atoi64(va("%04d%02d%02d%02d%02d%02d", ti->tm_year + 1900, ti->tm_mon + 1, ti->tm_mday, ti->tm_hour, ti->tm_min, ti->tm_sec));
	return 0;
}
char *SFWTime::date_string() {
	//time_t epoch = time(0);
	//struct tm *ti = localtime(&epoch);
	//return va("%04d-%02d-%02d %02d:%02d:%02d", ti->tm_year + 1900, ti->tm_mon + 1, ti->tm_mday, ti->tm_hour, ti->tm_min, ti->tm_sec);
	return 0;
}
uint64_t SFWTime::date_epoch() {
	time_t epoch = time(0);
	return epoch;
}
#if 0
double SFWTime::time_ss() {
    return glfwGetTime();
}
double SFWTime::time_ms() {
    return glfwGetTime() * 1000.0;
}
uint64_t SFWTime::time_us() {
    return (uint64_t)(glfwGetTime() * 1000000.0); // @fixme: use a high resolution timer instead, or time_gpu below
}
uint64_t SFWTime::sleep_us(uint64_t us) { // @fixme: use a high resolution sleeper instead
    return sleep_ms( us / 1000.0 );
}
double SFWTime::sleep_ms(double ms) {
    double now = time_ms();
    if( ms <= 0 ) {
#if defined(_WIN64) || defined(_WIN32)
        Sleep(0); // yield
#else
        usleep(0);
#endif
    } else {
#if defined(_WIN64) || defined(_WIN32)
        Sleep(ms);
#else
        usleep(ms * 1000);
#endif
    }
    return time_ms() - now;
}
double sleep_ss(double ss) {
    return sleep_ms( ss * 1000 ) / 1000.0;
}
#endif

// high-perf functions

#define TIMER_E3 1000ULL
#define TIMER_E6 1000000ULL
#define TIMER_E9 1000000000ULL

#ifdef CLOCK_MONOTONIC_RAW
#define TIME_MONOTONIC CLOCK_MONOTONIC_RAW
#elif defined CLOCK_MONOTONIC
#define TIME_MONOTONIC CLOCK_MONOTONIC
#else
// #define TIME_MONOTONIC CLOCK_REALTIME // untested
#endif

static uint64_t nanotimer(uint64_t *out_freq) {
	if (out_freq) {
#if defined(_WIN64) || defined(_WIN32)
		LARGE_INTEGER li;
		QueryPerformanceFrequency(&li);
		*out_freq = li.QuadPart;
//#elif is(ANDROID)
//      *out_freq = CLOCKS_PER_SEC;
#elif defined TIME_MONOTONIC
		*out_freq = TIMER_E9;
#else
		*out_freq = TIMER_E6;
#endif
	}
#if defined(_WIN64) || defined(_WIN32)
	LARGE_INTEGER li;
	QueryPerformanceCounter(&li);
	return (uint64_t)li.QuadPart;
//#elif is(ANDROID)
//    return (uint64_t)clock();
#elif defined TIME_MONOTONIC
	struct timespec ts;
	clock_gettime(TIME_MONOTONIC, &ts);
	return (TIMER_E9 * (uint64_t)ts.tv_sec) + ts.tv_nsec;
#else
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return (TIMER_E6 * (uint64_t)tv.tv_sec) + tv.tv_usec;
#endif
}

uint64_t SFWTime::time_ns() {
	static thread_local uint64_t epoch = 0;
	static thread_local uint64_t freq = 0;
	if (!freq) {
		epoch = nanotimer(&freq);
	}

	uint64_t a = nanotimer(NULL) - epoch;
	uint64_t b = TIMER_E9;
	uint64_t c = freq;

	// Computes (a*b)/c without overflow, as long as both (a*b) and the overall result fit into 64-bits.
	// [ref] https://github.com/rust-lang/rust/blob/3809bbf47c8557bd149b3e52ceb47434ca8378d5/src/libstd/sys_common/mod.rs#L124
	uint64_t q = a / c;
	uint64_t r = a % c;
	return q * b + r * b / c;
}
uint64_t SFWTime::time_us() {
	return time_ns() / TIMER_E3;
}
uint64_t SFWTime::time_ms() {
	return time_ns() / TIMER_E6;
}
double SFWTime::time_ss() {
	return time_ns() / 1e9; // TIMER_E9;
}
double SFWTime::time_mm() {
	return time_ss() / 60;
}
double SFWTime::time_hh() {
	return time_mm() / 60;
}

void SFWTime::sleep_ns(double ns) {
#if defined(_WIN64) || defined(_WIN32)
	if (ns >= 100) {
		LARGE_INTEGER li; // Windows sleep in 100ns units
		HANDLE timer = CreateWaitableTimer(NULL, TRUE, NULL);
		li.QuadPart = (LONGLONG)(__int64)(-ns / 100); // Negative for relative time
		SetWaitableTimer(timer, &li, 0, NULL, NULL, FALSE);
		WaitForSingleObject(timer, INFINITE);
		CloseHandle(timer);
#else
	if (ns > 0) {
		struct timespec wait = { 0 };
		wait.tv_sec = ns / 1e9;
		wait.tv_nsec = ns - wait.tv_sec * 1e9;
		nanosleep(&wait, NULL);
#endif
	} else {
#if defined(_WIN64) || defined(_WIN32)
		Sleep(0); // yield, Sleep(0), SwitchToThread
#else
		usleep(0);
#endif
	}
}
void SFWTime::sleep_us(double us) {
	sleep_ns(us * 1e3);
}
void SFWTime::sleep_ms(double ms) {
	sleep_ns(ms * 1e6);
}
void SFWTime::sleep_ss(double ss) {
	sleep_ns(ss * 1e9);
}
#line 0

#line 1 "sfw/core/memory.cpp"
/*************************************************************************/
/*  memory.cpp                                                           */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void *operator new(size_t p_size, const char *p_description) {
	return Memory::alloc_static(p_size, false);
}

void *operator new(size_t p_size, void *(*p_allocfunc)(size_t p_size)) {
	return p_allocfunc(p_size);
}

#ifdef _MSC_VER
void operator delete(void *p_mem, const char *p_description) {
	CRASH_MSG("Call to placement delete should not happen.");
}

void operator delete(void *p_mem, void *(*p_allocfunc)(size_t p_size)) {
	CRASH_MSG("Call to placement delete should not happen.");
}

void operator delete(void *p_mem, void *p_pointer, size_t check, const char *p_description) {
	CRASH_MSG("Call to placement delete should not happen.");
}
#endif

#ifdef DEBUG_ENABLED
SafeNumeric<uint64_t> Memory::mem_usage;
SafeNumeric<uint64_t> Memory::max_usage;
#endif

SafeNumeric<uint64_t> Memory::alloc_count;

void *Memory::alloc_static(size_t p_bytes, bool p_pad_align) {
#ifdef DEBUG_ENABLED
	bool prepad = true;
#else
	bool prepad = p_pad_align;
#endif

	void *mem = malloc(p_bytes + (prepad ? PAD_ALIGN : 0));

	ERR_FAIL_COND_V(!mem, nullptr);

	alloc_count.increment();

	if (prepad) {
		uint64_t *s = (uint64_t *)mem;
		*s = p_bytes;

		uint8_t *s8 = (uint8_t *)mem;

#ifdef DEBUG_ENABLED
		uint64_t new_mem_usage = mem_usage.add(p_bytes);
		max_usage.exchange_if_greater(new_mem_usage);
#endif
		return s8 + PAD_ALIGN;
	} else {
		return mem;
	}
}

void *Memory::realloc_static(void *p_memory, size_t p_bytes, bool p_pad_align) {
	if (p_memory == nullptr) {
		return alloc_static(p_bytes, p_pad_align);
	}

	uint8_t *mem = (uint8_t *)p_memory;

#ifdef DEBUG_ENABLED
	bool prepad = true;
#else
	bool prepad = p_pad_align;
#endif

	if (prepad) {
		mem -= PAD_ALIGN;
		uint64_t *s = (uint64_t *)mem;

#ifdef DEBUG_ENABLED
		if (p_bytes > *s) {
			uint64_t new_mem_usage = mem_usage.add(p_bytes - *s);
			max_usage.exchange_if_greater(new_mem_usage);
		} else {
			mem_usage.sub(*s - p_bytes);
		}
#endif

		if (p_bytes == 0) {
			free(mem);
			return nullptr;
		} else {
			*s = p_bytes;

			mem = (uint8_t *)realloc(mem, p_bytes + PAD_ALIGN);
			ERR_FAIL_COND_V(!mem, nullptr);

			s = (uint64_t *)mem;

			*s = p_bytes;

			return mem + PAD_ALIGN;
		}
	} else {
		mem = (uint8_t *)realloc(mem, p_bytes);

		ERR_FAIL_COND_V(mem == nullptr && p_bytes > 0, nullptr);

		return mem;
	}
}

void Memory::free_static(void *p_ptr, bool p_pad_align) {
	ERR_FAIL_COND(p_ptr == nullptr);

	uint8_t *mem = (uint8_t *)p_ptr;

#ifdef DEBUG_ENABLED
	bool prepad = true;
#else
	bool prepad = p_pad_align;
#endif

	alloc_count.decrement();

	if (prepad) {
		mem -= PAD_ALIGN;

#ifdef DEBUG_ENABLED
		uint64_t *s = (uint64_t *)mem;
		mem_usage.sub(*s);
#endif

		free(mem);
	} else {
		free(mem);
	}
}

uint64_t Memory::get_mem_available() {
	return -1; // 0xFFFF...
}

uint64_t Memory::get_mem_usage() {
#ifdef DEBUG_ENABLED
	return mem_usage.get();
#else
	return 0;
#endif
}

uint64_t Memory::get_mem_max_usage() {
#ifdef DEBUG_ENABLED
	return max_usage.get();
#else
	return 0;
#endif
}

_GlobalNil::_GlobalNil() {
	color = 1;
	left = this;
	right = this;
	parent = this;
}

_GlobalNil _GlobalNilClass::_nil;
#line 0

#line 1 "sfw/core/pool_vector.cpp"
/*************************************************************************/
/*  pool_vector.cpp                                                      */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

Mutex pool_vector_lock;

PoolAllocator *MemoryPool::memory_pool = nullptr;
uint8_t *MemoryPool::pool_memory = nullptr;
size_t *MemoryPool::pool_size = nullptr;

MemoryPool::Alloc *MemoryPool::allocs = nullptr;
MemoryPool::Alloc *MemoryPool::free_list = nullptr;
uint32_t MemoryPool::alloc_count = 0;
uint32_t MemoryPool::allocs_used = 0;
Mutex MemoryPool::alloc_mutex;

size_t MemoryPool::total_memory = 0;
size_t MemoryPool::max_memory = 0;

void MemoryPool::setup(uint32_t p_max_allocs) {
	allocs = memnew_arr(Alloc, p_max_allocs);
	alloc_count = p_max_allocs;
	allocs_used = 0;

	for (uint32_t i = 0; i < alloc_count - 1; i++) {
		allocs[i].free_list = &allocs[i + 1];
	}

	free_list = &allocs[0];
}

void MemoryPool::cleanup() {
	memdelete_arr(allocs);

	ERR_FAIL_COND_MSG(allocs_used > 0, "There are still MemoryPool allocs in use at exit!");
}
#line 0

#line 1 "sfw/core/pool_allocator.cpp"
/*************************************************************************/
/*  pool_allocator.cpp                                                   */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#define COMPACT_CHUNK(m_entry, m_to_pos)                      \
	do {                                                      \
		void *_dst = &((unsigned char *)pool)[m_to_pos];      \
		void *_src = &((unsigned char *)pool)[(m_entry).pos]; \
		memmove(_dst, _src, aligned((m_entry).len));          \
		(m_entry).pos = m_to_pos;                             \
	} while (0);

void PoolAllocator::mt_lock() const {
}

void PoolAllocator::mt_unlock() const {
}

bool PoolAllocator::get_free_entry(EntryArrayPos *p_pos) {
	if (entry_count == entry_max) {
		return false;
	}

	for (int i = 0; i < entry_max; i++) {
		if (entry_array[i].len == 0) {
			*p_pos = i;
			return true;
		}
	}

	ERR_PRINT("Out of memory Chunks!");

	return false; //
}

/**
 * Find a hole
 * @param p_pos The hole is behind the block pointed by this variable upon return. if pos==entry_count, then allocate at end
 * @param p_for_size hole size
 * @return false if hole found, true if no hole found
 */
bool PoolAllocator::find_hole(EntryArrayPos *p_pos, int p_for_size) {
	/* position where previous entry ends. Defaults to zero (begin of pool) */

	int prev_entry_end_pos = 0;

	for (int i = 0; i < entry_count; i++) {
		Entry &entry = entry_array[entry_indices[i]];

		/* determine hole size to previous entry */

		int hole_size = entry.pos - prev_entry_end_pos;

		/* determine if what we want fits in that hole */
		if (hole_size >= p_for_size) {
			*p_pos = i;
			return true;
		}

		/* prepare for next one */
		prev_entry_end_pos = entry_end(entry);
	}

	/* No holes between entries, check at the end..*/

	if ((pool_size - prev_entry_end_pos) >= p_for_size) {
		*p_pos = entry_count;
		return true;
	}

	return false;
}

void PoolAllocator::compact(int p_up_to) {
	uint32_t prev_entry_end_pos = 0;

	if (p_up_to < 0) {
		p_up_to = entry_count;
	}
	for (int i = 0; i < p_up_to; i++) {
		Entry &entry = entry_array[entry_indices[i]];

		/* determine hole size to previous entry */

		int hole_size = entry.pos - prev_entry_end_pos;

		/* if we can compact, do it */
		if (hole_size > 0 && !entry.lock) {
			COMPACT_CHUNK(entry, prev_entry_end_pos);
		}

		/* prepare for next one */
		prev_entry_end_pos = entry_end(entry);
	}
}

void PoolAllocator::compact_up(int p_from) {
	uint32_t next_entry_end_pos = pool_size; // - static_area_size;

	for (int i = entry_count - 1; i >= p_from; i--) {
		Entry &entry = entry_array[entry_indices[i]];

		/* determine hole size to nextious entry */

		int hole_size = next_entry_end_pos - (entry.pos + aligned(entry.len));

		/* if we can compact, do it */
		if (hole_size > 0 && !entry.lock) {
			COMPACT_CHUNK(entry, (next_entry_end_pos - aligned(entry.len)));
		}

		/* prepare for next one */
		next_entry_end_pos = entry.pos;
	}
}

bool PoolAllocator::find_entry_index(EntryIndicesPos *p_map_pos, Entry *p_entry) {
	EntryArrayPos entry_pos = entry_max;

	for (int i = 0; i < entry_count; i++) {
		if (&entry_array[entry_indices[i]] == p_entry) {
			entry_pos = i;
			break;
		}
	}

	if (entry_pos == entry_max) {
		return false;
	}

	*p_map_pos = entry_pos;
	return true;
}

PoolAllocator::ID PoolAllocator::alloc(int p_size) {
	ERR_FAIL_COND_V(p_size < 1, POOL_ALLOCATOR_INVALID_ID);
	ERR_FAIL_COND_V(p_size > free_mem, POOL_ALLOCATOR_INVALID_ID);

	mt_lock();

	if (entry_count == entry_max) {
		mt_unlock();
		ERR_PRINT("entry_count==entry_max");
		return POOL_ALLOCATOR_INVALID_ID;
	}

	int size_to_alloc = aligned(p_size);

	EntryIndicesPos new_entry_indices_pos;

	if (!find_hole(&new_entry_indices_pos, size_to_alloc)) {
		/* No hole could be found, try compacting mem */
		compact();
		/* Then search again */

		if (!find_hole(&new_entry_indices_pos, size_to_alloc)) {
			mt_unlock();
			ERR_FAIL_V_MSG(POOL_ALLOCATOR_INVALID_ID, "Memory can't be compacted further.");
		}
	}

	EntryArrayPos new_entry_array_pos;

	bool found_free_entry = get_free_entry(&new_entry_array_pos);

	if (!found_free_entry) {
		mt_unlock();
		ERR_FAIL_V_MSG(POOL_ALLOCATOR_INVALID_ID, "No free entry found in PoolAllocator.");
	}

	/* move all entry indices up, make room for this one */
	for (int i = entry_count; i > new_entry_indices_pos; i--) {
		entry_indices[i] = entry_indices[i - 1];
	}

	entry_indices[new_entry_indices_pos] = new_entry_array_pos;

	entry_count++;

	Entry &entry = entry_array[entry_indices[new_entry_indices_pos]];

	entry.len = p_size;
	entry.pos = (new_entry_indices_pos == 0) ? 0 : entry_end(entry_array[entry_indices[new_entry_indices_pos - 1]]); //alloc either at beginning or end of previous
	entry.lock = 0;
	entry.check = (check_count++) & CHECK_MASK;
	free_mem -= size_to_alloc;
	if (free_mem < free_mem_peak) {
		free_mem_peak = free_mem;
	}

	ID retval = (entry_indices[new_entry_indices_pos] << CHECK_BITS) | entry.check;
	mt_unlock();

	//ERR_FAIL_COND_V( (uintptr_t)get(retval)%align != 0, retval );

	return retval;
}

PoolAllocator::Entry *PoolAllocator::get_entry(ID p_mem) {
	unsigned int check = p_mem & CHECK_MASK;
	int entry = p_mem >> CHECK_BITS;
	ERR_FAIL_INDEX_V(entry, entry_max, nullptr);
	ERR_FAIL_COND_V(entry_array[entry].check != check, nullptr);
	ERR_FAIL_COND_V(entry_array[entry].len == 0, nullptr);

	return &entry_array[entry];
}

const PoolAllocator::Entry *PoolAllocator::get_entry(ID p_mem) const {
	unsigned int check = p_mem & CHECK_MASK;
	int entry = p_mem >> CHECK_BITS;
	ERR_FAIL_INDEX_V(entry, entry_max, nullptr);
	ERR_FAIL_COND_V(entry_array[entry].check != check, nullptr);
	ERR_FAIL_COND_V(entry_array[entry].len == 0, nullptr);

	return &entry_array[entry];
}

void PoolAllocator::free(ID p_mem) {
	mt_lock();
	Entry *e = get_entry(p_mem);
	if (!e) {
		mt_unlock();
		ERR_PRINT("!e");
		return;
	}
	if (e->lock) {
		mt_unlock();
		ERR_PRINT("e->lock");
		return;
	}

	EntryIndicesPos entry_indices_pos;

	bool index_found = find_entry_index(&entry_indices_pos, e);
	if (!index_found) {
		mt_unlock();
		ERR_FAIL_COND(!index_found);
	}

	for (int i = entry_indices_pos; i < (entry_count - 1); i++) {
		entry_indices[i] = entry_indices[i + 1];
	}

	entry_count--;
	free_mem += aligned(e->len);
	e->clear();
	mt_unlock();
}

int PoolAllocator::get_size(ID p_mem) const {
	int size;
	mt_lock();

	const Entry *e = get_entry(p_mem);
	if (!e) {
		mt_unlock();
		ERR_PRINT("!e");
		return 0;
	}

	size = e->len;

	mt_unlock();

	return size;
}

Error PoolAllocator::resize(ID p_mem, int p_new_size) {
	mt_lock();
	Entry *e = get_entry(p_mem);

	if (!e) {
		mt_unlock();
		ERR_FAIL_COND_V(!e, ERR_INVALID_PARAMETER);
	}

	if (needs_locking && e->lock) {
		mt_unlock();
		ERR_FAIL_COND_V(e->lock, ERR_ALREADY_IN_USE);
	}

	uint32_t alloc_size = aligned(p_new_size);

	if ((uint32_t)aligned(e->len) == alloc_size) {
		e->len = p_new_size;
		mt_unlock();
		return OK;
	} else if (e->len > (uint32_t)p_new_size) {
		free_mem += aligned(e->len);
		free_mem -= alloc_size;
		e->len = p_new_size;
		mt_unlock();
		return OK;
	}

	//p_new_size = align(p_new_size)
	int _free = free_mem; // - static_area_size;

	if (uint32_t(_free + aligned(e->len)) < alloc_size) {
		mt_unlock();
		ERR_FAIL_V(ERR_OUT_OF_MEMORY);
	};

	EntryIndicesPos entry_indices_pos;

	bool index_found = find_entry_index(&entry_indices_pos, e);

	if (!index_found) {
		mt_unlock();
		ERR_FAIL_COND_V(!index_found, ERR_BUG);
	}

	//no need to move stuff around, it fits before the next block
	uint32_t next_pos;
	if (entry_indices_pos + 1 == entry_count) {
		next_pos = pool_size; // - static_area_size;
	} else {
		next_pos = entry_array[entry_indices[entry_indices_pos + 1]].pos;
	};

	if ((next_pos - e->pos) > alloc_size) {
		free_mem += aligned(e->len);
		e->len = p_new_size;
		free_mem -= alloc_size;
		mt_unlock();
		return OK;
	}
	//it doesn't fit, compact around BEFORE current index (make room behind)

	compact(entry_indices_pos + 1);

	if ((next_pos - e->pos) > alloc_size) {
		//now fits! hooray!
		free_mem += aligned(e->len);
		e->len = p_new_size;
		free_mem -= alloc_size;
		mt_unlock();
		if (free_mem < free_mem_peak) {
			free_mem_peak = free_mem;
		}
		return OK;
	}

	//STILL doesn't fit, compact around AFTER current index (make room after)

	compact_up(entry_indices_pos + 1);

	if ((entry_array[entry_indices[entry_indices_pos + 1]].pos - e->pos) > alloc_size) {
		//now fits! hooray!
		free_mem += aligned(e->len);
		e->len = p_new_size;
		free_mem -= alloc_size;
		mt_unlock();
		if (free_mem < free_mem_peak) {
			free_mem_peak = free_mem;
		}
		return OK;
	}

	mt_unlock();
	ERR_FAIL_V(ERR_OUT_OF_MEMORY);
}

Error PoolAllocator::lock(ID p_mem) {
	if (!needs_locking) {
		return OK;
	}
	mt_lock();
	Entry *e = get_entry(p_mem);
	if (!e) {
		mt_unlock();
		ERR_PRINT("!e");
		return ERR_INVALID_PARAMETER;
	}
	e->lock++;
	mt_unlock();
	return OK;
}

bool PoolAllocator::is_locked(ID p_mem) const {
	if (!needs_locking) {
		return false;
	}

	mt_lock();
	const Entry *e = ((PoolAllocator *)(this))->get_entry(p_mem);
	if (!e) {
		mt_unlock();
		ERR_PRINT("!e");
		return false;
	}
	bool locked = e->lock;
	mt_unlock();
	return locked;
}

const void *PoolAllocator::get(ID p_mem) const {
	if (!needs_locking) {
		const Entry *e = get_entry(p_mem);
		ERR_FAIL_COND_V(!e, nullptr);
		return &pool[e->pos];
	}

	mt_lock();
	const Entry *e = get_entry(p_mem);

	if (!e) {
		mt_unlock();
		ERR_FAIL_COND_V(!e, nullptr);
	}
	if (e->lock == 0) {
		mt_unlock();
		ERR_PRINT("e->lock == 0");
		return nullptr;
	}

	if ((int)e->pos >= pool_size) {
		mt_unlock();
		ERR_PRINT("e->pos<0 || e->pos>=pool_size");
		return nullptr;
	}
	const void *ptr = &pool[e->pos];

	mt_unlock();

	return ptr;
}

void *PoolAllocator::get(ID p_mem) {
	if (!needs_locking) {
		Entry *e = get_entry(p_mem);
		ERR_FAIL_COND_V(!e, nullptr);
		return &pool[e->pos];
	}

	mt_lock();
	Entry *e = get_entry(p_mem);

	if (!e) {
		mt_unlock();
		ERR_FAIL_COND_V(!e, nullptr);
	}
	if (e->lock == 0) {
		mt_unlock();
		ERR_PRINT("e->lock == 0");
		return nullptr;
	}

	if ((int)e->pos >= pool_size) {
		mt_unlock();
		ERR_PRINT("e->pos<0 || e->pos>=pool_size");
		return nullptr;
	}
	void *ptr = &pool[e->pos];

	mt_unlock();

	return ptr;
}
void PoolAllocator::unlock(ID p_mem) {
	if (!needs_locking) {
		return;
	}
	mt_lock();
	Entry *e = get_entry(p_mem);
	if (!e) {
		mt_unlock();
		ERR_FAIL_COND(!e);
	}
	if (e->lock == 0) {
		mt_unlock();
		ERR_PRINT("e->lock == 0");
		return;
	}
	e->lock--;
	mt_unlock();
}

int PoolAllocator::get_used_mem() const {
	return pool_size - free_mem;
}

int PoolAllocator::get_free_peak() {
	return free_mem_peak;
}

int PoolAllocator::get_free_mem() {
	return free_mem;
}

void PoolAllocator::create_pool(void *p_mem, int p_size, int p_max_entries) {
	pool = (uint8_t *)p_mem;
	pool_size = p_size;

	entry_array = memnew_arr(Entry, p_max_entries);
	entry_indices = memnew_arr(int, p_max_entries);
	entry_max = p_max_entries;
	entry_count = 0;

	free_mem = p_size;
	free_mem_peak = p_size;

	check_count = 0;
}

PoolAllocator::PoolAllocator(int p_size, bool p_needs_locking, int p_max_entries) {
	mem_ptr = memalloc(p_size);
	ERR_FAIL_COND(!mem_ptr);
	align = 1;
	create_pool(mem_ptr, p_size, p_max_entries);
	needs_locking = p_needs_locking;
}

PoolAllocator::PoolAllocator(void *p_mem, int p_size, int p_align, bool p_needs_locking, int p_max_entries) {
	if (p_align > 1) {
		uint8_t *mem8 = (uint8_t *)p_mem;
		uint64_t ofs = (uint64_t)mem8;
		if (ofs % p_align) {
			int dif = p_align - (ofs % p_align);
			mem8 += p_align - (ofs % p_align);
			p_size -= dif;
			p_mem = (void *)mem8;
		};
	};

	create_pool(p_mem, p_size, p_max_entries);
	needs_locking = p_needs_locking;
	align = p_align;
	mem_ptr = nullptr;
}

PoolAllocator::PoolAllocator(int p_align, int p_size, bool p_needs_locking, int p_max_entries) {
	ERR_FAIL_COND(p_align < 1);
	mem_ptr = Memory::alloc_static(p_size + p_align, true);
	uint8_t *mem8 = (uint8_t *)mem_ptr;
	uint64_t ofs = (uint64_t)mem8;
	if (ofs % p_align) {
		mem8 += p_align - (ofs % p_align);
	}
	create_pool(mem8, p_size, p_max_entries);
	needs_locking = p_needs_locking;
	align = p_align;
}

PoolAllocator::~PoolAllocator() {
	if (mem_ptr) {
		memfree(mem_ptr);
	}

	memdelete_arr(entry_array);
	memdelete_arr(entry_indices);
}

#undef COMPACT_CHUNK
#line 0

#line 1 "sfw/core/random_pcg.cpp"
/*************************************************************************/
/*  random_pcg.cpp                                                       */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

RandomPCG::RandomPCG(uint64_t p_seed, uint64_t p_inc) :
		pcg(),
		current_inc(p_inc) {
	seed(p_seed);
}

void RandomPCG::randomize() {
	seed((SFWTime::date() + SFWTime::time_us()) * pcg.state + PCG_DEFAULT_INC_64);
}

double RandomPCG::random(double p_from, double p_to) {
	return randd() * (p_to - p_from) + p_from;
}

float RandomPCG::random(float p_from, float p_to) {
	return randf() * (p_to - p_from) + p_from;
}

int RandomPCG::random(int p_from, int p_to) {
	if (p_from == p_to) {
		return p_from;
	}
	return rand(abs(p_from - p_to) + 1) + MIN(p_from, p_to);
}
#line 0

#line 1 "sfw/core/math_funcs.cpp"
/*************************************************************************/
/*  math_funcs.cpp                                                       */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

RandomPCG Math::default_rand(RandomPCG::DEFAULT_SEED, RandomPCG::DEFAULT_INC);

#define PHI 0x9e3779b9

uint32_t Math::rand_from_seed(uint64_t *seed) {
	RandomPCG rng = RandomPCG(*seed, RandomPCG::DEFAULT_INC);
	uint32_t r = rng.rand();
	*seed = rng.get_seed();
	return r;
}

void Math::seed(uint64_t x) {
	default_rand.seed(x);
}

void Math::randomize() {
	default_rand.randomize();
}

uint32_t Math::rand() {
	return default_rand.rand();
}

double Math::randfn(double mean, double deviation) {
	return default_rand.randfn(mean, deviation);
}

int Math::step_decimals(double p_step) {
	static const int maxn = 10;
	static const double sd[maxn] = {
		0.9999, // somehow compensate for floating point error
		0.09999,
		0.009999,
		0.0009999,
		0.00009999,
		0.000009999,
		0.0000009999,
		0.00000009999,
		0.000000009999,
		0.0000000009999
	};

	double abs = Math::abs(p_step);
	double decs = abs - (int)abs; // Strip away integer part
	for (int i = 0; i < maxn; i++) {
		if (decs >= sd[i]) {
			return i;
		}
	}

	return 0;
}

// Only meant for editor usage in float ranges, where a step of 0
// means that decimal digits should not be limited in String::num.
int Math::range_step_decimals(double p_step) {
	if (p_step < 0.0000000000001) {
		return 16; // Max value hardcoded in String::num
	}
	return step_decimals(p_step);
}

double Math::dectime(double p_value, double p_amount, double p_step) {
	double sgn = p_value < 0 ? -1.0 : 1.0;
	double val = Math::abs(p_value);
	val -= p_amount * p_step;
	if (val < 0.0) {
		val = 0.0;
	}
	return val * sgn;
}

double Math::ease(double p_x, double p_c) {
	if (p_x < 0) {
		p_x = 0;
	} else if (p_x > 1.0) {
		p_x = 1.0;
	}
	if (p_c > 0) {
		if (p_c < 1.0) {
			return 1.0 - Math::pow(1.0 - p_x, 1.0 / p_c);
		} else {
			return Math::pow(p_x, p_c);
		}
	} else if (p_c < 0) {
		//inout ease

		if (p_x < 0.5) {
			return Math::pow(p_x * 2.0, -p_c) * 0.5;
		} else {
			return (1.0 - Math::pow(1.0 - (p_x - 0.5) * 2.0, -p_c)) * 0.5 + 0.5;
		}
	} else {
		return 0; // no ease (raw)
	}
}

double Math::stepify(double p_value, double p_step) {
	if (p_step != 0) {
		p_value = Math::floor(p_value / p_step + 0.5) * p_step;
	}
	return p_value;
}

uint32_t Math::larger_prime(uint32_t p_val) {
	static const uint32_t primes[] = {
		5,
		13,
		23,
		47,
		97,
		193,
		389,
		769,
		1543,
		3079,
		6151,
		12289,
		24593,
		49157,
		98317,
		196613,
		393241,
		786433,
		1572869,
		3145739,
		6291469,
		12582917,
		25165843,
		50331653,
		100663319,
		201326611,
		402653189,
		805306457,
		1610612741,
		0,
	};

	int idx = 0;
	while (true) {
		ERR_FAIL_COND_V(primes[idx] == 0, 0);
		if (primes[idx] > p_val) {
			return primes[idx];
		}
		idx++;
	}
}

double Math::random(double from, double to) {
	return default_rand.random(from, to);
}

float Math::random(float from, float to) {
	return default_rand.random(from, to);
}

real_t Math::randomr(real_t from, real_t to) {
	return default_rand.randomr(from, to);
}

int Math::random(int from, int to) {
	return default_rand.random(from, to);
}
#line 0

#line 1 "sfw/core/ustring.cpp"
/*************************************************************************/
/*  ustring.cpp                                                          */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS // to disable build-time warning which suggested to use strcpy_s instead strcpy
#endif

#define PRINT_UNICODE_ERRORS 0

#if defined(MINGW_ENABLED) || defined(_MSC_VER)
#define snprintf _snprintf_s
#endif

#define MAX_DIGITS 6
#define UPPERCASE(m_c) (((m_c) >= 'a' && (m_c) <= 'z') ? ((m_c) - ('a' - 'A')) : (m_c))
#define LOWERCASE(m_c) (((m_c) >= 'A' && (m_c) <= 'Z') ? ((m_c) + ('a' - 'A')) : (m_c))
#define IS_DIGIT(m_d) ((m_d) >= '0' && (m_d) <= '9')
#define IS_HEX_DIGIT(m_d) (((m_d) >= '0' && (m_d) <= '9') || ((m_d) >= 'a' && (m_d) <= 'f') || ((m_d) >= 'A' && (m_d) <= 'F'))

#define READING_SIGN 0
#define READING_INT 1
#define READING_DEC 2
#define READING_EXP 3
#define READING_DONE 4

const char CharString::_null = 0;
const char16_t Char16String::_null = 0;
const CharType String::_null = 0;

static bool _wildcard_match(const CharType *p_pattern, const CharType *p_string, bool p_case_sensitive) {
	switch (*p_pattern) {
		case '\0':
			return !*p_string;
		case '*':
			return _wildcard_match(p_pattern + 1, p_string, p_case_sensitive) || (*p_string && _wildcard_match(p_pattern, p_string + 1, p_case_sensitive));
		case '?':
			return *p_string && (*p_string != '.') && _wildcard_match(p_pattern + 1, p_string + 1, p_case_sensitive);
		default:

			return (p_case_sensitive ? (*p_string == *p_pattern) : (_find_upper(*p_string) == _find_upper(*p_pattern))) && _wildcard_match(p_pattern + 1, p_string + 1, p_case_sensitive);
	}
}

static int _humanize_digits(int p_num) {
	if (p_num < 100) {
		return 2;
	} else if (p_num < 1024) {
		return 1;
	} else {
		return 0;
	}
}

bool select_word(const String &p_s, int p_col, int &r_beg, int &r_end) {
	const String &s = p_s;
	int beg = CLAMP(p_col, 0, s.length());
	int end = beg;

	if (s[beg] > 32 || beg == s.length()) {
		bool symbol = beg < s.length() && is_symbol(s[beg]);

		while (beg > 0 && s[beg - 1] > 32 && (symbol == is_symbol(s[beg - 1]))) {
			beg--;
		}
		while (end < s.length() && s[end + 1] > 32 && (symbol == is_symbol(s[end + 1]))) {
			end++;
		}

		if (end < s.length()) {
			end += 1;
		}

		r_beg = beg;
		r_end = end;

		return true;
	} else {
		return false;
	}
}

/*************************************************************************/
/*  Char16String                                                         */
/*************************************************************************/

bool Char16String::operator<(const Char16String &p_right) const {
	if (length() == 0) {
		return p_right.length() != 0;
	}

	return is_str_less(get_data(), p_right.get_data());
}

Char16String &Char16String::operator+=(char16_t p_char) {
	const int lhs_len = length();
	resize(lhs_len + 2);

	char16_t *dst = ptrw();
	dst[lhs_len] = p_char;
	dst[lhs_len + 1] = 0;

	return *this;
}

void Char16String::operator=(const char16_t *p_cstr) {
	copy_from(p_cstr);
}

const char16_t *Char16String::get_data() const {
	if (size()) {
		return &operator[](0);
	} else {
		return u"";
	}
}

void Char16String::copy_from(const char16_t *p_cstr) {
	if (!p_cstr) {
		resize(0);
		return;
	}

	const char16_t *s = p_cstr;
	for (; *s; s++) {
	}
	size_t len = s - p_cstr;

	if (len == 0) {
		resize(0);
		return;
	}

	Error err = resize(++len); // include terminating null char

	ERR_FAIL_COND_MSG(err != OK, "Failed to copy char16_t string.");

	memcpy(ptrw(), p_cstr, len * sizeof(char16_t));
}

/*************************************************************************/
/*  CharString                                                           */
/*************************************************************************/

bool CharString::operator<(const CharString &p_right) const {
	if (length() == 0) {
		return p_right.length() != 0;
	}

	return is_str_less(get_data(), p_right.get_data());
}

CharString &CharString::operator+=(char p_char) {
	const int lhs_len = length();
	resize(lhs_len + 2);

	char *dst = ptrw();
	dst[lhs_len] = p_char;
	dst[lhs_len + 1] = 0;

	return *this;
}

void CharString::operator=(const char *p_cstr) {
	copy_from(p_cstr);
}

const char *CharString::get_data() const {
	if (size()) {
		return &operator[](0);
	} else {
		return "";
	}
}

void CharString::copy_from(const char *p_cstr) {
	if (!p_cstr) {
		resize(0);
		return;
	}

	size_t len = strlen(p_cstr);

	if (len == 0) {
		resize(0);
		return;
	}

	Error err = resize(++len); // include terminating null char

	ERR_FAIL_COND_MSG(err != OK, "Failed to copy C-string.");

	memcpy(ptrw(), p_cstr, len);
}

/*************************************************************************/
/*  String                                                               */
/*************************************************************************/

void String::copy_from(const char *p_cstr) {
	// copy Latin-1 encoded c-string directly
	if (!p_cstr) {
		resize(0);
		return;
	}

	const size_t len = strlen(p_cstr);

	if (len == 0) {
		resize(0);
		return;
	}

	resize(len + 1); // include 0

	CharType *dst = this->ptrw();

	for (size_t i = 0; i <= len; i++) {
		uint8_t c = p_cstr[i] >= 0 ? p_cstr[i] : uint8_t(256 + p_cstr[i]);
		if (c == 0 && i < len) {
#if PRINT_UNICODE_ERRORS
			print_unicode_error("NUL character", true);
#endif
			dst[i] = 0x20;
		} else {
			dst[i] = c;
		}
	}
}

void String::copy_from(const char *p_cstr, const int p_clip_to) {
	// copy Latin-1 encoded c-string directly
	if (!p_cstr) {
		resize(0);
		return;
	}

	int len = 0;
	const char *ptr = p_cstr;
	while ((p_clip_to < 0 || len < p_clip_to) && *(ptr++) != 0) {
		len++;
	}

	if (len == 0) {
		resize(0);
		return;
	}

	resize(len + 1); // include 0

	CharType *dst = this->ptrw();

	for (int i = 0; i < len; i++) {
		uint8_t c = p_cstr[i] >= 0 ? p_cstr[i] : uint8_t(256 + p_cstr[i]);
		if (c == 0) {
#if PRINT_UNICODE_ERRORS
			print_unicode_error("NUL character", true);
#endif

			dst[i] = 0x20;
		} else {
			dst[i] = c;
		}
	}
	dst[len] = 0;
}

void String::copy_from(const wchar_t *p_cstr) {
#ifdef WINDOWS_ENABLED
	// wchar_t is 16-bit, parse as UTF-16
	parse_utf16((const char16_t *)p_cstr);
#else
	// wchar_t is 32-bit, copy directly
	copy_from((const CharType *)p_cstr);
#endif
}

void String::copy_from(const wchar_t *p_cstr, const int p_clip_to) {
#ifdef WINDOWS_ENABLED
	// wchar_t is 16-bit, parse as UTF-16
	parse_utf16((const char16_t *)p_cstr, p_clip_to);
#else
	// wchar_t is 32-bit, copy directly
	copy_from((const CharType *)p_cstr, p_clip_to);
#endif
}

void String::copy_from(const Char16String &p_str) {
	parse_utf16(p_str.ptr());
}

void String::copy_from(const CharType &p_char) {
	if (p_char == 0) {
#if PRINT_UNICODE_ERRORS
		print_unicode_error("NUL character", true);
#endif

		return;
	}
	/*
	if ((p_char & 0xfffff800) == 0xd800) {
		print_unicode_error(vformat("Unpaired surrogate (%x)", (uint32_t)p_char));
	}
	if (p_char > 0x10ffff) {
		print_unicode_error(vformat("Invalid unicode codepoint (%x)", (uint32_t)p_char));
	}
	*/

	resize(2);

	CharType *dst = ptrw();
	dst[0] = p_char;
	dst[1] = 0;
}

void String::copy_from(const CharType *p_cstr) {
	if (!p_cstr) {
		resize(0);
		return;
	}

	int len = 0;
	const CharType *ptr = p_cstr;
	while (*(ptr++) != 0) {
		len++;
	}

	if (len == 0) {
		resize(0);
		return;
	}

	copy_from_unchecked(p_cstr, len);
}

void String::copy_from(const CharType *p_cstr, const int p_clip_to) {
	if (!p_cstr) {
		resize(0);
		return;
	}

	int len = 0;
	const CharType *ptr = p_cstr;
	while ((p_clip_to < 0 || len < p_clip_to) && *(ptr++) != 0) {
		len++;
	}

	if (len == 0) {
		resize(0);
		return;
	}

	copy_from_unchecked(p_cstr, len);
}

// assumes the following have already been validated:
// p_char != nullptr
// p_length > 0
// p_length <= p_char strlen
void String::copy_from_unchecked(const CharType *p_char, const int p_length) {
	resize(p_length + 1);
	CharType *dst = ptrw();
	dst[p_length] = 0;

	for (int i = 0; i < p_length; i++) {
		if (p_char[i] == 0) {
#if PRINT_UNICODE_ERRORS
			print_unicode_error("NUL character", true);
#endif

			dst[i] = 0x20;
			continue;
		}
		/*
		if ((p_char[i] & 0xfffff800) == 0xd800) {
			print_unicode_error(vformat("Unpaired surrogate (%x)", (uint32_t)p_char[i]));
		}
		if (p_char[i] > 0x10ffff) {
			print_unicode_error(vformat("Invalid unicode codepoint (%x)", (uint32_t)p_char[i]));
		}
		*/
		dst[i] = p_char[i];
	}
}

bool String::operator==(const String &p_str) const {
	if (length() != p_str.length()) {
		return false;
	}
	if (empty()) {
		return true;
	}

	int l = length();

	const CharType *src = get_data();
	const CharType *dst = p_str.get_data();

	/* Compare char by char */
	for (int i = 0; i < l; i++) {
		if (src[i] != dst[i]) {
			return false;
		}
	}

	return true;
}

bool String::operator!=(const String &p_str) const {
	return !((*this == p_str));
}

String String::operator+(const String &p_str) const {
	String res = *this;
	res += p_str;
	return res;
}

/*
String String::operator+(CharType p_char) const {
	String res = *this;
	res += p_char;
	return res;
}
*/

String &String::operator+=(const String &p_str) {
	const int lhs_len = length();
	if (lhs_len == 0) {
		*this = p_str;
		return *this;
	}

	const int rhs_len = p_str.length();
	if (rhs_len == 0) {
		return *this;
	}

	set_length(lhs_len + rhs_len);

	const CharType *src = p_str.get_data();
	CharType *dst = ptrw() + lhs_len;

	memcpy(dst, src, rhs_len * sizeof(CharType));

	return *this;
}

String &String::operator+=(CharType p_char) {
	if (p_char == 0) {
#if PRINT_UNICODE_ERRORS
		print_unicode_error("NUL character", true);
#endif

		return *this;
	}
	/*
	if ((p_char & 0xfffff800) == 0xd800) {
		print_unicode_error(vformat("Unpaired surrogate (%x)", (uint32_t)p_char));
	}
	if (p_char > 0x10ffff) {
		print_unicode_error(vformat("Invalid unicode codepoint (%x)", (uint32_t)p_char));
	}
	*/

	const int lhs_len = length();
	set_length(lhs_len + 1);
	CharType *dst = ptrw();
	dst[lhs_len] = p_char;

	return *this;
}

String &String::operator+=(const char *p_str) {
	if (!p_str || p_str[0] == 0) {
		return *this;
	}

	const int lhs_len = length();
	const size_t rhs_len = strlen(p_str);

	set_length(lhs_len + rhs_len);

	CharType *dst = ptrw() + lhs_len;

	for (size_t i = 0; i <= rhs_len; i++) {
		uint8_t c = p_str[i] >= 0 ? p_str[i] : uint8_t(256 + p_str[i]);
		if (c == 0 && i < rhs_len) {
#if PRINT_UNICODE_ERRORS
			print_unicode_error("NUL character", true);
#endif

			dst[i] = 0x20;
		} else {
			dst[i] = c;
		}
	}

	return *this;
}

String &String::operator+=(const wchar_t *p_str) {
#ifdef WINDOWS_ENABLED
	// wchar_t is 16-bit
	*this += String::utf16((const char16_t *)p_str);
#else
	// wchar_t is 32-bit
	*this += String((const CharType *)p_str);
#endif
	return *this;
}

String &String::operator+=(const CharType *p_str) {
	*this += String(p_str);
	return *this;
}

void String::operator=(const char *p_str) {
	copy_from(p_str);
}

void String::operator=(const CharType *p_str) {
	copy_from(p_str);
}

void String::operator=(const wchar_t *p_str) {
	copy_from(p_str);
}

bool String::operator==(const char *p_str) const {
	// compare Latin-1 encoded c-string
	int len = 0;
	const char *aux = p_str;

	while (*(aux++) != 0) {
		len++;
	}

	if (length() != len) {
		return false;
	}
	if (empty()) {
		return true;
	}

	int l = length();

	const CharType *dst = get_data();

	// Compare char by char
	for (int i = 0; i < l; i++) {
		if ((CharType)p_str[i] != dst[i]) {
			return false;
		}
	}

	return true;
}

bool String::operator==(const wchar_t *p_str) const {
#ifdef WINDOWS_ENABLED
	// wchar_t is 16-bit, parse as UTF-16
	return *this == String::utf16((const char16_t *)p_str);
#else
	// wchar_t is 32-bit, compare char by char
	return *this == (const CharType *)p_str;
#endif
}

bool String::operator==(const CharType *p_str) const {
	int len = 0;
	const CharType *aux = p_str;

	while (*(aux++) != 0) {
		len++;
	}

	if (length() != len) {
		return false;
	}
	if (empty()) {
		return true;
	}

	int l = length();

	const CharType *dst = get_data();

	/* Compare char by char */
	for (int i = 0; i < l; i++) {
		if (p_str[i] != dst[i]) {
			return false;
		}
	}

	return true;
}

bool String::operator==(const StrRange &p_str_range) const {
	int len = p_str_range.len;

	if (length() != len) {
		return false;
	}
	if (empty()) {
		return true;
	}

	const CharType *c_str = p_str_range.c_str;
	const CharType *dst = &operator[](0);

	/* Compare char by char */
	for (int i = 0; i < len; i++) {
		if (c_str[i] != dst[i]) {
			return false;
		}
	}

	return true;
}

bool String::operator!=(const char *p_str) const {
	return (!(*this == p_str));
}

bool String::operator!=(const wchar_t *p_str) const {
	return (!(*this == p_str));
}

bool String::operator!=(const CharType *p_str) const {
	return (!(*this == p_str));
}

bool String::operator<(const char *p_str) const {
	if (empty() && p_str[0] == 0) {
		return false;
	}
	if (empty()) {
		return true;
	}
	return is_str_less(get_data(), p_str);
}

bool String::operator<(const wchar_t *p_str) const {
	if (empty() && p_str[0] == 0) {
		return false;
	}
	if (empty()) {
		return true;
	}

#ifdef WINDOWS_ENABLED
	// wchar_t is 16-bit
	return is_str_less(get_data(), String::utf16((const char16_t *)p_str).get_data());
#else
	// wchar_t is 32-bit
	return is_str_less(get_data(), (const CharType *)p_str);
#endif
}

bool String::operator<(const CharType *p_str) const {
	if (empty() && p_str[0] == 0) {
		return false;
	}
	if (empty()) {
		return true;
	}

	return is_str_less(get_data(), p_str);
}

bool String::operator<(const String &p_str) const {
	return operator<(p_str.get_data());
}

bool String::operator<=(const String &p_str) const {
	return !(p_str < *this);
}

bool String::operator>(const String &p_str) const {
	return p_str < *this;
}

bool String::operator>=(const String &p_str) const {
	return !(*this < p_str);
}

signed char String::nocasecmp_to(const String &p_str) const {
	if (empty() && p_str.empty()) {
		return 0;
	}
	if (empty()) {
		return -1;
	}
	if (p_str.empty()) {
		return 1;
	}

	const CharType *that_str = p_str.get_data();
	const CharType *this_str = get_data();

	while (true) {
		if (*that_str == 0 && *this_str == 0) {
			return 0; //we're equal
		} else if (*this_str == 0) {
			return -1; //if this is empty, and the other one is not, then we're less.. I think?
		} else if (*that_str == 0) {
			return 1; //otherwise the other one is smaller..
		} else if (_find_upper(*this_str) < _find_upper(*that_str)) { //more than
			return -1;
		} else if (_find_upper(*this_str) > _find_upper(*that_str)) { //less than
			return 1;
		}

		this_str++;
		that_str++;
	}
}

signed char String::casecmp_to(const String &p_str) const {
	if (empty() && p_str.empty()) {
		return 0;
	}
	if (empty()) {
		return -1;
	}
	if (p_str.empty()) {
		return 1;
	}

	const CharType *that_str = p_str.get_data();
	const CharType *this_str = get_data();

	while (true) {
		if (*that_str == 0 && *this_str == 0) {
			return 0; //we're equal
		} else if (*this_str == 0) {
			return -1; //if this is empty, and the other one is not, then we're less.. I think?
		} else if (*that_str == 0) {
			return 1; //otherwise the other one is smaller..
		} else if (*this_str < *that_str) { //more than
			return -1;
		} else if (*this_str > *that_str) { //less than
			return 1;
		}

		this_str++;
		that_str++;
	}
}

signed char String::naturalnocasecmp_to(const String &p_str) const {
	const CharType *this_str = get_data();
	const CharType *that_str = p_str.get_data();

	if (this_str && that_str) {
		while (*this_str == '.' || *that_str == '.') {
			if (*this_str++ != '.') {
				return 1;
			}
			if (*that_str++ != '.') {
				return -1;
			}
			if (!*that_str) {
				return 1;
			}
			if (!*this_str) {
				return -1;
			}
		}

		while (*this_str) {
			if (!*that_str) {
				return 1;
			} else if (is_digit(*this_str)) {
				if (!is_digit(*that_str)) {
					return -1;
				}

				// Keep ptrs to start of numerical sequences
				const CharType *this_substr = this_str;
				const CharType *that_substr = that_str;

				// Compare lengths of both numerical sequences, ignoring leading zeros
				while (is_digit(*this_str)) {
					this_str++;
				}
				while (is_digit(*that_str)) {
					that_str++;
				}
				while (*this_substr == '0') {
					this_substr++;
				}
				while (*that_substr == '0') {
					that_substr++;
				}
				int this_len = this_str - this_substr;
				int that_len = that_str - that_substr;

				if (this_len < that_len) {
					return -1;
				} else if (this_len > that_len) {
					return 1;
				}

				// If lengths equal, compare lexicographically
				while (this_substr != this_str && that_substr != that_str) {
					if (*this_substr < *that_substr) {
						return -1;
					} else if (*this_substr > *that_substr) {
						return 1;
					}
					this_substr++;
					that_substr++;
				}
			} else if (is_digit(*that_str)) {
				return 1;
			} else {
				if (_find_upper(*this_str) < _find_upper(*that_str)) { //more than
					return -1;
				} else if (_find_upper(*this_str) > _find_upper(*that_str)) { //less than
					return 1;
				}

				this_str++;
				that_str++;
			}
		}
		if (*that_str) {
			return -1;
		}
	}

	return 0;
}

const CharType *String::get_data() const {
	static const CharType zero = 0;
	return size() ? &operator[](0) : &zero;
}

bool String::is_valid_string() const {
	int l = length();
	const CharType *src = get_data();
	bool valid = true;
	for (int i = 0; i < l; i++) {
		valid = valid && (src[i] < 0xd800 || (src[i] > 0xdfff && src[i] <= 0x10ffff));
	}
	return valid;
}

void String::print_unicode_error(const String &p_message, bool p_critical) const {
	/*
	if (p_critical) {
		print_error(vformat("Unicode parsing error, some characters were replaced with spaces: %s", p_message));
	} else {
		print_error(vformat("Unicode parsing error: %s", p_message));
	}
	*/
}

/* complex helpers */

String String::substr(int p_from, int p_chars) const {
	if (p_chars == -1) {
		p_chars = length() - p_from;
	}

	if (empty() || p_from < 0 || p_from >= length() || p_chars <= 0) {
		return "";
	}

	if ((p_from + p_chars) > length()) {
		p_chars = length() - p_from;
	}

	if (p_from == 0 && p_chars >= length()) {
		return String(*this);
	}

	String s = String();
	s.copy_from_unchecked(&get_data()[p_from], p_chars);
	return s;
}

String String::substr_index(const int start_index, const int end_index) const {
	int s = length();

	if (start_index < 0 || start_index >= s || end_index < 0) {
		return "";
	}

	if (start_index > end_index) {
		return "";
	}

	if (end_index > s) {
		return substr(start_index, (s - 1) - start_index);
	}

	return substr(start_index, end_index - start_index);
}

int String::find(const String &p_str, int p_from) const {
	if (p_from < 0) {
		return -1;
	}

	const int src_len = p_str.length();

	const int len = length();

	if (src_len == 0 || len == 0) {
		return -1; // won't find anything!
	}

	const CharType *src = get_data();
	const CharType *str = p_str.get_data();

	for (int i = p_from; i <= (len - src_len); i++) {
		bool found = true;
		for (int j = 0; j < src_len; j++) {
			int read_pos = i + j;

			if (read_pos >= len) {
				ERR_PRINT("read_pos>=len");
				return -1;
			};

			if (src[read_pos] != str[j]) {
				found = false;
				break;
			}
		}

		if (found) {
			return i;
		}
	}

	return -1;
}

int String::find(const char *p_str, int p_from) const {
	if (p_from < 0) {
		return -1;
	}

	const int len = length();

	if (len == 0) {
		return -1; // won't find anything!
	}

	const CharType *src = get_data();

	int src_len = 0;
	while (p_str[src_len] != '\0') {
		src_len++;
	}

	if (src_len == 1) {
		const CharType needle = p_str[0];

		for (int i = p_from; i < len; i++) {
			if (src[i] == needle) {
				return i;
			}
		}

	} else {
		for (int i = p_from; i <= (len - src_len); i++) {
			bool found = true;
			for (int j = 0; j < src_len; j++) {
				int read_pos = i + j;

				if (read_pos >= len) {
					ERR_PRINT("read_pos>=len");
					return -1;
				};

				if (src[read_pos] != (CharType)p_str[j]) {
					found = false;
					break;
				}
			}

			if (found) {
				return i;
			}
		}
	}

	return -1;
}

int String::find_char(const CharType &p_char, int p_from) const {
	return _cowdata.find(p_char, p_from);
}

int String::find_last(const String &p_str) const {
	return rfind(p_str);
}

int String::findn(const String &p_str, int p_from) const {
	if (p_from < 0) {
		return -1;
	}

	int src_len = p_str.length();

	if (src_len == 0 || length() == 0) {
		return -1; // won't find anything!
	}

	const CharType *srcd = get_data();

	for (int i = p_from; i <= (length() - src_len); i++) {
		bool found = true;
		for (int j = 0; j < src_len; j++) {
			int read_pos = i + j;

			if (read_pos >= length()) {
				ERR_PRINT("read_pos>=length()");
				return -1;
			};

			CharType src = _find_lower(srcd[read_pos]);
			CharType dst = _find_lower(p_str[j]);

			if (src != dst) {
				found = false;
				break;
			}
		}

		if (found) {
			return i;
		}
	}

	return -1;
}

int String::rfind(const String &p_str, int p_from) const {
	// establish a limit
	int limit = length() - p_str.length();
	if (limit < 0) {
		return -1;
	}

	// establish a starting point
	if (p_from < 0) {
		p_from = limit;
	} else if (p_from > limit) {
		p_from = limit;
	}

	int src_len = p_str.length();
	int len = length();

	if (src_len == 0 || len == 0) {
		return -1; // won't find anything!
	}

	const CharType *src = get_data();

	for (int i = p_from; i >= 0; i--) {
		bool found = true;
		for (int j = 0; j < src_len; j++) {
			int read_pos = i + j;

			if (read_pos >= len) {
				ERR_PRINT("read_pos>=len");
				return -1;
			};

			if (src[read_pos] != p_str[j]) {
				found = false;
				break;
			}
		}

		if (found) {
			return i;
		}
	}

	return -1;
}

int String::rfindn(const String &p_str, int p_from) const {
	// establish a limit
	int limit = length() - p_str.length();
	if (limit < 0) {
		return -1;
	}

	// establish a starting point
	if (p_from < 0) {
		p_from = limit;
	} else if (p_from > limit) {
		p_from = limit;
	}

	int src_len = p_str.length();
	int len = length();

	if (src_len == 0 || len == 0) {
		return -1; // won't find anything!
	}

	const CharType *src = get_data();

	for (int i = p_from; i >= 0; i--) {
		bool found = true;
		for (int j = 0; j < src_len; j++) {
			int read_pos = i + j;

			if (read_pos >= len) {
				ERR_PRINT("read_pos>=len");
				return -1;
			};

			CharType srcc = _find_lower(src[read_pos]);
			CharType dstc = _find_lower(p_str[j]);

			if (srcc != dstc) {
				found = false;
				break;
			}
		}

		if (found) {
			return i;
		}
	}

	return -1;
}

int String::findmk(const Vector<String> &p_keys, int p_from, int *r_key) const {
	if (p_from < 0) {
		return -1;
	}
	if (p_keys.size() == 0) {
		return -1;
	}

	//int src_len=p_str.length();
	const String *keys = &p_keys[0];
	int key_count = p_keys.size();
	int len = length();

	if (len == 0) {
		return -1; // won't find anything!
	}

	const CharType *src = get_data();

	for (int i = p_from; i < len; i++) {
		bool found = true;
		for (int k = 0; k < key_count; k++) {
			found = true;
			if (r_key) {
				*r_key = k;
			}
			const CharType *cmp = keys[k].get_data();
			int l = keys[k].length();

			for (int j = 0; j < l; j++) {
				int read_pos = i + j;

				if (read_pos >= len) {
					found = false;
					break;
				};

				if (src[read_pos] != cmp[j]) {
					found = false;
					break;
				}
			}
			if (found) {
				break;
			}
		}

		if (found) {
			return i;
		}
	}

	return -1;
}

int String::find_first_difference_index(const String &p_str) const {
	const int olen = p_str.length();
	const int len = length();
	const int c = len < olen ? len : olen;

	const CharType *p = get_data();
	const CharType *op = p_str.get_data();

	for (int i = 0; i < c; ++i) {
		if (p[i] != op[i]) {
			return i;
		}
	}

	return c;
}

bool String::is_word_at(const int index, const char *p_str) const {
	int size = length();

	ERR_FAIL_INDEX_V(index, size, false);

	int i = 0;

	while (p_str[i] != '\0') {
		int iind = index + i;

		if (iind >= size) {
			return false;
		}

		if (operator[](iind) != (CharType)p_str[i]) {
			return false;
		}

		++i;
	}

	return true;
}
bool String::is_word_at(const int index, const String &p_str) const {
	int size = length();

	ERR_FAIL_INDEX_V(index, size, false);

	if (index + p_str.length() >= size) {
		return false;
	}

	for (int i = 0; i < p_str.length(); ++i) {
		int iind = index + i;

		if (operator[](iind) != p_str[i]) {
			return false;
		}
	}

	return true;
}

bool String::match(const String &p_wildcard) const {
	if (!p_wildcard.length() || !length()) {
		return false;
	}

	return _wildcard_match(p_wildcard.get_data(), get_data(), true);
}

bool String::matchn(const String &p_wildcard) const {
	if (!p_wildcard.length() || !length()) {
		return false;
	}
	return _wildcard_match(p_wildcard.get_data(), get_data(), false);
}

bool String::begins_with(const String &p_string) const {
	int l = p_string.length();
	if (l > length()) {
		return false;
	}

	if (l == 0) {
		return true;
	}

	const CharType *p = &p_string[0];
	const CharType *s = &operator[](0);

	for (int i = 0; i < l; i++) {
		if (p[i] != s[i]) {
			return false;
		}
	}

	return true;
}

bool String::begins_with(const char *p_string) const {
	int l = length();
	if (l == 0 || !p_string) {
		return false;
	}

	const CharType *str = &operator[](0);
	int i = 0;

	while (*p_string && i < l) {
		if ((CharType)(*p_string) != str[i]) {
			return false;
		}
		i++;
		p_string++;
	}

	return *p_string == 0;
}

bool String::ends_with(const String &p_string) const {
	int l = p_string.length();
	if (l > length()) {
		return false;
	}

	if (l == 0) {
		return true;
	}

	const CharType *p = &p_string[0];
	const CharType *s = &operator[](length() - l);

	for (int i = 0; i < l; i++) {
		if (p[i] != s[i]) {
			return false;
		}
	}

	return true;
}

bool String::is_enclosed_in(const String &p_string) const {
	return begins_with(p_string) && ends_with(p_string);
}

bool String::is_subsequence_of(const String &p_string) const {
	return _base_is_subsequence_of(p_string, false);
}

bool String::is_subsequence_ofi(const String &p_string) const {
	return _base_is_subsequence_of(p_string, true);
}

bool String::is_quoted() const {
	return is_enclosed_in("\"") || is_enclosed_in("'");
}

Vector<String> String::bigrams() const {
	int n_pairs = length() - 1;
	Vector<String> b;
	if (n_pairs <= 0) {
		return b;
	}
	b.resize(n_pairs);
	for (int i = 0; i < n_pairs; i++) {
		b.write[i] = substr(i, 2);
	}
	return b;
}

// Similarity according to Sorensen-Dice coefficient
float String::similarity(const String &p_string) const {
	if (operator==(p_string)) {
		// Equal strings are totally similar
		return 1.0f;
	}
	if (length() < 2 || p_string.length() < 2) {
		// No way to calculate similarity without a single bigram
		return 0.0f;
	}

	Vector<String> src_bigrams = bigrams();
	Vector<String> tgt_bigrams = p_string.bigrams();

	int src_size = src_bigrams.size();
	int tgt_size = tgt_bigrams.size();

	float sum = src_size + tgt_size;
	float inter = 0;
	for (int i = 0; i < src_size; i++) {
		for (int j = 0; j < tgt_size; j++) {
			if (src_bigrams[i] == tgt_bigrams[j]) {
				inter++;
				break;
			}
		}
	}

	return (2.0f * inter) / sum;
}

/*
String String::format(const Variant &values, String placeholder) const {
	String new_string = String(this->ptr());

	if (values.get_type() == Variant::ARRAY) {
		Array values_arr = values;

		for (int i = 0; i < values_arr.size(); i++) {
			String i_as_str = String::num_int64(i);

			if (values_arr[i].get_type() == Variant::ARRAY) { //Array in Array structure [["name","RobotGuy"],[0,"pandemonium"],["strength",9000.91]]
				Array value_arr = values_arr[i];

				if (value_arr.size() == 2) {
					Variant v_key = value_arr[0];
					String key = v_key;

					Variant v_val = value_arr[1];
					String val = v_val;

					new_string = new_string.replace(placeholder.replace("_", key), val);
				} else {
					ERR_PRINT(String("STRING.format Inner Array size != 2 ").ascii().get_data());
				}
			} else { //Array structure ["RobotGuy","Logis","rookie"]
				Variant v_val = values_arr[i];
				String val = v_val;

				if (placeholder.find("_") > -1) {
					new_string = new_string.replace(placeholder.replace("_", i_as_str), val);
				} else {
					new_string = new_string.replace_first(placeholder, val);
				}
			}
		}
	} else if (values.get_type() == Variant::DICTIONARY) {
		Dictionary d = values;
		List<Variant> keys;
		d.get_key_list(&keys);

		for (List<Variant>::Element *E = keys.front(); E; E = E->next()) {
			String key = E->get();
			String val = d[E->get()];

			new_string = new_string.replace(placeholder.replace("_", key), val);
		}
	} else {
		ERR_PRINT(String("Invalid type: use Array or Dictionary.").ascii().get_data());
	}

	return new_string;
}
*/

String String::replace_first(const String &p_key, const String &p_with) const {
	int pos = find(p_key);
	if (pos >= 0) {
		return substr(0, pos) + p_with + substr(pos + p_key.length(), length());
	}

	return *this;
}

String String::replace(const String &p_key, const String &p_with) const {
	String new_string;
	int search_from = 0;
	int result = 0;

	while ((result = find(p_key, search_from)) >= 0) {
		new_string += substr(search_from, result - search_from);
		new_string += p_with;
		search_from = result + p_key.length();
	}

	if (search_from == 0) {
		return *this;
	}

	new_string += substr(search_from, length() - search_from);

	return new_string;
}

String String::replace(const char *p_key, const char *p_with) const {
	String new_string;
	int search_from = 0;
	int result = 0;

	while ((result = find(p_key, search_from)) >= 0) {
		new_string += substr(search_from, result - search_from);
		new_string += p_with;
		int k = 0;
		while (p_key[k] != '\0') {
			k++;
		}
		search_from = result + k;
	}

	if (search_from == 0) {
		return *this;
	}

	new_string += substr(search_from, length() - search_from);

	return new_string;
}

String String::replacen(const String &p_key, const String &p_with) const {
	String new_string;
	int search_from = 0;
	int result = 0;

	while ((result = findn(p_key, search_from)) >= 0) {
		new_string += substr(search_from, result - search_from);
		new_string += p_with;
		search_from = result + p_key.length();
	}

	if (search_from == 0) {
		return *this;
	}

	new_string += substr(search_from, length() - search_from);
	return new_string;
}

String String::newline_to_br() const {
	String r = replace("\r\n", "<br>");
	return r.replace("\n", "<br>");
}

String String::repeat(int p_count) const {
	ERR_FAIL_COND_V_MSG(p_count < 0, "", "Parameter count should be a positive number.");

	int len = length();
	String new_string = *this;
	new_string.resize(p_count * len + 1);

	CharType *dst = new_string.ptrw();
	int offset = 1;
	int stride = 1;
	while (offset < p_count) {
		memcpy(dst + offset * len, dst, stride * len * sizeof(CharType));
		offset += stride;
		stride = MIN(stride * 2, p_count - offset);
	}
	dst[p_count * len] = _null;

	return new_string;
}

String String::insert(int p_at_pos, const String &p_string) const {
	if (p_at_pos < 0) {
		return *this;
	}

	if (p_at_pos > length()) {
		p_at_pos = length();
	}

	String pre;
	if (p_at_pos > 0) {
		pre = substr(0, p_at_pos);
	}

	String post;
	if (p_at_pos < length()) {
		post = substr(p_at_pos, length() - p_at_pos);
	}

	return pre + p_string + post;
}

String String::pad_decimals(int p_digits) const {
	String s = *this;
	int c = s.find(".");

	if (c == -1) {
		if (p_digits <= 0) {
			return s;
		}
		s += ".";
		c = s.length() - 1;
	} else {
		if (p_digits <= 0) {
			return s.substr(0, c);
		}
	}

	if (s.length() - (c + 1) > p_digits) {
		s = s.substr(0, c + p_digits + 1);
	} else {
		while (s.length() - (c + 1) < p_digits) {
			s += "0";
		}
	}
	return s;
}

String String::pad_zeros(int p_digits) const {
	String s = *this;
	int end = s.find(".");

	if (end == -1) {
		end = s.length();
	}

	if (end == 0) {
		return s;
	}

	int begin = 0;

	while (begin < end && (s[begin] < '0' || s[begin] > '9')) {
		begin++;
	}

	if (begin >= end) {
		return s;
	}

	while (end - begin < p_digits) {
		s = s.insert(begin, "0");
		end++;
	}

	return s;
}

String String::trim_prefix(const String &p_prefix) const {
	String s = *this;
	if (s.begins_with(p_prefix)) {
		return s.substr(p_prefix.length(), s.length() - p_prefix.length());
	}
	return s;
}

String String::trim_suffix(const String &p_suffix) const {
	String s = *this;
	if (s.ends_with(p_suffix)) {
		return s.substr(0, s.length() - p_suffix.length());
	}
	return s;
}

// Left-pad with a character.
String String::lpad(int min_length, const String &character) const {
	String s = *this;
	int padding = min_length - s.length();
	if (padding > 0) {
		for (int i = 0; i < padding; i++) {
			s = character + s;
		}
	}

	return s;
}

// Right-pad with a character.
String String::rpad(int min_length, const String &character) const {
	String s = *this;
	int padding = min_length - s.length();
	if (padding > 0) {
		for (int i = 0; i < padding; i++) {
			s = s + character;
		}
	}

	return s;
}

String String::quote(String quotechar) const {
	return quotechar + *this + quotechar;
}

String String::unquote() const {
	if (!is_quoted()) {
		return *this;
	}

	return substr(1, length() - 2);
}

String String::num(double p_num, int p_decimals) {
	if (Math::is_nan(p_num)) {
		return "nan";
	}

	if (Math::is_inf(p_num)) {
		if (signbit(p_num)) {
			return "-inf";
		} else {
			return "inf";
		}
	}

#ifndef NO_USE_STDLIB

	if (p_decimals > 16) {
		p_decimals = 16;
	}

	char fmt[7];
	fmt[0] = '%';
	fmt[1] = '.';

	if (p_decimals < 0) {
		fmt[1] = 'l';
		fmt[2] = 'f';
		fmt[3] = 0;

	} else if (p_decimals < 10) {
		fmt[2] = '0' + p_decimals;
		fmt[3] = 'l';
		fmt[4] = 'f';
		fmt[5] = 0;
	} else {
		fmt[2] = '0' + (p_decimals / 10);
		fmt[3] = '0' + (p_decimals % 10);
		fmt[4] = 'l';
		fmt[5] = 'f';
		fmt[6] = 0;
	}
	char buf[256];

#if defined(__GNUC__) || defined(_MSC_VER)
	snprintf(buf, 256, fmt, p_num);
#else
	sprintf(buf, fmt, p_num);
#endif

	buf[255] = 0;
	//destroy trailing zeroes
	{
		bool period = false;
		int z = 0;
		while (buf[z]) {
			if (buf[z] == '.') {
				period = true;
			}
			z++;
		}

		if (period) {
			z--;
			while (z > 0) {
				if (buf[z] == '0') {
					buf[z] = 0;
				} else if (buf[z] == '.') {
					buf[z] = 0;
					break;
				} else {
					break;
				}

				z--;
			}
		}
	}

	return buf;
#else

	String s;
	String sd;
	/* integer part */

	bool neg = p_num < 0;
	p_num = ABS(p_num);
	int intn = (int)p_num;

	/* decimal part */

	if (p_decimals > 0 || (p_decimals == -1 && (int)p_num != p_num)) {
		double dec = p_num - (double)((int)p_num);

		int digit = 0;
		if (p_decimals > MAX_DIGITS)
			p_decimals = MAX_DIGITS;

		int dec_int = 0;
		int dec_max = 0;

		while (true) {
			dec *= 10.0;
			dec_int = dec_int * 10 + (int)dec % 10;
			dec_max = dec_max * 10 + 9;
			digit++;

			if (p_decimals == -1) {
				if (digit == MAX_DIGITS) //no point in going to infinite
					break;

				if ((dec - (double)((int)dec)) < 1e-6)
					break;
			}

			if (digit == p_decimals)
				break;
		}
		dec *= 10;
		int last = (int)dec % 10;

		if (last > 5) {
			if (dec_int == dec_max) {
				dec_int = 0;
				intn++;
			} else {
				dec_int++;
			}
		}

		String decimal;
		for (int i = 0; i < digit; i++) {
			char num[2] = { 0, 0 };
			num[0] = '0' + dec_int % 10;
			decimal = num + decimal;
			dec_int /= 10;
		}
		sd = '.' + decimal;
	}

	if (intn == 0)

		s = "0";
	else {
		while (intn) {
			CharType num = '0' + (intn % 10);
			intn /= 10;
			s = num + s;
		}
	}

	s = s + sd;
	if (neg)
		s = "-" + s;
	return s;
#endif
}

String String::num_scientific(double p_num) {
	if (Math::is_nan(p_num)) {
		return "nan";
	}

	if (Math::is_inf(p_num)) {
		if (signbit(p_num)) {
			return "-inf";
		} else {
			return "inf";
		}
	}

#ifndef NO_USE_STDLIB

	char buf[256];

#if defined(__GNUC__) || defined(_MSC_VER)

#if defined(__MINGW32__) && defined(_TWO_DIGIT_EXPONENT) && !defined(_UCRT)
	// MinGW requires _set_output_format() to conform to C99 output for printf
	unsigned int old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
#endif
	snprintf(buf, 256, "%lg", p_num);

#if defined(__MINGW32__) && defined(_TWO_DIGIT_EXPONENT) && !defined(_UCRT)
	_set_output_format(old_exponent_format);
#endif

#else
	sprintf(buf, "%.16lg", p_num);
#endif

	buf[255] = 0;

	return buf;
#else

	return String::num(p_num);
#endif
}

String String::num_real(double p_num) {
	if (Math::is_nan(p_num)) {
		return "nan";
	}

	if (Math::is_inf(p_num)) {
		if (signbit(p_num)) {
			return "-inf";
		} else {
			return "inf";
		}
	}

	String s;
	String sd;
	/* integer part */

	bool neg = p_num < 0;
	p_num = ABS(p_num);
	int intn = (int)p_num;

	/* decimal part */

	if ((int)p_num != p_num) {
		double dec = p_num - (double)((int)p_num);

		int digit = 0;
		int decimals = MAX_DIGITS;

		int dec_int = 0;
		int dec_max = 0;

		while (true) {
			dec *= 10.0;
			dec_int = dec_int * 10 + (int)dec % 10;
			dec_max = dec_max * 10 + 9;
			digit++;

			if ((dec - (double)((int)dec)) < 1e-6) {
				break;
			}

			if (digit == decimals) {
				break;
			}
		}

		dec *= 10;
		int last = (int)dec % 10;

		if (last > 5) {
			if (dec_int == dec_max) {
				dec_int = 0;
				intn++;
			} else {
				dec_int++;
			}
		}

		String decimal;
		for (int i = 0; i < digit; i++) {
			char num[2] = { 0, 0 };
			num[0] = '0' + dec_int % 10;
			decimal = num + decimal;
			dec_int /= 10;
		}
		sd = '.' + decimal;
	} else {
		sd = ".0";
	}

	if (intn == 0) {
		s = "0";
	} else {
		while (intn) {
			CharType num = '0' + (intn % 10);
			intn /= 10;
			s = num + s;
		}
	}

	s = s + sd;
	if (neg) {
		s = "-" + s;
	}
	return s;
}

String String::num_int64(int64_t p_num, int base, bool capitalize_hex) {
	bool sign = p_num < 0;

	int64_t n = p_num;

	int chars = 0;
	do {
		n /= base;
		chars++;
	} while (n);

	if (sign) {
		chars++;
	}
	String s;
	s.resize(chars + 1);
	CharType *c = s.ptrw();
	c[chars] = 0;
	n = p_num;
	do {
		int mod = ABS(n % base);
		if (mod >= 10) {
			char a = (capitalize_hex ? 'A' : 'a');
			c[--chars] = a + (mod - 10);
		} else {
			c[--chars] = '0' + mod;
		}

		n /= base;
	} while (n);

	if (sign) {
		c[0] = '-';
	}

	return s;
}

String String::num_uint64(uint64_t p_num, int base, bool capitalize_hex) {
	uint64_t n = p_num;

	int chars = 0;
	do {
		n /= base;
		chars++;
	} while (n);

	String s;
	s.resize(chars + 1);
	CharType *c = s.ptrw();
	c[chars] = 0;
	n = p_num;
	do {
		int mod = n % base;
		if (mod >= 10) {
			char a = (capitalize_hex ? 'A' : 'a');
			c[--chars] = a + (mod - 10);
		} else {
			c[--chars] = '0' + mod;
		}

		n /= base;
	} while (n);

	return s;
}

String String::chr(CharType p_char) {
	CharType c[2] = { p_char, 0 };
	return String(c);
}

String String::md5(const uint8_t *p_md5) {
	return String::hex_encode_buffer(p_md5, 16);
}

String String::hex_encode_buffer(const uint8_t *p_buffer, int p_len) {
	static const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

	String ret;
	char v[2] = { 0, 0 };

	for (int i = 0; i < p_len; i++) {
		v[0] = hex[p_buffer[i] >> 4];
		ret += v;
		v[0] = hex[p_buffer[i] & 0xF];
		ret += v;
	}

	return ret;
}

String String::bool_num(bool p_val) {
	if (p_val) {
		return "1";
	} else {
		return "0";
	}
}

String String::bool_str(bool p_val) {
	if (p_val) {
		return "true";
	} else {
		return "false";
	}
}

bool String::is_numeric() const {
	if (length() == 0) {
		return false;
	};

	int s = 0;
	if (operator[](0) == '-') {
		++s;
	}
	bool dot = false;
	for (int i = s; i < length(); i++) {
		CharType c = operator[](i);
		if (c == '.') {
			if (dot) {
				return false;
			};
			dot = true;
			continue;
		}
		if (c < '0' || c > '9') {
			return false;
		};
	};

	return true; // TODO: Use the parser below for this instead
};

bool String::is_zero() const {
	int size = length();

	if (size == 0) {
		return false;
	}

	int starti = 0;

	if (operator[](0) == '-') {
		starti += 1;
	}

	bool had_dot = false;
	for (int i = starti; i < size; ++i) {
		CharType c = operator[](i);

		if (c == '.') {
			if (!had_dot) {
				had_dot = true;
				continue;
			} else {
				return false;
			}
		}

		if (c != '0') {
			return false;
		}
	}

	return true;
}

String String::capitalize() const {
	String aux = this->camelcase_to_underscore(true).replace("_", " ").strip_edges();
	String cap;
	for (int i = 0; i < aux.get_slice_count(" "); i++) {
		String slice = aux.get_slicec(' ', i);
		if (slice.length() > 0) {
			slice[0] = _find_upper(slice[0]);
			if (i > 0) {
				cap += " ";
			}
			cap += slice;
		}
	}

	return cap;
}

String String::camelcase_to_underscore(bool lowercase) const {
	const CharType *cstr = get_data();
	String new_string;
	const char A = 'A', Z = 'Z';
	const char a = 'a', z = 'z';
	int start_index = 0;

	for (int i = 1; i < this->size(); i++) {
		bool is_upper = cstr[i] >= A && cstr[i] <= Z;
		bool is_number = cstr[i] >= '0' && cstr[i] <= '9';
		bool are_next_2_lower = false;
		bool is_next_lower = false;
		bool is_next_number = false;
		bool was_precedent_upper = cstr[i - 1] >= A && cstr[i - 1] <= Z;
		bool was_precedent_number = cstr[i - 1] >= '0' && cstr[i - 1] <= '9';

		if (i + 2 < this->size()) {
			are_next_2_lower = cstr[i + 1] >= a && cstr[i + 1] <= z && cstr[i + 2] >= a && cstr[i + 2] <= z;
		}

		if (i + 1 < this->size()) {
			is_next_lower = cstr[i + 1] >= a && cstr[i + 1] <= z;
			is_next_number = cstr[i + 1] >= '0' && cstr[i + 1] <= '9';
		}

		const bool cond_a = is_upper && !was_precedent_upper && !was_precedent_number;
		const bool cond_b = was_precedent_upper && is_upper && are_next_2_lower;
		const bool cond_c = is_number && !was_precedent_number;
		const bool can_break_number_letter = is_number && !was_precedent_number && is_next_lower;
		const bool can_break_letter_number = !is_number && was_precedent_number && (is_next_lower || is_next_number);

		bool should_split = cond_a || cond_b || cond_c || can_break_number_letter || can_break_letter_number;
		if (should_split) {
			new_string += this->substr(start_index, i - start_index) + "_";
			start_index = i;
		}
	}

	new_string += this->substr(start_index, this->size() - start_index);
	return lowercase ? new_string.to_lower() : new_string;
}

int String::get_slice_count(String p_splitter) const {
	if (empty()) {
		return 0;
	}
	if (p_splitter.empty()) {
		return 0;
	}

	int pos = 0;
	int slices = 1;

	while ((pos = find(p_splitter, pos)) >= 0) {
		slices++;
		pos += p_splitter.length();
	}

	return slices;
}

String String::get_slice(String p_splitter, int p_slice) const {
	if (empty() || p_splitter.empty()) {
		return "";
	}

	int pos = 0;
	int prev_pos = 0;
	//int slices=1;
	if (p_slice < 0) {
		return "";
	}
	if (find(p_splitter) == -1) {
		return *this;
	}

	int i = 0;
	while (true) {
		pos = find(p_splitter, pos);
		if (pos == -1) {
			pos = length(); //reached end
		}

		int from = prev_pos;
		//int to=pos;

		if (p_slice == i) {
			return substr(from, pos - from);
		}

		if (pos == length()) { //reached end and no find
			break;
		}
		pos += p_splitter.length();
		prev_pos = pos;
		i++;
	}

	return ""; //no find!
}

String String::get_slicec(CharType p_splitter, int p_slice) const {
	if (empty()) {
		return String();
	}

	if (p_slice < 0) {
		return String();
	}

	const CharType *c = this->ptr();
	int i = 0;
	int prev = 0;
	int count = 0;
	while (true) {
		if (c[i] == 0 || c[i] == p_splitter) {
			if (p_slice == count) {
				return substr(prev, i - prev);
			} else if (c[i] == 0) {
				return String();
			} else {
				count++;
				prev = i + 1;
			}
		}

		i++;
	}
}

Vector<String> String::split(const String &p_splitter, bool p_allow_empty, int p_maxsplit) const {
	Vector<String> ret;
	int from = 0;
	int len = length();

	while (true) {
		int end = find(p_splitter, from);
		if (end < 0) {
			end = len;
		}
		if (p_allow_empty || (end > from)) {
			if (p_maxsplit <= 0) {
				ret.push_back(substr(from, end - from));
			} else {
				// Put rest of the string and leave cycle.
				if (p_maxsplit == ret.size()) {
					ret.push_back(substr(from, len));
					break;
				}

				// Otherwise, push items until positive limit is reached.
				ret.push_back(substr(from, end - from));
			}
		}

		if (end == len) {
			break;
		}

		from = end + p_splitter.length();
	}

	return ret;
}

Vector<String> String::rsplit(const String &p_splitter, bool p_allow_empty, int p_maxsplit) const {
	Vector<String> ret;
	const int len = length();
	int remaining_len = len;

	while (true) {
		if (remaining_len < p_splitter.length() || (p_maxsplit > 0 && p_maxsplit == ret.size())) {
			// no room for another splitter or hit max splits, push what's left and we're done
			if (p_allow_empty || remaining_len > 0) {
				ret.push_back(substr(0, remaining_len));
			}
			break;
		}

		int left_edge = rfind(p_splitter, remaining_len - p_splitter.length());

		if (left_edge < 0) {
			// no more splitters, we're done
			ret.push_back(substr(0, remaining_len));
			break;
		}

		int substr_start = left_edge + p_splitter.length();
		if (p_allow_empty || substr_start < remaining_len) {
			ret.push_back(substr(substr_start, remaining_len - substr_start));
		}

		remaining_len = left_edge;
	}

	ret.invert();
	return ret;
}

Vector<String> String::split_spaces() const {
	Vector<String> ret;
	int from = 0;
	int i = 0;
	int len = length();
	if (len == 0) {
		return ret;
	}

	bool inside = false;

	while (true) {
		bool empty = operator[](i) < 33;

		if (i == 0) {
			inside = !empty;
		}

		if (!empty && !inside) {
			inside = true;
			from = i;
		}

		if (empty && inside) {
			ret.push_back(substr(from, i - from));
			inside = false;
		}

		if (i == len) {
			break;
		}
		i++;
	}

	return ret;
}

Vector<float> String::split_floats(const String &p_splitter, bool p_allow_empty) const {
	Vector<float> ret;
	int from = 0;
	int len = length();

	String buffer = *this;
	while (true) {
		int end = find(p_splitter, from);
		if (end < 0) {
			end = len;
		}
		if (p_allow_empty || (end > from)) {
			buffer[end] = 0;
			ret.push_back(String::to_double(&buffer.get_data()[from]));
			buffer[end] = _cowdata.get(end);
		}

		if (end == len) {
			break;
		}

		from = end + p_splitter.length();
	}

	return ret;
}

Vector<float> String::split_floats_mk(const Vector<String> &p_splitters, bool p_allow_empty) const {
	Vector<float> ret;
	int from = 0;
	int len = length();

	String buffer = *this;
	while (true) {
		int idx;
		int end = findmk(p_splitters, from, &idx);
		int spl_len = 1;
		if (end < 0) {
			end = len;
		} else {
			spl_len = p_splitters[idx].length();
		}

		if (p_allow_empty || (end > from)) {
			buffer[end] = 0;
			ret.push_back(String::to_double(&buffer.get_data()[from]));
			buffer[end] = _cowdata.get(end);
		}

		if (end == len) {
			break;
		}

		from = end + spl_len;
	}

	return ret;
}

Vector<int> String::split_ints(const String &p_splitter, bool p_allow_empty) const {
	Vector<int> ret;
	int from = 0;
	int len = length();

	while (true) {
		int end = find(p_splitter, from);
		if (end < 0) {
			end = len;
		}
		if (p_allow_empty || (end > from)) {
			ret.push_back(String::to_int(&get_data()[from], end - from));
		}

		if (end == len) {
			break;
		}

		from = end + p_splitter.length();
	}

	return ret;
}

Vector<int> String::split_ints_mk(const Vector<String> &p_splitters, bool p_allow_empty) const {
	Vector<int> ret;
	int from = 0;
	int len = length();

	while (true) {
		int idx;
		int end = findmk(p_splitters, from, &idx);
		int spl_len = 1;
		if (end < 0) {
			end = len;
		} else {
			spl_len = p_splitters[idx].length();
		}

		if (p_allow_empty || (end > from)) {
			ret.push_back(String::to_int(&get_data()[from], end - from));
		}

		if (end == len) {
			break;
		}

		from = end + spl_len;
	}

	return ret;
}

String String::join(const Vector<String> &parts) const {
	String ret;
	for (int i = 0; i < parts.size(); ++i) {
		if (i > 0) {
			ret += *this;
		}
		ret += parts[i];
	}
	return ret;
}

CharType String::char_uppercase(CharType p_char) {
	return _find_upper(p_char);
}

CharType String::char_lowercase(CharType p_char) {
	return _find_lower(p_char);
}

String String::to_lower() const {
	String lower = *this;

	for (int i = 0; i < lower.size(); i++) {
		const CharType s = lower[i];
		const CharType t = _find_lower(s);
		if (s != t) { // avoid copy on write
			lower[i] = t;
		}
	}

	return lower;
}

String String::to_upper() const {
	String upper = *this;

	for (int i = 0; i < upper.size(); i++) {
		const CharType s = upper[i];
		const CharType t = _find_upper(s);
		if (s != t) { // avoid copy on write
			upper[i] = t;
		}
	}

	return upper;
}

int String::_count(const String &p_string, int p_from, int p_to, bool p_case_insensitive) const {
	if (p_string.empty()) {
		return 0;
	}
	int len = length();
	int slen = p_string.length();
	if (len < slen) {
		return 0;
	}
	String str;
	if (p_from >= 0 && p_to >= 0) {
		if (p_to == 0) {
			p_to = len;
		} else if (p_from >= p_to) {
			return 0;
		}
		if (p_from == 0 && p_to == len) {
			str = String();
			str.copy_from_unchecked(&get_data()[0], len);
		} else {
			str = substr(p_from, p_to - p_from);
		}
	} else {
		return 0;
	}
	int c = 0;
	int idx = -1;
	do {
		idx = p_case_insensitive ? str.findn(p_string) : str.find(p_string);
		if (idx != -1) {
			str = str.substr(idx + slen, str.length() - slen);
			++c;
		}
	} while (idx != -1);
	return c;
}

int String::count(const String &p_string, int p_from, int p_to) const {
	return _count(p_string, p_from, p_to, false);
}

int String::countn(const String &p_string, int p_from, int p_to) const {
	return _count(p_string, p_from, p_to, true);
}

String String::left(int p_pos) const {
	if (p_pos <= 0) {
		return "";
	}

	if (p_pos >= length()) {
		return *this;
	}

	return substr(0, p_pos);
}

String String::right(int p_pos) const {
	if (p_pos >= length()) {
		return "";
	}

	if (p_pos <= 0) {
		return *this;
	}

	return substr(p_pos, (length() - p_pos));
}

String String::indent(const String &p_prefix) const {
	String new_string;
	int line_start = 0;

	for (int i = 0; i < length(); i++) {
		const CharType c = operator[](i);
		if (c == '\n') {
			if (i == line_start) {
				new_string += c; // Leave empty lines empty.
			} else {
				new_string += p_prefix + substr(line_start, i - line_start + 1);
			}
			line_start = i + 1;
		}
	}
	if (line_start != length()) {
		new_string += p_prefix + substr(line_start);
	}
	return new_string;
}

String String::dedent() const {
	String new_string;
	String indent;
	bool has_indent = false;
	bool has_text = false;
	int line_start = 0;
	int indent_stop = -1;

	for (int i = 0; i < length(); i++) {
		CharType c = operator[](i);
		if (c == '\n') {
			if (has_text) {
				new_string += substr(indent_stop, i - indent_stop);
			}
			new_string += "\n";
			has_text = false;
			line_start = i + 1;
			indent_stop = -1;
		} else if (!has_text) {
			if (c > 32) {
				has_text = true;
				if (!has_indent) {
					has_indent = true;
					indent = substr(line_start, i - line_start);
					indent_stop = i;
				}
			}
			if (has_indent && indent_stop < 0) {
				int j = i - line_start;
				if (j >= indent.length() || c != indent[j]) {
					indent_stop = i;
				}
			}
		}
	}

	if (has_text) {
		new_string += substr(indent_stop, length() - indent_stop);
	}

	return new_string;
}

String String::strip_edges(bool left, bool right) const {
	int len = length();
	int beg = 0, end = len;

	if (left) {
		for (int i = 0; i < len; i++) {
			if (operator[](i) <= 32) {
				beg++;
			} else {
				break;
			}
		}
	}

	if (right) {
		for (int i = (int)(len - 1); i >= 0; i--) {
			if (operator[](i) <= 32) {
				end--;
			} else {
				break;
			}
		}
	}

	if (beg == 0 && end == len) {
		return *this;
	}

	return substr(beg, end - beg);
}

String String::strip_escapes() const {
	String new_string;
	for (int i = 0; i < length(); i++) {
		// Escape characters on first page of the ASCII table, before 32 (Space).
		if (operator[](i) < 32) {
			continue;
		}
		new_string += operator[](i);
	}

	return new_string;
}

String String::lstrip(const String &p_chars) const {
	int len = length();
	int beg;

	for (beg = 0; beg < len; beg++) {
		if (p_chars.find_char(get(beg)) == -1) {
			break;
		}
	}

	if (beg == 0) {
		return *this;
	}

	return substr(beg, len - beg);
}

String String::rstrip(const String &p_chars) const {
	int len = length();
	int end;

	for (end = len - 1; end >= 0; end--) {
		if (p_chars.find_char(get(end)) == -1) {
			break;
		}
	}

	if (end == len - 1) {
		return *this;
	}

	return substr(0, end + 1);
}

String String::get_extension() const {
	int pos = rfind(".");
	if (pos < 0 || pos < MAX(rfind("/"), rfind("\\"))) {
		return "";
	}

	return substr(pos + 1, length());
}

String String::get_basename() const {
	int pos = rfind(".");
	if (pos < 0 || pos < MAX(rfind("/"), rfind("\\"))) {
		return *this;
	}

	return substr(0, pos);
}

String String::plus_file(const String &p_file) const {
	if (empty()) {
		return p_file;
	}
	if (operator[](length() - 1) == '/' || (p_file.size() > 0 && p_file.operator[](0) == '/')) {
		return *this + p_file;
	}
	return *this + "/" + p_file;
}

CharType String::unicode_at(int p_idx) const {
	ERR_FAIL_INDEX_V(p_idx, length(), 0);
	return operator[](p_idx);
}

CharType String::ord_at(int p_idx) const {
	ERR_FAIL_INDEX_V(p_idx, length(), 0);
	return operator[](p_idx);
}

void String::erase(int p_pos, int p_chars) {
	*this = left(p_pos) + substr(p_pos + p_chars, length() - ((p_pos + p_chars)));
}
CharString String::ascii(bool p_allow_extended) const {
	if (!length()) {
		return CharString();
	}

	CharString cs;
	cs.resize(size());

	for (int i = 0; i < size(); i++) {
		CharType c = operator[](i);
		if ((c <= 0x7f) || (c <= 0xff && p_allow_extended)) {
			cs[i] = c;
		} else {
			//print_unicode_error(vformat("Invalid unicode codepoint (%x), cannot represent as ASCII/Latin-1", (uint32_t)c));
			cs[i] = 0x20;
		}
	}

	return cs;
}

String String::utf8(const char *p_utf8, int p_len) {
	String ret;
	ret.parse_utf8(p_utf8, p_len);

	return ret;
}

Error String::parse_utf8(const char *p_utf8, int p_len, bool p_skip_cr) {
	if (!p_utf8) {
		return ERR_INVALID_DATA;
	}

	String aux;

	int cstr_size = 0;
	int str_size = 0;

	/* HANDLE BOM (Byte Order Mark) */
	if (p_len < 0 || p_len >= 3) {
		bool has_bom = uint8_t(p_utf8[0]) == 0xef && uint8_t(p_utf8[1]) == 0xbb && uint8_t(p_utf8[2]) == 0xbf;
		if (has_bom) {
			//8-bit encoding, byte order has no meaning in UTF-8, just skip it
			if (p_len >= 0) {
				p_len -= 3;
			}
			p_utf8 += 3;
		}
	}

	bool decode_error = false;
	bool decode_failed = false;
	{
		const char *ptrtmp = p_utf8;
		const char *ptrtmp_limit = &p_utf8[p_len];
		int skip = 0;
		uint8_t c_start = 0;
		while (ptrtmp != ptrtmp_limit && *ptrtmp) {
			uint8_t c = *ptrtmp >= 0 ? *ptrtmp : uint8_t(256 + *ptrtmp);

			if (skip == 0) {
				if (p_skip_cr && c == '\r') {
					ptrtmp++;
					continue;
				}
				/* Determine the number of characters in sequence */
				if ((c & 0x80) == 0) {
					skip = 0;
				} else if ((c & 0xe0) == 0xc0) {
					skip = 1;
				} else if ((c & 0xf0) == 0xe0) {
					skip = 2;
				} else if ((c & 0xf8) == 0xf0) {
					skip = 3;
				} else if ((c & 0xfc) == 0xf8) {
					skip = 4;
				} else if ((c & 0xfe) == 0xfc) {
					skip = 5;
				} else {
					skip = 0;
					//print_unicode_error(vformat("Invalid UTF-8 leading byte (%x)", c), true);
					decode_failed = true;
				}
				c_start = c;

				if (skip == 1 && (c & 0x1e) == 0) {
					//print_unicode_error(vformat("Overlong encoding (%x ...)", c));
					decode_error = true;
				}
				str_size++;
			} else {
				if ((c_start == 0xe0 && skip == 2 && c < 0xa0) || (c_start == 0xf0 && skip == 3 && c < 0x90) || (c_start == 0xf8 && skip == 4 && c < 0x88) || (c_start == 0xfc && skip == 5 && c < 0x84)) {
					//print_unicode_error(vformat("Overlong encoding (%x %x ...)", c_start, c));
					decode_error = true;
				}
				if (c < 0x80 || c > 0xbf) {
					//print_unicode_error(vformat("Invalid UTF-8 continuation byte (%x ... %x ...)", c_start, c), true);
					decode_failed = true;
					skip = 0;
				} else {
					--skip;
				}
			}

			cstr_size++;
			ptrtmp++;
		}

		if (skip) {
			//rrprint_unicode_error(vformat("Missing %d UTF-8 continuation byte(s)", skip), true);
			decode_failed = true;
		}
	}

	if (str_size == 0) {
		clear();
		return OK; // empty string
	}

	resize(str_size + 1);
	CharType *dst = ptrw();
	dst[str_size] = 0;

	int skip = 0;
	uint32_t unichar = 0;
	while (cstr_size) {
		uint8_t c = *p_utf8 >= 0 ? *p_utf8 : uint8_t(256 + *p_utf8);

		if (skip == 0) {
			if (p_skip_cr && c == '\r') {
				p_utf8++;
				continue;
			}
			/* Determine the number of characters in sequence */
			if ((c & 0x80) == 0) {
				*(dst++) = c;
				unichar = 0;
				skip = 0;
			} else if ((c & 0xe0) == 0xc0) {
				unichar = (0xff >> 3) & c;
				skip = 1;
			} else if ((c & 0xf0) == 0xe0) {
				unichar = (0xff >> 4) & c;
				skip = 2;
			} else if ((c & 0xf8) == 0xf0) {
				unichar = (0xff >> 5) & c;
				skip = 3;
			} else if ((c & 0xfc) == 0xf8) {
				unichar = (0xff >> 6) & c;
				skip = 4;
			} else if ((c & 0xfe) == 0xfc) {
				unichar = (0xff >> 7) & c;
				skip = 5;
			} else {
				*(dst++) = 0x20;
				unichar = 0;
				skip = 0;
			}
		} else {
			if (c < 0x80 || c > 0xbf) {
				*(dst++) = 0x20;
				skip = 0;
			} else {
				unichar = (unichar << 6) | (c & 0x3f);
				--skip;
				if (skip == 0) {
					if (unichar == 0) {
						//print_unicode_error("NUL character", true);
						decode_failed = true;
						unichar = 0x20;
					}
					if ((unichar & 0xfffff800) == 0xd800) {
						//print_unicode_error(vformat("Unpaired surrogate (%x)", unichar));
						decode_error = true;
					}
					if (unichar > 0x10ffff) {
						//print_unicode_error(vformat("Invalid unicode codepoint (%x)", unichar));
						decode_error = true;
					}
					*(dst++) = unichar;
				}
			}
		}

		cstr_size--;
		p_utf8++;
	}
	if (skip) {
		*(dst++) = 0x20;
	}

	if (decode_failed) {
		return ERR_INVALID_DATA;
	} else if (decode_error) {
		return ERR_PARSE_ERROR;
	} else {
		return OK;
	}
}

CharString String::utf8() const {
	int l = length();
	if (!l) {
		return CharString();
	}

	const CharType *d = &operator[](0);
	int fl = 0;
	for (int i = 0; i < l; i++) {
		uint32_t c = d[i];
		if (c <= 0x7f) { // 7 bits.
			fl += 1;
		} else if (c <= 0x7ff) { // 11 bits
			fl += 2;
		} else if (c <= 0xffff) { // 16 bits
			fl += 3;
		} else if (c <= 0x001fffff) { // 21 bits
			fl += 4;
		} else if (c <= 0x03ffffff) { // 26 bits
			fl += 5;
			//print_unicode_error(vformat("Invalid unicode codepoint (%x)", c));
		} else if (c <= 0x7fffffff) { // 31 bits
			fl += 6;
			//print_unicode_error(vformat("Invalid unicode codepoint (%x)", c));
		} else {
			fl += 1;
			//print_unicode_error(vformat("Invalid unicode codepoint (%x), cannot represent as UTF-8", c), true);
		}
	}

	CharString utf8s;
	if (fl == 0) {
		return utf8s;
	}

	utf8s.resize(fl + 1);
	uint8_t *cdst = (uint8_t *)utf8s.get_data();

#define APPEND_CHAR(m_c) *(cdst++) = m_c

	for (int i = 0; i < l; i++) {
		uint32_t c = d[i];

		if (c <= 0x7f) { // 7 bits.
			APPEND_CHAR(c);
		} else if (c <= 0x7ff) { // 11 bits
			APPEND_CHAR(uint32_t(0xc0 | ((c >> 6) & 0x1f))); // Top 5 bits.
			APPEND_CHAR(uint32_t(0x80 | (c & 0x3f))); // Bottom 6 bits.
		} else if (c <= 0xffff) { // 16 bits
			APPEND_CHAR(uint32_t(0xe0 | ((c >> 12) & 0x0f))); // Top 4 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 6) & 0x3f))); // Middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | (c & 0x3f))); // Bottom 6 bits.
		} else if (c <= 0x001fffff) { // 21 bits
			APPEND_CHAR(uint32_t(0xf0 | ((c >> 18) & 0x07))); // Top 3 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 12) & 0x3f))); // Upper middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 6) & 0x3f))); // Lower middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | (c & 0x3f))); // Bottom 6 bits.
		} else if (c <= 0x03ffffff) { // 26 bits
			APPEND_CHAR(uint32_t(0xf8 | ((c >> 24) & 0x03))); // Top 2 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 18) & 0x3f))); // Upper middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 12) & 0x3f))); // middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 6) & 0x3f))); // Lower middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | (c & 0x3f))); // Bottom 6 bits.
		} else if (c <= 0x7fffffff) { // 31 bits
			APPEND_CHAR(uint32_t(0xfc | ((c >> 30) & 0x01))); // Top 1 bit.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 24) & 0x3f))); // Upper upper middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 18) & 0x3f))); // Lower upper middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 12) & 0x3f))); // Upper lower middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | ((c >> 6) & 0x3f))); // Lower lower middle 6 bits.
			APPEND_CHAR(uint32_t(0x80 | (c & 0x3f))); // Bottom 6 bits.
		} else {
			APPEND_CHAR(0x20);
		}
	}
#undef APPEND_CHAR
	*cdst = 0; //trailing zero

	return utf8s;
}

int String::utf8_byte_length() const {
	int l = length();
	if (!l) {
		return 0;
	}

	const CharType *d = &operator[](0);
	int fl = 0;
	for (int i = 0; i < l; i++) {
		uint32_t c = d[i];
		if (c <= 0x7f) { // 7 bits.
			fl += 1;
		} else if (c <= 0x7ff) { // 11 bits
			fl += 2;
		} else if (c <= 0xffff) { // 16 bits
			fl += 3;
		} else if (c <= 0x001fffff) { // 21 bits
			fl += 4;
		} else if (c <= 0x03ffffff) { // 26 bits
			fl += 5;
			//print_unicode_error(vformat("Invalid unicode codepoint (%x)", c));
		} else if (c <= 0x7fffffff) { // 31 bits
			fl += 6;
			//print_unicode_error(vformat("Invalid unicode codepoint (%x)", c));
		} else {
			fl += 1;
			//print_unicode_error(vformat("Invalid unicode codepoint (%x), cannot represent as UTF-8", c), true);
		}
	}

	return fl;
}

String String::utf16(const char16_t *p_utf16, int p_len) {
	String ret;
	ret.parse_utf16(p_utf16, p_len);

	return ret;
}

Error String::parse_utf16(const char16_t *p_utf16, int p_len) {
	if (!p_utf16) {
		return ERR_INVALID_DATA;
	}

	String aux;

	int cstr_size = 0;
	int str_size = 0;

	/* HANDLE BOM (Byte Order Mark) */
	bool byteswap = false; // assume correct endianness if no BOM found
	if (p_len < 0 || p_len >= 1) {
		bool has_bom = false;
		if (uint16_t(p_utf16[0]) == 0xfeff) { // correct BOM, read as is
			has_bom = true;
			byteswap = false;
		} else if (uint16_t(p_utf16[0]) == 0xfffe) { // backwards BOM, swap bytes
			has_bom = true;
			byteswap = true;
		}
		if (has_bom) {
			if (p_len >= 0) {
				p_len -= 1;
			}
			p_utf16 += 1;
		}
	}

	bool decode_error = false;
	{
		const char16_t *ptrtmp = p_utf16;
		const char16_t *ptrtmp_limit = &p_utf16[p_len];
		//uint32_t c_prev = 0;
		bool skip = false;
		while (ptrtmp != ptrtmp_limit && *ptrtmp) {
			uint32_t c = (byteswap) ? BSWAP16(*ptrtmp) : *ptrtmp;

			if ((c & 0xfffffc00) == 0xd800) { // lead surrogate
				if (skip) {
					//print_unicode_error(vformat("Unpaired lead surrogate (%x [trail?] %x)", c_prev, c));
					decode_error = true;
				}
				skip = true;
			} else if ((c & 0xfffffc00) == 0xdc00) { // trail surrogate
				if (skip) {
					str_size--;
				} else {
					//print_unicode_error(vformat("Unpaired trail surrogate (%x [lead?] %x)", c_prev, c));
					decode_error = true;
				}
				skip = false;
			} else {
				skip = false;
			}

			//c_prev = c;
			str_size++;
			cstr_size++;
			ptrtmp++;
		}

		if (skip) {
			//print_unicode_error(vformat("Unpaired lead surrogate (%x [eol])", c_prev));
			decode_error = true;
		}
	}

	if (str_size == 0) {
		clear();
		return OK; // empty string
	}

	resize(str_size + 1);
	CharType *dst = ptrw();
	dst[str_size] = 0;

	bool skip = false;
	uint32_t c_prev = 0;
	while (cstr_size) {
		uint32_t c = (byteswap) ? BSWAP16(*p_utf16) : *p_utf16;

		if ((c & 0xfffffc00) == 0xd800) { // lead surrogate
			if (skip) {
				*(dst++) = c_prev; // unpaired, store as is
			}
			skip = true;
		} else if ((c & 0xfffffc00) == 0xdc00) { // trail surrogate
			if (skip) {
				*(dst++) = (c_prev << 10UL) + c - ((0xd800 << 10UL) + 0xdc00 - 0x10000); // decode pair
			} else {
				*(dst++) = c; // unpaired, store as is
			}
			skip = false;
		} else {
			*(dst++) = c;
			skip = false;
		}

		cstr_size--;
		p_utf16++;
		c_prev = c;
	}

	if (skip) {
		*(dst++) = c_prev;
	}

	if (decode_error) {
		return ERR_PARSE_ERROR;
	} else {
		return OK;
	}
}

Char16String String::utf16() const {
	int l = length();
	if (!l) {
		return Char16String();
	}

	const CharType *d = &operator[](0);
	int fl = 0;
	for (int i = 0; i < l; i++) {
		uint32_t c = d[i];
		if (c <= 0xffff) { // 16 bits.
			fl += 1;
			if ((c & 0xfffff800) == 0xd800) {
				//print_unicode_error(vformat("Unpaired surrogate (%x)", c));
			}
		} else if (c <= 0x10ffff) { // 32 bits.
			fl += 2;
		} else {
			//print_unicode_error(vformat("Invalid unicode codepoint (%x), cannot represent as UTF-16", c), true);
			fl += 1;
		}
	}

	Char16String utf16s;
	if (fl == 0) {
		return utf16s;
	}

	utf16s.resize(fl + 1);
	uint16_t *cdst = (uint16_t *)utf16s.get_data();

#define APPEND_CHAR(m_c) *(cdst++) = m_c

	for (int i = 0; i < l; i++) {
		uint32_t c = d[i];

		if (c <= 0xffff) { // 16 bits.
			APPEND_CHAR(c);
		} else if (c <= 0x10ffff) { // 32 bits.
			APPEND_CHAR(uint32_t((c >> 10) + 0xd7c0)); // lead surrogate.
			APPEND_CHAR(uint32_t((c & 0x3ff) | 0xdc00)); // trail surrogate.
		} else {
			APPEND_CHAR(0x20);
		}
	}
#undef APPEND_CHAR
	*cdst = 0; //trailing zero

	return utf16s;
}

int String::utf16_byte_length() const {
	int l = length();
	if (!l) {
		return 0;
	}

	const CharType *d = &operator[](0);
	int fl = 0;
	for (int i = 0; i < l; i++) {
		uint32_t c = d[i];
		if (c <= 0xffff) { // 16 bits.
			fl += 1;
			if ((c & 0xfffff800) == 0xd800) {
				//print_unicode_error(vformat("Unpaired surrogate (%x)", c));
			}
		} else if (c <= 0x10ffff) { // 32 bits.
			fl += 2;
		} else {
			//print_unicode_error(vformat("Invalid unicode codepoint (%x), cannot represent as UTF-16", c), true);
			fl += 1;
		}
	}

	return fl;
}

uint32_t String::hash(const char *p_cstr) {
	uint32_t hashv = 5381;
	uint32_t c;

	while ((c = *p_cstr++)) {
		hashv = ((hashv << 5) + hashv) + c; /* hash * 33 + c */
	}

	return hashv;
}

uint32_t String::hash(const char *p_cstr, int p_len) {
	uint32_t hashv = 5381;
	for (int i = 0; i < p_len; i++) {
		hashv = ((hashv << 5) + hashv) + p_cstr[i]; /* hash * 33 + c */
	}

	return hashv;
}

uint32_t String::hash(const wchar_t *p_cstr) {
	uint32_t hashv = 5381;
	uint32_t c;

	while ((c = *p_cstr++)) {
		hashv = ((hashv << 5) + hashv) + c; /* hash * 33 + c */
	}

	return hashv;
}

uint32_t String::hash(const wchar_t *p_cstr, int p_len) {
	uint32_t hashv = 5381;
	for (int i = 0; i < p_len; i++) {
		hashv = ((hashv << 5) + hashv) + p_cstr[i]; /* hash * 33 + c */
	}

	return hashv;
}

uint32_t String::hash(const CharType *p_cstr) {
	uint32_t hashv = 5381;
	uint32_t c;

	while ((c = *p_cstr++)) {
		hashv = ((hashv << 5) + hashv) + c; /* hash * 33 + c */
	}

	return hashv;
}

uint32_t String::hash(const CharType *p_cstr, int p_len) {
	uint32_t hashv = 5381;
	for (int i = 0; i < p_len; i++) {
		hashv = ((hashv << 5) + hashv) + p_cstr[i]; /* hash * 33 + c */
	}

	return hashv;
}

uint32_t String::hash() const {
	/* simple djb2 hashing */

	const CharType *chr = get_data();
	uint32_t hashv = 5381;
	uint32_t c;

	while ((c = *chr++)) {
		hashv = ((hashv << 5) + hashv) + c; /* hash * 33 + c */
	}

	return hashv;
}

uint64_t String::hash64() const {
	/* simple djb2 hashing */

	const CharType *chr = get_data();
	uint64_t hashv = 5381;
	uint64_t c;

	while ((c = *chr++)) {
		hashv = ((hashv << 5) + hashv) + c; /* hash * 33 + c */
	}

	return hashv;
}

bool String::is_abs_path() const {
	if (length() > 1) {
		return (operator[](0) == '/' || operator[](0) == '\\' || find(":/") != -1 || find(":\\") != -1);
	} else if ((length()) == 1) {
		return (operator[](0) == '/' || operator[](0) == '\\');
	} else {
		return false;
	}
}

bool String::is_rel_path() const {
	return !is_abs_path();
}

bool String::is_resource_file() const {
	return begins_with("res://") && find("::") == -1;
}

String String::path_to(const String &p_path) const {
	String src = this->replace("\\", "/");
	String dst = p_path.replace("\\", "/");
	if (!src.ends_with("/")) {
		src += "/";
	}
	if (!dst.ends_with("/")) {
		dst += "/";
	}

	String base;

	if (src.begins_with("res://") && dst.begins_with("res://")) {
		base = "res:/";
		src = src.replace("res://", "/");
		dst = dst.replace("res://", "/");

	} else if (src.begins_with("user://") && dst.begins_with("user://")) {
		base = "user:/";
		src = src.replace("user://", "/");
		dst = dst.replace("user://", "/");

	} else if (src.begins_with("/") && dst.begins_with("/")) {
		//nothing
	} else {
		//dos style
		String src_begin = src.get_slicec('/', 0);
		String dst_begin = dst.get_slicec('/', 0);

		if (src_begin != dst_begin) {
			return p_path; //impossible to do this
		}

		base = src_begin;
		src = src.substr(src_begin.length(), src.length());
		dst = dst.substr(dst_begin.length(), dst.length());
	}

	//remove leading and trailing slash and split
	Vector<String> src_dirs = src.substr(1, src.length() - 2).split("/");
	Vector<String> dst_dirs = dst.substr(1, dst.length() - 2).split("/");

	//find common parent
	int common_parent = 0;

	while (true) {
		if (src_dirs.size() == common_parent) {
			break;
		}
		if (dst_dirs.size() == common_parent) {
			break;
		}
		if (src_dirs[common_parent] != dst_dirs[common_parent]) {
			break;
		}
		common_parent++;
	}

	common_parent--;

	String dir;

	for (int i = src_dirs.size() - 1; i > common_parent; i--) {
		dir += "../";
	}

	for (int i = common_parent + 1; i < dst_dirs.size(); i++) {
		dir += dst_dirs[i] + "/";
	}

	if (dir.length() == 0) {
		dir = "./";
	}
	return dir;
}

String String::path_to_file(const String &p_path) const {
	// Don't get base dir for src, this is expected to be a dir already.
	String src = this->replace("\\", "/");
	String dst = p_path.replace("\\", "/").get_base_dir();
	String rel = src.path_to(dst);
	if (rel == dst) { // failed
		return p_path;
	} else {
		return rel + p_path.get_file();
	}
}

String String::get_base_dir() const {
	int end = 0;

	// url scheme style base
	int basepos = find("://");
	if (basepos != -1) {
		end = basepos + 3;
	}

	// windows top level directory base
	if (end == 0) {
		basepos = find(":/");
		if (basepos == -1) {
			basepos = find(":\\");
		}
		if (basepos != -1) {
			end = basepos + 2;
		}
	}

	// Windows UNC network share path.
	if (end == 0) {
		if (is_network_share_path()) {
			basepos = find("/", 2);
			if (basepos == -1) {
				basepos = find("\\", 2);
			}
			int servpos = find("/", basepos + 1);
			if (servpos == -1) {
				servpos = find("\\", basepos + 1);
			}
			if (servpos != -1) {
				end = servpos + 1;
			}
		}
	}

	// unix root directory base
	if (end == 0) {
		if (begins_with("/")) {
			end = 1;
		}
	}

	String rs;
	String base;
	if (end != 0) {
		rs = substr(end, length());
		base = substr(0, end);
	} else {
		rs = *this;
	}

	int sep = MAX(rs.rfind("/"), rs.rfind("\\"));
	if (sep == -1) {
		return base;
	}

	return base + rs.substr(0, sep);
}

String String::get_file() const {
	int sep = MAX(rfind("/"), rfind("\\"));
	if (sep == -1) {
		return *this;
	}

	return substr(sep + 1, length());
}

String String::humanize_size(uint64_t p_size) {
	uint64_t _div = 1;
	Vector<String> prefixes;
	prefixes.push_back(RTR("B"));
	prefixes.push_back(RTR("KiB"));
	prefixes.push_back(RTR("MiB"));
	prefixes.push_back(RTR("GiB"));
	prefixes.push_back(RTR("TiB"));
	prefixes.push_back(RTR("PiB"));
	prefixes.push_back(RTR("EiB"));

	int prefix_idx = 0;

	while (prefix_idx < prefixes.size() - 1 && p_size > (_div * 1024)) {
		_div *= 1024;
		prefix_idx++;
	}

	const int digits = prefix_idx > 0 ? _humanize_digits(p_size / _div) : 0;
	const double divisor = prefix_idx > 0 ? _div : 1;

	return String::num(p_size / divisor).pad_decimals(digits) + " " + prefixes[prefix_idx];
}

String String::simplify_path() const {
	String s = *this;
	String drive;
	if (s.begins_with("local://")) {
		drive = "local://";
		s = s.substr(8, s.length());
	} else if (s.begins_with("res://")) {
		drive = "res://";
		s = s.substr(6, s.length());
	} else if (s.begins_with("user://")) {
		drive = "user://";
		s = s.substr(7, s.length());
	} else if (is_network_share_path()) {
		drive = s.substr(0, 2);
		s = s.substr(2, s.length() - 2);
	} else if (s.begins_with("/") || s.begins_with("\\")) {
		drive = s.substr(0, 1);
		s = s.substr(1, s.length() - 1);
	} else {
		int p = s.find(":/");
		if (p == -1) {
			p = s.find(":\\");
		}
		if (p != -1 && p < s.find("/")) {
			drive = s.substr(0, p + 2);
			s = s.substr(p + 2, s.length());
		}
	}

	s = s.replace("\\", "/");
	while (true) { // in case of using 2 or more slash
		String compare = s.replace("//", "/");
		if (s == compare) {
			break;
		} else {
			s = compare;
		}
	}
	Vector<String> dirs = s.split("/", false);

	for (int i = 0; i < dirs.size(); i++) {
		String d = dirs[i];
		if (d == ".") {
			dirs.remove(i);
			i--;
		} else if (d == "..") {
			if (i == 0) {
				dirs.remove(i);
				i--;
			} else {
				dirs.remove(i);
				dirs.remove(i - 1);
				i -= 2;
			}
		}
	}

	s = "";

	for (int i = 0; i < dirs.size(); i++) {
		if (i > 0) {
			s += "/";
		}
		s += dirs[i];
	}

	return drive + s;
}

bool String::is_network_share_path() const {
	return begins_with("//") || begins_with("\\\\");
}

String String::append_path(const char *path) const {
	if (path[0] == '\0') {
		return *this;
	}

	String ret = *this;
	int size = length();

	if (size == 0) {
		ret += path;
		return ret;
	}

	int sindex = 0;
	char ch = path[sindex];
	while (ch == '/' || ch == '\\') {
		if (ch == '\0') {
			return ret;
		}

		ch = path[++sindex];
	}

	// /////folder
	//      ^ (sindex)

	if (ret.ends_with("/") || ret.ends_with("\\")) {
		ret += &path[sindex];
	} else {
		if (sindex > 0) {
			ret += '/';
			ret += &path[sindex - 1];
		} else {
			ret += '/';
			ret += &path[sindex];
		}
	}

	return ret;
}

String String::append_path(const String &path) const {
	if (path.length() == 0) {
		return *this;
	}

	int size = length();

	if (size == 0) {
		return path;
	}

	int sindex = 0;
	int ts = path.size() - 1;
	char ch = path[sindex];
	while (ch == '/' || ch == '\\') {
		if (sindex == ts) {
			return *this;
		}

		ch = path[++sindex];
	}

	String ret = *this;

	// /////folder
	//      ^ (sindex)

	if (ret.ends_with("/") || ret.ends_with("\\")) {
		ret += &path[sindex];
	} else {
		if (sindex > 0) {
			ret += '/';
			ret += &path[sindex - 1];
		} else {
			ret += '/';
			ret += &path[sindex];
		}
	}

	return ret;
}

String String::path_clean_end_slash() const {
	// _size > 1, so if root is given ("/"), it will not be removed

	String ret = *this;

	int strip_to = ret.length() - 1;

	CharType c = ret[strip_to];

	while (strip_to > 1 && (c == '/' || c == '\\')) {
		--strip_to;
		c = ret[strip_to];
	}

	if (ret.length() != strip_to + 1) {
		ret.set_length(strip_to + 1);
	}

	return ret;
}
String String::path_ensure_end_slash() const {
	// Don't add if empty string, as it would make it root on linux, which can easily become a serious bug

	String ret = *this;

	if (ret.length() == 0) {
		return ret;
	}

	if (!(ret.ends_with("/") || ret.ends_with("\\"))) {
		ret += "/";
	}

	return ret;
}

String String::path_get_prev_dir() const {
	int size = length();

	if (size == 0) {
		return "/";
	}

	int seind = size - 1;
	while (seind > 0 && (operator[](seind) == '/' || operator[](seind) == '\\')) {
		--seind;
	}

	if (seind == 0) {
		// /////////
		// or
		// a///////
		// no prev dir

		return "/";
	}

	// fol/fol2/fol3//
	//             ^  (seind)

	while (seind > 0 && (operator[](seind) != '/' && operator[](seind) != '\\')) {
		--seind;
	}

	// fol/fol2/fol3//
	//         ^  (seind)

	//--seind;

	if (seind <= 0) {
		return "/";
	}

	return substr_index(0, seind);
}

String String::xml_escape(bool p_escape_quotes) const {
	String str = *this;
	str = str.replace("&", "&amp;");
	str = str.replace("<", "&lt;");
	str = str.replace(">", "&gt;");
	if (p_escape_quotes) {
		str = str.replace("'", "&apos;");
		str = str.replace("\"", "&quot;");
	}
	/*
	for (int i=1;i<32;i++) {

		char chr[2]={i,0};
		str=str.replace(chr,"&#"+String::num(i)+";");
	}*/
	return str;
}

static _FORCE_INLINE_ int _xml_unescape(const CharType *p_src, int p_src_len, CharType *p_dst) {
	int len = 0;
	while (p_src_len) {
		if (*p_src == '&') {
			int eat = 0;

			if (p_src_len >= 4 && p_src[1] == '#') {
				CharType c = 0;
				bool overflow = false;
				if (p_src[2] == 'x') {
					// Hex entity &#x<num>;
					for (int i = 3; i < p_src_len; i++) {
						eat = i + 1;
						CharType ct = p_src[i];
						if (ct == ';') {
							break;
						} else if (ct >= '0' && ct <= '9') {
							ct = ct - '0';
						} else if (ct >= 'a' && ct <= 'f') {
							ct = (ct - 'a') + 10;
						} else if (ct >= 'A' && ct <= 'F') {
							ct = (ct - 'A') + 10;
						} else {
							break;
						}
						if (c > (WCHAR_MAX >> 4)) {
							overflow = true;
							break;
						}
						c <<= 4;
						c |= ct;
					}
				} else {
					// Decimal entity &#<num>;
					for (int i = 2; i < p_src_len; i++) {
						eat = i + 1;
						CharType ct = p_src[i];
						if (ct == ';' || ct < '0' || ct > '9') {
							break;
						}
					}
					if (p_src[eat - 1] == ';') {
						int64_t val = String::to_int(p_src + 2, eat - 3);
						if (val > 0 && val <= WCHAR_MAX) {
							c = (CharType)val;
						} else {
							overflow = true;
						}
					}
				}

				// Value must be non-zero, in the range of CharType,
				// actually end with ';'. If invalid, leave the entity as-is
				if (c == '\0' || overflow || p_src[eat - 1] != ';') {
					eat = 1;
					c = *p_src;
				}
				if (p_dst) {
					*p_dst = c;
				}
			} else if (p_src_len >= 4 && p_src[1] == 'g' && p_src[2] == 't' && p_src[3] == ';') {
				if (p_dst) {
					*p_dst = '>';
				}
				eat = 4;
			} else if (p_src_len >= 4 && p_src[1] == 'l' && p_src[2] == 't' && p_src[3] == ';') {
				if (p_dst) {
					*p_dst = '<';
				}
				eat = 4;
			} else if (p_src_len >= 5 && p_src[1] == 'a' && p_src[2] == 'm' && p_src[3] == 'p' && p_src[4] == ';') {
				if (p_dst) {
					*p_dst = '&';
				}
				eat = 5;
			} else if (p_src_len >= 6 && p_src[1] == 'q' && p_src[2] == 'u' && p_src[3] == 'o' && p_src[4] == 't' && p_src[5] == ';') {
				if (p_dst) {
					*p_dst = '"';
				}
				eat = 6;
			} else if (p_src_len >= 6 && p_src[1] == 'a' && p_src[2] == 'p' && p_src[3] == 'o' && p_src[4] == 's' && p_src[5] == ';') {
				if (p_dst) {
					*p_dst = '\'';
				}
				eat = 6;
			} else {
				if (p_dst) {
					*p_dst = *p_src;
				}
				eat = 1;
			}

			if (p_dst) {
				p_dst++;
			}

			len++;
			p_src += eat;
			p_src_len -= eat;
		} else {
			if (p_dst) {
				*p_dst = *p_src;
				p_dst++;
			}
			len++;
			p_src++;
			p_src_len--;
		}
	}

	return len;
}

String String::xml_unescape() const {
	String str;
	int l = length();
	int len = _xml_unescape(get_data(), l, nullptr);
	if (len == 0) {
		return String();
	}
	str.resize(len + 1);
	_xml_unescape(get_data(), l, str.ptrw());
	str[len] = 0;
	return str;
}

String String::http_escape() const {
	const CharString temp = utf8();
	String res;
	for (int i = 0; i < temp.length(); ++i) {
		uint8_t ord = temp[i];
		if (ord == '.' || ord == '-' || ord == '_' || ord == '~' ||
				(ord >= 'a' && ord <= 'z') ||
				(ord >= 'A' && ord <= 'Z') ||
				(ord >= '0' && ord <= '9')) {
			res += ord;
		} else {
			char p[4] = { '%', 0, 0, 0 };
			static const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

			p[1] = hex[ord >> 4];
			p[2] = hex[ord & 0xF];
			res += p;
		}
	}
	return res;
}

String String::http_unescape() const {
	String res;
	for (int i = 0; i < length(); ++i) {
		if (ord_at(i) == '%' && i + 2 < length()) {
			CharType ord1 = ord_at(i + 1);
			if ((ord1 >= '0' && ord1 <= '9') || (ord1 >= 'A' && ord1 <= 'Z')) {
				CharType ord2 = ord_at(i + 2);
				if ((ord2 >= '0' && ord2 <= '9') || (ord2 >= 'A' && ord2 <= 'Z')) {
					char bytes[3] = { (char)ord1, (char)ord2, 0 };
					res += (char)strtol(bytes, nullptr, 16);
					i += 2;
				}
			} else {
				res += ord_at(i);
			}
		} else {
			res += ord_at(i);
		}
	}
	return String::utf8(res.ascii());
}

String String::uri_encode() const {
	const CharString temp = utf8();
	String res;
	for (int i = 0; i < temp.length(); ++i) {
		uint8_t ord = temp[i];
		if (ord == '.' || ord == '-' || ord == '~' || is_ascii_identifier_char(ord)) {
			res += ord;
		} else {
			char p[4] = { '%', 0, 0, 0 };
			static const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
			p[1] = hex[ord >> 4];
			p[2] = hex[ord & 0xF];
			res += p;
		}
	}
	return res;
}

String String::uri_decode() const {
	CharString src = utf8();
	CharString res;
	for (int i = 0; i < src.length(); ++i) {
		if (src[i] == '%' && i + 2 < src.length()) {
			char ord1 = src[i + 1];
			if (is_digit(ord1) || is_ascii_upper_case(ord1)) {
				char ord2 = src[i + 2];
				if (is_digit(ord2) || is_ascii_upper_case(ord2)) {
					char bytes[3] = { (char)ord1, (char)ord2, 0 };
					res += (char)strtol(bytes, nullptr, 16);
					i += 2;
				}
			} else {
				res += src[i];
			}
		} else if (src[i] == '+') {
			res += ' ';
		} else {
			res += src[i];
		}
	}
	return String::utf8(res);
}

String String::c_escape() const {
	String escaped = *this;
	escaped = escaped.replace("\\", "\\\\");
	escaped = escaped.replace("\a", "\\a");
	escaped = escaped.replace("\b", "\\b");
	escaped = escaped.replace("\f", "\\f");
	escaped = escaped.replace("\n", "\\n");
	escaped = escaped.replace("\r", "\\r");
	escaped = escaped.replace("\t", "\\t");
	escaped = escaped.replace("\v", "\\v");
	escaped = escaped.replace("\'", "\\'");
	escaped = escaped.replace("\?", "\\?");
	escaped = escaped.replace("\"", "\\\"");

	return escaped;
}

String String::c_escape_multiline() const {
	String escaped = *this;
	escaped = escaped.replace("\\", "\\\\");
	escaped = escaped.replace("\"", "\\\"");

	return escaped;
}

String String::c_unescape() const {
	String escaped = *this;
	escaped = escaped.replace("\\a", "\a");
	escaped = escaped.replace("\\b", "\b");
	escaped = escaped.replace("\\f", "\f");
	escaped = escaped.replace("\\n", "\n");
	escaped = escaped.replace("\\r", "\r");
	escaped = escaped.replace("\\t", "\t");
	escaped = escaped.replace("\\v", "\v");
	escaped = escaped.replace("\\'", "\'");
	escaped = escaped.replace("\\\"", "\"");
	escaped = escaped.replace("\\?", "\?");
	escaped = escaped.replace("\\\\", "\\");

	return escaped;
}

String String::json_escape() const {
	String escaped = *this;
	escaped = escaped.replace("\\", "\\\\");
	escaped = escaped.replace("\b", "\\b");
	escaped = escaped.replace("\f", "\\f");
	escaped = escaped.replace("\n", "\\n");
	escaped = escaped.replace("\r", "\\r");
	escaped = escaped.replace("\t", "\\t");
	escaped = escaped.replace("\v", "\\v");
	escaped = escaped.replace("\"", "\\\"");

	return escaped;
}

String String::word_wrap(int p_chars_per_line) const {
	String ret;

	int line_start = 0;
	int line_end = 0; // End of last word on current line.
	int word_start = 0; // -1 if no word encountered. Leading spaces are part of a word.
	int word_length = 0;

	for (int i = 0; i < length(); i++) {
		const CharType c = operator[](i);

		switch (c) {
			case '\n': {
				// Force newline.
				ret += substr(line_start, i - line_start + 1);
				line_start = i + 1;
				line_end = line_start;
				word_start = line_start;
				word_length = 0;
			} break;

			case ' ':
			case '\t': {
				// A whitespace ends current word.
				if (word_length > 0) {
					line_end = i - 1;
					word_start = -1;
					word_length = 0;
				}
			} break;

			default: {
				if (word_start == -1) {
					word_start = i;
				}
				word_length += 1;

				if (word_length > p_chars_per_line) {
					// Word too long: wrap before current character.
					ret += substr(line_start, i - line_start) + "\n";
					line_start = i;
					line_end = i;
					word_start = i;
					word_length = 1;
				} else if (i - line_start + 1 > p_chars_per_line) {
					// Line too long: wrap after the last word.
					ret += substr(line_start, line_end - line_start + 1) + "\n";
					line_start = word_start;
					line_end = line_start;
				}
			} break;
		}
	}

	const int remaining = length() - line_start;
	if (remaining) {
		ret += substr(line_start, remaining);
	}

	return ret;
}

Error String::parse_url(String &r_scheme, String &r_host, int &r_port, String &r_path) const {
	// Splits the URL into scheme, host, port, path. Strip credentials when present.
	String base = *this;
	r_scheme = "";
	r_host = "";
	r_port = 0;
	r_path = "";
	int pos = base.find("://");
	// Scheme
	if (pos != -1) {
		r_scheme = base.substr(0, pos + 3).to_lower();
		base = base.substr(pos + 3, base.length() - pos - 3);
	}
	pos = base.find("/");
	// Path
	if (pos != -1) {
		r_path = base.substr(pos, base.length() - pos);
		base = base.substr(0, pos);
	}
	// Host
	pos = base.find("@");
	if (pos != -1) {
		// Strip credentials
		base = base.substr(pos + 1, base.length() - pos - 1);
	}
	if (base.begins_with("[")) {
		// Literal IPv6
		pos = base.rfind("]");
		if (pos == -1) {
			return ERR_INVALID_PARAMETER;
		}
		r_host = base.substr(1, pos - 1);
		base = base.substr(pos + 1, base.length() - pos - 1);
	} else {
		// Anything else
		if (base.get_slice_count(":") > 2) {
			return ERR_INVALID_PARAMETER;
		}
		pos = base.rfind(":");
		if (pos == -1) {
			r_host = base;
			base = "";
		} else {
			r_host = base.substr(0, pos);
			base = base.substr(pos, base.length() - pos);
		}
	}
	if (r_host.empty()) {
		return ERR_INVALID_PARAMETER;
	}
	r_host = r_host.to_lower();
	// Port
	if (base.begins_with(":")) {
		base = base.substr(1, base.length() - 1);
		if (!base.is_valid_integer()) {
			return ERR_INVALID_PARAMETER;
		}
		r_port = base.to_int();
		if (r_port < 1 || r_port > 65535) {
			return ERR_INVALID_PARAMETER;
		}
	}
	return OK;
}

String String::percent_encode() const {
	CharString cs = utf8();
	String encoded;
	for (int i = 0; i < cs.length(); i++) {
		uint8_t c = cs[i];
		if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '-' || c == '_' || c == '~' || c == '.') {
			char p[2] = { (char)c, 0 };
			encoded += p;
		} else {
			char p[4] = { '%', 0, 0, 0 };
			static const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

			p[1] = hex[c >> 4];
			p[2] = hex[c & 0xF];
			encoded += p;
		}
	}

	return encoded;
}
String String::percent_decode() const {
	CharString pe;

	CharString cs = utf8();
	for (int i = 0; i < cs.length(); i++) {
		uint8_t c = cs[i];
		if (c == '%' && i < length() - 2) {
			uint8_t a = LOWERCASE(cs[i + 1]);
			uint8_t b = LOWERCASE(cs[i + 2]);

			if (a >= '0' && a <= '9') {
				c = (a - '0') << 4;
			} else if (a >= 'a' && a <= 'f') {
				c = (a - 'a' + 10) << 4;
			} else {
				continue;
			}

			uint8_t d = 0;

			if (b >= '0' && b <= '9') {
				d = (b - '0');
			} else if (b >= 'a' && b <= 'f') {
				d = (b - 'a' + 10);
			} else {
				continue;
			}
			c += d;
			i += 2;
		}
		pe += c;
	}

	return String::utf8(pe.ptr());
}

String String::property_name_encode() const {
	// Escape and quote strings with extended ASCII or further Unicode characters
	// as well as '"', '=' or ' ' (32)
	const CharType *cstr = get_data();
	for (int i = 0; cstr[i]; i++) {
		if (cstr[i] == '=' || cstr[i] == '"' || cstr[i] == ';' || cstr[i] == '[' || cstr[i] == ']' || cstr[i] < 33 || cstr[i] > 126) {
			return "\"" + c_escape_multiline() + "\"";
		}
	}
	// Keep as is
	return *this;
}

// Changes made to the set of invalid characters must also be reflected in the String documentation.

static const char32_t invalid_node_name_characters[] = { '.', ':', '@', '/', '\"', '%', 0 };

String String::get_invalid_node_name_characters() {
	// Do not use this function for critical validation.
	String r;
	const char32_t *c = invalid_node_name_characters;
	while (*c) {
		if (c != invalid_node_name_characters) {
			r += " ";
		}
		r += String::chr(*c);
		c++;
	}
	return r;
}

String String::validate_node_name() const {
	// This is a critical validation in node addition, so it must be optimized.
	const char32_t *cn = ptr();
	if (cn == nullptr) {
		return String();
	}

	bool valid = true;
	uint32_t idx = 0;
	while (cn[idx]) {
		const char32_t *c = invalid_node_name_characters;
		while (*c) {
			if (cn[idx] == *c) {
				valid = false;
				break;
			}
			c++;
		}
		if (!valid) {
			break;
		}
		idx++;
	}

	if (valid) {
		return *this;
	}

	String validated = *this;
	char32_t *nn = validated.ptrw();
	while (nn[idx]) {
		const char32_t *c = invalid_node_name_characters;
		while (*c) {
			if (nn[idx] == *c) {
				nn[idx] = '_';
				break;
			}
			c++;
		}
		idx++;
	}

	return validated;
}

static _FORCE_INLINE_ bool _is_valid_identifier_bit(int p_index, char32_t p_char) {
	if (p_index == 0 && is_digit(p_char)) {
		return false; // No start with number plz.
	}
	return is_ascii_identifier_char(p_char);
}

String String::validate_identifier() const {
	if (empty()) {
		return "_"; // Empty string is not a valid identifier;
	}

	String result = *this;
	int len = result.length();
	char32_t *buffer = result.ptrw();

	for (int i = 0; i < len; i++) {
		if (!_is_valid_identifier_bit(i, buffer[i])) {
			buffer[i] = '_';
		}
	}

	return result;
}

bool String::is_valid_identifier() const {
	int len = length();

	if (len == 0) {
		return false;
	}

	const CharType *str = &operator[](0);

	for (int i = 0; i < len; i++) {
		if (i == 0) {
			if (str[0] >= '0' && str[0] <= '9') {
				return false; // no start with number plz
			}
		}

		bool valid_char = (str[i] >= '0' && str[i] <= '9') || (str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z') || str[i] == '_';

		if (!valid_char) {
			return false;
		}
	}

	return true;
}

bool String::is_valid_integer() const {
	int len = length();

	if (len == 0) {
		return false;
	}

	int from = 0;
	if (len != 1 && (operator[](0) == '+' || operator[](0) == '-')) {
		from++;
	}

	for (int i = from; i < len; i++) {
		if (operator[](i) < '0' || operator[](i) > '9') {
			return false; // no start with number plz
		}
	}

	return true;
}

bool String::is_valid_hex_number(bool p_with_prefix) const {
	int len = length();

	if (len == 0) {
		return false;
	}

	int from = 0;
	if (len != 1 && (operator[](0) == '+' || operator[](0) == '-')) {
		from++;
	}

	if (p_with_prefix) {
		if (len < 3) {
			return false;
		}
		if (operator[](from) != '0' || operator[](from + 1) != 'x') {
			return false;
		}
		from += 2;
	}

	for (int i = from; i < len; i++) {
		CharType c = operator[](i);
		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) {
			continue;
		}
		return false;
	}

	return true;
};

bool String::is_valid_float() const {
	int len = length();

	if (len == 0) {
		return false;
	}

	int from = 0;
	if (operator[](0) == '+' || operator[](0) == '-') {
		from++;
	}

	bool exponent_found = false;
	bool period_found = false;
	bool sign_found = false;
	bool exponent_values_found = false;
	bool numbers_found = false;

	for (int i = from; i < len; i++) {
		if (operator[](i) >= '0' && operator[](i) <= '9') {
			if (exponent_found) {
				exponent_values_found = true;
			} else {
				numbers_found = true;
			}
		} else if (numbers_found && !exponent_found && operator[](i) == 'e') {
			exponent_found = true;
		} else if (!period_found && !exponent_found && operator[](i) == '.') {
			period_found = true;
		} else if ((operator[](i) == '-' || operator[](i) == '+') && exponent_found && !exponent_values_found && !sign_found) {
			sign_found = true;
		} else {
			return false; // no start with number plz
		}
	}

	return numbers_found;
}

bool String::is_valid_bool() const {
	int size = length();

	if (size == 1) {
		CharType c = ptr()[0];

		if (c == '0') {
			return true;
		} else if (c == '1') {
			return true;
		}

		return false;
	} else if (size == 4) {
		String l = to_lower();
		const CharType *p = l.ptr();

		if (p[0] == 't' && p[1] == 'r' && p[2] == 'u' && p[3] == 'e') {
			return true;
		} else {
			return false;
		}
	} else if (size == 5) {
		String l = to_lower();
		const CharType *p = l.ptr();

		if (p[0] == 'f' && p[1] == 'a' && p[2] == 'l' && p[3] == 's' && p[3] == 'e') {
			return true;
		} else {
			return false;
		}
	}

	return false;
}

bool String::is_valid_unsigned_integer() const {
	int len = length();

	if (len == 0) {
		return false;
	}

	int from = 0;
	if (len != 1 && (operator[](0) == '+')) {
		from++;
	}

	for (int i = from; i < len; i++) {
		if (operator[](i) < '0' || operator[](i) > '9') {
			return false; // no start with number plz
		}
	}

	return true;
}

bool String::is_valid_html_color() const {
	return Color::html_is_valid(*this);
}

bool String::is_valid_filename() const {
	String stripped = strip_edges();
	if (*this != stripped) {
		return false;
	}

	if (stripped == String()) {
		return false;
	}

	return !(find(":") != -1 || find("/") != -1 || find("\\") != -1 || find("?") != -1 || find("*") != -1 || find("\"") != -1 || find("|") != -1 || find("%") != -1 || find("<") != -1 || find(">") != -1);
}

bool String::is_valid_ip_address() const {
	if (find(":") >= 0) {
		Vector<String> ip = split(":");
		for (int i = 0; i < ip.size(); i++) {
			String n = ip[i];
			if (n.empty()) {
				continue;
			}
			if (n.is_valid_hex_number(false)) {
				int nint = n.hex_to_int(false);
				if (nint < 0 || nint > 0xffff) {
					return false;
				}
				continue;
			};
			if (!n.is_valid_ip_address()) {
				return false;
			}
		};

	} else {
		Vector<String> ip = split(".");
		if (ip.size() != 4) {
			return false;
		}
		for (int i = 0; i < ip.size(); i++) {
			String n = ip[i];
			if (!n.is_valid_integer()) {
				return false;
			}
			int val = n.to_int();
			if (val < 0 || val > 255) {
				return false;
			}
		}
	};

	return true;
}

Vector<uint8_t> String::to_ascii_buffer() const {
	const String *s = this;
	if (s->empty()) {
		return Vector<uint8_t>();
	}
	CharString charstr = s->ascii();

	Vector<uint8_t> retval;
	size_t len = charstr.length();
	retval.resize(len);
	uint8_t *w = retval.ptrw();
	memcpy(w, charstr.ptr(), len);

	return retval;
}

Vector<uint8_t> String::to_utf8_buffer() const {
	const String *s = this;
	if (s->empty()) {
		return Vector<uint8_t>();
	}
	CharString charstr = s->utf8();

	Vector<uint8_t> retval;
	size_t len = charstr.length();
	retval.resize(len);
	uint8_t *w = retval.ptrw();
	memcpy(w, charstr.ptr(), len);

	return retval;
}

Vector<uint8_t> String::to_utf16_buffer() const {
	const String *s = this;
	if (s->empty()) {
		return Vector<uint8_t>();
	}
	Char16String charstr = s->utf16();

	Vector<uint8_t> retval;
	size_t len = charstr.length() * sizeof(char16_t);
	retval.resize(len);
	uint8_t *w = retval.ptrw();
	memcpy(w, (const void *)charstr.ptr(), len);

	return retval;
}

Vector<uint8_t> String::to_utf32_buffer() const {
	const String *s = this;
	if (s->empty()) {
		return Vector<uint8_t>();
	}

	Vector<uint8_t> retval;
	size_t len = s->length() * sizeof(CharType);
	retval.resize(len);
	uint8_t *w = retval.ptrw();
	memcpy(w, (const void *)s->ptr(), len);

	return retval;
}

String::String(const char *p_str) {
	copy_from(p_str);
}

String::String(const wchar_t *p_str) {
	copy_from(p_str);
}

String::String(const CharType *p_str) {
	copy_from(p_str);
}

String::String(const Char16String &p_str) {
	copy_from(p_str);
}

String::String(const char *p_str, int p_clip_to_len) {
	copy_from(p_str, p_clip_to_len);
}

String::String(const wchar_t *p_str, int p_clip_to_len) {
	copy_from(p_str, p_clip_to_len);
}

String::String(const CharType *p_str, int p_clip_to_len) {
	copy_from(p_str, p_clip_to_len);
}

String::String(const StrRange &p_range) {
	if (!p_range.c_str) {
		return;
	}
	copy_from(p_range.c_str, p_range.len);
}

// Other conversions

int String::hex_to_int(bool p_with_prefix) const {
	int len = length();
	ERR_FAIL_COND_V_MSG(p_with_prefix ? len < 3 : len == 0, 0, String("Invalid hexadecimal notation length in string ") + (p_with_prefix ? "with" : "without") + " prefix \"" + *this + "\".");

	const CharType *s = ptr();

	int sign = s[0] == '-' ? -1 : 1;

	if (sign < 0) {
		s++;
	}

	if (p_with_prefix) {
		ERR_FAIL_COND_V_MSG(s[0] != '0' || LOWERCASE(s[1]) != 'x', 0, "Invalid hexadecimal notation prefix in string \"" + *this + "\".");
		s += 2;
	}

	int hex = 0;

	while (*s) {
		CharType c = LOWERCASE(*s);
		int n;
		if (c >= '0' && c <= '9') {
			n = c - '0';
		} else if (c >= 'a' && c <= 'f') {
			n = (c - 'a') + 10;
		} else {
			ERR_FAIL_V_MSG(0, "Invalid hexadecimal notation character \"" + chr(*s) + "\" in string \"" + *this + "\".");
		}
		// Check for overflow/underflow, with special case to ensure INT32_MIN does not result in error
		bool overflow = ((hex > INT32_MAX / 16) && (sign == 1 || (sign == -1 && hex != (INT32_MAX >> 4) + 1))) || (sign == -1 && hex == (INT32_MAX >> 4) + 1 && c > '0');
		ERR_FAIL_COND_V_MSG(overflow, sign == 1 ? INT32_MAX : INT32_MIN, "Cannot represent " + *this + " as a 32-bit signed integer, since the value is " + (sign == 1 ? "too large." : "too small."));
		hex *= 16;
		hex += n;
		s++;
	}

	return hex * sign;
}

int64_t String::hex_to_int64(bool p_with_prefix) const {
	int len = length();
	ERR_FAIL_COND_V_MSG(p_with_prefix ? len < 3 : len == 0, 0, String("Invalid hexadecimal notation length in string ") + (p_with_prefix ? "with" : "without") + " prefix \"" + *this + "\".");

	const CharType *s = ptr();

	int64_t sign = s[0] == '-' ? -1 : 1;

	if (sign < 0) {
		s++;
	}

	if (p_with_prefix) {
		ERR_FAIL_COND_V_MSG(s[0] != '0' || LOWERCASE(s[1]) != 'x', 0, "Invalid hexadecimal notation prefix in string \"" + *this + "\".");
		s += 2;
	}

	int64_t hex = 0;

	while (*s) {
		CharType c = LOWERCASE(*s);
		int64_t n;
		if (c >= '0' && c <= '9') {
			n = c - '0';
		} else if (c >= 'a' && c <= 'f') {
			n = (c - 'a') + 10;
		} else {
			ERR_FAIL_V_MSG(0, "Invalid hexadecimal notation character \"" + chr(*s) + "\" in string \"" + *this + "\".");
		}
		bool overflow = ((hex > INT64_MAX / 16) && (sign == 1 || (sign == -1 && hex != (INT64_MAX >> 4) + 1))) || (sign == -1 && hex == (INT64_MAX >> 4) + 1 && c > '0');
		ERR_FAIL_COND_V_MSG(overflow, sign == 1 ? INT64_MAX : INT64_MIN, "Cannot represent " + *this + " as a 64-bit signed integer, since the value is " + (sign == 1 ? "too large." : "too small."));
		hex *= 16;
		hex += n;
		s++;
	}

	return hex * sign;
}

int64_t String::bin_to_int64(bool p_with_prefix) const {
	int len = length();
	ERR_FAIL_COND_V_MSG(p_with_prefix ? len < 3 : len == 0, 0, String("Invalid binary notation length in string ") + (p_with_prefix ? "with" : "without") + " prefix \"" + *this + "\".");

	const CharType *s = ptr();

	int64_t sign = s[0] == '-' ? -1 : 1;

	if (sign < 0) {
		s++;
	}

	if (p_with_prefix) {
		ERR_FAIL_COND_V_MSG(s[0] != '0' || LOWERCASE(s[1]) != 'b', 0, "Invalid binary notation prefix in string \"" + *this + "\".");
		s += 2;
	}

	int64_t binary = 0;

	while (*s) {
		CharType c = LOWERCASE(*s);
		int64_t n;
		if (c == '0' || c == '1') {
			n = c - '0';
		} else {
			ERR_FAIL_V_MSG(0, "Invalid binary notation character \"" + chr(*s) + "\" in string \"" + *this + "\".");
		}
		// Check for overflow/underflow, with special case to ensure INT64_MIN does not result in error
		bool overflow = ((binary > INT64_MAX / 2) && (sign == 1 || (sign == -1 && binary != (INT64_MAX >> 1) + 1))) || (sign == -1 && binary == (INT64_MAX >> 1) + 1 && c > '0');
		ERR_FAIL_COND_V_MSG(overflow, sign == 1 ? INT64_MAX : INT64_MIN, "Cannot represent " + *this + " as a 64-bit signed integer, since the value is " + (sign == 1 ? "too large." : "too small."));
		binary *= 2;
		binary += n;
		s++;
	}

	return binary * sign;
}

template <class C>
static double built_in_strtod(
		/* A decimal ASCII floating-point number,
		 * optionally preceded by white space. Must
		 * have form "-I.FE-X", where I is the integer
		 * part of the mantissa, F is the fractional
		 * part of the mantissa, and X is the
		 * exponent. Either of the signs may be "+",
		 * "-", or omitted. Either I or F may be
		 * omitted, or both. The decimal point isn't
		 * necessary unless F is present. The "E" may
		 * actually be an "e". E and X may both be
		 * omitted (but not just one). */
		const C *string,
		/* If non-nullptr, store terminating Cacter's
		 * address here. */
		C **endPtr = nullptr) {
	/* Largest possible base 10 exponent. Any
	 * exponent larger than this will already
	 * produce underflow or overflow, so there's
	 * no need to worry about additional digits. */
	static const int maxExponent = 511;
	/* Table giving binary powers of 10. Entry
	 * is 10^2^i. Used to convert decimal
	 * exponents into floating-point numbers. */
	static const double powersOf10[] = {
		10.,
		100.,
		1.0e4,
		1.0e8,
		1.0e16,
		1.0e32,
		1.0e64,
		1.0e128,
		1.0e256
	};

	bool sign, expSign = false;
	double fraction, dblExp;
	const double *d;
	const C *p;
	int c;
	/* Exponent read from "EX" field. */
	int exp = 0;
	/* Exponent that derives from the fractional
	 * part. Under normal circumstances, it is
	 * the negative of the number of digits in F.
	 * However, if I is very long, the last digits
	 * of I get dropped (otherwise a long I with a
	 * large negative exponent could cause an
	 * unnecessary overflow on I alone). In this
	 * case, fracExp is incremented one for each
	 * dropped digit. */
	int fracExp = 0;
	/* Number of digits in mantissa. */
	int mantSize;
	/* Number of mantissa digits BEFORE decimal point. */
	int decPt;
	/* Temporarily holds location of exponent in string. */
	const C *pExp;

	/*
	 * Strip off leading blanks and check for a sign.
	 */

	p = string;
	while (*p == ' ' || *p == '\t' || *p == '\n') {
		p += 1;
	}
	if (*p == '-') {
		sign = true;
		p += 1;
	} else {
		if (*p == '+') {
			p += 1;
		}
		sign = false;
	}

	/*
	 * Count the number of digits in the mantissa (including the decimal
	 * point), and also locate the decimal point.
	 */

	decPt = -1;
	for (mantSize = 0;; mantSize += 1) {
		c = *p;
		if (!IS_DIGIT(c)) {
			if ((c != '.') || (decPt >= 0)) {
				break;
			}
			decPt = mantSize;
		}
		p += 1;
	}

	/*
	 * Now suck up the digits in the mantissa. Use two integers to collect 9
	 * digits each (this is faster than using floating-point). If the mantissa
	 * has more than 18 digits, ignore the extras, since they can't affect the
	 * value anyway.
	 */

	pExp = p;
	p -= mantSize;
	if (decPt < 0) {
		decPt = mantSize;
	} else {
		mantSize -= 1; /* One of the digits was the point. */
	}
	if (mantSize > 18) {
		fracExp = decPt - 18;
		mantSize = 18;
	} else {
		fracExp = decPt - mantSize;
	}
	if (mantSize == 0) {
		fraction = 0.0;
		p = string;
		goto done;
	} else {
		int frac1, frac2;

		frac1 = 0;
		for (; mantSize > 9; mantSize -= 1) {
			c = *p;
			p += 1;
			if (c == '.') {
				c = *p;
				p += 1;
			}
			frac1 = 10 * frac1 + (c - '0');
		}
		frac2 = 0;
		for (; mantSize > 0; mantSize -= 1) {
			c = *p;
			p += 1;
			if (c == '.') {
				c = *p;
				p += 1;
			}
			frac2 = 10 * frac2 + (c - '0');
		}
		fraction = (1.0e9 * frac1) + frac2;
	}

	/*
	 * Skim off the exponent.
	 */

	p = pExp;
	if ((*p == 'E') || (*p == 'e')) {
		p += 1;
		if (*p == '-') {
			expSign = true;
			p += 1;
		} else {
			if (*p == '+') {
				p += 1;
			}
			expSign = false;
		}
		if (!IS_DIGIT(CharType(*p))) {
			p = pExp;
			goto done;
		}
		while (IS_DIGIT(CharType(*p))) {
			exp = exp * 10 + (*p - '0');
			p += 1;
		}
	}
	if (expSign) {
		exp = fracExp - exp;
	} else {
		exp = fracExp + exp;
	}

	/*
	 * Generate a floating-point number that represents the exponent. Do this
	 * by processing the exponent one bit at a time to combine many powers of
	 * 2 of 10. Then combine the exponent with the fraction.
	 */

	if (exp < 0) {
		expSign = true;
		exp = -exp;
	} else {
		expSign = false;
	}

	if (exp > maxExponent) {
		exp = maxExponent;
		//LOG_WARN("Exponent too high");
	}
	dblExp = 1.0;
	for (d = powersOf10; exp != 0; exp >>= 1, ++d) {
		if (exp & 01) {
			dblExp *= *d;
		}
	}
	if (expSign) {
		fraction /= dblExp;
	} else {
		fraction *= dblExp;
	}

done:
	if (endPtr != nullptr) {
		*endPtr = (C *)p;
	}

	if (sign) {
		return -fraction;
	}
	return fraction;
}

double String::to_double() const {
	if (empty()) {
		return 0;
	}

	return built_in_strtod<CharType>(get_data());
}

float String::to_float() const {
	if (empty()) {
		return 0;
	}

	return built_in_strtod<CharType>(get_data());
}

int String::to_int() const {
	if (length() == 0) {
		return 0;
	}

	int to = (find(".") >= 0) ? find(".") : length();

	int integer = 0;
	int sign = 1;

	for (int i = 0; i < to; i++) {
		CharType c = operator[](i);
		if (c >= '0' && c <= '9') {
			bool overflow = (integer > INT32_MAX / 10) || (integer == INT32_MAX / 10 && ((sign == 1 && c > '7') || (sign == -1 && c > '8')));
			ERR_FAIL_COND_V_MSG(overflow, sign == 1 ? INT32_MAX : INT32_MIN, "Cannot represent " + *this + " as a 32-bit signed integer, since the value is " + (sign == 1 ? "too large." : "too small."));
			integer *= 10;
			integer += c - '0';

		} else if (integer == 0 && c == '-') {
			sign = -sign;
		}
	}

	return integer * sign;
}

bool String::to_bool() const {
	if (length() == 0) {
		return false;
	}

	if (is_numeric()) {
		return to_int() != 0;
	}

	return to_lower() == "true";
}

uint32_t String::to_uint() const {
	if (is_numeric()) {
		return static_cast<uint32_t>(to_int());
	}

	return 0;
}

int64_t String::to_int64() const {
	if (length() == 0) {
		return 0;
	}

	int to = (find(".") >= 0) ? find(".") : length();

	int64_t integer = 0;
	int64_t sign = 1;

	for (int i = 0; i < to; i++) {
		CharType c = operator[](i);
		if (c >= '0' && c <= '9') {
			bool overflow = (integer > INT64_MAX / 10) || (integer == INT64_MAX / 10 && ((sign == 1 && c > '7') || (sign == -1 && c > '8')));
			ERR_FAIL_COND_V_MSG(overflow, sign == 1 ? INT64_MAX : INT64_MIN, "Cannot represent " + *this + " as a 64-bit signed integer, since the value is " + (sign == 1 ? "too large." : "too small."));
			integer *= 10;
			integer += c - '0';

		} else if (integer == 0 && c == '-') {
			sign = -sign;
		}
	}

	return integer * sign;
}

int64_t String::to_int(const char *p_str, int p_len) {
	int to = 0;
	if (p_len >= 0) {
		to = p_len;
	} else {
		while (p_str[to] != 0 && p_str[to] != '.') {
			to++;
		}
	}

	int64_t integer = 0;
	int64_t sign = 1;

	for (int i = 0; i < to; i++) {
		char c = p_str[i];
		if (is_digit(c)) {
			bool overflow = (integer > INT64_MAX / 10) || (integer == INT64_MAX / 10 && ((sign == 1 && c > '7') || (sign == -1 && c > '8')));
			ERR_FAIL_COND_V_MSG(overflow, sign == 1 ? INT64_MAX : INT64_MIN, "Cannot represent " + String(p_str).substr(0, to) + " as a 64-bit signed integer, since the value is " + (sign == 1 ? "too large." : "too small."));
			integer *= 10;
			integer += c - '0';

		} else if (c == '-' && integer == 0) {
			sign = -sign;
		} else if (c != ' ') {
			break;
		}
	}

	return integer * sign;
}

int64_t String::to_int(const wchar_t *p_str, int p_len) {
	int to = 0;
	if (p_len >= 0) {
		to = p_len;
	} else {
		while (p_str[to] != 0 && p_str[to] != '.') {
			to++;
		}
	}

	int64_t integer = 0;
	int64_t sign = 1;

	for (int i = 0; i < to; i++) {
		wchar_t c = p_str[i];
		if (is_digit(c)) {
			bool overflow = (integer > INT64_MAX / 10) || (integer == INT64_MAX / 10 && ((sign == 1 && c > '7') || (sign == -1 && c > '8')));
			ERR_FAIL_COND_V_MSG(overflow, sign == 1 ? INT64_MAX : INT64_MIN, "Cannot represent " + String(p_str).substr(0, to) + " as a 64-bit signed integer, since the value is " + (sign == 1 ? "too large." : "too small."));
			integer *= 10;
			integer += c - '0';

		} else if (c == '-' && integer == 0) {
			sign = -sign;
		} else if (c != ' ') {
			break;
		}
	}

	return integer * sign;
}

int64_t String::to_int(const CharType *p_str, int p_len, bool p_clamp) {
	if (p_len == 0 || !p_str[0]) {
		return 0;
	}
	///@todo make more exact so saving and loading does not lose precision

	int64_t integer = 0;
	int64_t sign = 1;
	int reading = READING_SIGN;

	const CharType *str = p_str;
	const CharType *limit = &p_str[p_len];

	while (*str && reading != READING_DONE && str != limit) {
		CharType c = *(str++);
		switch (reading) {
			case READING_SIGN: {
				if (is_digit(c)) {
					reading = READING_INT;
					// let it fallthrough
				} else if (c == '-') {
					sign = -1;
					reading = READING_INT;
					break;
				} else if (c == '+') {
					sign = 1;
					reading = READING_INT;
					break;
				} else {
					break;
				}
				FALLTHROUGH;
			}
			case READING_INT: {
				if (is_digit(c)) {
					if (integer > INT64_MAX / 10) {
						String number("");
						str = p_str;
						while (*str && str != limit) {
							number += *(str++);
						}
						if (p_clamp) {
							if (sign == 1) {
								return INT64_MAX;
							} else {
								return INT64_MIN;
							}
						} else {
							ERR_FAIL_V_MSG(sign == 1 ? INT64_MAX : INT64_MIN, "Cannot represent " + number + " as a 64-bit signed integer, since the value is " + (sign == 1 ? "too large." : "too small."));
						}
					}
					integer *= 10;
					integer += c - '0';
				} else {
					reading = READING_DONE;
				}

			} break;
		}
	}

	return sign * integer;
}

double String::to_float(const char *p_str) {
	return built_in_strtod<char>(p_str);
}

double String::to_float(const wchar_t *p_str, const wchar_t **r_end) {
	return built_in_strtod<wchar_t>(p_str, (wchar_t **)r_end);
}
double String::to_float(const CharType *p_str, const CharType **r_end) {
	return built_in_strtod<CharType>(p_str, (CharType **)r_end);
}

double String::to_double(const char *p_str) {
	return built_in_strtod<char>(p_str);
}

double String::to_double(const wchar_t *p_str, const wchar_t **r_end) {
	return built_in_strtod<wchar_t>(p_str, (wchar_t **)r_end);
}
double String::to_double(const CharType *p_str, const CharType **r_end) {
	return built_in_strtod<CharType>(p_str, (CharType **)r_end);
}

uint32_t String::num_characters(int64_t p_int) {
	int r = 1;
	if (p_int < 0) {
		r += 1;
		if (p_int == INT64_MIN) {
			p_int = INT64_MAX;
		} else {
			p_int = -p_int;
		}
	}
	while (p_int >= 10) {
		p_int /= 10;
		r++;
	}
	return r;
}

bool String::_base_is_subsequence_of(const String &p_string, bool case_insensitive) const {
	int len = length();
	if (len == 0) {
		// Technically an empty string is subsequence of any string
		return true;
	}

	if (len > p_string.length()) {
		return false;
	}

	const CharType *src = &operator[](0);
	const CharType *tgt = &p_string[0];

	for (; *src && *tgt; tgt++) {
		bool match = false;
		if (case_insensitive) {
			CharType srcc = _find_lower(*src);
			CharType tgtc = _find_lower(*tgt);
			match = srcc == tgtc;
		} else {
			match = *src == *tgt;
		}
		if (match) {
			src++;
			if (!*src) {
				return true;
			}
		}
	}

	return false;
}

bool operator==(const char *p_chr, const String &p_str) {
	return p_str == p_chr;
}

bool operator==(const wchar_t *p_chr, const String &p_str) {
#ifdef WINDOWS_ENABLED
	// wchar_t is 16-bit
	return p_str == String::utf16((const char16_t *)p_chr);
#else
	// wchar_t is 32-bi
	return p_str == String((const CharType *)p_chr);
#endif
}

bool operator!=(const char *p_chr, const String &p_str) {
	return !(p_str == p_chr);
}

bool operator!=(const wchar_t *p_chr, const String &p_str) {
#ifdef WINDOWS_ENABLED
	// wchar_t is 16-bit
	return !(p_str == String::utf16((const char16_t *)p_chr));
#else
	// wchar_t is 32-bi
	return !(p_str == String((const CharType *)p_chr));
#endif
}

String operator+(const char *p_chr, const String &p_str) {
	String tmp = p_chr;
	tmp += p_str;
	return tmp;
}

String operator+(const wchar_t *p_chr, const String &p_str) {
#ifdef WINDOWS_ENABLED
	// wchar_t is 16-bit
	String tmp = String::utf16((const char16_t *)p_chr);
#else
	// wchar_t is 32-bit
	String tmp = (const CharType *)p_chr;
#endif
	tmp += p_str;
	return tmp;
}

String operator+(CharType p_chr, const String &p_str) {
	return (String::chr(p_chr) + p_str);
}

String itos(int64_t p_val) {
	return String::num_int64(p_val);
}

String uitos(uint64_t p_val) {
	return String::num_uint64(p_val);
}

String rtos(double p_val) {
	return String::num(p_val);
}

String rtoss(double p_val) {
	return String::num_scientific(p_val);
}

#ifdef TOOLS_ENABLED
String TTR(const String &p_text, const String &p_context) {
	return p_text;
}

/* DTR is used for the documentation, handling descriptions extracted from the XML.
 * It also replaces `$DOCS_URL` with the actual URL to the documentation's branch,
 * to allow dehardcoding it in the XML and doing proper substitutions everywhere.
 */
String DTR(const String &p_text) {
	// Comes straight from the XML, so remove indentation and any trailing whitespace.
	const String text = p_text.dedent().strip_edges();

	return text.replace("$DOCS_URL", VERSION_DOCS_URL);
}
#endif

String RTR(const String &p_text) {
	return p_text;
}
#line 0

#line 1 "sfw/core/logger.cpp"

void RLogger::print_trace(const String &str) {
	print_trace(str.utf8().get_data());
}
void RLogger::print_trace(const char *str) {
	printf("T %s\n", str);
}
void RLogger::print_trace(const char *p_function, const char *p_file, int p_line, const char *str) {
	printf("T | %s::%s:%d | %s\n", p_file, p_function, p_line, str);
}
void RLogger::print_trace(const char *p_function, const char *p_file, int p_line, const String &str) {
	printf("T | %s::%s:%d | %s\n", p_file, p_function, p_line, str.utf8().get_data());
}

void RLogger::print_message(const String &str) {
	print_message(str.utf8().get_data());
}
void RLogger::print_message(const char *str) {
	printf("M %s\n", str);
}
void RLogger::print_message(const char *p_function, const char *p_file, int p_line, const char *str) {
	printf("M | %s::%s:%d | %s\n", p_file, p_function, p_line, str);
}
void RLogger::print_message(const char *p_function, const char *p_file, int p_line, const String &str) {
	printf("M | %s::%s:%d | %s\n", p_file, p_function, p_line, str.utf8().get_data());
}

void RLogger::print_warning(const String &str) {
	print_warning(str.utf8().get_data());
}
void RLogger::print_warning(const char *str) {
	printf("W %s\n", str);
}
void RLogger::print_warning(const char *p_function, const char *p_file, int p_line, const char *str) {
	printf("W | %s::%s:%d | %s\n", p_file, p_function, p_line, str);
}
void RLogger::print_warning(const char *p_function, const char *p_file, int p_line, const String &str) {
	printf("W | %s::%s:%d | %s\n", p_file, p_function, p_line, str.utf8().get_data());
}

void RLogger::print_error(const String &str) {
	print_error(str.utf8().get_data());
}
void RLogger::print_error(const char *str) {
	printf("E %s\n", str);
}

void RLogger::print_error(const char *p_function, const char *p_file, int p_line, const char *str) {
	printf("E | %s::%s:%d | %s\n", p_file, p_function, p_line, str);
}
void RLogger::print_error(const char *p_function, const char *p_file, int p_line, const String &str) {
	printf("E | %s::%s:%d | %s\n", p_file, p_function, p_line, str.utf8().get_data());
}
void RLogger::print_msg_error(const char *p_function, const char *p_file, int p_line, const char *p_msg, const char *str) {
	printf("E | %s::%s:%d | :: %s. %s\n", p_file, p_function, p_line, str, p_msg);
}
void RLogger::print_index_error(const char *p_function, const char *p_file, int p_line, const int index, const int size, const char *str) {
	printf("E (INDEX) | %s::%s:%d | :: index: %d/%d. %s\n", p_file, p_function, p_line, index, size, str);
}

void RLogger::log_trace(const String &str) {
	log_trace(str.utf8().get_data());
}
void RLogger::log_trace(const char *str) {
	printf("T %s\n", str);
}
void RLogger::log_trace(const char *p_function, const char *p_file, int p_line, const char *str) {
	printf("T | %s::%s:%d | %s\n", p_file, p_function, p_line, str);
}
void RLogger::log_trace(const char *p_function, const char *p_file, int p_line, const String &str) {
	printf("T | %s::%s:%d | %s\n", p_file, p_function, p_line, str.utf8().get_data());
}

void RLogger::log_message(const String &str) {
	log_message(str.utf8().get_data());
}
void RLogger::log_message(const char *str) {
	printf("M %s\n", str);
}
void RLogger::log_message(const char *p_function, const char *p_file, int p_line, const char *str) {
	printf("M | %s::%s:%d | %s\n", p_file, p_function, p_line, str);
}
void RLogger::log_message(const char *p_function, const char *p_file, int p_line, const String &str) {
	printf("M | %s::%s:%d | %s\n", p_file, p_function, p_line, str.utf8().get_data());
}

void RLogger::log_warning(const String &str) {
	log_warning(str.utf8().get_data());
}
void RLogger::log_warning(const char *str) {
	printf("W %s\n", str);
}
void RLogger::log_warning(const char *p_function, const char *p_file, int p_line, const char *str) {
	printf("W | %s::%s:%d | %s\n", p_file, p_function, p_line, str);
}
void RLogger::log_warning(const char *p_function, const char *p_file, int p_line, const String &str) {
	printf("W | %s::%s:%d | %s\n", p_file, p_function, p_line, str.utf8().get_data());
}

void RLogger::log_error(const String &str) {
	log_error(str.utf8().get_data());
}
void RLogger::log_error(const char *str) {
	printf("E %s\n", str);
}

void RLogger::log_error(const char *p_function, const char *p_file, int p_line, const char *str) {
	printf("E | %s::%s:%d | %s\n", p_file, p_function, p_line, str);
}
void RLogger::log_error(const char *p_function, const char *p_file, int p_line, const String &str) {
	printf("E | %s::%s:%d | %s\n", p_file, p_function, p_line, str.utf8().get_data());
}
void RLogger::log_msg_error(const char *p_function, const char *p_file, int p_line, const char *p_msg, const char *str) {
	printf("E | %s::%s:%d | :: %s. %s\n", p_file, p_function, p_line, str, p_msg);
}
void RLogger::log_index_error(const char *p_function, const char *p_file, int p_line, const int index, const int size, const char *str) {
	printf("E (INDEX) | %s::%s:%d | :: index: %d/%d. %s\n", p_file, p_function, p_line, index, size, str);
}
void RLogger::log_index_error(const char *p_function, const char *p_file, int p_line, const int index, const int size, const String &str) {
	printf("E (INDEX) | %s::%s:%d | :: index: %d/%d. %s\n", p_file, p_function, p_line, index, size, str.utf8().get_data());
}

String *RLogger::get_string_ptr(const int p_default_size) {
	return memnew(String());
}
String *RLogger::get_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size) {
	String *s = memnew(String());

	s->operator+=(p_function);
	s->operator+=("::");
	s->operator+=(p_file);
	s->operator+=(":");
	s->operator+=(String::num(p_line));
	s->operator+=(" | ");

	return s;
}
String *RLogger::get_string_ptr(const char *p_prefix, const char *p_function, const char *p_file, int p_line, const int p_default_size) {
	String *s = memnew(String());

	s->operator+=(p_prefix);
	s->operator+=(" | ");
	s->operator+=(p_function);
	s->operator+=("::");
	s->operator+=(p_file);
	s->operator+=(":");
	s->operator+=(String::num(p_line));
	s->operator+=(" | ");

	return s;
}
void RLogger::return_string_ptr(String *str) {
	memdelete(str);
}

String *RLogger::get_trace_string_ptr(const int p_default_size) {
	String *str = get_string_ptr(p_default_size);
	str->operator+=("T ");
	return str;
}
String *RLogger::get_message_string_ptr(const int p_default_size) {
	String *str = get_string_ptr(p_default_size);
	str->operator+=("M ");
	return str;
}
String *RLogger::get_warning_string_ptr(const int p_default_size) {
	String *str = get_string_ptr(p_default_size);
	str->operator+=("W ");
	return str;
}
String *RLogger::get_error_string_ptr(const int p_default_size) {
	String *str = get_string_ptr(p_default_size);
	str->operator+=("E ");
	return str;
}

String *RLogger::get_trace_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size) {
	return get_string_ptr("T", p_function, p_file, p_line, p_default_size);
}
String *RLogger::get_message_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size) {
	return get_string_ptr("M", p_function, p_file, p_line, p_default_size);
}
String *RLogger::get_warning_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size) {
	return get_string_ptr("W", p_function, p_file, p_line, p_default_size);
}
String *RLogger::get_error_string_ptr(const char *p_function, const char *p_file, int p_line, const int p_default_size) {
	return get_string_ptr("E", p_function, p_file, p_line, p_default_size);
}

void RLogger::log_ptr(String *str) {
	printf("%s\n", str->utf8().get_data());
}

void RLogger::log_ret_ptr(String *str) {
	log_ptr(str);

	return_string_ptr(str);
}
#line 0

#line 1 "sfw/core/string_name.cpp"
/*************************************************************************/
/*  string_name.cpp                                                      */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

StaticCString StaticCString::create(const char *p_ptr) {
	StaticCString scs;
	scs.ptr = p_ptr;
	return scs;
}

StringName::_Data *StringName::_table[STRING_TABLE_LEN];

StringName _scs_create(const char *p_chr, bool p_static) {
	return (p_chr[0] ? StringName(StaticCString::create(p_chr), p_static) : StringName());
}

bool StringName::configured = false;
Mutex StringName::lock;

#ifdef DEBUG_ENABLED
bool StringName::debug_stringname = false;
#endif

void StringName::setup() {
	ERR_FAIL_COND(configured);
	for (int i = 0; i < STRING_TABLE_LEN; i++) {
		_table[i] = nullptr;
	}
	configured = true;
}

void StringName::cleanup() {
	lock.lock();

#ifdef DEBUG_ENABLED
	if (unlikely(debug_stringname)) {
		Vector<_Data *> data;
		for (int i = 0; i < STRING_TABLE_LEN; i++) {
			_Data *d = _table[i];
			while (d) {
				data.push_back(d);
				d = d->next;
			}
		}

		LOG_MSG("\nStringName reference ranking (from most to least referenced):\n");

		data.sort_custom<DebugSortReferences>();
		int unreferenced_stringnames = 0;
		int rarely_referenced_stringnames = 0;
		for (int i = 0; i < data.size(); i++) {
			LOG_MSG(itos(i + 1) + ": " + data[i]->get_name() + " - " + itos(data[i]->debug_references));
			if (data[i]->debug_references == 0) {
				unreferenced_stringnames += 1;
			} else if (data[i]->debug_references < 5) {
				rarely_referenced_stringnames += 1;
			}
		}

		LOG_MSG(vformat("\nOut of %d StringNames, %d StringNames were never referenced during this run (0 times) (%.2f%%).", data.size(), unreferenced_stringnames, unreferenced_stringnames / float(data.size()) * 100));
		LOG_MSG(vformat("Out of %d StringNames, %d StringNames were rarely referenced during this run (1-4 times) (%.2f%%).", data.size(), rarely_referenced_stringnames, rarely_referenced_stringnames / float(data.size()) * 100));
	}
#endif

	//int lost_strings = 0;
	for (int i = 0; i < STRING_TABLE_LEN; i++) {
		while (_table[i]) {
			_Data *d = _table[i];

			/*
			if (d->static_count.get() != d->refcount.get()) {
				lost_strings++;
				if (OS::get_singleton()->is_stdout_verbose()) {
					if (d->cname) {
						LOG_MSG("Orphan StringName: " + String(d->cname));
					} else {
						LOG_MSG("Orphan StringName: " + String(d->name));
					}
				}
			}
			*/

			_table[i] = _table[i]->next;
			memdelete(d);
		}
	}

	/*
	if (lost_strings) {
		print_verbose("StringName: " + itos(lost_strings) + " unclaimed string names at exit.");
	}
	*/

	configured = false;

	lock.unlock();
}

void StringName::unref() {
	ERR_FAIL_COND(!configured);

	if (_data && _data->refcount.unref()) {
		lock.lock();

		if (_data->static_count.get() > 0) {
			if (_data->cname) {
				ERR_PRINT("BUG: Unreferenced static string to 0: " + String(_data->cname));
			} else {
				ERR_PRINT("BUG: Unreferenced static string to 0: " + String(_data->name));
			}
		}

		if (_data->prev) {
			_data->prev->next = _data->next;
		} else {
			if (_table[_data->idx] != _data) {
				ERR_PRINT("BUG!");
			}

			_table[_data->idx] = _data->next;
		}

		if (_data->next) {
			_data->next->prev = _data->prev;
		}

		memdelete(_data);
		lock.unlock();
	}

	_data = nullptr;
}

bool StringName::operator==(const String &p_name) const {
	if (!_data) {
		return (p_name.length() == 0);
	}

	return (_data->get_name() == p_name);
}

bool StringName::operator==(const char *p_name) const {
	if (!_data) {
		return (p_name[0] == 0);
	}

	return (_data->get_name() == p_name);
}

bool StringName::operator!=(const String &p_name) const {
	return !(operator==(p_name));
}

bool StringName::operator!=(const StringName &p_name) const {
	// the real magic of all this mess happens here.
	// this is why path comparisons are very fast
	return _data != p_name._data;
}

void StringName::operator=(const StringName &p_name) {
	if (this == &p_name) {
		return;
	}

	unref();

	if (p_name._data && p_name._data->refcount.ref()) {
		_data = p_name._data;
	}
}

StringName::StringName(const StringName &p_name) {
	_data = nullptr;

	ERR_FAIL_COND(!configured);

	if (p_name._data && p_name._data->refcount.ref()) {
		_data = p_name._data;
	}
}

StringName::StringName(const char *p_name, bool p_static) {
	_data = nullptr;

	ERR_FAIL_COND(!configured);

	if (!p_name || p_name[0] == 0) {
		return; //empty, ignore
	}

	lock.lock();

	uint32_t hash = String::hash(p_name);

	uint32_t idx = hash & STRING_TABLE_MASK;

	_data = _table[idx];

	while (_data) {
		// compare hash first
		if (_data->hash == hash && _data->get_name() == p_name) {
			break;
		}
		_data = _data->next;
	}

	if (_data) {
		if (_data->refcount.ref()) {
			// exists
			if (p_static) {
				_data->static_count.increment();
			}

#ifdef DEBUG_ENABLED
			if (unlikely(debug_stringname)) {
				_data->debug_references++;
			}
#endif

			lock.unlock();
			return;
		}
	}

	_data = memnew(_Data);
	_data->name = p_name;
	_data->refcount.init();
	_data->static_count.set(p_static ? 1 : 0);
	_data->hash = hash;
	_data->idx = idx;
	_data->cname = NULL;
	_data->next = _table[idx];
	_data->prev = NULL;

#ifdef DEBUG_ENABLED
	if (unlikely(debug_stringname)) {
		// Keep in memory, force static.
		_data->refcount.ref();
		_data->static_count.increment();
	}
#endif

	if (_table[idx]) {
		_table[idx]->prev = _data;
	}

	_table[idx] = _data;

	lock.unlock();
}

StringName::StringName(const StaticCString &p_static_string, bool p_static) {
	_data = NULL;

	ERR_FAIL_COND(!configured);

	ERR_FAIL_COND(!p_static_string.ptr || !p_static_string.ptr[0]);

	lock.lock();

	uint32_t hash = String::hash(p_static_string.ptr);

	uint32_t idx = hash & STRING_TABLE_MASK;

	_data = _table[idx];

	while (_data) {
		// compare hash first
		if (_data->hash == hash && _data->get_name() == p_static_string.ptr) {
			break;
		}
		_data = _data->next;
	}

	if (_data) {
		if (_data->refcount.ref()) {
			// exists
			if (p_static) {
				_data->static_count.increment();
			}

#ifdef DEBUG_ENABLED
			if (unlikely(debug_stringname)) {
				_data->debug_references++;
			}
#endif

			lock.unlock();
			return;
		}
	}

	_data = memnew(_Data);

	_data->refcount.init();
	_data->static_count.set(p_static ? 1 : 0);
	_data->hash = hash;
	_data->idx = idx;
	_data->cname = p_static_string.ptr;
	_data->next = _table[idx];
	_data->prev = NULL;

#ifdef DEBUG_ENABLED
	if (unlikely(debug_stringname)) {
		// Keep in memory, force static.
		_data->refcount.ref();
		_data->static_count.increment();
	}
#endif

	if (_table[idx]) {
		_table[idx]->prev = _data;
	}

	_table[idx] = _data;

	lock.unlock();
}

StringName::StringName(const String &p_name, bool p_static) {
	_data = nullptr;

	ERR_FAIL_COND(!configured);

	if (p_name.empty()) {
		return;
	}

	lock.lock();

	uint32_t hash = p_name.hash();

	uint32_t idx = hash & STRING_TABLE_MASK;

	_data = _table[idx];

	while (_data) {
		if (_data->hash == hash && _data->get_name() == p_name) {
			break;
		}

		_data = _data->next;
	}

	if (_data) {
		if (_data->refcount.ref()) {
			// exists
			if (p_static) {
				_data->static_count.increment();
			}

#ifdef DEBUG_ENABLED
			if (unlikely(debug_stringname)) {
				_data->debug_references++;
			}
#endif

			lock.unlock();
			return;
		}
	}

	_data = memnew(_Data);
	_data->name = p_name;
	_data->refcount.init();
	_data->static_count.set(p_static ? 1 : 0);
	_data->hash = hash;
	_data->idx = idx;
	_data->cname = NULL;
	_data->next = _table[idx];
	_data->prev = NULL;

#ifdef DEBUG_ENABLED
	if (unlikely(debug_stringname)) {
		// Keep in memory, force static.
		_data->refcount.ref();
		_data->static_count.increment();
	}
#endif

	if (_table[idx]) {
		_table[idx]->prev = _data;
	}

	_table[idx] = _data;

	lock.unlock();
}

StringName StringName::search(const char *p_name) {
	ERR_FAIL_COND_V(!configured, StringName());

	ERR_FAIL_COND_V(!p_name, StringName());
	if (!p_name[0]) {
		return StringName();
	}

	lock.lock();

	uint32_t hash = String::hash(p_name);

	uint32_t idx = hash & STRING_TABLE_MASK;

	_Data *_data = _table[idx];

	while (_data) {
		// compare hash first
		if (_data->hash == hash && _data->get_name() == p_name) {
			break;
		}
		_data = _data->next;
	}

	if (_data && _data->refcount.ref()) {
#ifdef DEBUG_ENABLED
		if (unlikely(debug_stringname)) {
			_data->debug_references++;
		}
#endif

		lock.unlock();

		return StringName(_data);
	}

	lock.unlock();
	return StringName(); //does not exist
}

StringName StringName::search(const CharType *p_name) {
	ERR_FAIL_COND_V(!configured, StringName());

	ERR_FAIL_COND_V(!p_name, StringName());
	if (!p_name[0]) {
		return StringName();
	}

	lock.lock();

	uint32_t hash = String::hash(p_name);

	uint32_t idx = hash & STRING_TABLE_MASK;

	_Data *_data = _table[idx];

	while (_data) {
		// compare hash first
		if (_data->hash == hash && _data->get_name() == p_name) {
			break;
		}

		_data = _data->next;
	}

	if (_data && _data->refcount.ref()) {
		lock.unlock();
		return StringName(_data);
	}

	lock.unlock();
	return StringName(); //does not exist
}
StringName StringName::search(const String &p_name) {
	ERR_FAIL_COND_V(p_name == "", StringName());

	lock.lock();

	uint32_t hash = p_name.hash();

	uint32_t idx = hash & STRING_TABLE_MASK;

	_Data *_data = _table[idx];

	while (_data) {
		// compare hash first
		if (_data->hash == hash && p_name == _data->get_name()) {
			break;
		}

		_data = _data->next;
	}

	if (_data && _data->refcount.ref()) {
#ifdef DEBUG_ENABLED
		if (unlikely(debug_stringname)) {
			_data->debug_references++;
		}
#endif
		lock.unlock();
		return StringName(_data);
	}

	lock.unlock();
	return StringName(); //does not exist
}

StringName::StringName() {
	_data = nullptr;
}

/*
bool operator==(const String &p_name, const StringName &p_string_name) {
	return p_name == p_string_name.operator String();
}
bool operator!=(const String &p_name, const StringName &p_string_name) {
	return p_name != p_string_name.operator String();
}

bool operator==(const char *p_name, const StringName &p_string_name) {
	return p_name == p_string_name.operator String();
}
bool operator!=(const char *p_name, const StringName &p_string_name) {
	return p_name != p_string_name.operator String();
}
*/
#line 0

#line 1 "sfw/core/aabb.cpp"
/*************************************************************************/
/*  aabb.cpp                                                             */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

real_t AABB::get_volume() const {
	return size.x * size.y * size.z;
}

bool AABB::operator==(const AABB &p_rval) const {
	return ((position == p_rval.position) && (size == p_rval.size));
}
bool AABB::operator!=(const AABB &p_rval) const {
	return ((position != p_rval.position) || (size != p_rval.size));
}

bool AABB::create_from_points(const Vector<Vector3> &p_points) {
	if (!p_points.size()) {
		return false;
	}

	Vector3 begin = p_points[0];
	Vector3 end = begin;

	for (int n = 1; n < p_points.size(); n++) {
		const Vector3 &pt = p_points[n];

		if (pt.x < begin.x) {
			begin.x = pt.x;
		}
		if (pt.y < begin.y) {
			begin.y = pt.y;
		}
		if (pt.z < begin.z) {
			begin.z = pt.z;
		}

		if (pt.x > end.x) {
			end.x = pt.x;
		}
		if (pt.y > end.y) {
			end.y = pt.y;
		}
		if (pt.z > end.z) {
			end.z = pt.z;
		}
	}

	position = begin;
	size = end - begin;

	return true;
}

void AABB::merge_with(const AABB &p_aabb) {
	Vector3 beg_1, beg_2;
	Vector3 end_1, end_2;
	Vector3 min, max;

	beg_1 = position;
	beg_2 = p_aabb.position;
	end_1 = Vector3(size.x, size.y, size.z) + beg_1;
	end_2 = Vector3(p_aabb.size.x, p_aabb.size.y, p_aabb.size.z) + beg_2;

	min.x = (beg_1.x < beg_2.x) ? beg_1.x : beg_2.x;
	min.y = (beg_1.y < beg_2.y) ? beg_1.y : beg_2.y;
	min.z = (beg_1.z < beg_2.z) ? beg_1.z : beg_2.z;

	max.x = (end_1.x > end_2.x) ? end_1.x : end_2.x;
	max.y = (end_1.y > end_2.y) ? end_1.y : end_2.y;
	max.z = (end_1.z > end_2.z) ? end_1.z : end_2.z;

	position = min;
	size = max - min;
}

bool AABB::is_equal_approx(const AABB &p_aabb) const {
	return position.is_equal_approx(p_aabb.position) && size.is_equal_approx(p_aabb.size);
}

AABB AABB::intersection(const AABB &p_aabb) const {
	Vector3 src_min = position;
	Vector3 src_max = position + size;
	Vector3 dst_min = p_aabb.position;
	Vector3 dst_max = p_aabb.position + p_aabb.size;

	Vector3 min, max;

	if (src_min.x > dst_max.x || src_max.x < dst_min.x) {
		return AABB();
	} else {
		min.x = (src_min.x > dst_min.x) ? src_min.x : dst_min.x;
		max.x = (src_max.x < dst_max.x) ? src_max.x : dst_max.x;
	}

	if (src_min.y > dst_max.y || src_max.y < dst_min.y) {
		return AABB();
	} else {
		min.y = (src_min.y > dst_min.y) ? src_min.y : dst_min.y;
		max.y = (src_max.y < dst_max.y) ? src_max.y : dst_max.y;
	}

	if (src_min.z > dst_max.z || src_max.z < dst_min.z) {
		return AABB();
	} else {
		min.z = (src_min.z > dst_min.z) ? src_min.z : dst_min.z;
		max.z = (src_max.z < dst_max.z) ? src_max.z : dst_max.z;
	}

	return AABB(min, max - min);
}

bool AABB::intersects_ray(const Vector3 &p_from, const Vector3 &p_dir, Vector3 *r_clip, Vector3 *r_normal) const {
	Vector3 c1, c2;
	Vector3 end = position + size;
	//<windows.h> has a far and near macro defined, and we can't undo it here in the amalgamation
	real_t aabb_near = -1e20;
	real_t aabb_far = 1e20;
	int axis = 0;

	for (int i = 0; i < 3; i++) {
		if (p_dir[i] == 0) {
			if ((p_from[i] < position[i]) || (p_from[i] > end[i])) {
				return false;
			}
		} else { // ray not parallel to planes in this direction
			c1[i] = (position[i] - p_from[i]) / p_dir[i];
			c2[i] = (end[i] - p_from[i]) / p_dir[i];

			if (c1[i] > c2[i]) {
				SWAP(c1, c2);
			}
			if (c1[i] > aabb_near) {
				aabb_near = c1[i];
				axis = i;
			}
			if (c2[i] < aabb_far) {
				aabb_far = c2[i];
			}
			if ((aabb_near > aabb_far) || (aabb_far < 0)) {
				return false;
			}
		}
	}

	if (r_clip) {
		*r_clip = c1;
	}
	if (r_normal) {
		*r_normal = Vector3();
		(*r_normal)[axis] = p_dir[axis] ? -1 : 1;
	}

	return true;
}

bool AABB::intersects_segment(const Vector3 &p_from, const Vector3 &p_to, Vector3 *r_clip, Vector3 *r_normal) const {
	real_t min = 0, max = 1;
	int axis = 0;
	real_t sign = 0;

	for (int i = 0; i < 3; i++) {
		real_t seg_from = p_from[i];
		real_t seg_to = p_to[i];
		real_t box_begin = position[i];
		real_t box_end = box_begin + size[i];
		real_t cmin, cmax;
		real_t csign;

		if (seg_from < seg_to) {
			if (seg_from > box_end || seg_to < box_begin) {
				return false;
			}
			real_t length = seg_to - seg_from;
			cmin = (seg_from < box_begin) ? ((box_begin - seg_from) / length) : 0;
			cmax = (seg_to > box_end) ? ((box_end - seg_from) / length) : 1;
			csign = -1.0;

		} else {
			if (seg_to > box_end || seg_from < box_begin) {
				return false;
			}
			real_t length = seg_to - seg_from;
			cmin = (seg_from > box_end) ? (box_end - seg_from) / length : 0;
			cmax = (seg_to < box_begin) ? (box_begin - seg_from) / length : 1;
			csign = 1.0;
		}

		if (cmin > min) {
			min = cmin;
			axis = i;
			sign = csign;
		}
		if (cmax < max) {
			max = cmax;
		}
		if (max < min) {
			return false;
		}
	}

	Vector3 rel = p_to - p_from;

	if (r_normal) {
		Vector3 normal;
		normal[axis] = sign;
		*r_normal = normal;
	}

	if (r_clip) {
		*r_clip = p_from + rel * min;
	}

	return true;
}

bool AABB::intersects_plane(const Plane &p_plane) const {
	Vector3 points[8] = {
		Vector3(position.x, position.y, position.z),
		Vector3(position.x, position.y, position.z + size.z),
		Vector3(position.x, position.y + size.y, position.z),
		Vector3(position.x, position.y + size.y, position.z + size.z),
		Vector3(position.x + size.x, position.y, position.z),
		Vector3(position.x + size.x, position.y, position.z + size.z),
		Vector3(position.x + size.x, position.y + size.y, position.z),
		Vector3(position.x + size.x, position.y + size.y, position.z + size.z),
	};

	bool over = false;
	bool under = false;

	for (int i = 0; i < 8; i++) {
		if (p_plane.distance_to(points[i]) > 0) {
			over = true;
		} else {
			under = true;
		}
	}

	return under && over;
}

Vector3 AABB::get_longest_axis() const {
	Vector3 axis(1, 0, 0);
	real_t max_size = size.x;

	if (size.y > max_size) {
		axis = Vector3(0, 1, 0);
		max_size = size.y;
	}

	if (size.z > max_size) {
		axis = Vector3(0, 0, 1);
	}

	return axis;
}
int AABB::get_longest_axis_index() const {
	int axis = 0;
	real_t max_size = size.x;

	if (size.y > max_size) {
		axis = 1;
		max_size = size.y;
	}

	if (size.z > max_size) {
		axis = 2;
	}

	return axis;
}

Vector3 AABB::get_shortest_axis() const {
	Vector3 axis(1, 0, 0);
	real_t max_size = size.x;

	if (size.y < max_size) {
		axis = Vector3(0, 1, 0);
		max_size = size.y;
	}

	if (size.z < max_size) {
		axis = Vector3(0, 0, 1);
	}

	return axis;
}
int AABB::get_shortest_axis_index() const {
	int axis = 0;
	real_t max_size = size.x;

	if (size.y < max_size) {
		axis = 1;
		max_size = size.y;
	}

	if (size.z < max_size) {
		axis = 2;
	}

	return axis;
}

AABB AABB::merge(const AABB &p_with) const {
	AABB aabb = *this;
	aabb.merge_with(p_with);
	return aabb;
}
AABB AABB::expand(const Vector3 &p_vector) const {
	AABB aabb = *this;
	aabb.expand_to(p_vector);
	return aabb;
}
AABB AABB::grow(real_t p_by) const {
	AABB aabb = *this;
	aabb.grow_by(p_by);
	return aabb;
}

void AABB::get_edge(int p_edge, Vector3 &r_from, Vector3 &r_to) const {
	ERR_FAIL_INDEX(p_edge, 12);
	switch (p_edge) {
		case 0: {
			r_from = Vector3(position.x + size.x, position.y, position.z);
			r_to = Vector3(position.x, position.y, position.z);
		} break;
		case 1: {
			r_from = Vector3(position.x + size.x, position.y, position.z + size.z);
			r_to = Vector3(position.x + size.x, position.y, position.z);
		} break;
		case 2: {
			r_from = Vector3(position.x, position.y, position.z + size.z);
			r_to = Vector3(position.x + size.x, position.y, position.z + size.z);

		} break;
		case 3: {
			r_from = Vector3(position.x, position.y, position.z);
			r_to = Vector3(position.x, position.y, position.z + size.z);

		} break;
		case 4: {
			r_from = Vector3(position.x, position.y + size.y, position.z);
			r_to = Vector3(position.x + size.x, position.y + size.y, position.z);
		} break;
		case 5: {
			r_from = Vector3(position.x + size.x, position.y + size.y, position.z);
			r_to = Vector3(position.x + size.x, position.y + size.y, position.z + size.z);
		} break;
		case 6: {
			r_from = Vector3(position.x + size.x, position.y + size.y, position.z + size.z);
			r_to = Vector3(position.x, position.y + size.y, position.z + size.z);

		} break;
		case 7: {
			r_from = Vector3(position.x, position.y + size.y, position.z + size.z);
			r_to = Vector3(position.x, position.y + size.y, position.z);

		} break;
		case 8: {
			r_from = Vector3(position.x, position.y, position.z + size.z);
			r_to = Vector3(position.x, position.y + size.y, position.z + size.z);

		} break;
		case 9: {
			r_from = Vector3(position.x, position.y, position.z);
			r_to = Vector3(position.x, position.y + size.y, position.z);

		} break;
		case 10: {
			r_from = Vector3(position.x + size.x, position.y, position.z);
			r_to = Vector3(position.x + size.x, position.y + size.y, position.z);

		} break;
		case 11: {
			r_from = Vector3(position.x + size.x, position.y, position.z + size.z);
			r_to = Vector3(position.x + size.x, position.y + size.y, position.z + size.z);

		} break;
	}
}

/*
Variant AABB::intersects_segmentv(const Vector3 &p_from, const Vector3 &p_to) const {
	Vector3 inters;
	if (intersects_segment(p_from, p_to, &inters)) {
		return inters;
	}
	return Variant();
}

Variant AABB::intersects_rayv(const Vector3 &p_from, const Vector3 &p_dir) const {
	Vector3 inters;
	if (intersects_ray(p_from, p_dir, &inters)) {
		return inters;
	}
	return Variant();
}
*/

AABB::operator String() const {
	return "[P: " + position.operator String() + ", S: " + size + "]";
}
#line 0

#line 1 "sfw/core/vector3i.cpp"
/*************************************************************************/
/*  vector3i.cpp                                                         */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void Vector3i::set_axis(const int p_axis, const int32_t p_value) {
	ERR_FAIL_INDEX(p_axis, 3);
	coord[p_axis] = p_value;
}

int32_t Vector3i::get_axis(const int p_axis) const {
	ERR_FAIL_INDEX_V(p_axis, 3, 0);
	return operator[](p_axis);
}

Vector3i::Axis Vector3i::min_axis() const {
	return x < y ? (x < z ? Vector3i::AXIS_X : Vector3i::AXIS_Z) : (y < z ? Vector3i::AXIS_Y : Vector3i::AXIS_Z);
}

Vector3i::Axis Vector3i::max_axis() const {
	return x < y ? (y < z ? Vector3i::AXIS_Z : Vector3i::AXIS_Y) : (x < z ? Vector3i::AXIS_Z : Vector3i::AXIS_X);
}

Vector3i Vector3i::clamp(const Vector3i &p_min, const Vector3i &p_max) const {
	return Vector3i(
			CLAMP(x, p_min.x, p_max.x),
			CLAMP(y, p_min.y, p_max.y),
			CLAMP(z, p_min.z, p_max.z));
}

Vector3 Vector3i::to_vector3() const {
	return Vector3(x, y, z);
}

Vector3i::operator String() const {
	return "(" + itos(x) + ", " + itos(y) + ", " + itos(z) + ")";
}

Vector3i::operator Vector3() const {
	return Vector3(x, y, z);
}
#line 0

#line 1 "sfw/core/transform_2d.cpp"
/*************************************************************************/
/*  transform_2d.cpp                                                     */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void Transform2D::invert() {
	// FIXME: this function assumes the basis is a rotation matrix, with no scaling.
	// Transform2D::affine_inverse can handle matrices with scaling, so GDScript should eventually use that.
	SWAP(columns[0][1], columns[1][0]);
	columns[2] = basis_xform(-columns[2]);
}

Transform2D Transform2D::inverse() const {
	Transform2D inv = *this;
	inv.invert();
	return inv;
}

void Transform2D::affine_invert() {
	real_t det = basis_determinant();
#ifdef MATH_CHECKS
	ERR_FAIL_COND(det == 0);
#endif
	real_t idet = 1 / det;

	SWAP(columns[0][0], columns[1][1]);
	columns[0] *= Vector2(idet, -idet);
	columns[1] *= Vector2(-idet, idet);

	columns[2] = basis_xform(-columns[2]);
}

Transform2D Transform2D::affine_inverse() const {
	Transform2D inv = *this;
	inv.affine_invert();
	return inv;
}

void Transform2D::rotate(real_t p_phi) {
	*this = Transform2D(p_phi, Vector2()) * (*this);
}

real_t Transform2D::get_rotation() const {
	return Math::atan2(columns[0].y, columns[0].x);
}

void Transform2D::set_rotation(real_t p_rot) {
	Size2 scale = get_scale();
	real_t cr = Math::cos(p_rot);
	real_t sr = Math::sin(p_rot);
	columns[0][0] = cr;
	columns[0][1] = sr;
	columns[1][0] = -sr;
	columns[1][1] = cr;
	set_scale(scale);
}

real_t Transform2D::get_skew() const {
	real_t det = basis_determinant();
	return Math::acos(columns[0].normalized().dot(SGN(det) * columns[1].normalized())) - (real_t)Math_PI * 0.5f;
}

void Transform2D::set_skew(const real_t p_angle) {
	real_t det = basis_determinant();
	columns[1] = SGN(det) * columns[0].rotated(((real_t)Math_PI * 0.5f + p_angle)).normalized() * columns[1].length();
}

Transform2D::Transform2D(real_t p_rot, const Vector2 &p_pos) {
	real_t cr = Math::cos(p_rot);
	real_t sr = Math::sin(p_rot);
	columns[0][0] = cr;
	columns[0][1] = sr;
	columns[1][0] = -sr;
	columns[1][1] = cr;
	columns[2] = p_pos;
}

Transform2D::Transform2D(const real_t p_rot, const Size2 &p_scale, const real_t p_skew, const Vector2 &p_pos) {
	columns[0][0] = Math::cos(p_rot) * p_scale.x;
	columns[1][1] = Math::cos(p_rot + p_skew) * p_scale.y;
	columns[1][0] = -Math::sin(p_rot + p_skew) * p_scale.y;
	columns[0][1] = Math::sin(p_rot) * p_scale.x;
	columns[2] = p_pos;
}

Size2 Transform2D::get_scale() const {
	real_t det_sign = SGN(basis_determinant());
	return Size2(columns[0].length(), det_sign * columns[1].length());
}

void Transform2D::set_scale(const Size2 &p_scale) {
	columns[0].normalize();
	columns[1].normalize();
	columns[0] *= p_scale.x;
	columns[1] *= p_scale.y;
}

void Transform2D::scale(const Size2 &p_scale) {
	scale_basis(p_scale);
	columns[2] *= p_scale;
}
void Transform2D::scale_basis(const Size2 &p_scale) {
	columns[0][0] *= p_scale.x;
	columns[0][1] *= p_scale.y;
	columns[1][0] *= p_scale.x;
	columns[1][1] *= p_scale.y;
}

void Transform2D::translate(real_t p_tx, real_t p_ty) {
	translate(Vector2(p_tx, p_ty));
}
void Transform2D::translate(const Vector2 &p_offset) {
	columns[2] += p_offset;
}

void Transform2D::translate_local(real_t p_tx, real_t p_ty) {
	translate_local(Vector2(p_tx, p_ty));
}
void Transform2D::translate_local(const Vector2 &p_translation) {
	columns[2] += basis_xform(p_translation);
}

void Transform2D::translater(real_t p_tx, real_t p_ty) {
	translate(Vector2(p_tx, p_ty));
}
void Transform2D::translatev(const Vector2 &p_offset) {
	columns[2] += p_offset;
}

void Transform2D::translate_localr(real_t p_tx, real_t p_ty) {
	translate_local(Vector2(p_tx, p_ty));
}
void Transform2D::translate_localv(const Vector2 &p_translation) {
	columns[2] += basis_xform(p_translation);
}

void Transform2D::orthonormalize() {
	// Gram-Schmidt Process

	Vector2 x = columns[0];
	Vector2 y = columns[1];

	x.normalize();
	y = (y - x * (x.dot(y)));
	y.normalize();

	columns[0] = x;
	columns[1] = y;
}

Transform2D Transform2D::orthonormalized() const {
	Transform2D on = *this;
	on.orthonormalize();
	return on;
}

bool Transform2D::is_equal_approx(const Transform2D &p_transform) const {
	return columns[0].is_equal_approx(p_transform.columns[0]) && columns[1].is_equal_approx(p_transform.columns[1]) && columns[2].is_equal_approx(p_transform.columns[2]);
}

Transform2D Transform2D::looking_at(const Vector2 &p_target) const {
	Transform2D return_trans = Transform2D(get_rotation(), get_origin());
	Vector2 target_position = affine_inverse().xform(p_target);
	return_trans.set_rotation(return_trans.get_rotation() + (target_position * get_scale()).angle());
	return return_trans;
}

bool Transform2D::operator==(const Transform2D &p_transform) const {
	for (int i = 0; i < 3; i++) {
		if (columns[i] != p_transform.columns[i]) {
			return false;
		}
	}

	return true;
}

bool Transform2D::operator!=(const Transform2D &p_transform) const {
	for (int i = 0; i < 3; i++) {
		if (columns[i] != p_transform.columns[i]) {
			return true;
		}
	}

	return false;
}

void Transform2D::operator*=(const Transform2D &p_transform) {
	columns[2] = xform(p_transform.columns[2]);

	real_t x0, x1, y0, y1;

	x0 = tdotx(p_transform.columns[0]);
	x1 = tdoty(p_transform.columns[0]);
	y0 = tdotx(p_transform.columns[1]);
	y1 = tdoty(p_transform.columns[1]);

	columns[0][0] = x0;
	columns[0][1] = x1;
	columns[1][0] = y0;
	columns[1][1] = y1;
}

Transform2D Transform2D::operator*(const Transform2D &p_transform) const {
	Transform2D t = *this;
	t *= p_transform;
	return t;
}

void Transform2D::operator*=(const real_t p_val) {
	columns[0] *= p_val;
	columns[1] *= p_val;
	columns[2] *= p_val;
}

Transform2D Transform2D::operator*(const real_t p_val) const {
	Transform2D ret(*this);
	ret *= p_val;
	return ret;
}

Transform2D Transform2D::basis_scaled(const Size2 &p_scale) const {
	Transform2D copy = *this;
	copy.scale_basis(p_scale);
	return copy;
}

Transform2D Transform2D::scaled(const Size2 &p_scale) const {
	// Equivalent to left multiplication
	Transform2D copy = *this;
	copy.scale(p_scale);
	return copy;
}

Transform2D Transform2D::scaled_local(const Size2 &p_scale) const {
	// Equivalent to right multiplication
	return Transform2D(columns[0] * p_scale.x, columns[1] * p_scale.y, columns[2]);
}

Transform2D Transform2D::untranslated() const {
	Transform2D copy = *this;
	copy.columns[2] = Vector2();
	return copy;
}

Transform2D Transform2D::translated(const Vector2 &p_offset) const {
	// Equivalent to left multiplication
	return Transform2D(columns[0], columns[1], columns[2] + p_offset);
}

Transform2D Transform2D::translated_local(const Vector2 &p_offset) const {
	// Equivalent to right multiplication
	return Transform2D(columns[0], columns[1], columns[2] + basis_xform(p_offset));
}

Transform2D Transform2D::rotated(const real_t p_angle) const {
	// Equivalent to left multiplication
	return Transform2D(p_angle, Vector2()) * (*this);
}

Transform2D Transform2D::rotated_local(const real_t p_angle) const {
	// Equivalent to right multiplication
	return (*this) * Transform2D(p_angle, Vector2()); // Could be optimized, because origin transform can be skipped.
}

real_t Transform2D::basis_determinant() const {
	return columns[0].x * columns[1].y - columns[0].y * columns[1].x;
}

Transform2D Transform2D::interpolate_with(const Transform2D &p_transform, real_t p_c) const {
	//extract parameters
	Vector2 p1 = get_origin();
	Vector2 p2 = p_transform.get_origin();

	real_t r1 = get_rotation();
	real_t r2 = p_transform.get_rotation();

	Size2 s1 = get_scale();
	Size2 s2 = p_transform.get_scale();

	//slerp rotation
	Vector2 v1(Math::cos(r1), Math::sin(r1));
	Vector2 v2(Math::cos(r2), Math::sin(r2));

	real_t dot = v1.dot(v2);

	dot = CLAMP(dot, -1, 1);

	Vector2 v;

	if (dot > 0.9995f) {
		v = Vector2::linear_interpolate(v1, v2, p_c).normalized(); //linearly interpolate to avoid numerical precision issues
	} else {
		real_t angle = p_c * Math::acos(dot);
		Vector2 v3 = (v2 - v1 * dot).normalized();
		v = v1 * Math::cos(angle) + v3 * Math::sin(angle);
	}

	//construct matrix
	Transform2D res(Math::atan2(v.y, v.x), Vector2::linear_interpolate(p1, p2, p_c));
	res.scale_basis(Vector2::linear_interpolate(s1, s2, p_c));
	return res;
}

Transform2D::operator String() const {
	return "[X: " + columns[0].operator String() +
			", Y: " + columns[1].operator String() +
			", O: " + columns[2].operator String() + "]";
}
#line 0

#line 1 "sfw/core/projection.cpp"
/*************************************************************************/
/*  projection.cpp                                                       */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

float Projection::determinant() const {
	return matrix[0][3] * matrix[1][2] * matrix[2][1] * matrix[3][0] - matrix[0][2] * matrix[1][3] * matrix[2][1] * matrix[3][0] -
			matrix[0][3] * matrix[1][1] * matrix[2][2] * matrix[3][0] + matrix[0][1] * matrix[1][3] * matrix[2][2] * matrix[3][0] +
			matrix[0][2] * matrix[1][1] * matrix[2][3] * matrix[3][0] - matrix[0][1] * matrix[1][2] * matrix[2][3] * matrix[3][0] -
			matrix[0][3] * matrix[1][2] * matrix[2][0] * matrix[3][1] + matrix[0][2] * matrix[1][3] * matrix[2][0] * matrix[3][1] +
			matrix[0][3] * matrix[1][0] * matrix[2][2] * matrix[3][1] - matrix[0][0] * matrix[1][3] * matrix[2][2] * matrix[3][1] -
			matrix[0][2] * matrix[1][0] * matrix[2][3] * matrix[3][1] + matrix[0][0] * matrix[1][2] * matrix[2][3] * matrix[3][1] +
			matrix[0][3] * matrix[1][1] * matrix[2][0] * matrix[3][2] - matrix[0][1] * matrix[1][3] * matrix[2][0] * matrix[3][2] -
			matrix[0][3] * matrix[1][0] * matrix[2][1] * matrix[3][2] + matrix[0][0] * matrix[1][3] * matrix[2][1] * matrix[3][2] +
			matrix[0][1] * matrix[1][0] * matrix[2][3] * matrix[3][2] - matrix[0][0] * matrix[1][1] * matrix[2][3] * matrix[3][2] -
			matrix[0][2] * matrix[1][1] * matrix[2][0] * matrix[3][3] + matrix[0][1] * matrix[1][2] * matrix[2][0] * matrix[3][3] +
			matrix[0][2] * matrix[1][0] * matrix[2][1] * matrix[3][3] - matrix[0][0] * matrix[1][2] * matrix[2][1] * matrix[3][3] -
			matrix[0][1] * matrix[1][0] * matrix[2][2] * matrix[3][3] + matrix[0][0] * matrix[1][1] * matrix[2][2] * matrix[3][3];
}

void Projection::set_identity() {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			matrix[i][j] = (i == j) ? 1 : 0;
		}
	}
}

void Projection::set_zero() {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			matrix[i][j] = 0;
		}
	}
}

void Projection::adjust_perspective_znear(real_t p_new_znear) {
	real_t zfar = get_z_far();
	real_t znear = p_new_znear;

	real_t deltaZ = zfar - znear;
	matrix[2][2] = -(zfar + znear) / deltaZ;
	matrix[3][2] = -2 * znear * zfar / deltaZ;
}

Projection Projection::create_depth_correction(bool p_flip_y) {
	Projection proj;
	proj.set_depth_correction(p_flip_y);
	return proj;
}

Projection Projection::create_light_atlas_rect(const Rect2 &p_rect) {
	Projection proj;
	proj.set_light_atlas_rect(p_rect);
	return proj;
}

Projection Projection::create_perspective(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov) {
	Projection proj;
	proj.set_perspective(p_fovy_degrees, p_aspect, p_z_near, p_z_far, p_flip_fov);
	return proj;
}

Projection Projection::create_perspective_hmd(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov, int p_eye, real_t p_intraocular_dist, real_t p_convergence_dist) {
	Projection proj;
	proj.set_perspective(p_fovy_degrees, p_aspect, p_z_near, p_z_far, p_flip_fov, p_eye, p_intraocular_dist, p_convergence_dist);
	return proj;
}

Projection Projection::create_for_hmd(int p_eye, real_t p_aspect, real_t p_intraocular_dist, real_t p_display_width, real_t p_display_to_lens, real_t p_oversample, real_t p_z_near, real_t p_z_far) {
	Projection proj;
	proj.set_for_hmd(p_eye, p_aspect, p_intraocular_dist, p_display_width, p_display_to_lens, p_oversample, p_z_near, p_z_far);
	return proj;
}

Projection Projection::create_orthogonal(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_znear, real_t p_zfar) {
	Projection proj;
	proj.set_orthogonal(p_left, p_right, p_bottom, p_top, p_zfar, p_zfar);
	return proj;
}

Projection Projection::create_orthogonal_aspect(real_t p_size, real_t p_aspect, real_t p_znear, real_t p_zfar, bool p_flip_fov) {
	Projection proj;
	proj.set_orthogonal(p_size, p_aspect, p_znear, p_zfar, p_flip_fov);
	return proj;
}

Projection Projection::create_frustum(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_near, real_t p_far) {
	Projection proj;
	proj.set_frustum(p_left, p_right, p_bottom, p_top, p_near, p_far);
	return proj;
}

Projection Projection::create_frustum_aspect(real_t p_size, real_t p_aspect, Vector2 p_offset, real_t p_near, real_t p_far, bool p_flip_fov) {
	Projection proj;
	proj.set_frustum(p_size, p_aspect, p_offset, p_near, p_far, p_flip_fov);
	return proj;
}

Projection Projection::create_fit_aabb(const AABB &p_aabb) {
	Projection proj;
	proj.scale_translate_to_fit(p_aabb);
	return proj;
}

Projection Projection::perspective_znear_adjusted(real_t p_new_znear) const {
	Projection proj = *this;
	proj.adjust_perspective_znear(p_new_znear);
	return proj;
}

Plane Projection::get_projection_plane(Projection::Planes p_plane) const {
	const real_t *matrix = (const real_t *)this->matrix;

	switch (p_plane) {
		case PLANE_NEAR: {
			Plane new_plane = Plane(matrix[3] + matrix[2],
					matrix[7] + matrix[6],
					matrix[11] + matrix[10],
					matrix[15] + matrix[14]);

			new_plane.normal = -new_plane.normal;
			new_plane.normalize();
			return new_plane;
		} break;
		case PLANE_FAR: {
			Plane new_plane = Plane(matrix[3] - matrix[2],
					matrix[7] - matrix[6],
					matrix[11] - matrix[10],
					matrix[15] - matrix[14]);

			new_plane.normal = -new_plane.normal;
			new_plane.normalize();
			return new_plane;
		} break;
		case PLANE_LEFT: {
			Plane new_plane = Plane(matrix[3] + matrix[0],
					matrix[7] + matrix[4],
					matrix[11] + matrix[8],
					matrix[15] + matrix[12]);

			new_plane.normal = -new_plane.normal;
			new_plane.normalize();
			return new_plane;
		} break;
		case PLANE_TOP: {
			Plane new_plane = Plane(matrix[3] - matrix[1],
					matrix[7] - matrix[5],
					matrix[11] - matrix[9],
					matrix[15] - matrix[13]);

			new_plane.normal = -new_plane.normal;
			new_plane.normalize();
			return new_plane;
		} break;
		case PLANE_RIGHT: {
			Plane new_plane = Plane(matrix[3] - matrix[0],
					matrix[7] - matrix[4],
					matrix[11] - matrix[8],
					matrix[15] - matrix[12]);

			new_plane.normal = -new_plane.normal;
			new_plane.normalize();
			return new_plane;
		} break;
		case PLANE_BOTTOM: {
			Plane new_plane = Plane(matrix[3] + matrix[1],
					matrix[7] + matrix[5],
					matrix[11] + matrix[9],
					matrix[15] + matrix[13]);

			new_plane.normal = -new_plane.normal;
			new_plane.normalize();
			return new_plane;
		} break;
	}

	return Plane();
}

Projection Projection::flipped_y() const {
	Projection proj = *this;
	proj.flip_y();
	return proj;
}

Projection Projection ::jitter_offseted(const Vector2 &p_offset) const {
	Projection proj = *this;
	proj.add_jitter_offset(p_offset);
	return proj;
}

void Projection::set_perspective(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov) {
	if (p_flip_fov) {
		p_fovy_degrees = get_fovy(p_fovy_degrees, 1.0 / p_aspect);
	}

	real_t sine, cotangent, deltaZ;
	real_t radians = Math::deg2rad(p_fovy_degrees / 2.0);

	deltaZ = p_z_far - p_z_near;
	sine = Math::sin(radians);

	if ((deltaZ == 0) || (sine == 0) || (p_aspect == 0)) {
		return;
	}
	cotangent = Math::cos(radians) / sine;

	set_identity();

	matrix[0][0] = cotangent / p_aspect;
	matrix[1][1] = cotangent;
	matrix[2][2] = -(p_z_far + p_z_near) / deltaZ;
	matrix[2][3] = -1;
	matrix[3][2] = -2 * p_z_near * p_z_far / deltaZ;
	matrix[3][3] = 0;
}

void Projection::set_perspective(real_t p_fovy_degrees, real_t p_aspect, real_t p_z_near, real_t p_z_far, bool p_flip_fov, int p_eye, real_t p_intraocular_dist, real_t p_convergence_dist) {
	if (p_flip_fov) {
		p_fovy_degrees = get_fovy(p_fovy_degrees, 1.0 / p_aspect);
	}

	real_t left, right, modeltranslation, ymax, xmax, frustumshift;

	ymax = p_z_near * tan(Math::deg2rad(p_fovy_degrees / 2.0));
	xmax = ymax * p_aspect;
	frustumshift = (p_intraocular_dist / 2.0) * p_z_near / p_convergence_dist;

	switch (p_eye) {
		case 1: { // left eye
			left = -xmax + frustumshift;
			right = xmax + frustumshift;
			modeltranslation = p_intraocular_dist / 2.0;
		} break;
		case 2: { // right eye
			left = -xmax - frustumshift;
			right = xmax - frustumshift;
			modeltranslation = -p_intraocular_dist / 2.0;
		} break;
		default: { // mono, should give the same result as set_perspective(p_fovy_degrees,p_aspect,p_z_near,p_z_far,p_flip_fov)
			left = -xmax;
			right = xmax;
			modeltranslation = 0.0;
		} break;
	}

	set_frustum(left, right, -ymax, ymax, p_z_near, p_z_far);

	// translate matrix by (modeltranslation, 0.0, 0.0)
	Projection cm;
	cm.set_identity();
	cm.matrix[3][0] = modeltranslation;
	*this = *this * cm;
}

void Projection::set_for_hmd(int p_eye, real_t p_aspect, real_t p_intraocular_dist, real_t p_display_width, real_t p_display_to_lens, real_t p_oversample, real_t p_z_near, real_t p_z_far) {
	// we first calculate our base frustum on our values without taking our lens magnification into account.
	real_t f1 = (p_intraocular_dist * 0.5) / p_display_to_lens;
	real_t f2 = ((p_display_width - p_intraocular_dist) * 0.5) / p_display_to_lens;
	real_t f3 = (p_display_width / 4.0) / p_display_to_lens;

	// now we apply our oversample factor to increase our FOV. how much we oversample is always a balance we strike between performance and how much
	// we're willing to sacrifice in FOV.
	real_t add = ((f1 + f2) * (p_oversample - 1.0)) / 2.0;
	f1 += add;
	f2 += add;
	f3 *= p_oversample;

	// always apply KEEP_WIDTH aspect ratio
	f3 /= p_aspect;

	switch (p_eye) {
		case 1: { // left eye
			set_frustum(-f2 * p_z_near, f1 * p_z_near, -f3 * p_z_near, f3 * p_z_near, p_z_near, p_z_far);
		} break;
		case 2: { // right eye
			set_frustum(-f1 * p_z_near, f2 * p_z_near, -f3 * p_z_near, f3 * p_z_near, p_z_near, p_z_far);
		} break;
		default: { // mono, does not apply here!
		} break;
	}
}

void Projection::set_orthogonal(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_znear, real_t p_zfar) {
	set_identity();

	matrix[0][0] = 2.0 / (p_right - p_left);
	matrix[3][0] = -((p_right + p_left) / (p_right - p_left));
	matrix[1][1] = 2.0 / (p_top - p_bottom);
	matrix[3][1] = -((p_top + p_bottom) / (p_top - p_bottom));
	matrix[2][2] = -2.0 / (p_zfar - p_znear);
	matrix[3][2] = -((p_zfar + p_znear) / (p_zfar - p_znear));
	matrix[3][3] = 1.0;
}

void Projection::set_orthogonal(real_t p_size, real_t p_aspect, real_t p_znear, real_t p_zfar, bool p_flip_fov) {
	if (!p_flip_fov) {
		p_size *= p_aspect;
	}

	set_orthogonal(-p_size / 2, +p_size / 2, -p_size / p_aspect / 2, +p_size / p_aspect / 2, p_znear, p_zfar);
}

void Projection::set_frustum(real_t p_left, real_t p_right, real_t p_bottom, real_t p_top, real_t p_near, real_t p_far) {
	ERR_FAIL_COND(p_right <= p_left);
	ERR_FAIL_COND(p_top <= p_bottom);
	ERR_FAIL_COND(p_far <= p_near);

	real_t *te = &matrix[0][0];
	real_t x = 2 * p_near / (p_right - p_left);
	real_t y = 2 * p_near / (p_top - p_bottom);

	real_t a = (p_right + p_left) / (p_right - p_left);
	real_t b = (p_top + p_bottom) / (p_top - p_bottom);
	real_t c = -(p_far + p_near) / (p_far - p_near);
	real_t d = -2 * p_far * p_near / (p_far - p_near);

	te[0] = x;
	te[1] = 0;
	te[2] = 0;
	te[3] = 0;
	te[4] = 0;
	te[5] = y;
	te[6] = 0;
	te[7] = 0;
	te[8] = a;
	te[9] = b;
	te[10] = c;
	te[11] = -1;
	te[12] = 0;
	te[13] = 0;
	te[14] = d;
	te[15] = 0;
}

void Projection::set_frustum(real_t p_size, real_t p_aspect, Vector2 p_offset, real_t p_near, real_t p_far, bool p_flip_fov) {
	if (!p_flip_fov) {
		p_size *= p_aspect;
	}

	set_frustum(-p_size / 2 + p_offset.x, +p_size / 2 + p_offset.x, -p_size / p_aspect / 2 + p_offset.y, +p_size / p_aspect / 2 + p_offset.y, p_near, p_far);
}

real_t Projection::get_z_far() const {
	const real_t *matrix = (const real_t *)this->matrix;
	Plane new_plane = Plane(matrix[3] - matrix[2],
			matrix[7] - matrix[6],
			matrix[11] - matrix[10],
			matrix[15] - matrix[14]);

	new_plane.normal = -new_plane.normal;
	new_plane.normalize();

	return new_plane.d;
}

real_t Projection::get_z_near() const {
	const real_t *matrix = (const real_t *)this->matrix;
	Plane new_plane = Plane(matrix[3] + matrix[2],
			matrix[7] + matrix[6],
			matrix[11] + matrix[10],
			-matrix[15] - matrix[14]);

	new_plane.normalize();
	return new_plane.d;
}

Vector2 Projection::get_viewport_half_extents() const {
	const real_t *matrix = (const real_t *)this->matrix;
	///////--- Near Plane ---///////
	Plane near_plane = Plane(matrix[3] + matrix[2],
			matrix[7] + matrix[6],
			matrix[11] + matrix[10],
			-matrix[15] - matrix[14]);
	near_plane.normalize();

	///////--- Right Plane ---///////
	Plane right_plane = Plane(matrix[3] - matrix[0],
			matrix[7] - matrix[4],
			matrix[11] - matrix[8],
			-matrix[15] + matrix[12]);
	right_plane.normalize();

	Plane top_plane = Plane(matrix[3] - matrix[1],
			matrix[7] - matrix[5],
			matrix[11] - matrix[9],
			-matrix[15] + matrix[13]);
	top_plane.normalize();

	Vector3 res;
	near_plane.intersect_3(right_plane, top_plane, &res);

	return Vector2(res.x, res.y);
}

Vector2 Projection::get_far_plane_half_extents() const {
	const real_t *matrix = (const real_t *)this->matrix;
	///////--- Far Plane ---///////
	Plane far_plane = Plane(matrix[3] - matrix[2],
			matrix[7] - matrix[6],
			matrix[11] - matrix[10],
			-matrix[15] + matrix[14]);
	far_plane.normalize();

	///////--- Right Plane ---///////
	Plane right_plane = Plane(matrix[3] - matrix[0],
			matrix[7] - matrix[4],
			matrix[11] - matrix[8],
			-matrix[15] + matrix[12]);
	right_plane.normalize();

	Plane top_plane = Plane(matrix[3] - matrix[1],
			matrix[7] - matrix[5],
			matrix[11] - matrix[9],
			-matrix[15] + matrix[13]);
	top_plane.normalize();

	Vector3 res;
	far_plane.intersect_3(right_plane, top_plane, &res);

	return Vector2(res.x, res.y);
}

bool Projection::get_endpoints(const Transform &p_transform, Vector3 *p_8points) const {
	Vector<Plane> planes = get_projection_planes(Transform());
	const Planes intersections[8][3] = {
		{ PLANE_FAR, PLANE_LEFT, PLANE_TOP },
		{ PLANE_FAR, PLANE_LEFT, PLANE_BOTTOM },
		{ PLANE_FAR, PLANE_RIGHT, PLANE_TOP },
		{ PLANE_FAR, PLANE_RIGHT, PLANE_BOTTOM },
		{ PLANE_NEAR, PLANE_LEFT, PLANE_TOP },
		{ PLANE_NEAR, PLANE_LEFT, PLANE_BOTTOM },
		{ PLANE_NEAR, PLANE_RIGHT, PLANE_TOP },
		{ PLANE_NEAR, PLANE_RIGHT, PLANE_BOTTOM },
	};

	for (int i = 0; i < 8; i++) {
		Vector3 point;
		bool res = planes[intersections[i][0]].intersect_3(planes[intersections[i][1]], planes[intersections[i][2]], &point);
		ERR_FAIL_COND_V(!res, false);
		p_8points[i] = p_transform.xform(point);
	}

	return true;
}

Vector<Plane> Projection::get_projection_planes(const Transform &p_transform) const {
	/** Fast Plane Extraction from combined modelview/projection matrices.
	 * References:
	 * https://web.archive.org/web/20011221205252/https://www.markmorley.com/opengl/frustumculling.html
	 * https://web.archive.org/web/20061020020112/https://www2.ravensoft.com/users/ggribb/plane%20extraction.pdf
	 */

	Vector<Plane> planes;
	planes.resize(6);

	const real_t *matrix = (const real_t *)this->matrix;

	Plane new_plane;

	///////--- Near Plane ---///////
	new_plane = Plane(matrix[3] + matrix[2],
			matrix[7] + matrix[6],
			matrix[11] + matrix[10],
			matrix[15] + matrix[14]);

	new_plane.normal = -new_plane.normal;
	new_plane.normalize();

	planes.write[0] = p_transform.xform(new_plane);

	///////--- Far Plane ---///////
	new_plane = Plane(matrix[3] - matrix[2],
			matrix[7] - matrix[6],
			matrix[11] - matrix[10],
			matrix[15] - matrix[14]);

	new_plane.normal = -new_plane.normal;
	new_plane.normalize();

	planes.write[1] = p_transform.xform(new_plane);

	///////--- Left Plane ---///////
	new_plane = Plane(matrix[3] + matrix[0],
			matrix[7] + matrix[4],
			matrix[11] + matrix[8],
			matrix[15] + matrix[12]);

	new_plane.normal = -new_plane.normal;
	new_plane.normalize();

	planes.write[2] = p_transform.xform(new_plane);

	///////--- Top Plane ---///////
	new_plane = Plane(matrix[3] - matrix[1],
			matrix[7] - matrix[5],
			matrix[11] - matrix[9],
			matrix[15] - matrix[13]);

	new_plane.normal = -new_plane.normal;
	new_plane.normalize();

	planes.write[3] = p_transform.xform(new_plane);

	///////--- Right Plane ---///////
	new_plane = Plane(matrix[3] - matrix[0],
			matrix[7] - matrix[4],
			matrix[11] - matrix[8],
			matrix[15] - matrix[12]);

	new_plane.normal = -new_plane.normal;
	new_plane.normalize();

	planes.write[4] = p_transform.xform(new_plane);

	///////--- Bottom Plane ---///////
	new_plane = Plane(matrix[3] + matrix[1],
			matrix[7] + matrix[5],
			matrix[11] + matrix[9],
			matrix[15] + matrix[13]);

	new_plane.normal = -new_plane.normal;
	new_plane.normalize();

	planes.write[5] = p_transform.xform(new_plane);

	return planes;
}

Projection Projection::inverse() const {
	Projection cm = *this;
	cm.invert();
	return cm;
}

void Projection::invert() {
	int i, j, k;
	int pvt_i[4], pvt_j[4]; /* Locations of pivot matrix */
	real_t pvt_val; /* Value of current pivot element */
	real_t hold; /* Temporary storage */
	real_t determinant = 1.0f;
	for (k = 0; k < 4; k++) {
		/** Locate k'th pivot element **/
		pvt_val = matrix[k][k]; /** Initialize for search **/
		pvt_i[k] = k;
		pvt_j[k] = k;
		for (i = k; i < 4; i++) {
			for (j = k; j < 4; j++) {
				if (Math::abs(matrix[i][j]) > Math::abs(pvt_val)) {
					pvt_i[k] = i;
					pvt_j[k] = j;
					pvt_val = matrix[i][j];
				}
			}
		}

		/** Product of pivots, gives determinant when finished **/
		determinant *= pvt_val;
		if (Math::is_zero_approx(determinant)) {
			return; /** Matrix is singular (zero determinant). **/
		}

		/** "Interchange" rows (with sign change stuff) **/
		i = pvt_i[k];
		if (i != k) { /** If rows are different **/
			for (j = 0; j < 4; j++) {
				hold = -matrix[k][j];
				matrix[k][j] = matrix[i][j];
				matrix[i][j] = hold;
			}
		}

		/** "Interchange" columns **/
		j = pvt_j[k];
		if (j != k) { /** If columns are different **/
			for (i = 0; i < 4; i++) {
				hold = -matrix[i][k];
				matrix[i][k] = matrix[i][j];
				matrix[i][j] = hold;
			}
		}

		/** Divide column by minus pivot value **/
		for (i = 0; i < 4; i++) {
			if (i != k) {
				matrix[i][k] /= (-pvt_val);
			}
		}

		/** Reduce the matrix **/
		for (i = 0; i < 4; i++) {
			hold = matrix[i][k];
			for (j = 0; j < 4; j++) {
				if (i != k && j != k) {
					matrix[i][j] += hold * matrix[k][j];
				}
			}
		}

		/** Divide row by pivot **/
		for (j = 0; j < 4; j++) {
			if (j != k) {
				matrix[k][j] /= pvt_val;
			}
		}

		/** Replace pivot by reciprocal (at last we can touch it). **/
		matrix[k][k] = 1.0 / pvt_val;
	}

	/* That was most of the work, one final pass of row/column interchange */
	/* to finish */
	for (k = 4 - 2; k >= 0; k--) { /* Don't need to work with 1 by 1 corner*/
		i = pvt_j[k]; /* Rows to swap correspond to pivot COLUMN */
		if (i != k) { /* If rows are different */
			for (j = 0; j < 4; j++) {
				hold = matrix[k][j];
				matrix[k][j] = -matrix[i][j];
				matrix[i][j] = hold;
			}
		}

		j = pvt_i[k]; /* Columns to swap correspond to pivot ROW */
		if (j != k) { /* If columns are different */
			for (i = 0; i < 4; i++) {
				hold = matrix[i][k];
				matrix[i][k] = -matrix[i][j];
				matrix[i][j] = hold;
			}
		}
	}
}

void Projection::flip_y() {
	for (int i = 0; i < 4; i++) {
		matrix[1][i] = -matrix[1][i];
	}
}

Projection::Projection() {
	set_identity();
}

Projection Projection::operator*(const Projection &p_matrix) const {
	Projection new_matrix;

	for (int j = 0; j < 4; j++) {
		for (int i = 0; i < 4; i++) {
			real_t ab = 0;
			for (int k = 0; k < 4; k++) {
				ab += matrix[k][i] * p_matrix.matrix[j][k];
			}
			new_matrix.matrix[j][i] = ab;
		}
	}

	return new_matrix;
}

void Projection::set_depth_correction(bool p_flip_y) {
	real_t *m = &matrix[0][0];

	m[0] = 1;
	m[1] = 0.0;
	m[2] = 0.0;
	m[3] = 0.0;
	m[4] = 0.0;
	m[5] = p_flip_y ? -1 : 1;
	m[6] = 0.0;
	m[7] = 0.0;
	m[8] = 0.0;
	m[9] = 0.0;
	m[10] = 0.5;
	m[11] = 0.0;
	m[12] = 0.0;
	m[13] = 0.0;
	m[14] = 0.5;
	m[15] = 1.0;
}

void Projection::set_light_bias() {
	real_t *m = &matrix[0][0];

	m[0] = 0.5;
	m[1] = 0.0;
	m[2] = 0.0;
	m[3] = 0.0;
	m[4] = 0.0;
	m[5] = 0.5;
	m[6] = 0.0;
	m[7] = 0.0;
	m[8] = 0.0;
	m[9] = 0.0;
	m[10] = 0.5;
	m[11] = 0.0;
	m[12] = 0.5;
	m[13] = 0.5;
	m[14] = 0.5;
	m[15] = 1.0;
}

void Projection::set_light_atlas_rect(const Rect2 &p_rect) {
	real_t *m = &matrix[0][0];

	m[0] = p_rect.size.width;
	m[1] = 0.0;
	m[2] = 0.0;
	m[3] = 0.0;
	m[4] = 0.0;
	m[5] = p_rect.size.height;
	m[6] = 0.0;
	m[7] = 0.0;
	m[8] = 0.0;
	m[9] = 0.0;
	m[10] = 1.0;
	m[11] = 0.0;
	m[12] = p_rect.position.x;
	m[13] = p_rect.position.y;
	m[14] = 0.0;
	m[15] = 1.0;
}

Vector4 Projection::xform(const Vector4 &p_vec4) const {
	return Vector4(
			matrix[0][0] * p_vec4.x + matrix[1][0] * p_vec4.y + matrix[2][0] * p_vec4.z + matrix[3][0] * p_vec4.w,
			matrix[0][1] * p_vec4.x + matrix[1][1] * p_vec4.y + matrix[2][1] * p_vec4.z + matrix[3][1] * p_vec4.w,
			matrix[0][2] * p_vec4.x + matrix[1][2] * p_vec4.y + matrix[2][2] * p_vec4.z + matrix[3][2] * p_vec4.w,
			matrix[0][3] * p_vec4.x + matrix[1][3] * p_vec4.y + matrix[2][3] * p_vec4.z + matrix[3][3] * p_vec4.w);
}

Vector4 Projection::xform_inv(const Vector4 &p_vec4) const {
	return Vector4(
			matrix[0][0] * p_vec4.x + matrix[0][1] * p_vec4.y + matrix[0][2] * p_vec4.z + matrix[0][3] * p_vec4.w,
			matrix[1][0] * p_vec4.x + matrix[1][1] * p_vec4.y + matrix[1][2] * p_vec4.z + matrix[1][3] * p_vec4.w,
			matrix[2][0] * p_vec4.x + matrix[2][1] * p_vec4.y + matrix[2][2] * p_vec4.z + matrix[2][3] * p_vec4.w,
			matrix[3][0] * p_vec4.x + matrix[3][1] * p_vec4.y + matrix[3][2] * p_vec4.z + matrix[3][3] * p_vec4.w);
}

Plane Projection::xform(const Plane &p_vec4) const {
	Plane ret;

	ret.normal.x = matrix[0][0] * p_vec4.normal.x + matrix[1][0] * p_vec4.normal.y + matrix[2][0] * p_vec4.normal.z + matrix[3][0] * p_vec4.d;
	ret.normal.y = matrix[0][1] * p_vec4.normal.x + matrix[1][1] * p_vec4.normal.y + matrix[2][1] * p_vec4.normal.z + matrix[3][1] * p_vec4.d;
	ret.normal.z = matrix[0][2] * p_vec4.normal.x + matrix[1][2] * p_vec4.normal.y + matrix[2][2] * p_vec4.normal.z + matrix[3][2] * p_vec4.d;
	ret.d = matrix[0][3] * p_vec4.normal.x + matrix[1][3] * p_vec4.normal.y + matrix[2][3] * p_vec4.normal.z + matrix[3][3] * p_vec4.d;
	return ret;
}

Projection::operator String() const {
	return "[ X: " + matrix[0].operator String() +
			", Y: " + matrix[1].operator String() +
			", Z: " + matrix[2].operator String() +
			", W: " + matrix[3].operator String() + " ]";
}

real_t Projection::get_aspect() const {
	Vector2 vp_he = get_viewport_half_extents();
	return vp_he.x / vp_he.y;
}

int Projection::get_pixels_per_meter(int p_for_pixel_width) const {
	Vector3 result = xform(Vector3(1, 0, -1));

	return int((result.x * 0.5 + 0.5) * p_for_pixel_width);
}

bool Projection::is_orthogonal() const {
	return matrix[3][3] == 1.0;
}

real_t Projection::get_fov() const {
	const real_t *matrix = (const real_t *)this->matrix;

	Plane right_plane = Plane(matrix[3] - matrix[0],
			matrix[7] - matrix[4],
			matrix[11] - matrix[8],
			-matrix[15] + matrix[12]);
	right_plane.normalize();

	if ((matrix[8] == 0) && (matrix[9] == 0)) {
		return Math::rad2deg(Math::acos(Math::abs(right_plane.normal.x))) * 2.0;
	} else {
		// our frustum is asymmetrical need to calculate the left planes angle separately..
		Plane left_plane = Plane(matrix[3] + matrix[0],
				matrix[7] + matrix[4],
				matrix[11] + matrix[8],
				matrix[15] + matrix[12]);
		left_plane.normalize();

		return Math::rad2deg(Math::acos(Math::abs(left_plane.normal.x))) + Math::rad2deg(Math::acos(Math::abs(right_plane.normal.x)));
	}
}

float Projection::get_lod_multiplier() const {
	if (is_orthogonal()) {
		return get_viewport_half_extents().x;
	} else {
		float zn = get_z_near();
		float width = get_viewport_half_extents().x * 2.0;
		return 1.0 / (zn / width);
	}

	//usage is lod_size / (lod_distance * multiplier) < threshold
}
void Projection::make_scale(const Vector3 &p_scale) {
	set_identity();
	matrix[0][0] = p_scale.x;
	matrix[1][1] = p_scale.y;
	matrix[2][2] = p_scale.z;
}

void Projection::scale_translate_to_fit(const AABB &p_aabb) {
	Vector3 min = p_aabb.position;
	Vector3 max = p_aabb.position + p_aabb.size;

	matrix[0][0] = 2 / (max.x - min.x);
	matrix[1][0] = 0;
	matrix[2][0] = 0;
	matrix[3][0] = -(max.x + min.x) / (max.x - min.x);

	matrix[0][1] = 0;
	matrix[1][1] = 2 / (max.y - min.y);
	matrix[2][1] = 0;
	matrix[3][1] = -(max.y + min.y) / (max.y - min.y);

	matrix[0][2] = 0;
	matrix[1][2] = 0;
	matrix[2][2] = 2 / (max.z - min.z);
	matrix[3][2] = -(max.z + min.z) / (max.z - min.z);

	matrix[0][3] = 0;
	matrix[1][3] = 0;
	matrix[2][3] = 0;
	matrix[3][3] = 1;
}

void Projection::add_jitter_offset(const Vector2 &p_offset) {
	matrix[3][0] += p_offset.x;
	matrix[3][1] += p_offset.y;
}

Projection::operator Transform() const {
	Transform tr;
	const real_t *m = &matrix[0][0];

	tr.basis.rows[0][0] = m[0];
	tr.basis.rows[1][0] = m[1];
	tr.basis.rows[2][0] = m[2];

	tr.basis.rows[0][1] = m[4];
	tr.basis.rows[1][1] = m[5];
	tr.basis.rows[2][1] = m[6];

	tr.basis.rows[0][2] = m[8];
	tr.basis.rows[1][2] = m[9];
	tr.basis.rows[2][2] = m[10];

	tr.origin.x = m[12];
	tr.origin.y = m[13];
	tr.origin.z = m[14];

	return tr;
}

void Projection::set_frustum2(real_t p_size, real_t p_aspect, Vector2 p_offset, real_t p_near, real_t p_far, bool p_flip_fov) {
	set_frustum(p_size, p_aspect, p_offset, p_near, p_far, p_flip_fov);
}

Projection::Projection(const Vector4 &p_x, const Vector4 &p_y, const Vector4 &p_z, const Vector4 &p_w) {
	matrix[0] = p_x;
	matrix[1] = p_y;
	matrix[2] = p_z;
	matrix[3] = p_w;
}
Projection::Projection(const Transform &p_transform) {
	const Transform &tr = p_transform;
	real_t *m = &matrix[0][0];

	m[0] = tr.basis.rows[0][0];
	m[1] = tr.basis.rows[1][0];
	m[2] = tr.basis.rows[2][0];
	m[3] = 0.0;
	m[4] = tr.basis.rows[0][1];
	m[5] = tr.basis.rows[1][1];
	m[6] = tr.basis.rows[2][1];
	m[7] = 0.0;
	m[8] = tr.basis.rows[0][2];
	m[9] = tr.basis.rows[1][2];
	m[10] = tr.basis.rows[2][2];
	m[11] = 0.0;
	m[12] = tr.origin.x;
	m[13] = tr.origin.y;
	m[14] = tr.origin.z;
	m[15] = 1.0;
}

Projection::~Projection() {
}
#line 0

#line 1 "sfw/core/vector3.cpp"
/*************************************************************************/
/*  vector3.cpp                                                          */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void Vector3::rotate(const Vector3 &p_axis, real_t p_phi) {
	*this = Basis(p_axis, p_phi).xform(*this);
}

Vector3 Vector3::rotated(const Vector3 &p_axis, real_t p_phi) const {
	Vector3 r = *this;
	r.rotate(p_axis, p_phi);
	return r;
}

void Vector3::set_axis(int p_axis, real_t p_value) {
	ERR_FAIL_INDEX(p_axis, 3);
	coord[p_axis] = p_value;
}
real_t Vector3::get_axis(int p_axis) const {
	ERR_FAIL_INDEX_V(p_axis, 3, 0);
	return operator[](p_axis);
}

void Vector3::snap(const Vector3 &p_val) {
	x = Math::stepify(x, p_val.x);
	y = Math::stepify(y, p_val.y);
	z = Math::stepify(z, p_val.z);
}
Vector3 Vector3::snapped(const Vector3 &p_val) const {
	Vector3 v = *this;
	v.snap(p_val);
	return v;
}

Vector3 Vector3::limit_length(const real_t p_len) const {
	const real_t l = length();
	Vector3 v = *this;
	if (l > 0 && p_len < l) {
		v /= l;
		v *= p_len;
	}

	return v;
}

Vector3 Vector3::move_toward(const Vector3 &p_to, const real_t p_delta) const {
	Vector3 v = *this;
	Vector3 vd = p_to - v;
	real_t len = vd.length();
	return len <= p_delta || len < (real_t)CMP_EPSILON ? p_to : v + vd / len * p_delta;
}

Basis Vector3::outer(const Vector3 &p_b) const {
	Vector3 row0(x * p_b.x, x * p_b.y, x * p_b.z);
	Vector3 row1(y * p_b.x, y * p_b.y, y * p_b.z);
	Vector3 row2(z * p_b.x, z * p_b.y, z * p_b.z);

	return Basis(row0, row1, row2);
}

Basis Vector3::to_diagonal_matrix() const {
	return Basis(x, 0, 0,
			0, y, 0,
			0, 0, z);
}

Vector3 Vector3::clamp(const Vector3 &p_min, const Vector3 &p_max) const {
	return Vector3(
			CLAMP(x, p_min.x, p_max.x),
			CLAMP(y, p_min.y, p_max.y),
			CLAMP(z, p_min.z, p_max.z));
}

bool Vector3::is_equal_approx(const Vector3 &p_v) const {
	return Math::is_equal_approx(x, p_v.x) && Math::is_equal_approx(y, p_v.y) && Math::is_equal_approx(z, p_v.z);
}

bool Vector3::is_zero_approx() const {
	return Math::is_zero_approx(x) && Math::is_zero_approx(y) && Math::is_zero_approx(z);
}

Vector3::operator String() const {
	return "(" + String::num_real(x) + ", " + String::num_real(y) + ", " + String::num_real(z) + ")";
}
#line 0

#line 1 "sfw/core/pcg.cpp"
// *Really* minimal PCG32 code / (c) 2014 M.E. O'Neill / pcg-random.org
// Licensed under Apache License 2.0 (NO WARRANTY, etc. see website)

uint32_t pcg32_random_r(pcg32_random_t *rng) {
	uint64_t oldstate = rng->state;
	// Advance internal state
	rng->state = oldstate * 6364136223846793005ULL + (rng->inc | 1);
	// Calculate output function (XSH RR), uses old state for max ILP
	uint32_t xorshifted = ((oldstate >> 18u) ^ oldstate) >> 27u;
	uint32_t rot = oldstate >> 59u;
	return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));
}

// Source from http://www.pcg-random.org/downloads/pcg-c-basic-0.9.zip
void pcg32_srandom_r(pcg32_random_t *rng, uint64_t initstate, uint64_t initseq) {
	rng->state = 0U;
	rng->inc = (initseq << 1u) | 1u;
	pcg32_random_r(rng);
	rng->state += initstate;
	pcg32_random_r(rng);
}

// Source from https://github.com/imneme/pcg-c-basic/blob/master/pcg_basic.c
// pcg32_boundedrand_r(rng, bound):
//     Generate a uniformly distributed number, r, where 0 <= r < bound
uint32_t pcg32_boundedrand_r(pcg32_random_t *rng, uint32_t bound) {
	// To avoid bias, we need to make the range of the RNG a multiple of
	// bound, which we do by dropping output less than a threshold.
	// A naive scheme to calculate the threshold would be to do
	//
	//     uint32_t threshold = 0x100000000ull % bound;
	//
	// but 64-bit div/mod is slower than 32-bit div/mod (especially on
	// 32-bit platforms).  In essence, we do
	//
	//     uint32_t threshold = (0x100000000ull-bound) % bound;
	//
	// because this version will calculate the same modulus, but the LHS
	// value is less than 2^32.
	uint32_t threshold = -bound % bound;

	// Uniformity guarantees that this loop will terminate.  In practice, it
	// should usually terminate quickly; on average (assuming all bounds are
	// equally likely), 82.25% of the time, we can expect it to require just
	// one iteration.  In the worst case, someone passes a bound of 2^31 + 1
	// (i.e., 2147483649), which invalidates almost 50% of the range.  In
	// practice, bounds are typically small and only a tiny amount of the range
	// is eliminated.
	for (;;) {
		uint32_t r = pcg32_random_r(rng);
		if (r >= threshold)
			return r % bound;
	}
}
#line 0

#line 1 "sfw/core/vector2i.cpp"
/*************************************************************************/
/*  vector2i.cpp                                                         */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

Vector2i Vector2i::clamp(const Vector2i &p_min, const Vector2i &p_max) const {
	return Vector2i(
			CLAMP(x, p_min.x, p_max.x),
			CLAMP(y, p_min.y, p_max.y));
}

int64_t Vector2i::length_squared() const {
	return x * (int64_t)x + y * (int64_t)y;
}

double Vector2i::length() const {
	return Math::sqrt((double)length_squared());
}

Vector2i Vector2i::operator+(const Vector2i &p_v) const {
	return Vector2i(x + p_v.x, y + p_v.y);
}
void Vector2i::operator+=(const Vector2i &p_v) {
	x += p_v.x;
	y += p_v.y;
}
Vector2i Vector2i::operator-(const Vector2i &p_v) const {
	return Vector2i(x - p_v.x, y - p_v.y);
}
void Vector2i::operator-=(const Vector2i &p_v) {
	x -= p_v.x;
	y -= p_v.y;
}

Vector2i Vector2i::operator*(const Vector2i &p_v1) const {
	return Vector2i(x * p_v1.x, y * p_v1.y);
};

Vector2i Vector2i::operator*(const int &rvalue) const {
	return Vector2i(x * rvalue, y * rvalue);
};
void Vector2i::operator*=(const int &rvalue) {
	x *= rvalue;
	y *= rvalue;
};

Vector2i Vector2i::operator/(const Vector2i &p_v1) const {
	return Vector2i(x / p_v1.x, y / p_v1.y);
};

Vector2i Vector2i::operator/(const int &rvalue) const {
	return Vector2i(x / rvalue, y / rvalue);
};

void Vector2i::operator/=(const int &rvalue) {
	x /= rvalue;
	y /= rvalue;
};

Vector2i Vector2i::operator-() const {
	return Vector2i(-x, -y);
}

bool Vector2i::operator==(const Vector2i &p_vec2) const {
	return x == p_vec2.x && y == p_vec2.y;
}
bool Vector2i::operator!=(const Vector2i &p_vec2) const {
	return x != p_vec2.x || y != p_vec2.y;
}

Vector2i::operator String() const {
	return "(" + itos(x) + ", " + itos(y) + ")";
}
#line 0

#line 1 "sfw/core/vector2.cpp"
/*************************************************************************/
/*  vector2.cpp                                                          */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

real_t Vector2::angle() const {
	return Math::atan2(y, x);
}

real_t Vector2::length() const {
	return Math::sqrt(x * x + y * y);
}

real_t Vector2::length_squared() const {
	return x * x + y * y;
}

void Vector2::normalize() {
	real_t l = x * x + y * y;
	if (l != 0) {
		l = Math::sqrt(l);
		x /= l;
		y /= l;
	}
}

Vector2 Vector2::normalized() const {
	Vector2 v = *this;
	v.normalize();
	return v;
}

bool Vector2::is_normalized() const {
	// use length_squared() instead of length() to avoid sqrt(), makes it more stringent.
	return Math::is_equal_approx(length_squared(), 1, (real_t)UNIT_EPSILON);
}

real_t Vector2::distance_to(const Vector2 &p_vector2) const {
	return Math::sqrt((x - p_vector2.x) * (x - p_vector2.x) + (y - p_vector2.y) * (y - p_vector2.y));
}

real_t Vector2::distance_squared_to(const Vector2 &p_vector2) const {
	return (x - p_vector2.x) * (x - p_vector2.x) + (y - p_vector2.y) * (y - p_vector2.y);
}

real_t Vector2::angle_to(const Vector2 &p_vector2) const {
	return Math::atan2(cross(p_vector2), dot(p_vector2));
}

real_t Vector2::angle_to_point(const Vector2 &p_vector2) const {
	return Math::atan2(y - p_vector2.y, x - p_vector2.x);
}

real_t Vector2::dot(const Vector2 &p_other) const {
	return x * p_other.x + y * p_other.y;
}

real_t Vector2::cross(const Vector2 &p_other) const {
	return x * p_other.y - y * p_other.x;
}

Vector2 Vector2::sign() const {
	return Vector2(SGN(x), SGN(y));
}

Vector2 Vector2::floor() const {
	return Vector2(Math::floor(x), Math::floor(y));
}

Vector2 Vector2::ceil() const {
	return Vector2(Math::ceil(x), Math::ceil(y));
}

Vector2 Vector2::round() const {
	return Vector2(Math::round(x), Math::round(y));
}

Vector2 Vector2::rotated(real_t p_by) const {
	Vector2 v;
	v.set_rotation(angle() + p_by);
	v *= length();
	return v;
}

Vector2 Vector2::posmod(const real_t p_mod) const {
	return Vector2(Math::fposmod(x, p_mod), Math::fposmod(y, p_mod));
}

Vector2 Vector2::posmodv(const Vector2 &p_modv) const {
	return Vector2(Math::fposmod(x, p_modv.x), Math::fposmod(y, p_modv.y));
}

Vector2 Vector2::project(const Vector2 &p_to) const {
	return p_to * (dot(p_to) / p_to.length_squared());
}

Vector2 Vector2::snapped(const Vector2 &p_by) const {
	return Vector2(
			Math::stepify(x, p_by.x),
			Math::stepify(y, p_by.y));
}

Vector2 Vector2::limit_length(const real_t p_len) const {
	const real_t l = length();
	Vector2 v = *this;
	if (l > 0 && p_len < l) {
		v /= l;
		v *= p_len;
	}

	return v;
}

Vector2 Vector2::move_toward(const Vector2 &p_to, const real_t p_delta) const {
	Vector2 v = *this;
	Vector2 vd = p_to - v;
	real_t len = vd.length();
	return len <= p_delta || len < (real_t)CMP_EPSILON ? p_to : v + vd / len * p_delta;
}

// slide returns the component of the vector along the given plane, specified by its normal vector.
Vector2 Vector2::slide(const Vector2 &p_normal) const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!p_normal.is_normalized(), Vector2(), "The normal Vector2 must be normalized.");
#endif
	return *this - p_normal * this->dot(p_normal);
}

Vector2 Vector2::bounce(const Vector2 &p_normal) const {
	return -reflect(p_normal);
}

Vector2 Vector2::reflect(const Vector2 &p_normal) const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!p_normal.is_normalized(), Vector2(), "The normal Vector2 must be normalized.");
#endif
	return 2 * p_normal * this->dot(p_normal) - *this;
}

bool Vector2::is_equal_approx(const Vector2 &p_v) const {
	return Math::is_equal_approx(x, p_v.x) && Math::is_equal_approx(y, p_v.y);
}

bool Vector2::is_zero_approx() const {
	return Math::is_zero_approx(x) && Math::is_zero_approx(y);
}

Vector2::operator String() const {
	return "(" + String::num_real(x) + ", " + String::num_real(y) + ")";
}

Vector2::operator Vector2i() const {
	return Vector2i(x, y);
}
#line 0

#line 1 "sfw/core/basis.cpp"
/*************************************************************************/
/*  basis.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#define cofac(row1, col1, row2, col2) \
	(rows[row1][col1] * rows[row2][col2] - rows[row1][col2] * rows[row2][col1])

void Basis::from_z(const Vector3 &p_z) {
	if (Math::abs(p_z.z) > (real_t)Math_SQRT12) {
		// choose p in y-z plane
		real_t a = p_z[1] * p_z[1] + p_z[2] * p_z[2];
		real_t k = 1 / Math::sqrt(a);
		rows[0] = Vector3(0, -p_z[2] * k, p_z[1] * k);
		rows[1] = Vector3(a * k, -p_z[0] * rows[0][2], p_z[0] * rows[0][1]);
	} else {
		// choose p in x-y plane
		real_t a = p_z.x * p_z.x + p_z.y * p_z.y;
		real_t k = 1 / Math::sqrt(a);
		rows[0] = Vector3(-p_z.y * k, p_z.x * k, 0);
		rows[1] = Vector3(-p_z.z * rows[0].y, p_z.z * rows[0].x, a * k);
	}
	rows[2] = p_z;
}

void Basis::invert() {
	real_t co[3] = {
		cofac(1, 1, 2, 2), cofac(1, 2, 2, 0), cofac(1, 0, 2, 1)
	};
	real_t det = rows[0][0] * co[0] +
			rows[0][1] * co[1] +
			rows[0][2] * co[2];
#ifdef MATH_CHECKS
	ERR_FAIL_COND(det == 0);
#endif
	real_t s = 1 / det;

	set(co[0] * s, cofac(0, 2, 2, 1) * s, cofac(0, 1, 1, 2) * s,
			co[1] * s, cofac(0, 0, 2, 2) * s, cofac(0, 2, 1, 0) * s,
			co[2] * s, cofac(0, 1, 2, 0) * s, cofac(0, 0, 1, 1) * s);
}

void Basis::orthonormalize() {
	// Gram-Schmidt Process

	Vector3 x = get_column(0);
	Vector3 y = get_column(1);
	Vector3 z = get_column(2);

	x.normalize();
	y = (y - x * (x.dot(y)));
	y.normalize();
	z = (z - x * (x.dot(z)) - y * (y.dot(z)));
	z.normalize();

	set_column(0, x);
	set_column(1, y);
	set_column(2, z);
}

Basis Basis::orthonormalized() const {
	Basis c = *this;
	c.orthonormalize();
	return c;
}

bool Basis::is_orthogonal() const {
	Basis identity;
	Basis m = (*this) * transposed();

	return m.is_equal_approx(identity);
}

void Basis::orthogonalize() {
	Vector3 scl = get_scale();
	orthonormalize();
	scale_local(scl);
}

Basis Basis::orthogonalized() const {
	Basis c = *this;
	c.orthogonalize();
	return c;
}

bool Basis::is_diagonal() const {
	return (
			Math::is_zero_approx(rows[0][1]) && Math::is_zero_approx(rows[0][2]) &&
			Math::is_zero_approx(rows[1][0]) && Math::is_zero_approx(rows[1][2]) &&
			Math::is_zero_approx(rows[2][0]) && Math::is_zero_approx(rows[2][1]));
}

bool Basis::is_rotation() const {
	return Math::is_equal_approx(determinant(), 1, (real_t)UNIT_EPSILON) && is_orthogonal();
}

bool Basis::is_symmetric() const {
	if (!Math::is_equal_approx_ratio(rows[0][1], rows[1][0], (real_t)UNIT_EPSILON)) {
		return false;
	}
	if (!Math::is_equal_approx_ratio(rows[0][2], rows[2][0], (real_t)UNIT_EPSILON)) {
		return false;
	}
	if (!Math::is_equal_approx_ratio(rows[1][2], rows[2][1], (real_t)UNIT_EPSILON)) {
		return false;
	}

	return true;
}

Basis Basis::diagonalize() {
//NOTE: only implemented for symmetric matrices
//with the Jacobi iterative method method
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V(!is_symmetric(), Basis());
#endif
	const int ite_max = 1024;

	real_t off_matrix_norm_2 = rows[0][1] * rows[0][1] + rows[0][2] * rows[0][2] + rows[1][2] * rows[1][2];

	int ite = 0;
	Basis acc_rot;
	while (off_matrix_norm_2 > (real_t)CMP_EPSILON2 && ite++ < ite_max) {
		real_t el01_2 = rows[0][1] * rows[0][1];
		real_t el02_2 = rows[0][2] * rows[0][2];
		real_t el12_2 = rows[1][2] * rows[1][2];
		// Find the pivot element
		int i, j;
		if (el01_2 > el02_2) {
			if (el12_2 > el01_2) {
				i = 1;
				j = 2;
			} else {
				i = 0;
				j = 1;
			}
		} else {
			if (el12_2 > el02_2) {
				i = 1;
				j = 2;
			} else {
				i = 0;
				j = 2;
			}
		}

		// Compute the rotation angle
		real_t angle;
		if (Math::is_equal_approx(rows[j][j], rows[i][i])) {
			angle = Math_PI / 4;
		} else {
			angle = 0.5f * Math::atan(2 * rows[i][j] / (rows[j][j] - rows[i][i]));
		}

		// Compute the rotation matrix
		Basis rot;
		rot.rows[i][i] = rot.rows[j][j] = Math::cos(angle);
		rot.rows[i][j] = -(rot.rows[j][i] = Math::sin(angle));

		// Update the off matrix norm
		off_matrix_norm_2 -= rows[i][j] * rows[i][j];

		// Apply the rotation
		*this = rot * *this * rot.transposed();
		acc_rot = rot * acc_rot;
	}

	return acc_rot;
}

Basis Basis::inverse() const {
	Basis inv = *this;
	inv.invert();
	return inv;
}

void Basis::transpose() {
	SWAP(rows[0][1], rows[1][0]);
	SWAP(rows[0][2], rows[2][0]);
	SWAP(rows[1][2], rows[2][1]);
}

Basis Basis::transposed() const {
	Basis tr = *this;
	tr.transpose();
	return tr;
}

Basis Basis::from_scale(const Vector3 &p_scale) {
	return Basis(p_scale.x, 0, 0, 0, p_scale.y, 0, 0, 0, p_scale.z);
}

// Multiplies the matrix from left by the scaling matrix: M -> S.M
// See the comment for Basis::rotated for further explanation.
void Basis::scale(const Vector3 &p_scale) {
	rows[0][0] *= p_scale.x;
	rows[0][1] *= p_scale.x;
	rows[0][2] *= p_scale.x;
	rows[1][0] *= p_scale.y;
	rows[1][1] *= p_scale.y;
	rows[1][2] *= p_scale.y;
	rows[2][0] *= p_scale.z;
	rows[2][1] *= p_scale.z;
	rows[2][2] *= p_scale.z;
}

Basis Basis::scaled(const Vector3 &p_scale) const {
	Basis m = *this;
	m.scale(p_scale);
	return m;
}

void Basis::scale_local(const Vector3 &p_scale) {
	// performs a scaling in object-local coordinate system:
	// M -> (M.S.Minv).M = M.S.
	*this = scaled_local(p_scale);
}

Basis Basis::scaled_local(const Vector3 &p_scale) const {
	Basis b;
	b.set_diagonal(p_scale);

	return (*this) * b;
}

void Basis::scale_orthogonal(const Vector3 &p_scale) {
	*this = scaled_orthogonal(p_scale);
}

Basis Basis::scaled_orthogonal(const Vector3 &p_scale) const {
	Basis m = *this;
	Vector3 s = Vector3(-1, -1, -1) + p_scale;
	Vector3 dots;
	Basis b;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			dots[j] += s[i] * Math::abs(m.get_column(i).normalized().dot(b.get_column(j)));
		}
	}
	m.scale_local(Vector3(1, 1, 1) + dots);
	return m;
}

real_t Basis::get_uniform_scale() const {
	return (rows[0].length() + rows[1].length() + rows[2].length()) / 3.0f;
}

void Basis::make_scale_uniform() {
	float l = (rows[0].length() + rows[1].length() + rows[2].length()) / 3.0f;
	for (int i = 0; i < 3; i++) {
		rows[i].normalize();
		rows[i] *= l;
	}
}

Vector3 Basis::get_scale_abs() const {
	return Vector3(
			Vector3(rows[0][0], rows[1][0], rows[2][0]).length(),
			Vector3(rows[0][1], rows[1][1], rows[2][1]).length(),
			Vector3(rows[0][2], rows[1][2], rows[2][2]).length());
}

Vector3 Basis::get_scale_local() const {
	real_t det_sign = SGN(determinant());
	return det_sign * Vector3(rows[0].length(), rows[1].length(), rows[2].length());
}

// get_scale works with get_rotation, use get_scale_abs if you need to enforce positive signature.
Vector3 Basis::get_scale() const {
	// FIXME: We are assuming M = R.S (R is rotation and S is scaling), and use polar decomposition to extract R and S.
	// A polar decomposition is M = O.P, where O is an orthogonal matrix (meaning rotation and reflection) and
	// P is a positive semi-definite matrix (meaning it contains absolute values of scaling along its diagonal).
	//
	// Despite being different from what we want to achieve, we can nevertheless make use of polar decomposition
	// here as follows. We can split O into a rotation and a reflection as O = R.Q, and obtain M = R.S where
	// we defined S = Q.P. Now, R is a proper rotation matrix and S is a (signed) scaling matrix,
	// which can involve negative scalings. However, there is a catch: unlike the polar decomposition of M = O.P,
	// the decomposition of O into a rotation and reflection matrix as O = R.Q is not unique.
	// Therefore, we are going to do this decomposition by sticking to a particular convention.
	// This may lead to confusion for some users though.
	//
	// The convention we use here is to absorb the sign flip into the scaling matrix.
	// The same convention is also used in other similar functions such as get_rotation_axis_angle, get_rotation, ...
	//
	// A proper way to get rid of this issue would be to store the scaling values (or at least their signs)
	// as a part of Basis. However, if we go that path, we need to disable direct (write) access to the
	// matrix rows.
	//
	// The rotation part of this decomposition is returned by get_rotation* functions.
	real_t det_sign = SGN(determinant());
	return det_sign * get_scale_abs();
}

// Decomposes a Basis into a rotation-reflection matrix (an element of the group O(3)) and a positive scaling matrix as B = O.S.
// Returns the rotation-reflection matrix via reference argument, and scaling information is returned as a Vector3.
// This (internal) function is too specific and named too ugly to expose to users, and probably there's no need to do so.
Vector3 Basis::rotref_posscale_decomposition(Basis &rotref) const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V(determinant() == 0, Vector3());

	Basis m = transposed() * (*this);
	ERR_FAIL_COND_V(!m.is_diagonal(), Vector3());
#endif
	Vector3 scale = get_scale();
	Basis inv_scale = Basis().scaled(scale.inverse()); // this will also absorb the sign of scale
	rotref = (*this) * inv_scale;

#ifdef MATH_CHECKS
	ERR_FAIL_COND_V(!rotref.is_orthogonal(), Vector3());
#endif
	return scale.abs();
}

// Multiplies the matrix from left by the rotation matrix: M -> R.M
// Note that this does *not* rotate the matrix itself.
//
// The main use of Basis is as Transform.basis, which is used a the transformation matrix
// of 3D object. Rotate here refers to rotation of the object (which is R * (*this)),
// not the matrix itself (which is R * (*this) * R.transposed()).
Basis Basis::rotated(const Vector3 &p_axis, real_t p_phi) const {
	return Basis(p_axis, p_phi) * (*this);
}

void Basis::rotate(const Vector3 &p_axis, real_t p_phi) {
	*this = rotated(p_axis, p_phi);
}

void Basis::rotate_local(const Vector3 &p_axis, real_t p_phi) {
	// performs a rotation in object-local coordinate system:
	// M -> (M.R.Minv).M = M.R.
	*this = rotated_local(p_axis, p_phi);
}
Basis Basis::rotated_local(const Vector3 &p_axis, real_t p_phi) const {
	return (*this) * Basis(p_axis, p_phi);
}

Basis Basis::rotated(const Vector3 &p_euler) const {
	return Basis(p_euler) * (*this);
}

void Basis::rotate(const Vector3 &p_euler) {
	*this = rotated(p_euler);
}

Basis Basis::rotated(const Quaternion &p_quat) const {
	return Basis(p_quat) * (*this);
}

void Basis::rotate(const Quaternion &p_quat) {
	*this = rotated(p_quat);
}

Vector3 Basis::get_rotation_euler() const {
	// Assumes that the matrix can be decomposed into a proper rotation and scaling matrix as M = R.S,
	// and returns the Euler angles corresponding to the rotation part, complementing get_scale().
	// See the comment in get_scale() for further information.
	Basis m = orthonormalized();
	real_t det = m.determinant();
	if (det < 0) {
		// Ensure that the determinant is 1, such that result is a proper rotation matrix which can be represented by Euler angles.
		m.scale(Vector3(-1, -1, -1));
	}

	return m.get_euler();
}

Quaternion Basis::get_rotation_quaternion() const {
	// Assumes that the matrix can be decomposed into a proper rotation and scaling matrix as M = R.S,
	// and returns the Euler angles corresponding to the rotation part, complementing get_scale().
	// See the comment in get_scale() for further information.
	Basis m = orthonormalized();
	real_t det = m.determinant();
	if (det < 0) {
		// Ensure that the determinant is 1, such that result is a proper rotation matrix which can be represented by Euler angles.
		m.scale(Vector3(-1, -1, -1));
	}

	return m.get_quaternion();
}

void Basis::rotate_to_align(const Vector3 &p_start_direction, const Vector3 &p_end_direction) {
	// Takes two vectors and rotates the basis from the first vector to the second vector.
	// Adopted from: https://gist.github.com/kevinmoran/b45980723e53edeb8a5a43c49f134724
	const Vector3 axis = p_start_direction.cross(p_end_direction).normalized();
	if (axis.length_squared() != 0) {
		real_t dot = p_start_direction.dot(p_end_direction);
		dot = CLAMP(dot, -1.0, 1.0);
		const real_t angle_rads = Math::acos(dot);
		*this = Basis(axis, angle_rads) * (*this);
	}
}

void Basis::get_rotation_axis_angle(Vector3 &p_axis, real_t &p_angle) const {
	// Assumes that the matrix can be decomposed into a proper rotation and scaling matrix as M = R.S,
	// and returns the Euler angles corresponding to the rotation part, complementing get_scale().
	// See the comment in get_scale() for further information.
	Basis m = orthonormalized();
	real_t det = m.determinant();
	if (det < 0) {
		// Ensure that the determinant is 1, such that result is a proper rotation matrix which can be represented by Euler angles.
		m.scale(Vector3(-1, -1, -1));
	}

	m.get_axis_angle(p_axis, p_angle);
}

void Basis::get_rotation_axis_angle_local(Vector3 &p_axis, real_t &p_angle) const {
	// Assumes that the matrix can be decomposed into a proper rotation and scaling matrix as M = R.S,
	// and returns the Euler angles corresponding to the rotation part, complementing get_scale().
	// See the comment in get_scale() for further information.
	Basis m = transposed();
	m.orthonormalize();
	real_t det = m.determinant();
	if (det < 0) {
		// Ensure that the determinant is 1, such that result is a proper rotation matrix which can be represented by Euler angles.
		m.scale(Vector3(-1, -1, -1));
	}

	m.get_axis_angle(p_axis, p_angle);
	p_angle = -p_angle;
}

// get_euler_xyz returns a vector containing the Euler angles in the format
// (a1,a2,a3), where a3 is the angle of the first rotation, and a1 is the last
// (following the convention they are commonly defined in the literature).
//
// The current implementation uses XYZ convention (Z is the first rotation),
// so euler.z is the angle of the (first) rotation around Z axis and so on,
//
// And thus, assuming the matrix is a rotation matrix, this function returns
// the angles in the decomposition R = X(a1).Y(a2).Z(a3) where Z(a) rotates
// around the z-axis by a and so on.
Vector3 Basis::get_euler_xyz() const {
	// Euler angles in XYZ convention.
	// See https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
	//
	// rot =  cy*cz          -cy*sz           sy
	//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
	//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy

	Vector3 euler;
	real_t sy = rows[0][2];
	if (sy < (1 - (real_t)CMP_EPSILON)) {
		if (sy > -(1 - (real_t)CMP_EPSILON)) {
			// is this a pure Y rotation?
			if (rows[1][0] == 0 && rows[0][1] == 0 && rows[1][2] == 0 && rows[2][1] == 0 && rows[1][1] == 1) {
				// return the simplest form (human friendlier in editor and scripts)
				euler.x = 0;
				euler.y = atan2(rows[0][2], rows[0][0]);
				euler.z = 0;
			} else {
				euler.x = Math::atan2(-rows[1][2], rows[2][2]);
				euler.y = Math::asin(sy);
				euler.z = Math::atan2(-rows[0][1], rows[0][0]);
			}
		} else {
			euler.x = Math::atan2(rows[2][1], rows[1][1]);
			euler.y = -Math_PI / 2.0;
			euler.z = 0.0;
		}
	} else {
		euler.x = Math::atan2(rows[2][1], rows[1][1]);
		euler.y = Math_PI / 2.0;
		euler.z = 0.0;
	}
	return euler;
}

// set_euler_xyz expects a vector containing the Euler angles in the format
// (ax,ay,az), where ax is the angle of rotation around x axis,
// and similar for other axes.
// The current implementation uses XYZ convention (Z is the first rotation).
void Basis::set_euler_xyz(const Vector3 &p_euler) {
	real_t c, s;

	c = Math::cos(p_euler.x);
	s = Math::sin(p_euler.x);
	Basis xmat(1, 0, 0, 0, c, -s, 0, s, c);

	c = Math::cos(p_euler.y);
	s = Math::sin(p_euler.y);
	Basis ymat(c, 0, s, 0, 1, 0, -s, 0, c);

	c = Math::cos(p_euler.z);
	s = Math::sin(p_euler.z);
	Basis zmat(c, -s, 0, s, c, 0, 0, 0, 1);

	//optimizer will optimize away all this anyway
	*this = xmat * (ymat * zmat);
}

Vector3 Basis::get_euler_xzy() const {
	// Euler angles in XZY convention.
	// See https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
	//
	// rot =  cz*cy             -sz             cz*sy
	//        sx*sy+cx*cy*sz    cx*cz           cx*sz*sy-cy*sx
	//        cy*sx*sz          cz*sx           cx*cy+sx*sz*sy

	Vector3 euler;
	real_t sz = rows[0][1];
	if (sz < (1 - (real_t)CMP_EPSILON)) {
		if (sz > -(1 - (real_t)CMP_EPSILON)) {
			euler.x = Math::atan2(rows[2][1], rows[1][1]);
			euler.y = Math::atan2(rows[0][2], rows[0][0]);
			euler.z = Math::asin(-sz);
		} else {
			// It's -1
			euler.x = -Math::atan2(rows[1][2], rows[2][2]);
			euler.y = 0.0;
			euler.z = Math_PI / 2.0;
		}
	} else {
		// It's 1
		euler.x = -Math::atan2(rows[1][2], rows[2][2]);
		euler.y = 0.0;
		euler.z = -Math_PI / 2.0;
	}
	return euler;
}

void Basis::set_euler_xzy(const Vector3 &p_euler) {
	real_t c, s;

	c = Math::cos(p_euler.x);
	s = Math::sin(p_euler.x);
	Basis xmat(1, 0, 0, 0, c, -s, 0, s, c);

	c = Math::cos(p_euler.y);
	s = Math::sin(p_euler.y);
	Basis ymat(c, 0, s, 0, 1, 0, -s, 0, c);

	c = Math::cos(p_euler.z);
	s = Math::sin(p_euler.z);
	Basis zmat(c, -s, 0, s, c, 0, 0, 0, 1);

	*this = xmat * zmat * ymat;
}

Vector3 Basis::get_euler_yzx() const {
	// Euler angles in YZX convention.
	// See https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
	//
	// rot =  cy*cz             sy*sx-cy*cx*sz     cx*sy+cy*sz*sx
	//        sz                cz*cx              -cz*sx
	//        -cz*sy            cy*sx+cx*sy*sz     cy*cx-sy*sz*sx

	Vector3 euler;
	real_t sz = rows[1][0];
	if (sz < (1 - (real_t)CMP_EPSILON)) {
		if (sz > -(1 - (real_t)CMP_EPSILON)) {
			euler.x = Math::atan2(-rows[1][2], rows[1][1]);
			euler.y = Math::atan2(-rows[2][0], rows[0][0]);
			euler.z = Math::asin(sz);
		} else {
			// It's -1
			euler.x = Math::atan2(rows[2][1], rows[2][2]);
			euler.y = 0.0;
			euler.z = -Math_PI / 2.0;
		}
	} else {
		// It's 1
		euler.x = Math::atan2(rows[2][1], rows[2][2]);
		euler.y = 0.0;
		euler.z = Math_PI / 2.0;
	}
	return euler;
}

void Basis::set_euler_yzx(const Vector3 &p_euler) {
	real_t c, s;

	c = Math::cos(p_euler.x);
	s = Math::sin(p_euler.x);
	Basis xmat(1, 0, 0, 0, c, -s, 0, s, c);

	c = Math::cos(p_euler.y);
	s = Math::sin(p_euler.y);
	Basis ymat(c, 0, s, 0, 1, 0, -s, 0, c);

	c = Math::cos(p_euler.z);
	s = Math::sin(p_euler.z);
	Basis zmat(c, -s, 0, s, c, 0, 0, 0, 1);

	*this = ymat * zmat * xmat;
}

// get_euler_yxz returns a vector containing the Euler angles in the YXZ convention,
// as in first-Z, then-X, last-Y. The angles for X, Y, and Z rotations are returned
// as the x, y, and z components of a Vector3 respectively.
Vector3 Basis::get_euler_yxz() const {
	// Euler angles in YXZ convention.
	// See https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
	//
	// rot =  cy*cz+sy*sx*sz    cz*sy*sx-cy*sz        cx*sy
	//        cx*sz             cx*cz                 -sx
	//        cy*sx*sz-cz*sy    cy*cz*sx+sy*sz        cy*cx

	Vector3 euler;

	real_t m12 = rows[1][2];

	if (m12 < (1 - (real_t)CMP_EPSILON)) {
		if (m12 > -(1 - (real_t)CMP_EPSILON)) {
			// is this a pure X rotation?
			if (rows[1][0] == 0 && rows[0][1] == 0 && rows[0][2] == 0 && rows[2][0] == 0 && rows[0][0] == 1) {
				// return the simplest form (human friendlier in editor and scripts)
				euler.x = atan2(-m12, rows[1][1]);
				euler.y = 0;
				euler.z = 0;
			} else {
				euler.x = asin(-m12);
				euler.y = atan2(rows[0][2], rows[2][2]);
				euler.z = atan2(rows[1][0], rows[1][1]);
			}
		} else { // m12 == -1
			euler.x = Math_PI * 0.5;
			euler.y = atan2(rows[0][1], rows[0][0]);
			euler.z = 0;
		}
	} else { // m12 == 1
		euler.x = -Math_PI * 0.5;
		euler.y = -atan2(rows[0][1], rows[0][0]);
		euler.z = 0;
	}

	return euler;
}

// set_euler_yxz expects a vector containing the Euler angles in the format
// (ax,ay,az), where ax is the angle of rotation around x axis,
// and similar for other axes.
// The current implementation uses YXZ convention (Z is the first rotation).
void Basis::set_euler_yxz(const Vector3 &p_euler) {
	real_t c, s;

	c = Math::cos(p_euler.x);
	s = Math::sin(p_euler.x);
	Basis xmat(1, 0, 0, 0, c, -s, 0, s, c);

	c = Math::cos(p_euler.y);
	s = Math::sin(p_euler.y);
	Basis ymat(c, 0, s, 0, 1, 0, -s, 0, c);

	c = Math::cos(p_euler.z);
	s = Math::sin(p_euler.z);
	Basis zmat(c, -s, 0, s, c, 0, 0, 0, 1);

	//optimizer will optimize away all this anyway
	*this = ymat * xmat * zmat;
}

Vector3 Basis::get_euler_zxy() const {
	// Euler angles in ZXY convention.
	// See https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
	//
	// rot =  cz*cy-sz*sx*sy    -cx*sz                cz*sy+cy*sz*sx
	//        cy*sz+cz*sx*sy    cz*cx                 sz*sy-cz*cy*sx
	//        -cx*sy            sx                    cx*cy
	Vector3 euler;
	real_t sx = rows[2][1];
	if (sx < (1 - (real_t)CMP_EPSILON)) {
		if (sx > -(1 - (real_t)CMP_EPSILON)) {
			euler.x = Math::asin(sx);
			euler.y = Math::atan2(-rows[2][0], rows[2][2]);
			euler.z = Math::atan2(-rows[0][1], rows[1][1]);
		} else {
			// It's -1
			euler.x = -Math_PI / 2.0;
			euler.y = Math::atan2(rows[0][2], rows[0][0]);
			euler.z = 0;
		}
	} else {
		// It's 1
		euler.x = Math_PI / 2.0;
		euler.y = Math::atan2(rows[0][2], rows[0][0]);
		euler.z = 0;
	}
	return euler;
}

void Basis::set_euler_zxy(const Vector3 &p_euler) {
	real_t c, s;

	c = Math::cos(p_euler.x);
	s = Math::sin(p_euler.x);
	Basis xmat(1, 0, 0, 0, c, -s, 0, s, c);

	c = Math::cos(p_euler.y);
	s = Math::sin(p_euler.y);
	Basis ymat(c, 0, s, 0, 1, 0, -s, 0, c);

	c = Math::cos(p_euler.z);
	s = Math::sin(p_euler.z);
	Basis zmat(c, -s, 0, s, c, 0, 0, 0, 1);

	*this = zmat * xmat * ymat;
}

Vector3 Basis::get_euler_zyx() const {
	// Euler angles in ZYX convention.
	// See https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
	//
	// rot =  cz*cy             cz*sy*sx-cx*sz        sz*sx+cz*cx*cy
	//        cy*sz             cz*cx+sz*sy*sx        cx*sz*sy-cz*sx
	//        -sy               cy*sx                 cy*cx
	Vector3 euler;
	real_t sy = rows[2][0];
	if (sy < (1 - (real_t)CMP_EPSILON)) {
		if (sy > -(1 - (real_t)CMP_EPSILON)) {
			euler.x = Math::atan2(rows[2][1], rows[2][2]);
			euler.y = Math::asin(-sy);
			euler.z = Math::atan2(rows[1][0], rows[0][0]);
		} else {
			// It's -1
			euler.x = 0;
			euler.y = Math_PI / 2.0;
			euler.z = -Math::atan2(rows[0][1], rows[1][1]);
		}
	} else {
		// It's 1
		euler.x = 0;
		euler.y = -Math_PI / 2.0;
		euler.z = -Math::atan2(rows[0][1], rows[1][1]);
	}
	return euler;
}

void Basis::set_euler_zyx(const Vector3 &p_euler) {
	real_t c, s;

	c = Math::cos(p_euler.x);
	s = Math::sin(p_euler.x);
	Basis xmat(1, 0, 0, 0, c, -s, 0, s, c);

	c = Math::cos(p_euler.y);
	s = Math::sin(p_euler.y);
	Basis ymat(c, 0, s, 0, 1, 0, -s, 0, c);

	c = Math::cos(p_euler.z);
	s = Math::sin(p_euler.z);
	Basis zmat(c, -s, 0, s, c, 0, 0, 0, 1);

	*this = zmat * ymat * xmat;
}

bool Basis::is_equal_approx(const Basis &p_basis) const {
	return rows[0].is_equal_approx(p_basis.rows[0]) && rows[1].is_equal_approx(p_basis.rows[1]) && rows[2].is_equal_approx(p_basis.rows[2]);
}

bool Basis::is_equal_approx_ratio(const Basis &a, const Basis &b, real_t p_epsilon) const {
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			if (!Math::is_equal_approx_ratio(a.rows[i][j], b.rows[i][j], p_epsilon)) {
				return false;
			}
		}
	}

	return true;
}

bool Basis::operator==(const Basis &p_matrix) const {
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			if (rows[i][j] != p_matrix.rows[i][j]) {
				return false;
			}
		}
	}

	return true;
}

bool Basis::operator!=(const Basis &p_matrix) const {
	return (!(*this == p_matrix));
}

Basis::operator String() const {
	return "[X: " + get_axis(0).operator String() +
			", Y: " + get_axis(1).operator String() +
			", Z: " + get_axis(2).operator String() + "]";
}

Quaternion Basis::get_quaternion() const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!is_rotation(), Quaternion(), "Basis must be normalized in order to be casted to a Quaternion. Use get_rotation_quaternion() or call orthonormalized() if the Basis contains linearly independent vectors.");
#endif
	/* Allow getting a quaternion from an unnormalized transform */
	Basis m = *this;
	real_t trace = m.rows[0][0] + m.rows[1][1] + m.rows[2][2];
	real_t temp[4];

	if (trace > 0) {
		real_t s = Math::sqrt(trace + 1);
		temp[3] = (s * 0.5f);
		s = 0.5f / s;

		temp[0] = ((m.rows[2][1] - m.rows[1][2]) * s);
		temp[1] = ((m.rows[0][2] - m.rows[2][0]) * s);
		temp[2] = ((m.rows[1][0] - m.rows[0][1]) * s);
	} else {
		int i = m.rows[0][0] < m.rows[1][1]
				? (m.rows[1][1] < m.rows[2][2] ? 2 : 1)
				: (m.rows[0][0] < m.rows[2][2] ? 2 : 0);
		int j = (i + 1) % 3;
		int k = (i + 2) % 3;

		real_t s = Math::sqrt(m.rows[i][i] - m.rows[j][j] - m.rows[k][k] + 1);
		temp[i] = s * 0.5f;
		s = 0.5f / s;

		temp[3] = (m.rows[k][j] - m.rows[j][k]) * s;
		temp[j] = (m.rows[j][i] + m.rows[i][j]) * s;
		temp[k] = (m.rows[k][i] + m.rows[i][k]) * s;
	}

	return Quaternion(temp[0], temp[1], temp[2], temp[3]);
}

static const Basis _ortho_bases[24] = {
	Basis(1, 0, 0, 0, 1, 0, 0, 0, 1),
	Basis(0, -1, 0, 1, 0, 0, 0, 0, 1),
	Basis(-1, 0, 0, 0, -1, 0, 0, 0, 1),
	Basis(0, 1, 0, -1, 0, 0, 0, 0, 1),
	Basis(1, 0, 0, 0, 0, -1, 0, 1, 0),
	Basis(0, 0, 1, 1, 0, 0, 0, 1, 0),
	Basis(-1, 0, 0, 0, 0, 1, 0, 1, 0),
	Basis(0, 0, -1, -1, 0, 0, 0, 1, 0),
	Basis(1, 0, 0, 0, -1, 0, 0, 0, -1),
	Basis(0, 1, 0, 1, 0, 0, 0, 0, -1),
	Basis(-1, 0, 0, 0, 1, 0, 0, 0, -1),
	Basis(0, -1, 0, -1, 0, 0, 0, 0, -1),
	Basis(1, 0, 0, 0, 0, 1, 0, -1, 0),
	Basis(0, 0, -1, 1, 0, 0, 0, -1, 0),
	Basis(-1, 0, 0, 0, 0, -1, 0, -1, 0),
	Basis(0, 0, 1, -1, 0, 0, 0, -1, 0),
	Basis(0, 0, 1, 0, 1, 0, -1, 0, 0),
	Basis(0, -1, 0, 0, 0, 1, -1, 0, 0),
	Basis(0, 0, -1, 0, -1, 0, -1, 0, 0),
	Basis(0, 1, 0, 0, 0, -1, -1, 0, 0),
	Basis(0, 0, 1, 0, -1, 0, 1, 0, 0),
	Basis(0, 1, 0, 0, 0, 1, 1, 0, 0),
	Basis(0, 0, -1, 0, 1, 0, 1, 0, 0),
	Basis(0, -1, 0, 0, 0, -1, 1, 0, 0)
};

int Basis::get_orthogonal_index() const {
	//could be sped up if i come up with a way
	Basis orth = *this;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			real_t v = orth[i][j];
			if (v > 0.5f) {
				v = 1;
			} else if (v < -0.5f) {
				v = -1;
			} else {
				v = 0;
			}

			orth[i][j] = v;
		}
	}

	for (int i = 0; i < 24; i++) {
		if (_ortho_bases[i] == orth) {
			return i;
		}
	}

	return 0;
}

void Basis::set_orthogonal_index(int p_index) {
	//there only exist 24 orthogonal bases in r3
	ERR_FAIL_INDEX(p_index, 24);

	*this = _ortho_bases[p_index];
}

void Basis::get_axis_angle(Vector3 &r_axis, real_t &r_angle) const {
	/* checking this is a bad idea, because obtaining from scaled transform is a valid use case
#ifdef MATH_CHECKS
	ERR_FAIL_COND(!is_rotation());
#endif
	*/

	// https://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	real_t x, y, z; // Variables for result.
	if (Math::is_zero_approx(rows[0][1] - rows[1][0]) && Math::is_zero_approx(rows[0][2] - rows[2][0]) && Math::is_zero_approx(rows[1][2] - rows[2][1])) {
		// Singularity found.
		// First check for identity matrix which must have +1 for all terms in leading diagonal and zero in other terms.
		if (is_diagonal() && (Math::abs(rows[0][0] + rows[1][1] + rows[2][2] - 3) < 3 * CMP_EPSILON)) {
			// This singularity is identity matrix so angle = 0.

			r_axis = Vector3(0, 1, 0);
			r_angle = 0;
			return;
		}

		// Otherwise this singularity is angle = 180
		real_t xx = (rows[0][0] + 1) / 2;
		real_t yy = (rows[1][1] + 1) / 2;
		real_t zz = (rows[2][2] + 1) / 2;
		real_t xy = (rows[0][1] + rows[1][0]) / 4;
		real_t xz = (rows[0][2] + rows[2][0]) / 4;
		real_t yz = (rows[1][2] + rows[2][1]) / 4;

		if ((xx > yy) && (xx > zz)) { // rows[0][0] is the largest diagonal term.
			if (xx < CMP_EPSILON) {
				x = 0;
				y = Math_SQRT12;
				z = Math_SQRT12;
			} else {
				x = Math::sqrt(xx);
				y = xy / x;
				z = xz / x;
			}
		} else if (yy > zz) { // rows[1][1] is the largest diagonal term.
			if (yy < CMP_EPSILON) {
				x = Math_SQRT12;
				y = 0;
				z = Math_SQRT12;
			} else {
				y = Math::sqrt(yy);
				x = xy / y;
				z = yz / y;
			}
		} else { // rows[2][2] is the largest diagonal term so base result on this.
			if (zz < CMP_EPSILON) {
				x = Math_SQRT12;
				y = Math_SQRT12;
				z = 0;
			} else {
				z = Math::sqrt(zz);
				x = xz / z;
				y = yz / z;
			}
		}
		r_axis = Vector3(x, y, z);
		r_angle = Math_PI;
		return;
	}

	// As we have reached here there are no singularities so we can handle normally
	real_t s = Math::sqrt((rows[2][1] - rows[1][2]) * (rows[2][1] - rows[1][2]) + (rows[0][2] - rows[2][0]) * (rows[0][2] - rows[2][0]) + (rows[1][0] - rows[0][1]) * (rows[1][0] - rows[0][1])); // Used to normalise.

	if (Math::abs(s) < CMP_EPSILON) {
		// Prevent divide by zero, should not happen if matrix is orthogonal and should be caught by singularity test above.
		s = 1;
	}

	x = (rows[2][1] - rows[1][2]) / s;
	y = (rows[0][2] - rows[2][0]) / s;
	z = (rows[1][0] - rows[0][1]) / s;

	r_axis = Vector3(x, y, z);
	// acos does clamping.
	r_angle = Math::acos((rows[0][0] + rows[1][1] + rows[2][2] - 1) / 2);
}

void Basis::set_quaternion(const Quaternion &p_quat) {
	real_t d = p_quat.length_squared();
	real_t s = 2 / d;
	real_t xs = p_quat.x * s, ys = p_quat.y * s, zs = p_quat.z * s;
	real_t wx = p_quat.w * xs, wy = p_quat.w * ys, wz = p_quat.w * zs;
	real_t xx = p_quat.x * xs, xy = p_quat.x * ys, xz = p_quat.x * zs;
	real_t yy = p_quat.y * ys, yz = p_quat.y * zs, zz = p_quat.z * zs;
	set(1 - (yy + zz), xy - wz, xz + wy,
			xy + wz, 1 - (xx + zz), yz - wx,
			xz - wy, yz + wx, 1 - (xx + yy));
}

void Basis::set_axis_angle(const Vector3 &p_axis, real_t p_phi) {
// Rotation matrix from axis and angle, see https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_angle
#ifdef MATH_CHECKS
	ERR_FAIL_COND_MSG(!p_axis.is_normalized(), "The axis Vector3 must be normalized.");
#endif
	Vector3 axis_sq(p_axis.x * p_axis.x, p_axis.y * p_axis.y, p_axis.z * p_axis.z);
	real_t cosine = Math::cos(p_phi);
	rows[0][0] = axis_sq.x + cosine * (1 - axis_sq.x);
	rows[1][1] = axis_sq.y + cosine * (1 - axis_sq.y);
	rows[2][2] = axis_sq.z + cosine * (1 - axis_sq.z);

	real_t sine = Math::sin(p_phi);
	real_t t = 1 - cosine;

	real_t xyzt = p_axis.x * p_axis.y * t;
	real_t zyxs = p_axis.z * sine;
	rows[0][1] = xyzt - zyxs;
	rows[1][0] = xyzt + zyxs;

	xyzt = p_axis.x * p_axis.z * t;
	zyxs = p_axis.y * sine;
	rows[0][2] = xyzt + zyxs;
	rows[2][0] = xyzt - zyxs;

	xyzt = p_axis.y * p_axis.z * t;
	zyxs = p_axis.x * sine;
	rows[1][2] = xyzt - zyxs;
	rows[2][1] = xyzt + zyxs;
}

void Basis::set_axis_angle_scale(const Vector3 &p_axis, real_t p_phi, const Vector3 &p_scale) {
	set_diagonal(p_scale);
	rotate(p_axis, p_phi);
}

void Basis::set_euler_scale(const Vector3 &p_euler, const Vector3 &p_scale) {
	set_diagonal(p_scale);
	rotate(p_euler);
}

void Basis::set_quaternion_scale(const Quaternion &p_quat, const Vector3 &p_scale) {
	set_diagonal(p_scale);
	rotate(p_quat);
}

void Basis::set_diagonal(const Vector3 &p_diag) {
	rows[0][0] = p_diag.x;
	rows[0][1] = 0;
	rows[0][2] = 0;

	rows[1][0] = 0;
	rows[1][1] = p_diag.y;
	rows[1][2] = 0;

	rows[2][0] = 0;
	rows[2][1] = 0;
	rows[2][2] = p_diag.z;
}

Basis Basis::slerp(const Basis &p_to, const real_t &p_weight) const {
	//consider scale
	Quaternion from(*this);
	Quaternion to(p_to);

	Basis b(from.slerp(to, p_weight));
	b.rows[0] *= Math::lerp(rows[0].length(), p_to.rows[0].length(), p_weight);
	b.rows[1] *= Math::lerp(rows[1].length(), p_to.rows[1].length(), p_weight);
	b.rows[2] *= Math::lerp(rows[2].length(), p_to.rows[2].length(), p_weight);

	return b;
}

void Basis::rotate_sh(real_t *p_values) {
	// code by John Hable
	// http://filmicworlds.com/blog/simple-and-fast-spherical-harmonic-rotation/
	// this code is Public Domain

	const static real_t s_c3 = 0.94617469575; // (3*sqrt(5))/(4*sqrt(pi))
	const static real_t s_c4 = -0.31539156525; // (-sqrt(5))/(4*sqrt(pi))
	const static real_t s_c5 = 0.54627421529; // (sqrt(15))/(4*sqrt(pi))

	const static real_t s_c_scale = 1.0 / 0.91529123286551084;
	const static real_t s_c_scale_inv = 0.91529123286551084;

	const static real_t s_rc2 = 1.5853309190550713 * s_c_scale;
	const static real_t s_c4_div_c3 = s_c4 / s_c3;
	const static real_t s_c4_div_c3_x2 = (s_c4 / s_c3) * 2.0;

	const static real_t s_scale_dst2 = s_c3 * s_c_scale_inv;
	const static real_t s_scale_dst4 = s_c5 * s_c_scale_inv;

	const real_t src[9] = { p_values[0], p_values[1], p_values[2], p_values[3], p_values[4], p_values[5], p_values[6], p_values[7], p_values[8] };

	real_t m00 = rows[0][0];
	real_t m01 = rows[0][1];
	real_t m02 = rows[0][2];
	real_t m10 = rows[1][0];
	real_t m11 = rows[1][1];
	real_t m12 = rows[1][2];
	real_t m20 = rows[2][0];
	real_t m21 = rows[2][1];
	real_t m22 = rows[2][2];

	p_values[0] = src[0];
	p_values[1] = m11 * src[1] - m12 * src[2] + m10 * src[3];
	p_values[2] = -m21 * src[1] + m22 * src[2] - m20 * src[3];
	p_values[3] = m01 * src[1] - m02 * src[2] + m00 * src[3];

	real_t sh0 = src[7] + src[8] + src[8] - src[5];
	real_t sh1 = src[4] + s_rc2 * src[6] + src[7] + src[8];
	real_t sh2 = src[4];
	real_t sh3 = -src[7];
	real_t sh4 = -src[5];

	// Rotations.  R0 and R1 just use the raw matrix columns
	real_t r2x = m00 + m01;
	real_t r2y = m10 + m11;
	real_t r2z = m20 + m21;

	real_t r3x = m00 + m02;
	real_t r3y = m10 + m12;
	real_t r3z = m20 + m22;

	real_t r4x = m01 + m02;
	real_t r4y = m11 + m12;
	real_t r4z = m21 + m22;

	// dense matrix multiplication one column at a time

	// column 0
	real_t sh0_x = sh0 * m00;
	real_t sh0_y = sh0 * m10;
	real_t d0 = sh0_x * m10;
	real_t d1 = sh0_y * m20;
	real_t d2 = sh0 * (m20 * m20 + s_c4_div_c3);
	real_t d3 = sh0_x * m20;
	real_t d4 = sh0_x * m00 - sh0_y * m10;

	// column 1
	real_t sh1_x = sh1 * m02;
	real_t sh1_y = sh1 * m12;
	d0 += sh1_x * m12;
	d1 += sh1_y * m22;
	d2 += sh1 * (m22 * m22 + s_c4_div_c3);
	d3 += sh1_x * m22;
	d4 += sh1_x * m02 - sh1_y * m12;

	// column 2
	real_t sh2_x = sh2 * r2x;
	real_t sh2_y = sh2 * r2y;
	d0 += sh2_x * r2y;
	d1 += sh2_y * r2z;
	d2 += sh2 * (r2z * r2z + s_c4_div_c3_x2);
	d3 += sh2_x * r2z;
	d4 += sh2_x * r2x - sh2_y * r2y;

	// column 3
	real_t sh3_x = sh3 * r3x;
	real_t sh3_y = sh3 * r3y;
	d0 += sh3_x * r3y;
	d1 += sh3_y * r3z;
	d2 += sh3 * (r3z * r3z + s_c4_div_c3_x2);
	d3 += sh3_x * r3z;
	d4 += sh3_x * r3x - sh3_y * r3y;

	// column 4
	real_t sh4_x = sh4 * r4x;
	real_t sh4_y = sh4 * r4y;
	d0 += sh4_x * r4y;
	d1 += sh4_y * r4z;
	d2 += sh4 * (r4z * r4z + s_c4_div_c3_x2);
	d3 += sh4_x * r4z;
	d4 += sh4_x * r4x - sh4_y * r4y;

	// extra multipliers
	p_values[4] = d0;
	p_values[5] = -d1;
	p_values[6] = d2 * s_scale_dst2;
	p_values[7] = -d3;
	p_values[8] = d4 * s_scale_dst4;
}

Basis Basis::looking_at(const Vector3 &p_target, const Vector3 &p_up, bool p_use_model_front) {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(p_target.is_equal_approx(Vector3()), Basis(), "The target vector can't be zero.");
	ERR_FAIL_COND_V_MSG(p_up.is_equal_approx(Vector3()), Basis(), "The up vector can't be zero.");
#endif
	Vector3 v_z = p_target.normalized();

	if (!p_use_model_front) {
		v_z = -v_z;
	}
	Vector3 v_x = p_up.cross(v_z);
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(v_x.is_equal_approx(Vector3()), Basis(), "The target vector and up vector can't be parallel to each other.");
#endif
	v_x.normalize();
	Vector3 v_y = v_z.cross(v_x);

	Basis basis;
	basis.set_columns(v_x, v_y, v_z);
	return basis;
}

#undef cofac
#line 0

#line 1 "sfw/core/face3.cpp"
/*************************************************************************/
/*  face3.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

int Face3::split_by_plane(const Plane &p_plane, Face3 p_res[3], bool p_is_point_over[3]) const {
	ERR_FAIL_COND_V(is_degenerate(), 0);

	Vector3 above[4];
	int above_count = 0;

	Vector3 below[4];
	int below_count = 0;

	for (int i = 0; i < 3; i++) {
		if (p_plane.has_point(vertex[i], (real_t)CMP_EPSILON)) { // point is in plane

			ERR_FAIL_COND_V(above_count >= 4, 0);
			above[above_count++] = vertex[i];
			ERR_FAIL_COND_V(below_count >= 4, 0);
			below[below_count++] = vertex[i];

		} else {
			if (p_plane.is_point_over(vertex[i])) {
				//Point is over
				ERR_FAIL_COND_V(above_count >= 4, 0);
				above[above_count++] = vertex[i];

			} else {
				//Point is under
				ERR_FAIL_COND_V(below_count >= 4, 0);
				below[below_count++] = vertex[i];
			}

			/* Check for Intersection between this and the next vertex*/

			Vector3 inters;
			if (!p_plane.intersects_segment(vertex[i], vertex[(i + 1) % 3], &inters)) {
				continue;
			}

			/* Intersection goes to both */
			ERR_FAIL_COND_V(above_count >= 4, 0);
			above[above_count++] = inters;
			ERR_FAIL_COND_V(below_count >= 4, 0);
			below[below_count++] = inters;
		}
	}

	int polygons_created = 0;

	ERR_FAIL_COND_V(above_count >= 4 && below_count >= 4, 0); //bug in the algo

	if (above_count >= 3) {
		p_res[polygons_created] = Face3(above[0], above[1], above[2]);
		p_is_point_over[polygons_created] = true;
		polygons_created++;

		if (above_count == 4) {
			p_res[polygons_created] = Face3(above[2], above[3], above[0]);
			p_is_point_over[polygons_created] = true;
			polygons_created++;
		}
	}

	if (below_count >= 3) {
		p_res[polygons_created] = Face3(below[0], below[1], below[2]);
		p_is_point_over[polygons_created] = false;
		polygons_created++;

		if (below_count == 4) {
			p_res[polygons_created] = Face3(below[2], below[3], below[0]);
			p_is_point_over[polygons_created] = false;
			polygons_created++;
		}
	}

	return polygons_created;
}

bool Face3::intersects_ray(const Vector3 &p_from, const Vector3 &p_dir, Vector3 *p_intersection) const {
	//return Geometry::ray_intersects_triangle(p_from, p_dir, vertex[0], vertex[1], vertex[2], p_intersection);
	return false;
}

bool Face3::intersects_segment(const Vector3 &p_from, const Vector3 &p_dir, Vector3 *p_intersection) const {
	//return Geometry::segment_intersects_triangle(p_from, p_dir, vertex[0], vertex[1], vertex[2], p_intersection);
	return false;
}

bool Face3::is_degenerate() const {
	Vector3 normal = vec3_cross(vertex[0] - vertex[1], vertex[0] - vertex[2]);
	return (normal.length_squared() < (real_t)CMP_EPSILON2);
}

Face3::Side Face3::get_side_of(const Face3 &p_face, ClockDirection p_clock_dir) const {
	int over = 0, under = 0;

	Plane plane = get_plane(p_clock_dir);

	for (int i = 0; i < 3; i++) {
		const Vector3 &v = p_face.vertex[i];

		if (plane.has_point(v)) { //coplanar, don't bother
			continue;
		}

		if (plane.is_point_over(v)) {
			over++;
		} else {
			under++;
		}
	}

	if (over > 0 && under == 0) {
		return SIDE_OVER;
	} else if (under > 0 && over == 0) {
		return SIDE_UNDER;
	} else if (under == 0 && over == 0) {
		return SIDE_COPLANAR;
	} else {
		return SIDE_SPANNING;
	}
}

Vector3 Face3::get_random_point_inside() const {
	real_t a = Math::random(0, 1);
	real_t b = Math::random(0, 1);
	if (a > b) {
		SWAP(a, b);
	}

	return vertex[0] * a + vertex[1] * (b - a) + vertex[2] * (1.0 - b);
}

Plane Face3::get_plane(ClockDirection p_dir) const {
	return Plane(vertex[0], vertex[1], vertex[2], p_dir);
}

Vector3 Face3::get_median_point() const {
	return (vertex[0] + vertex[1] + vertex[2]) / 3.0;
}

real_t Face3::get_area() const {
	return vec3_cross(vertex[0] - vertex[1], vertex[0] - vertex[2]).length() * 0.5;
}

ClockDirection Face3::get_clock_dir() const {
	Vector3 normal = vec3_cross(vertex[0] - vertex[1], vertex[0] - vertex[2]);
	//printf("normal is %g,%g,%g x %g,%g,%g- wtfu is %g\n",tofloat(normal.x),tofloat(normal.y),tofloat(normal.z),tofloat(vertex[0].x),tofloat(vertex[0].y),tofloat(vertex[0].z),tofloat( normal.dot( vertex[0] ) ) );
	return (normal.dot(vertex[0]) >= 0) ? CLOCKWISE : COUNTERCLOCKWISE;
}

bool Face3::intersects_aabb(const AABB &p_aabb) const {
	/** TEST PLANE **/
	if (!p_aabb.intersects_plane(get_plane())) {
		return false;
	}

#define TEST_AXIS(m_ax)                                            \
	/** TEST FACE AXIS */                                          \
	{                                                              \
		real_t aabb_min = p_aabb.position.m_ax;                    \
		real_t aabb_max = p_aabb.position.m_ax + p_aabb.size.m_ax; \
		real_t tri_min = vertex[0].m_ax;                           \
		real_t tri_max = vertex[0].m_ax;                           \
		for (int i = 1; i < 3; i++) {                              \
			if (vertex[i].m_ax > tri_max)                          \
				tri_max = vertex[i].m_ax;                          \
			if (vertex[i].m_ax < tri_min)                          \
				tri_min = vertex[i].m_ax;                          \
		}                                                          \
                                                                   \
		if (tri_max < aabb_min || aabb_max < tri_min)              \
			return false;                                          \
	}

	TEST_AXIS(x);
	TEST_AXIS(y);
	TEST_AXIS(z);

	/** TEST ALL EDGES **/

	Vector3 edge_norms[3] = {
		vertex[0] - vertex[1],
		vertex[1] - vertex[2],
		vertex[2] - vertex[0],
	};

	for (int i = 0; i < 12; i++) {
		Vector3 from, to;
		p_aabb.get_edge(i, from, to);
		Vector3 e1 = from - to;
		for (int j = 0; j < 3; j++) {
			Vector3 e2 = edge_norms[j];

			Vector3 axis = vec3_cross(e1, e2);

			if (axis.length_squared() < 0.0001f) {
				continue; // coplanar
			}
			axis.normalize();

			real_t minA, maxA, minB, maxB;
			p_aabb.project_range_in_plane(Plane(axis, 0), minA, maxA);
			project_range(axis, Transform(), minB, maxB);

			if (maxA < minB || maxB < minA) {
				return false;
			}
		}
	}
	return true;
}

Face3::operator String() const {
	return String() + vertex[0] + ", " + vertex[1] + ", " + vertex[2];
}

void Face3::project_range(const Vector3 &p_normal, const Transform &p_transform, real_t &r_min, real_t &r_max) const {
	for (int i = 0; i < 3; i++) {
		Vector3 v = p_transform.xform(vertex[i]);
		real_t d = p_normal.dot(v);

		if (i == 0 || d > r_max) {
			r_max = d;
		}

		if (i == 0 || d < r_min) {
			r_min = d;
		}
	}
}

void Face3::get_support(const Vector3 &p_normal, const Transform &p_transform, Vector3 *p_vertices, int *p_count, int p_max) const {
#define _FACE_IS_VALID_SUPPORT_THRESHOLD 0.98
#define _EDGE_IS_VALID_SUPPORT_THRESHOLD 0.05

	if (p_max <= 0) {
		return;
	}

	Vector3 n = p_transform.basis.xform_inv(p_normal);

	/** TEST FACE AS SUPPORT **/
	if (get_plane().normal.dot(n) > (real_t)_FACE_IS_VALID_SUPPORT_THRESHOLD) {
		*p_count = MIN(3, p_max);

		for (int i = 0; i < *p_count; i++) {
			p_vertices[i] = p_transform.xform(vertex[i]);
		}

		return;
	}

	/** FIND SUPPORT VERTEX **/

	int vert_support_idx = -1;
	real_t support_max = 0;

	for (int i = 0; i < 3; i++) {
		real_t d = n.dot(vertex[i]);

		if (i == 0 || d > support_max) {
			support_max = d;
			vert_support_idx = i;
		}
	}

	/** TEST EDGES AS SUPPORT **/

	for (int i = 0; i < 3; i++) {
		if (i != vert_support_idx && i + 1 != vert_support_idx) {
			continue;
		}

		// check if edge is valid as a support
		real_t dot = (vertex[i] - vertex[(i + 1) % 3]).normalized().dot(n);
		dot = ABS(dot);
		if (dot < (real_t)_EDGE_IS_VALID_SUPPORT_THRESHOLD) {
			*p_count = MIN(2, p_max);

			for (int j = 0; j < *p_count; j++) {
				p_vertices[j] = p_transform.xform(vertex[(j + i) % 3]);
			}

			return;
		}
	}

	*p_count = 1;
	p_vertices[0] = p_transform.xform(vertex[vert_support_idx]);
}

Vector3 Face3::get_closest_point_to(const Vector3 &p_point) const {
	Vector3 edge0 = vertex[1] - vertex[0];
	Vector3 edge1 = vertex[2] - vertex[0];
	Vector3 v0 = vertex[0] - p_point;

	real_t a = edge0.dot(edge0);
	real_t b = edge0.dot(edge1);
	real_t c = edge1.dot(edge1);
	real_t d = edge0.dot(v0);
	real_t e = edge1.dot(v0);

	real_t det = a * c - b * b;
	real_t s = b * e - c * d;
	real_t t = b * d - a * e;

	if (s + t < det) {
		if (s < 0.f) {
			if (t < 0.f) {
				if (d < 0.f) {
					s = CLAMP(-d / a, 0.f, 1.f);
					t = 0.f;
				} else {
					s = 0.f;
					t = CLAMP(-e / c, 0.f, 1.f);
				}
			} else {
				s = 0.f;
				t = CLAMP(-e / c, 0.f, 1.f);
			}
		} else if (t < 0.f) {
			s = CLAMP(-d / a, 0.f, 1.f);
			t = 0.f;
		} else {
			real_t invDet = 1.f / det;
			s *= invDet;
			t *= invDet;
		}
	} else {
		if (s < 0.f) {
			real_t tmp0 = b + d;
			real_t tmp1 = c + e;
			if (tmp1 > tmp0) {
				real_t numer = tmp1 - tmp0;
				real_t denom = a - 2 * b + c;
				s = CLAMP(numer / denom, 0.f, 1.f);
				t = 1 - s;
			} else {
				t = CLAMP(-e / c, 0.f, 1.f);
				s = 0.f;
			}
		} else if (t < 0.f) {
			if (a + d > b + e) {
				real_t numer = c + e - b - d;
				real_t denom = a - 2 * b + c;
				s = CLAMP(numer / denom, 0.f, 1.f);
				t = 1 - s;
			} else {
				s = CLAMP(-d / a, 0.f, 1.f);
				t = 0.f;
			}
		} else {
			real_t numer = c + e - b - d;
			real_t denom = a - 2 * b + c;
			s = CLAMP(numer / denom, 0.f, 1.f);
			t = 1.f - s;
		}
	}

	return vertex[0] + s * edge0 + t * edge1;
}
#line 0

#line 1 "sfw/core/vector4i.cpp"
/*************************************************************************/
/*  vector4i.cpp                                                         */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void Vector4i::set_axis(const int p_axis, const int32_t p_value) {
	ERR_FAIL_INDEX(p_axis, 4);
	coord[p_axis] = p_value;
}

int32_t Vector4i::get_axis(const int p_axis) const {
	ERR_FAIL_INDEX_V(p_axis, 4, 0);
	return operator[](p_axis);
}

Vector4i::Axis Vector4i::min_axis() const {
	uint32_t min_index = 0;
	int32_t min_value = x;
	for (uint32_t i = 1; i < 4; i++) {
		if (operator[](i) <= min_value) {
			min_index = i;
			min_value = operator[](i);
		}
	}
	return Vector4i::Axis(min_index);
}

Vector4i::Axis Vector4i::max_axis() const {
	uint32_t max_index = 0;
	int32_t max_value = x;
	for (uint32_t i = 1; i < 4; i++) {
		if (operator[](i) > max_value) {
			max_index = i;
			max_value = operator[](i);
		}
	}
	return Vector4i::Axis(max_index);
}

Vector4i Vector4i::clamp(const Vector4i &p_min, const Vector4i &p_max) const {
	return Vector4i(
			CLAMP(x, p_min.x, p_max.x),
			CLAMP(y, p_min.y, p_max.y),
			CLAMP(z, p_min.z, p_max.z),
			CLAMP(w, p_min.w, p_max.w));
}

Vector4i Vector4i::linear_interpolate(const Vector4i &p_to, const real_t p_weight) const {
	return Vector4i(
			x + (p_weight * (p_to.x - x)),
			y + (p_weight * (p_to.y - y)),
			z + (p_weight * (p_to.z - z)),
			w + (p_weight * (p_to.w - w)));
}

Vector4 Vector4i::to_vector4() const {
	return Vector4(x, y, z, w);
}

Vector4i::operator String() const {
	return "(" + itos(x) + ", " + itos(y) + ", " + itos(z) + ", " + itos(w) + ")";
}

Vector4i::operator Vector4() const {
	return Vector4(x, y, z, w);
}

/*
Vector4i::Vector4i(const Vector4 &p_vec4) {
	x = p_vec4.x;
	y = p_vec4.y;
	z = p_vec4.z;
	w = p_vec4.w;
}
*/
#line 0

#line 1 "sfw/core/transform.cpp"
/*************************************************************************/
/*  transform.cpp                                                        */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void Transform::invert() {
	basis.transpose();
	origin = basis.xform(-origin);
}

Transform Transform::inverse() const {
	// FIXME: this function assumes the basis is a rotation matrix, with no scaling.
	// Transform::affine_inverse can handle matrices with scaling, so GDScript should eventually use that.
	Transform ret = *this;
	ret.invert();
	return ret;
}

void Transform::affine_invert() {
	basis.invert();
	origin = basis.xform(-origin);
}

Transform Transform::affine_inverse() const {
	Transform ret = *this;
	ret.affine_invert();
	return ret;
}

Transform Transform::rotated(const Vector3 &p_axis, real_t p_angle) const {
	// Equivalent to left multiplication
	Basis p_basis(p_axis, p_angle);
	return Transform(p_basis * basis, p_basis.xform(origin));
}

Transform Transform::rotated_local(const Vector3 &p_axis, real_t p_angle) const {
	// Equivalent to right multiplication
	Basis p_basis(p_axis, p_angle);
	return Transform(basis * p_basis, origin);
}

void Transform::rotate(const Vector3 &p_axis, real_t p_phi) {
	*this = rotated(p_axis, p_phi);
}

void Transform::rotate_local(const Vector3 &p_axis, real_t p_phi) {
	*this = rotated_local(p_axis, p_phi);
}

void Transform::rotate_basis(const Vector3 &p_axis, real_t p_phi) {
	basis.rotate(p_axis, p_phi);
}

void Transform::set_look_at(const Vector3 &p_eye, const Vector3 &p_target, const Vector3 &p_up) {
	basis = Basis::looking_at(p_target - p_eye, p_up);

	origin = p_eye;
}

Transform Transform::looking_at(const Vector3 &p_target, const Vector3 &p_up) const {
	Transform t = *this;
	t.set_look_at(origin, p_target, p_up);
	return t;
}

void Transform::scale(const Vector3 &p_scale) {
	basis.scale(p_scale);
	origin *= p_scale;
}

Transform Transform::scaled(const Vector3 &p_scale) const {
	// Equivalent to left multiplication
	return Transform(basis.scaled(p_scale), origin * p_scale);
}

Transform Transform::scaled_local(const Vector3 &p_scale) const {
	// Equivalent to right multiplication
	return Transform(basis.scaled_local(p_scale), origin);
}

void Transform::scale_basis(const Vector3 &p_scale) {
	basis.scale(p_scale);
}

void Transform::translate_local(real_t p_tx, real_t p_ty, real_t p_tz) {
	translate_local(Vector3(p_tx, p_ty, p_tz));
}
void Transform::translate_local(const Vector3 &p_translation) {
	for (int i = 0; i < 3; i++) {
		origin[i] += basis[i].dot(p_translation);
	}
}

void Transform::translate_localr(real_t p_tx, real_t p_ty, real_t p_tz) {
	translate_local(Vector3(p_tx, p_ty, p_tz));
}
void Transform::translate_localv(const Vector3 &p_translation) {
	for (int i = 0; i < 3; i++) {
		origin[i] += basis[i].dot(p_translation);
	}
}

Transform Transform::translated(const Vector3 &p_translation) const {
	// Equivalent to left multiplication
	return Transform(basis, origin + p_translation);
}

Transform Transform::translated_local(const Vector3 &p_translation) const {
	// Equivalent to right multiplication
	return Transform(basis, origin + basis.xform(p_translation));
}

void Transform::orthonormalize() {
	basis.orthonormalize();
}

Transform Transform::orthonormalized() const {
	Transform _copy = *this;
	_copy.orthonormalize();
	return _copy;
}

void Transform::orthogonalize() {
	basis.orthogonalize();
}

Transform Transform::orthogonalized() const {
	Transform _copy = *this;
	_copy.orthogonalize();
	return _copy;
}

bool Transform::is_equal_approx(const Transform &p_transform) const {
	return basis.is_equal_approx(p_transform.basis) && origin.is_equal_approx(p_transform.origin);
}

bool Transform::operator==(const Transform &p_transform) const {
	return (basis == p_transform.basis && origin == p_transform.origin);
}
bool Transform::operator!=(const Transform &p_transform) const {
	return (basis != p_transform.basis || origin != p_transform.origin);
}

void Transform::operator*=(const Transform &p_transform) {
	origin = xform(p_transform.origin);
	basis *= p_transform.basis;
}

Transform Transform::operator*(const Transform &p_transform) const {
	Transform t = *this;
	t *= p_transform;
	return t;
}

void Transform::operator*=(const real_t p_val) {
	origin *= p_val;
	basis *= p_val;
}

Transform Transform::operator*(const real_t p_val) const {
	Transform ret(*this);
	ret *= p_val;
	return ret;
}

Transform Transform::spherical_interpolate_with(const Transform &p_transform, real_t p_c) const {
	/* not sure if very "efficient" but good enough? */

	Transform interp;

	Vector3 src_scale = basis.get_scale();
	Quaternion src_rot = basis.get_rotation_quaternion();
	Vector3 src_loc = origin;

	Vector3 dst_scale = p_transform.basis.get_scale();
	Quaternion dst_rot = p_transform.basis.get_rotation_quaternion();
	Vector3 dst_loc = p_transform.origin;

	interp.basis.set_quaternion_scale(src_rot.slerp(dst_rot, p_c).normalized(), src_scale.linear_interpolate(dst_scale, p_c));
	interp.origin = src_loc.linear_interpolate(dst_loc, p_c);

	return interp;
}

Transform Transform::interpolate_with(const Transform &p_transform, real_t p_c) const {
	/* not sure if very "efficient" but good enough? */

	Vector3 src_scale = basis.get_scale();
	Quaternion src_rot = basis.get_rotation_quaternion();
	Vector3 src_loc = origin;

	Vector3 dst_scale = p_transform.basis.get_scale();
	Quaternion dst_rot = p_transform.basis.get_rotation_quaternion();
	Vector3 dst_loc = p_transform.origin;

	Transform interp;
	interp.basis.set_quaternion_scale(src_rot.slerp(dst_rot, p_c).normalized(), src_scale.linear_interpolate(dst_scale, p_c));
	interp.origin = src_loc.linear_interpolate(dst_loc, p_c);

	return interp;
}

Transform::operator String() const {
	return "[X: " + basis.get_axis(0).operator String() +
			", Y: " + basis.get_axis(1).operator String() +
			", Z: " + basis.get_axis(2).operator String() +
			", O: " + origin.operator String() + "]";
}

Transform::Transform(const Basis &p_basis, const Vector3 &p_origin) :
		basis(p_basis),
		origin(p_origin) {
}

Transform::Transform(real_t xx, real_t xy, real_t xz, real_t yx, real_t yy, real_t yz, real_t zx, real_t zy, real_t zz, real_t ox, real_t oy, real_t oz) {
	basis = Basis(xx, xy, xz, yx, yy, yz, zx, zy, zz);
	origin = Vector3(ox, oy, oz);
}

Transform::Transform(const Vector3 &p_x, const Vector3 &p_y, const Vector3 &p_z, const Vector3 &p_origin) :
		origin(p_origin) {
	basis.set_column(0, p_x);
	basis.set_column(1, p_y);
	basis.set_column(2, p_z);
}
#line 0

#line 1 "sfw/core/color.cpp"
/*************************************************************************/
/*  color.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

uint32_t Color::to_argb32() const {
	uint32_t c = (uint8_t)Math::round(a * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(r * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(g * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(b * 255);

	return c;
}

uint32_t Color::to_abgr32() const {
	uint32_t c = (uint8_t)Math::round(a * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(b * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(g * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(r * 255);

	return c;
}

uint32_t Color::to_rgba32() const {
	uint32_t c = (uint8_t)Math::round(r * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(g * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(b * 255);
	c <<= 8;
	c |= (uint8_t)Math::round(a * 255);

	return c;
}

uint64_t Color::to_abgr64() const {
	uint64_t c = (uint16_t)Math::round(a * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(b * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(g * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(r * 65535);

	return c;
}

uint64_t Color::to_argb64() const {
	uint64_t c = (uint16_t)Math::round(a * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(r * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(g * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(b * 65535);

	return c;
}

uint64_t Color::to_rgba64() const {
	uint64_t c = (uint16_t)Math::round(r * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(g * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(b * 65535);
	c <<= 16;
	c |= (uint16_t)Math::round(a * 65535);

	return c;
}

float Color::get_h() const {
	float min = MIN(r, g);
	min = MIN(min, b);
	float max = MAX(r, g);
	max = MAX(max, b);

	float delta = max - min;

	if (delta == 0) {
		return 0;
	}

	float h;
	if (r == max) {
		h = (g - b) / delta; // between yellow & magenta
	} else if (g == max) {
		h = 2 + (b - r) / delta; // between cyan & yellow
	} else {
		h = 4 + (r - g) / delta; // between magenta & cyan
	}

	h /= 6.0;
	if (h < 0) {
		h += 1.0;
	}

	return h;
}

float Color::get_s() const {
	float min = MIN(r, g);
	min = MIN(min, b);
	float max = MAX(r, g);
	max = MAX(max, b);

	float delta = max - min;

	return (max != 0) ? (delta / max) : 0;
}

float Color::get_v() const {
	float max = MAX(r, g);
	max = MAX(max, b);
	return max;
}

void Color::set_hsv(float p_h, float p_s, float p_v, float p_alpha) {
	int i;
	float f, p, q, t;
	a = p_alpha;

	if (p_s == 0) {
		// acp_hromatic (grey)
		r = g = b = p_v;
		return;
	}

	p_h *= 6.0;
	p_h = Math::fmod(p_h, 6);
	i = Math::floor(p_h);

	f = p_h - i;
	p = p_v * (1 - p_s);
	q = p_v * (1 - p_s * f);
	t = p_v * (1 - p_s * (1 - f));

	switch (i) {
		case 0: // Red is the dominant color
			r = p_v;
			g = t;
			b = p;
			break;
		case 1: // Green is the dominant color
			r = q;
			g = p_v;
			b = p;
			break;
		case 2:
			r = p;
			g = p_v;
			b = t;
			break;
		case 3: // Blue is the dominant color
			r = p;
			g = q;
			b = p_v;
			break;
		case 4:
			r = t;
			g = p;
			b = p_v;
			break;
		default: // (5) Red is the dominant color
			r = p_v;
			g = p;
			b = q;
			break;
	}
}

bool Color::is_equal_approx(const Color &p_color) const {
	return Math::is_equal_approx(r, p_color.r) && Math::is_equal_approx(g, p_color.g) && Math::is_equal_approx(b, p_color.b) && Math::is_equal_approx(a, p_color.a);
}

Color Color::clamp(const Color &p_min, const Color &p_max) const {
	return Color(
			CLAMP(r, p_min.r, p_max.r),
			CLAMP(g, p_min.g, p_max.g),
			CLAMP(b, p_min.b, p_max.b),
			CLAMP(a, p_min.a, p_max.a));
}

void Color::invert() {
	r = 1.0 - r;
	g = 1.0 - g;
	b = 1.0 - b;
}
void Color::contrast() {
	r = Math::fmod(r + 0.5, 1.0);
	g = Math::fmod(g + 0.5, 1.0);
	b = Math::fmod(b + 0.5, 1.0);
}

Color Color::hex(uint32_t p_hex) {
	float a = (p_hex & 0xFF) / 255.0;
	p_hex >>= 8;
	float b = (p_hex & 0xFF) / 255.0;
	p_hex >>= 8;
	float g = (p_hex & 0xFF) / 255.0;
	p_hex >>= 8;
	float r = (p_hex & 0xFF) / 255.0;

	return Color(r, g, b, a);
}

Color Color::hex64(uint64_t p_hex) {
	float a = (p_hex & 0xFFFF) / 65535.0;
	p_hex >>= 16;
	float b = (p_hex & 0xFFFF) / 65535.0;
	p_hex >>= 16;
	float g = (p_hex & 0xFFFF) / 65535.0;
	p_hex >>= 16;
	float r = (p_hex & 0xFFFF) / 65535.0;

	return Color(r, g, b, a);
}

Color Color::from_rgbe9995(uint32_t p_rgbe) {
	float r = p_rgbe & 0x1ff;
	float g = (p_rgbe >> 9) & 0x1ff;
	float b = (p_rgbe >> 18) & 0x1ff;
	float e = (p_rgbe >> 27);
	float m = Math::pow(2, e - 15.0 - 9.0);

	float rd = r * m;
	float gd = g * m;
	float bd = b * m;

	return Color(rd, gd, bd, 1.0f);
}

static float _parse_col(const String &p_str, int p_ofs) {
	int ig = 0;

	for (int i = 0; i < 2; i++) {
		int c = p_str[i + p_ofs];
		int v = 0;

		if (c >= '0' && c <= '9') {
			v = c - '0';
		} else if (c >= 'a' && c <= 'f') {
			v = c - 'a';
			v += 10;
		} else if (c >= 'A' && c <= 'F') {
			v = c - 'A';
			v += 10;
		} else {
			return -1;
		}

		if (i == 0) {
			ig += v * 16;
		} else {
			ig += v;
		}
	}

	return ig;
}

Color Color::inverted() const {
	Color c = *this;
	c.invert();
	return c;
}

Color Color::contrasted() const {
	Color c = *this;
	c.contrast();
	return c;
}

Color Color::html(const String &p_color) {
	String color = p_color;
	if (color.length() == 0) {
		return Color();
	}
	if (color[0] == '#') {
		color = color.substr(1, color.length() - 1);
	}
	if (color.length() == 3 || color.length() == 4) {
		String exp_color;
		for (int i = 0; i < color.length(); i++) {
			exp_color += color[i];
			exp_color += color[i];
		}
		color = exp_color;
	}

	bool alpha = false;

	if (color.length() == 8) {
		alpha = true;
	} else if (color.length() == 6) {
		alpha = false;
	} else {
		ERR_FAIL_V_MSG(Color(), "Invalid color code: " + p_color + ".");
	}

	int a = 255;
	if (alpha) {
		a = _parse_col(color, 0);
		ERR_FAIL_COND_V_MSG(a < 0, Color(), "Invalid color code: " + p_color + ".");
	}

	int from = alpha ? 2 : 0;

	int r = _parse_col(color, from + 0);
	ERR_FAIL_COND_V_MSG(r < 0, Color(), "Invalid color code: " + p_color + ".");
	int g = _parse_col(color, from + 2);
	ERR_FAIL_COND_V_MSG(g < 0, Color(), "Invalid color code: " + p_color + ".");
	int b = _parse_col(color, from + 4);
	ERR_FAIL_COND_V_MSG(b < 0, Color(), "Invalid color code: " + p_color + ".");

	return Color(r / 255.0, g / 255.0, b / 255.0, a / 255.0);
}

bool Color::html_is_valid(const String &p_color) {
	String color = p_color;

	if (color.length() == 0) {
		return false;
	}
	if (color[0] == '#') {
		color = color.substr(1, color.length() - 1);
	}

	bool alpha = false;

	if (color.length() == 8) {
		alpha = true;
	} else if (color.length() == 6) {
		alpha = false;
	} else {
		return false;
	}

	if (alpha) {
		int a = _parse_col(color, 0);
		if (a < 0) {
			return false;
		}
	}

	int from = alpha ? 2 : 0;

	int r = _parse_col(color, from + 0);
	if (r < 0) {
		return false;
	}
	int g = _parse_col(color, from + 2);
	if (g < 0) {
		return false;
	}
	int b = _parse_col(color, from + 4);
	if (b < 0) {
		return false;
	}

	return true;
}

String _to_hex(float p_val) {
	int v = Math::round(p_val * 255);
	v = CLAMP(v, 0, 255);
	String ret;

	for (int i = 0; i < 2; i++) {
		CharType c[2] = { 0, 0 };
		int lv = v & 0xF;
		if (lv < 10) {
			c[0] = '0' + lv;
		} else {
			c[0] = 'a' + lv - 10;
		}

		v >>= 4;
		String cs = (const CharType *)c;
		ret = cs + ret;
	}

	return ret;
}

String Color::to_html(bool p_alpha) const {
	String txt;
	txt += _to_hex(r);
	txt += _to_hex(g);
	txt += _to_hex(b);
	if (p_alpha) {
		txt = _to_hex(a) + txt;
	}
	return txt;
}

Color Color::from_hsv(float p_h, float p_s, float p_v, float p_a) const {
	Color c;
	c.set_hsv(p_h, p_s, p_v, p_a);
	return c;
}

Color::operator String() const {
	return "(" + String::num(r, 4) + ", " + String::num(g, 4) + ", " + String::num(b, 4) + ", " + String::num(a, 4) + ")";
}

Color Color::operator+(const Color &p_color) const {
	return Color(
			r + p_color.r,
			g + p_color.g,
			b + p_color.b,
			a + p_color.a);
}

void Color::operator+=(const Color &p_color) {
	r = r + p_color.r;
	g = g + p_color.g;
	b = b + p_color.b;
	a = a + p_color.a;
}

Color Color::operator-(const Color &p_color) const {
	return Color(
			r - p_color.r,
			g - p_color.g,
			b - p_color.b,
			a - p_color.a);
}

void Color::operator-=(const Color &p_color) {
	r = r - p_color.r;
	g = g - p_color.g;
	b = b - p_color.b;
	a = a - p_color.a;
}

Color Color::operator*(const Color &p_color) const {
	return Color(
			r * p_color.r,
			g * p_color.g,
			b * p_color.b,
			a * p_color.a);
}

Color Color::operator*(const real_t &rvalue) const {
	return Color(
			r * rvalue,
			g * rvalue,
			b * rvalue,
			a * rvalue);
}

void Color::operator*=(const Color &p_color) {
	r = r * p_color.r;
	g = g * p_color.g;
	b = b * p_color.b;
	a = a * p_color.a;
}

void Color::operator*=(const real_t &rvalue) {
	r = r * rvalue;
	g = g * rvalue;
	b = b * rvalue;
	a = a * rvalue;
}

Color Color::operator/(const Color &p_color) const {
	return Color(
			r / p_color.r,
			g / p_color.g,
			b / p_color.b,
			a / p_color.a);
}

Color Color::operator/(const real_t &rvalue) const {
	return Color(
			r / rvalue,
			g / rvalue,
			b / rvalue,
			a / rvalue);
}

void Color::operator/=(const Color &p_color) {
	r = r / p_color.r;
	g = g / p_color.g;
	b = b / p_color.b;
	a = a / p_color.a;
}

void Color::operator/=(const real_t &rvalue) {
	if (rvalue == 0) {
		r = 1.0;
		g = 1.0;
		b = 1.0;
		a = 1.0;
	} else {
		r = r / rvalue;
		g = g / rvalue;
		b = b / rvalue;
		a = a / rvalue;
	}
};

Color Color::operator-() const {
	return Color(
			1.0 - r,
			1.0 - g,
			1.0 - b,
			1.0 - a);
}
#line 0

#line 1 "sfw/core/quaternion.cpp"
/*************************************************************************/
/*  quaternion.cpp                                                       */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

real_t Quaternion::angle_to(const Quaternion &p_to) const {
	real_t d = dot(p_to);

	// acos does clamping.
	return Math::acos(d * d * 2 - 1);
}

// set_euler_xyz expects a vector containing the Euler angles in the format
// (ax,ay,az), where ax is the angle of rotation around x axis,
// and similar for other axes.
// This implementation uses XYZ convention (Z is the first rotation).
void Quaternion::set_euler_xyz(const Vector3 &p_euler) {
	real_t half_a1 = p_euler.x * 0.5f;
	real_t half_a2 = p_euler.y * 0.5f;
	real_t half_a3 = p_euler.z * 0.5f;

	// R = X(a1).Y(a2).Z(a3) convention for Euler angles.
	// Conversion to quaternion as listed in https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19770024290.pdf (page A-2)
	// a3 is the angle of the first rotation, following the notation in this reference.

	real_t cos_a1 = Math::cos(half_a1);
	real_t sin_a1 = Math::sin(half_a1);
	real_t cos_a2 = Math::cos(half_a2);
	real_t sin_a2 = Math::sin(half_a2);
	real_t cos_a3 = Math::cos(half_a3);
	real_t sin_a3 = Math::sin(half_a3);

	set(sin_a1 * cos_a2 * cos_a3 + sin_a2 * sin_a3 * cos_a1,
			-sin_a1 * sin_a3 * cos_a2 + sin_a2 * cos_a1 * cos_a3,
			sin_a1 * sin_a2 * cos_a3 + sin_a3 * cos_a1 * cos_a2,
			-sin_a1 * sin_a2 * sin_a3 + cos_a1 * cos_a2 * cos_a3);
}

// get_euler_xyz returns a vector containing the Euler angles in the format
// (ax,ay,az), where ax is the angle of rotation around x axis,
// and similar for other axes.
// This implementation uses XYZ convention (Z is the first rotation).
Vector3 Quaternion::get_euler_xyz() const {
	Basis m(*this);
	return m.get_euler_xyz();
}

// set_euler_yxz expects a vector containing the Euler angles in the format
// (ax,ay,az), where ax is the angle of rotation around x axis,
// and similar for other axes.
// This implementation uses YXZ convention (Z is the first rotation).
void Quaternion::set_euler_yxz(const Vector3 &p_euler) {
	real_t half_a1 = p_euler.y * 0.5f;
	real_t half_a2 = p_euler.x * 0.5f;
	real_t half_a3 = p_euler.z * 0.5f;

	// R = Y(a1).X(a2).Z(a3) convention for Euler angles.
	// Conversion to quaternion as listed in https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19770024290.pdf (page A-6)
	// a3 is the angle of the first rotation, following the notation in this reference.

	real_t cos_a1 = Math::cos(half_a1);
	real_t sin_a1 = Math::sin(half_a1);
	real_t cos_a2 = Math::cos(half_a2);
	real_t sin_a2 = Math::sin(half_a2);
	real_t cos_a3 = Math::cos(half_a3);
	real_t sin_a3 = Math::sin(half_a3);

	set(sin_a1 * cos_a2 * sin_a3 + cos_a1 * sin_a2 * cos_a3,
			sin_a1 * cos_a2 * cos_a3 - cos_a1 * sin_a2 * sin_a3,
			-sin_a1 * sin_a2 * cos_a3 + cos_a1 * cos_a2 * sin_a3,
			sin_a1 * sin_a2 * sin_a3 + cos_a1 * cos_a2 * cos_a3);
}

// get_euler_yxz returns a vector containing the Euler angles in the format
// (ax,ay,az), where ax is the angle of rotation around x axis,
// and similar for other axes.
// This implementation uses YXZ convention (Z is the first rotation).
Vector3 Quaternion::get_euler_yxz() const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!is_normalized(), Vector3(0, 0, 0), "The quaternion must be normalized.");
#endif
	Basis m(*this);
	return m.get_euler_yxz();
}

void Quaternion::operator*=(const Quaternion &p_q) {
	set(w * p_q.x + x * p_q.w + y * p_q.z - z * p_q.y,
			w * p_q.y + y * p_q.w + z * p_q.x - x * p_q.z,
			w * p_q.z + z * p_q.w + x * p_q.y - y * p_q.x,
			w * p_q.w - x * p_q.x - y * p_q.y - z * p_q.z);
}

Quaternion Quaternion::operator*(const Quaternion &p_q) const {
	Quaternion r = *this;
	r *= p_q;
	return r;
}

bool Quaternion::is_equal_approx(const Quaternion &p_quat) const {
	return Math::is_equal_approx(x, p_quat.x) && Math::is_equal_approx(y, p_quat.y) && Math::is_equal_approx(z, p_quat.z) && Math::is_equal_approx(w, p_quat.w);
}

real_t Quaternion::length() const {
	return Math::sqrt(length_squared());
}

void Quaternion::normalize() {
	*this /= length();
}

Quaternion Quaternion::normalized() const {
	return *this / length();
}

bool Quaternion::is_normalized() const {
	return Math::is_equal_approx(length_squared(), 1, (real_t)UNIT_EPSILON); //use less epsilon
}

Quaternion Quaternion::inverse() const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!is_normalized(), Quaternion(), "The quaternion must be normalized.");
#endif
	return Quaternion(-x, -y, -z, w);
}

Quaternion Quaternion::log() const {
	Quaternion src = *this;
	Vector3 src_v = src.get_axis() * src.get_angle();
	return Quaternion(src_v.x, src_v.y, src_v.z, 0);
}

Quaternion Quaternion::exp() const {
	Quaternion src = *this;
	Vector3 src_v = Vector3(src.x, src.y, src.z);
	float theta = src_v.length();
	if (theta < CMP_EPSILON) {
		return Quaternion(0, 0, 0, 1);
	}
	return Quaternion(src_v.normalized(), theta);
}

Quaternion Quaternion::slerp(const Quaternion &p_to, const real_t &p_weight) const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!is_normalized(), Quaternion(), "The start quaternion must be normalized.");
	ERR_FAIL_COND_V_MSG(!p_to.is_normalized(), Quaternion(), "The end quaternion must be normalized.");
#endif
	Quaternion to1;
	real_t omega, cosom, sinom, scale0, scale1;

	// calc cosine
	cosom = dot(p_to);

	// adjust signs (if necessary)
	if (cosom < 0) {
		cosom = -cosom;
		to1.x = -p_to.x;
		to1.y = -p_to.y;
		to1.z = -p_to.z;
		to1.w = -p_to.w;
	} else {
		to1.x = p_to.x;
		to1.y = p_to.y;
		to1.z = p_to.z;
		to1.w = p_to.w;
	}

	// calculate coefficients

	if ((1 - cosom) > (real_t)CMP_EPSILON) {
		// standard case (slerp)
		omega = Math::acos(cosom);
		sinom = Math::sin(omega);
		scale0 = Math::sin((1 - p_weight) * omega) / sinom;
		scale1 = Math::sin(p_weight * omega) / sinom;
	} else {
		// "from" and "to" quaternions are very close
		//  ... so we can do a linear interpolation
		scale0 = 1 - p_weight;
		scale1 = p_weight;
	}
	// calculate final values
	return Quaternion(
			scale0 * x + scale1 * to1.x,
			scale0 * y + scale1 * to1.y,
			scale0 * z + scale1 * to1.z,
			scale0 * w + scale1 * to1.w);
}

Quaternion Quaternion::slerpni(const Quaternion &p_to, const real_t &p_weight) const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!is_normalized(), Quaternion(), "The start quaternion must be normalized.");
	ERR_FAIL_COND_V_MSG(!p_to.is_normalized(), Quaternion(), "The end quaternion must be normalized.");
#endif
	const Quaternion &from = *this;

	real_t dot = from.dot(p_to);

	if (Math::absf(dot) > 0.9999f) {
		return from;
	}

	real_t theta = Math::acos(dot),
		   sinT = 1 / Math::sin(theta),
		   newFactor = Math::sin(p_weight * theta) * sinT,
		   invFactor = Math::sin((1 - p_weight) * theta) * sinT;

	return Quaternion(invFactor * from.x + newFactor * p_to.x,
			invFactor * from.y + newFactor * p_to.y,
			invFactor * from.z + newFactor * p_to.z,
			invFactor * from.w + newFactor * p_to.w);
}

Quaternion Quaternion::cubic_slerp(const Quaternion &p_b, const Quaternion &p_pre_a, const Quaternion &p_post_b, const real_t &p_weight) const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!is_normalized(), Quaternion(), "The start quaternion must be normalized.");
	ERR_FAIL_COND_V_MSG(!p_b.is_normalized(), Quaternion(), "The end quaternion must be normalized.");
#endif
	//the only way to do slerp :|
	real_t t2 = (1 - p_weight) * p_weight * 2;
	Quaternion sp = this->slerp(p_b, p_weight);
	Quaternion sq = p_pre_a.slerpni(p_post_b, p_weight);
	return sp.slerpni(sq, t2);
}

Quaternion Quaternion::spherical_cubic_interpolate(const Quaternion &p_b, const Quaternion &p_pre_a, const Quaternion &p_post_b, const real_t &p_weight) const {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_V_MSG(!is_normalized(), Quaternion(), "The start quaternion must be normalized.");
	ERR_FAIL_COND_V_MSG(!p_b.is_normalized(), Quaternion(), "The end quaternion must be normalized.");
#endif
	Quaternion from_q = *this;
	Quaternion pre_q = p_pre_a;
	Quaternion to_q = p_b;
	Quaternion post_q = p_post_b;

	// Align flip phases.
	from_q = Basis(from_q).get_rotation_quaternion();
	pre_q = Basis(pre_q).get_rotation_quaternion();
	to_q = Basis(to_q).get_rotation_quaternion();
	post_q = Basis(post_q).get_rotation_quaternion();

	// Flip quaternions to shortest path if necessary.
	bool flip1 = signbit(from_q.dot(pre_q));
	pre_q = flip1 ? -pre_q : pre_q;
	bool flip2 = signbit(from_q.dot(to_q));
	to_q = flip2 ? -to_q : to_q;
	bool flip3 = flip2 ? to_q.dot(post_q) <= 0 : signbit(to_q.dot(post_q));
	post_q = flip3 ? -post_q : post_q;

	// Calc by Expmap in from_q space.
	Quaternion ln_from = Quaternion(0, 0, 0, 0);
	Quaternion ln_to = (from_q.inverse() * to_q).log();
	Quaternion ln_pre = (from_q.inverse() * pre_q).log();
	Quaternion ln_post = (from_q.inverse() * post_q).log();
	Quaternion ln = Quaternion(0, 0, 0, 0);
	ln.x = Math::cubic_interpolate(ln_from.x, ln_to.x, ln_pre.x, ln_post.x, p_weight);
	ln.y = Math::cubic_interpolate(ln_from.y, ln_to.y, ln_pre.y, ln_post.y, p_weight);
	ln.z = Math::cubic_interpolate(ln_from.z, ln_to.z, ln_pre.z, ln_post.z, p_weight);
	Quaternion q1 = from_q * ln.exp();

	// Calc by Expmap in to_q space.
	ln_from = (to_q.inverse() * from_q).log();
	ln_to = Quaternion(0, 0, 0, 0);
	ln_pre = (to_q.inverse() * pre_q).log();
	ln_post = (to_q.inverse() * post_q).log();
	ln = Quaternion(0, 0, 0, 0);
	ln.x = Math::cubic_interpolate(ln_from.x, ln_to.x, ln_pre.x, ln_post.x, p_weight);
	ln.y = Math::cubic_interpolate(ln_from.y, ln_to.y, ln_pre.y, ln_post.y, p_weight);
	ln.z = Math::cubic_interpolate(ln_from.z, ln_to.z, ln_pre.z, ln_post.z, p_weight);
	Quaternion q2 = to_q * ln.exp();

	// To cancel error made by Expmap ambiguity, do blends.
	return q1.slerp(q2, p_weight);
}

Vector3 Quaternion::get_axis() const {
	if (Math::abs(w) > 1 - CMP_EPSILON) {
		return Vector3(x, y, z);
	}
	real_t r = ((real_t)1) / Math::sqrt(1 - w * w);
	return Vector3(x * r, y * r, z * r);
}

float Quaternion::get_angle() const {
	return 2 * Math::acos(w);
}

Quaternion::operator String() const {
	return "(" + String::num_real(x) + ", " + String::num_real(y) + ", " + String::num_real(z) + ", " + String::num_real(w) + ")";
}

void Quaternion::set_axis_angle(const Vector3 &axis, const real_t &angle) {
#ifdef MATH_CHECKS
	ERR_FAIL_COND_MSG(!axis.is_normalized(), "The axis Vector3 must be normalized.");
#endif
	real_t d = axis.length();
	if (d == 0) {
		set(0, 0, 0, 0);
	} else {
		real_t sin_angle = Math::sin(angle * 0.5f);
		real_t cos_angle = Math::cos(angle * 0.5f);
		real_t s = sin_angle / d;
		set(axis.x * s, axis.y * s, axis.z * s,
				cos_angle);
	}
}
#line 0

#line 1 "sfw/core/plane.cpp"
/*************************************************************************/
/*  plane.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void Plane::set_normal(const Vector3 &p_normal) {
	normal = p_normal;
}

void Plane::normalize() {
	real_t l = normal.length();
	if (l == 0) {
		*this = Plane(0, 0, 0, 0);
		return;
	}
	normal /= l;
	d /= l;
}

Plane Plane::normalized() const {
	Plane p = *this;
	p.normalize();
	return p;
}

Vector3 Plane::get_any_point() const {
	return get_normal() * d;
}

Vector3 Plane::get_any_perpendicular_normal() const {
	static const Vector3 p1 = Vector3(1, 0, 0);
	static const Vector3 p2 = Vector3(0, 1, 0);
	Vector3 p;

	if (ABS(normal.dot(p1)) > 0.99f) { // if too similar to p1
		p = p2; // use p2
	} else {
		p = p1; // use p1
	}

	p -= normal * normal.dot(p);
	p.normalize();

	return p;
}

/* intersections */

bool Plane::intersect_3(const Plane &p_plane1, const Plane &p_plane2, Vector3 *r_result) const {
	const Plane &p_plane0 = *this;
	Vector3 normal0 = p_plane0.normal;
	Vector3 normal1 = p_plane1.normal;
	Vector3 normal2 = p_plane2.normal;

	real_t denom = vec3_cross(normal0, normal1).dot(normal2);

	if (Math::is_zero_approx(denom)) {
		return false;
	}

	if (r_result) {
		*r_result = ((vec3_cross(normal1, normal2) * p_plane0.d) +
							(vec3_cross(normal2, normal0) * p_plane1.d) +
							(vec3_cross(normal0, normal1) * p_plane2.d)) /
				denom;
	}

	return true;
}

bool Plane::intersects_ray(const Vector3 &p_from, const Vector3 &p_dir, Vector3 *p_intersection) const {
	Vector3 segment = p_dir;
	real_t den = normal.dot(segment);

	//printf("den is %i\n",den);
	if (Math::is_zero_approx(den)) {
		return false;
	}

	real_t dist = (normal.dot(p_from) - d) / den;
	//printf("dist is %i\n",dist);

	if (dist > (real_t)CMP_EPSILON) { //this is a ray, before the emitting pos (p_from) doesn't exist

		return false;
	}

	dist = -dist;
	*p_intersection = p_from + segment * dist;

	return true;
}

bool Plane::intersects_segment(const Vector3 &p_begin, const Vector3 &p_end, Vector3 *p_intersection) const {
	Vector3 segment = p_begin - p_end;
	real_t den = normal.dot(segment);

	//printf("den is %i\n",den);
	if (Math::is_zero_approx(den)) {
		return false;
	}

	real_t dist = (normal.dot(p_begin) - d) / den;
	//printf("dist is %i\n",dist);

	if (dist < (real_t)-CMP_EPSILON || dist > (1 + (real_t)CMP_EPSILON)) {
		return false;
	}

	dist = -dist;
	*p_intersection = p_begin + segment * dist;

	return true;
}

/* misc */

bool Plane::is_equal_approx(const Plane &p_plane) const {
	return normal.is_equal_approx(p_plane.normal) && Math::is_equal_approx(d, p_plane.d);
}

bool Plane::is_equal_approx_any_side(const Plane &p_plane) const {
	return (normal.is_equal_approx(p_plane.normal) && Math::is_equal_approx(d, p_plane.d)) || (normal.is_equal_approx(-p_plane.normal) && Math::is_equal_approx(d, -p_plane.d));
}

Plane::operator String() const {
	return "[N: " + normal.operator String() + ", D: " + String::num_real(d) + "]";
}
#line 0

#line 1 "sfw/core/rect2.cpp"
/*************************************************************************/
/*  rect2.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

bool Rect2::is_equal_approx(const Rect2 &p_rect) const {
	return position.is_equal_approx(p_rect.position) && size.is_equal_approx(p_rect.size);
}

bool Rect2::intersects_segment(const Point2 &p_from, const Point2 &p_to, Point2 *r_pos, Point2 *r_normal) const {
	real_t min = 0, max = 1;
	int axis = 0;
	real_t sign = 0;

	for (int i = 0; i < 2; i++) {
		real_t seg_from = p_from[i];
		real_t seg_to = p_to[i];
		real_t box_begin = position[i];
		real_t box_end = box_begin + size[i];
		real_t cmin, cmax;
		real_t csign;

		if (seg_from < seg_to) {
			if (seg_from > box_end || seg_to < box_begin) {
				return false;
			}
			real_t length = seg_to - seg_from;
			cmin = (seg_from < box_begin) ? ((box_begin - seg_from) / length) : 0;
			cmax = (seg_to > box_end) ? ((box_end - seg_from) / length) : 1;
			csign = -1.0;

		} else {
			if (seg_to > box_end || seg_from < box_begin) {
				return false;
			}
			real_t length = seg_to - seg_from;
			cmin = (seg_from > box_end) ? (box_end - seg_from) / length : 0;
			cmax = (seg_to < box_begin) ? (box_begin - seg_from) / length : 1;
			csign = 1.0;
		}

		if (cmin > min) {
			min = cmin;
			axis = i;
			sign = csign;
		}
		if (cmax < max) {
			max = cmax;
		}
		if (max < min) {
			return false;
		}
	}

	Vector2 rel = p_to - p_from;

	if (r_normal) {
		Vector2 normal;
		normal[axis] = sign;
		*r_normal = normal;
	}

	if (r_pos) {
		*r_pos = p_from + rel * min;
	}

	return true;
}

bool Rect2::intersects_transformed(const Transform2D &p_xform, const Rect2 &p_rect) const {
	//SAT intersection between local and transformed rect2

	Vector2 xf_points[4] = {
		p_xform.xform(p_rect.position),
		p_xform.xform(Vector2(p_rect.position.x + p_rect.size.x, p_rect.position.y)),
		p_xform.xform(Vector2(p_rect.position.x, p_rect.position.y + p_rect.size.y)),
		p_xform.xform(Vector2(p_rect.position.x + p_rect.size.x, p_rect.position.y + p_rect.size.y)),
	};

	real_t low_limit;

	//base rect2 first (faster)

	if (xf_points[0].y > position.y) {
		goto next1;
	}
	if (xf_points[1].y > position.y) {
		goto next1;
	}
	if (xf_points[2].y > position.y) {
		goto next1;
	}
	if (xf_points[3].y > position.y) {
		goto next1;
	}

	return false;

next1:

	low_limit = position.y + size.y;

	if (xf_points[0].y < low_limit) {
		goto next2;
	}
	if (xf_points[1].y < low_limit) {
		goto next2;
	}
	if (xf_points[2].y < low_limit) {
		goto next2;
	}
	if (xf_points[3].y < low_limit) {
		goto next2;
	}

	return false;

next2:

	if (xf_points[0].x > position.x) {
		goto next3;
	}
	if (xf_points[1].x > position.x) {
		goto next3;
	}
	if (xf_points[2].x > position.x) {
		goto next3;
	}
	if (xf_points[3].x > position.x) {
		goto next3;
	}

	return false;

next3:

	low_limit = position.x + size.x;

	if (xf_points[0].x < low_limit) {
		goto next4;
	}
	if (xf_points[1].x < low_limit) {
		goto next4;
	}
	if (xf_points[2].x < low_limit) {
		goto next4;
	}
	if (xf_points[3].x < low_limit) {
		goto next4;
	}

	return false;

next4:

	Vector2 xf_points2[4] = {
		position,
		Vector2(position.x + size.x, position.y),
		Vector2(position.x, position.y + size.y),
		Vector2(position.x + size.x, position.y + size.y),
	};

	real_t maxa = p_xform.columns[0].dot(xf_points2[0]);
	real_t mina = maxa;

	real_t dp = p_xform.columns[0].dot(xf_points2[1]);
	maxa = MAX(dp, maxa);
	mina = MIN(dp, mina);

	dp = p_xform.columns[0].dot(xf_points2[2]);
	maxa = MAX(dp, maxa);
	mina = MIN(dp, mina);

	dp = p_xform.columns[0].dot(xf_points2[3]);
	maxa = MAX(dp, maxa);
	mina = MIN(dp, mina);

	real_t maxb = p_xform.columns[0].dot(xf_points[0]);
	real_t minb = maxb;

	dp = p_xform.columns[0].dot(xf_points[1]);
	maxb = MAX(dp, maxb);
	minb = MIN(dp, minb);

	dp = p_xform.columns[0].dot(xf_points[2]);
	maxb = MAX(dp, maxb);
	minb = MIN(dp, minb);

	dp = p_xform.columns[0].dot(xf_points[3]);
	maxb = MAX(dp, maxb);
	minb = MIN(dp, minb);

	if (mina > maxb) {
		return false;
	}
	if (minb > maxa) {
		return false;
	}

	maxa = p_xform.columns[1].dot(xf_points2[0]);
	mina = maxa;

	dp = p_xform.columns[1].dot(xf_points2[1]);
	maxa = MAX(dp, maxa);
	mina = MIN(dp, mina);

	dp = p_xform.columns[1].dot(xf_points2[2]);
	maxa = MAX(dp, maxa);
	mina = MIN(dp, mina);

	dp = p_xform.columns[1].dot(xf_points2[3]);
	maxa = MAX(dp, maxa);
	mina = MIN(dp, mina);

	maxb = p_xform.columns[1].dot(xf_points[0]);
	minb = maxb;

	dp = p_xform.columns[1].dot(xf_points[1]);
	maxb = MAX(dp, maxb);
	minb = MIN(dp, minb);

	dp = p_xform.columns[1].dot(xf_points[2]);
	maxb = MAX(dp, maxb);
	minb = MIN(dp, minb);

	dp = p_xform.columns[1].dot(xf_points[3]);
	maxb = MAX(dp, maxb);
	minb = MIN(dp, minb);

	if (mina > maxb) {
		return false;
	}
	if (minb > maxa) {
		return false;
	}

	return true;
}

Rect2::operator String() const {
	return "[P: " + position.operator String() + ", S: " + size + "]";
}
#line 0

#line 1 "sfw/core/rect2i.cpp"
/*************************************************************************/
/*  rect2i.cpp                                                           */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

Rect2i::operator String() const {
	return "[P: " + position.operator String() + ", S: " + size + "]";
}
#line 0

#line 1 "sfw/core/vector4.cpp"
/*************************************************************************/
/*  vector4.cpp                                                          */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void Vector4::set_axis(const int p_axis, const real_t p_value) {
	ERR_FAIL_INDEX(p_axis, 4);
	components[p_axis] = p_value;
}

real_t Vector4::get_axis(const int p_axis) const {
	ERR_FAIL_INDEX_V(p_axis, 4, 0);
	return operator[](p_axis);
}

Vector4::Axis Vector4::min_axis() const {
	uint32_t min_index = 0;
	real_t min_value = x;
	for (uint32_t i = 1; i < 4; i++) {
		if (operator[](i) <= min_value) {
			min_index = i;
			min_value = operator[](i);
		}
	}
	return Vector4::Axis(min_index);
}

Vector4::Axis Vector4::max_axis() const {
	uint32_t max_index = 0;
	real_t max_value = x;
	for (uint32_t i = 1; i < 4; i++) {
		if (operator[](i) > max_value) {
			max_index = i;
			max_value = operator[](i);
		}
	}
	return Vector4::Axis(max_index);
}

bool Vector4::is_equal_approx(const Vector4 &p_vec4) const {
	return Math::is_equal_approx(x, p_vec4.x) && Math::is_equal_approx(y, p_vec4.y) && Math::is_equal_approx(z, p_vec4.z) && Math::is_equal_approx(w, p_vec4.w);
}

bool Vector4::is_zero_approx() const {
	return Math::is_zero_approx(x) && Math::is_zero_approx(y) && Math::is_zero_approx(z) && Math::is_zero_approx(w);
}

real_t Vector4::length() const {
	return Math::sqrt(length_squared());
}

void Vector4::normalize() {
	*this /= length();
}

Vector4 Vector4::normalized() const {
	return *this / length();
}

bool Vector4::is_normalized() const {
	return Math::is_equal_approx(length_squared(), 1, (real_t)UNIT_EPSILON); // Use less epsilon.
}

Vector4 Vector4::limit_length(const real_t p_len) const {
	const real_t l = length();
	Vector4 v = *this;
	if (l > 0 && p_len < l) {
		v /= l;
		v *= p_len;
	}

	return v;
}

real_t Vector4::distance_to(const Vector4 &p_to) const {
	return (p_to - *this).length();
}

Vector4 Vector4::direction_to(const Vector4 &p_to) const {
	Vector4 ret(p_to.x - x, p_to.y - y, p_to.z - z, p_to.w - w);
	ret.normalize();
	return ret;
}

real_t Vector4::distance_squared_to(const Vector4 &p_to) const {
	return (p_to - *this).length_squared();
}

Vector4 Vector4::abs() const {
	return Vector4(Math::abs(x), Math::abs(y), Math::abs(z), Math::abs(w));
}

Vector4 Vector4::sign() const {
	return Vector4(SGN(x), SGN(y), SGN(z), SGN(w));
}

Vector4 Vector4::floor() const {
	return Vector4(Math::floor(x), Math::floor(y), Math::floor(z), Math::floor(w));
}

Vector4 Vector4::ceil() const {
	return Vector4(Math::ceil(x), Math::ceil(y), Math::ceil(z), Math::ceil(w));
}

Vector4 Vector4::round() const {
	return Vector4(Math::round(x), Math::round(y), Math::round(z), Math::round(w));
}

Vector4 Vector4::linear_interpolate(const Vector4 &p_to, const real_t p_weight) const {
	return Vector4(
			x + (p_weight * (p_to.x - x)),
			y + (p_weight * (p_to.y - y)),
			z + (p_weight * (p_to.z - z)),
			w + (p_weight * (p_to.w - w)));
}

Vector4 Vector4::cubic_interpolate(const Vector4 &p_b, const Vector4 &p_pre_a, const Vector4 &p_post_b, const real_t p_weight) const {
	Vector4 res = *this;
	res.x = Math::cubic_interpolate(res.x, p_b.x, p_pre_a.x, p_post_b.x, p_weight);
	res.y = Math::cubic_interpolate(res.y, p_b.y, p_pre_a.y, p_post_b.y, p_weight);
	res.z = Math::cubic_interpolate(res.z, p_b.z, p_pre_a.z, p_post_b.z, p_weight);
	res.w = Math::cubic_interpolate(res.w, p_b.w, p_pre_a.w, p_post_b.w, p_weight);
	return res;
}

Vector4 Vector4::posmod(const real_t p_mod) const {
	return Vector4(Math::fposmod(x, p_mod), Math::fposmod(y, p_mod), Math::fposmod(z, p_mod), Math::fposmod(w, p_mod));
}

Vector4 Vector4::posmodv(const Vector4 &p_modv) const {
	return Vector4(Math::fposmod(x, p_modv.x), Math::fposmod(y, p_modv.y), Math::fposmod(z, p_modv.z), Math::fposmod(w, p_modv.w));
}

void Vector4::snap(const Vector4 &p_step) {
	x = Math::stepify(x, p_step.x);
	y = Math::stepify(y, p_step.y);
	z = Math::stepify(z, p_step.z);
	w = Math::stepify(w, p_step.w);
}

Vector4 Vector4::snapped(const Vector4 &p_step) const {
	Vector4 v = *this;
	v.snap(p_step);
	return v;
}

Vector4 Vector4::inverse() const {
	return Vector4(1.0f / x, 1.0f / y, 1.0f / z, 1.0f / w);
}

Vector4 Vector4::clamp(const Vector4 &p_min, const Vector4 &p_max) const {
	return Vector4(
			CLAMP(x, p_min.x, p_max.x),
			CLAMP(y, p_min.y, p_max.y),
			CLAMP(z, p_min.z, p_max.z),
			CLAMP(w, p_min.w, p_max.w));
}

Vector4::operator String() const {
	return "(" + String::num_real(x) + ", " + String::num_real(y) + ", " + String::num_real(z) + ", " + String::num_real(w) + ")";
}
#line 0

#line 1 "sfw/core/string_builder.cpp"
/*************************************************************************/
/*  string_builder.cpp                                                   */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

StringBuilder &StringBuilder::append(const String &p_string) {
	if (p_string == String()) {
		return *this;
	}

	strings.push_back(p_string);
	appended_strings.push_back(-1);

	string_length += p_string.length();

	return *this;
}

StringBuilder &StringBuilder::append(const char *p_cstring) {
	int32_t len = strlen(p_cstring);

	c_strings.push_back(p_cstring);
	appended_strings.push_back(len);

	string_length += len;

	return *this;
}

void StringBuilder::clear() {
	string_length = 0;
	strings.clear();
	c_strings.clear();
	appended_strings.clear();
}

String StringBuilder::as_string() const {
	if (string_length == 0) {
		return "";
	}

	CharType *buffer = memnew_arr(CharType, string_length);

	int current_position = 0;

	int pandemonium_string_elem = 0;
	int c_string_elem = 0;

	for (int i = 0; i < appended_strings.size(); i++) {
		if (appended_strings[i] == -1) {
			// Pandemonium string
			const String &s = strings[pandemonium_string_elem];

			memcpy(buffer + current_position, s.ptr(), s.length() * sizeof(CharType));

			current_position += s.length();

			pandemonium_string_elem++;
		} else {
			const char *s = c_strings[c_string_elem];

			for (int32_t j = 0; j < appended_strings[i]; j++) {
				buffer[current_position + j] = s[j];
			}

			current_position += appended_strings[i];

			c_string_elem++;
		}
	}

	String final_string = String(buffer, string_length);

	memdelete_arr(buffer);

	return final_string;
}
#line 0

#line 1 "sfw/core/file_access.cpp"

/*************************************************************************/
/*  file_access.cpp                                                      */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#if defined(_WIN64) || defined(_WIN32)

#include <share.h> // _SH_DENYNO
#include <shlwapi.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <tchar.h>
#include <wchar.h>

#ifdef _MSC_VER
#define S_ISREG(m) ((m) & _S_IFREG)
#endif

#else

#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>

#include <unistd.h>

#ifdef MSVC
#define S_ISREG(m) ((m) & _S_IFREG)
#include <io.h>
#endif
#ifndef S_ISREG
#define S_ISREG(m) ((m) & S_IFREG)
#endif

#ifndef NO_FCNTL
#include <fcntl.h>
#else
#include <sys/ioctl.h>
#endif

#endif

#if defined(_WIN64) || defined(_WIN32)

void FileAccess::check_errors() const {
	ERR_FAIL_COND(!f);

	if (feof(f)) {
		last_error = ERR_FILE_EOF;
	}
}

Error FileAccess::_open(const String &p_path, int p_mode_flags) {
	path_src = p_path;
	path = fix_path(p_path);

	if (f) {
		close();
	}

	const WCHAR *mode_string;

	if (p_mode_flags == READ) {
		mode_string = L"rb";
	} else if (p_mode_flags == WRITE) {
		mode_string = L"wb";
	} else if (p_mode_flags == READ_WRITE) {
		mode_string = L"rb+";
	} else if (p_mode_flags == WRITE_READ) {
		mode_string = L"wb+";
	} else {
		return ERR_INVALID_PARAMETER;
	}

	/* pretty much every implementation that uses fopen as primary
	   backend supports utf8 encoding */

	struct _stat st;
	if (_wstat((LPCWSTR)(path.utf16().get_data()), &st) == 0) {
		if (!S_ISREG(st.st_mode)) {
			return ERR_FILE_CANT_OPEN;
		}
	};

#ifdef TOOLS_ENABLED
	// Windows is case insensitive, but all other platforms are sensitive to it
	// To ease cross-platform development, we issue a warning if users try to access
	// a file using the wrong case (which *works* on Windows, but won't on other
	// platforms).
	if (p_mode_flags == READ) {
		WIN32_FIND_DATAW d;
		HANDLE f = FindFirstFileW((LPCWSTR)(path.utf16().get_data()), &d);

		if (f != INVALID_HANDLE_VALUE) {
			String fname = String::utf16((const char16_t *)(d.cFileName));

			if (fname != String()) {
				String base_file = path.get_file();
				if (base_file != fname && base_file.findn(fname) == 0) {
					LOG_WARN("Case mismatch opening requested file '" + base_file + "', stored as '" + fname + "' in the filesystem. This file will not open when exported to other case-sensitive platforms.");
				}
			}

			FindClose(f);
		}
	}
#endif

	if (is_backup_save_enabled() && p_mode_flags & WRITE && !(p_mode_flags & READ)) {
		save_path = path;
		path = path + ".tmp";
	}

	f = _wfsopen((LPCWSTR)(path.utf16().get_data()), mode_string, _SH_DENYNO);

	if (f == nullptr) {
		switch (errno) {
			case ENOENT: {
				last_error = ERR_FILE_NOT_FOUND;
			} break;
			default: {
				last_error = ERR_FILE_CANT_OPEN;
			} break;
		}
		return last_error;
	} else {
		last_error = OK;
		flags = p_mode_flags;
		return OK;
	}
}

void FileAccess::close() {
	if (!f) {
		return;
	}

	fclose(f);
	f = NULL;

	if (save_path != "") {
		bool rename_error = true;
		int attempts = 4;
		while (rename_error && attempts) {
			// This workaround of trying multiple times is added to deal with paranoid Windows
			// antiviruses that love reading just written files even if they are not executable, thus
			// locking the file and preventing renaming from happening.

#ifdef UWP_ENABLED
			// UWP has no PathFileExists, so we check attributes instead
			DWORD fileAttr;

			fileAttr = GetFileAttributesW((LPCWSTR)(save_path.utf16().get_data()));
			if (INVALID_FILE_ATTRIBUTES == fileAttr) {
#else
			if (!PathFileExistsW((LPCWSTR)(save_path.utf16().get_data()))) {
#endif
				//creating new file
				rename_error = _wrename((LPCWSTR)((save_path + ".tmp").utf16().get_data()), (LPCWSTR)(save_path.utf16().get_data())) != 0;
			} else {
				//atomic replace for existing file
				rename_error = !ReplaceFileW((LPCWSTR)(save_path.utf16().get_data()), (LPCWSTR)((save_path + ".tmp").utf16().get_data()), NULL, 2 | 4, NULL, NULL);
			}
			if (rename_error) {
				attempts--;
				SFWTime::sleep_us(100000); // wait 100msec and try again
			}
		}

		if (rename_error) {
			if (close_fail_notify) {
				close_fail_notify(save_path);
			}
		}

		save_path = "";

		ERR_FAIL_COND_MSG(rename_error, "Safe save failed. This may be a permissions problem, but also may happen because you are running a paranoid antivirus. If this is the case, please switch to Windows Defender or disable the 'safe save' option in editor settings. This makes it work, but increases the risk of file corruption in a crash.");
	}
}

String FileAccess::get_path() const {
	return path_src;
}

String FileAccess::get_path_absolute() const {
	return path;
}

bool FileAccess::is_open() const {
	return (f != NULL);
}

void FileAccess::seek(uint64_t p_position) {
	ERR_FAIL_COND(!f);

	last_error = OK;

	if (_fseeki64(f, p_position, SEEK_SET)) {
		check_errors();
	}

	prev_op = 0;
}

void FileAccess::seek_end(int64_t p_position) {
	ERR_FAIL_COND(!f);

	if (_fseeki64(f, p_position, SEEK_END)) {
		check_errors();
	}

	prev_op = 0;
}

uint64_t FileAccess::get_position() const {
	int64_t aux_position = _ftelli64(f);

	if (aux_position < 0) {
		check_errors();
	}

	return aux_position;
}

uint64_t FileAccess::get_len() const {
	ERR_FAIL_COND_V(!f, 0);

	uint64_t pos = get_position();
	_fseeki64(f, 0, SEEK_END);
	uint64_t size = get_position();
	_fseeki64(f, pos, SEEK_SET);

	return size;
}

bool FileAccess::eof_reached() const {
	check_errors();
	return last_error == ERR_FILE_EOF;
}

uint8_t FileAccess::get_8() const {
	ERR_FAIL_COND_V(!f, 0);
	if (flags == READ_WRITE || flags == WRITE_READ) {
		if (prev_op == WRITE) {
			fflush(f);
		}
		prev_op = READ;
	}
	uint8_t b;
	if (fread(&b, 1, 1, f) == 0) {
		check_errors();
		b = '\0';
	};

	return b;
}

uint64_t FileAccess::get_buffer(uint8_t *p_dst, uint64_t p_length) const {
	ERR_FAIL_COND_V(!p_dst && p_length > 0, -1);
	ERR_FAIL_COND_V(!f, -1);

	if (flags == READ_WRITE || flags == WRITE_READ) {
		if (prev_op == WRITE) {
			fflush(f);
		}
		prev_op = READ;
	}
	uint64_t read = fread(p_dst, 1, p_length, f);
	check_errors();
	return read;
};

Error FileAccess::get_error() const {
	return last_error;
}

void FileAccess::flush() {
	ERR_FAIL_COND(!f);
	fflush(f);

	if (prev_op == WRITE) {
		prev_op = 0;
	}
}

void FileAccess::store_8(uint8_t p_dest) {
	ERR_FAIL_COND(!f);
	if (flags == READ_WRITE || flags == WRITE_READ) {
		if (prev_op == READ) {
			if (last_error != ERR_FILE_EOF) {
				fseek(f, 0, SEEK_CUR);
			}
		}
		prev_op = WRITE;
	}
	fwrite(&p_dest, 1, 1, f);
}

void FileAccess::store_buffer(const uint8_t *p_src, uint64_t p_length) {
	ERR_FAIL_COND(!f);
	ERR_FAIL_COND(!p_src && p_length > 0);

	if (flags == READ_WRITE || flags == WRITE_READ) {
		if (prev_op == READ) {
			if (last_error != ERR_FILE_EOF) {
				fseek(f, 0, SEEK_CUR);
			}
		}
		prev_op = WRITE;
	}
	ERR_FAIL_COND(fwrite(p_src, 1, p_length, f) != (size_t)p_length);
}

bool FileAccess::file_exists(const String &p_name) {
	String filename = fix_path(p_name);

	FILE *g = _wfsopen((LPCWSTR)(filename.utf16().get_data()), L"rb", _SH_DENYNO);

	if (g == nullptr) {
		return false;
	} else {
		fclose(g);
		return true;
	}
}

uint64_t FileAccess::_get_modified_time(const String &p_file) {
	String file = fix_path(p_file);
	if (file.ends_with("/") && file != "/")
		file = file.substr(0, file.length() - 1);

	struct _stat st;
	int rv = _wstat((LPCWSTR)(file.utf16().get_data()), &st);

	if (rv == 0) {
		return st.st_mtime;
	} else {
		LOG_TRACE("Failed to get modified time for: " + p_file + "");
		return 0;
	}
}

uint32_t FileAccess::_get_unix_permissions(const String &p_file) {
	return 0;
}

Error FileAccess::_set_unix_permissions(const String &p_file, uint32_t p_permissions) {
	return ERR_UNAVAILABLE;
}

FileAccess::FileAccess() :
		f(NULL),
		flags(0),
		prev_op(0),
		last_error(OK) {
}
FileAccess::~FileAccess() {
	close();
}

#else

void FileAccess::check_errors() const {
	ERR_FAIL_COND_MSG(!f, "File must be opened before use.");

	if (feof(f)) {
		last_error = ERR_FILE_EOF;
	}
}

Error FileAccess::_open(const String &p_path, int p_mode_flags) {
	if (f) {
		fclose(f);
	}
	f = nullptr;

	path_src = p_path;
	path = fix_path(p_path);
	//printf("opening %s, %i\n", path.utf8().get_data(), Memory::get_static_mem_usage());

	ERR_FAIL_COND_V_MSG(f, ERR_ALREADY_IN_USE, "File is already in use.");
	const char *mode_string;

	if (p_mode_flags == READ) {
		mode_string = "rb";
	} else if (p_mode_flags == WRITE) {
		mode_string = "wb";
	} else if (p_mode_flags == READ_WRITE) {
		mode_string = "rb+";
	} else if (p_mode_flags == WRITE_READ) {
		mode_string = "wb+";
	} else {
		return ERR_INVALID_PARAMETER;
	}

	/* pretty much every implementation that uses fopen as primary
	   backend (unix-compatible mostly) supports utf8 encoding */

	//printf("opening %s as %s\n", p_path.utf8().get_data(), path.utf8().get_data());
	struct stat st;
	int err = stat(path.utf8().get_data(), &st);
	if (!err) {
		switch (st.st_mode & S_IFMT) {
			case S_IFLNK:
			case S_IFREG:
				break;
			default:
				return ERR_FILE_CANT_OPEN;
		}
	}

	if (is_backup_save_enabled() && (p_mode_flags & WRITE) && !(p_mode_flags & READ)) {
		save_path = path;
		path = path + ".tmp";
	}

	f = fopen(path.utf8().get_data(), mode_string);

	if (f == nullptr) {
		switch (errno) {
			case ENOENT: {
				last_error = ERR_FILE_NOT_FOUND;
			} break;
			default: {
				last_error = ERR_FILE_CANT_OPEN;
			} break;
		}
		return last_error;
	}

	// Set close on exec to avoid leaking it to subprocesses.
	int fd = fileno(f);

	if (fd != -1) {
#if defined(NO_FCNTL)
		unsigned long par = 0;
		ioctl(fd, FIOCLEX, &par);
#else
		int opts = fcntl(fd, F_GETFD);
		fcntl(fd, F_SETFD, opts | FD_CLOEXEC);
#endif
	}

	last_error = OK;
	flags = p_mode_flags;
	return OK;
}

void FileAccess::close() {
	if (!f) {
		return;
	}

	fclose(f);
	f = nullptr;

	if (close_notification_func) {
		close_notification_func(path, flags);
	}

	if (save_path != "") {
		int rename_error = rename((save_path + ".tmp").utf8().get_data(), save_path.utf8().get_data());

		if (rename_error && close_fail_notify) {
			close_fail_notify(save_path);
		}

		save_path = "";
		ERR_FAIL_COND(rename_error != 0);
	}
}

bool FileAccess::is_open() const {
	return (f != nullptr);
}

String FileAccess::get_path() const {
	return path_src;
}

String FileAccess::get_path_absolute() const {
	return path;
}

void FileAccess::seek(uint64_t p_position) {
	ERR_FAIL_COND_MSG(!f, "File must be opened before use.");

	last_error = OK;
	if (fseeko(f, p_position, SEEK_SET)) {
		check_errors();
	}
}

void FileAccess::seek_end(int64_t p_position) {
	ERR_FAIL_COND_MSG(!f, "File must be opened before use.");

	if (fseeko(f, p_position, SEEK_END)) {
		check_errors();
	}
}

uint64_t FileAccess::get_position() const {
	ERR_FAIL_COND_V_MSG(!f, 0, "File must be opened before use.");

	int64_t pos = ftello(f);
	if (pos < 0) {
		check_errors();
		ERR_FAIL_V(0);
	}
	return pos;
}

uint64_t FileAccess::get_len() const {
	ERR_FAIL_COND_V_MSG(!f, 0, "File must be opened before use.");

	int64_t pos = ftello(f);
	ERR_FAIL_COND_V(pos < 0, 0);
	ERR_FAIL_COND_V(fseeko(f, 0, SEEK_END), 0);
	int64_t size = ftello(f);
	ERR_FAIL_COND_V(size < 0, 0);
	ERR_FAIL_COND_V(fseeko(f, pos, SEEK_SET), 0);

	return size;
}

bool FileAccess::eof_reached() const {
	return last_error == ERR_FILE_EOF;
}

uint8_t FileAccess::get_8() const {
	ERR_FAIL_COND_V_MSG(!f, 0, "File must be opened before use.");
	uint8_t b;
	if (fread(&b, 1, 1, f) == 0) {
		check_errors();
		b = '\0';
	}
	return b;
}

uint64_t FileAccess::get_buffer(uint8_t *p_dst, uint64_t p_length) const {
	ERR_FAIL_COND_V(!p_dst && p_length > 0, -1);
	ERR_FAIL_COND_V_MSG(!f, -1, "File must be opened before use.");

	uint64_t read = fread(p_dst, 1, p_length, f);
	check_errors();
	return read;
};

Error FileAccess::get_error() const {
	return last_error;
}

void FileAccess::flush() {
	ERR_FAIL_COND_MSG(!f, "File must be opened before use.");
	fflush(f);
}

void FileAccess::store_8(uint8_t p_dest) {
	ERR_FAIL_COND_MSG(!f, "File must be opened before use.");
	ERR_FAIL_COND(fwrite(&p_dest, 1, 1, f) != 1);
}

void FileAccess::store_buffer(const uint8_t *p_src, uint64_t p_length) {
	ERR_FAIL_COND_MSG(!f, "File must be opened before use.");
	ERR_FAIL_COND(!p_src && p_length > 0);
	ERR_FAIL_COND(fwrite(p_src, 1, p_length, f) != p_length);
}

bool FileAccess::file_exists(const String &p_path) {
	int err;
	struct stat st;
	String filename = fix_path(p_path);

	// Does the name exist at all?
	err = stat(filename.utf8().get_data(), &st);
	if (err) {
		return false;
	}

#if defined(_WIN64) || defined(_WIN32)
	if (_access(filename.utf8().get_data(), 4) == -1) {
		return false;
	}
#else
	// See if we have access to the file
	if (access(filename.utf8().get_data(), F_OK)) {
		return false;
	}
#endif

	// See if this is a regular file
	switch (st.st_mode & S_IFMT) {
		case S_IFLNK:
		case S_IFREG:
			return true;
		default:
			return false;
	}
}

uint64_t FileAccess::_get_modified_time(const String &p_file) {
	String file = fix_path(p_file);
	struct stat flags;
	int err = stat(file.utf8().get_data(), &flags);

	if (!err) {
		return flags.st_mtime;
	} else {
		LOG_TRACE("Failed to get modified time for: " + p_file + "");
		return 0;
	};
}

uint32_t FileAccess::_get_unix_permissions(const String &p_file) {
	String file = fix_path(p_file);
	struct stat flags;
	int err = stat(file.utf8().get_data(), &flags);

	if (!err) {
		return flags.st_mode & 0x7FF; //only permissions
	} else {
		ERR_FAIL_V_MSG(0, "Failed to get unix permissions for: " + p_file + ".");
	};
}

Error FileAccess::_set_unix_permissions(const String &p_file, uint32_t p_permissions) {
	String file = fix_path(p_file);

	int err = chmod(file.utf8().get_data(), p_permissions);
	if (!err) {
		return OK;
	}

	return FAILED;
}

FileCloseNotificationFunc FileAccess::close_notification_func = nullptr;

FileAccess::FileAccess() :
		f(nullptr),
		flags(0),
		last_error(OK) {
	endian_swap = false;
	real_is_double = false;
}

FileAccess::~FileAccess() {
	close();
}

#endif

FileAccess::FileCloseFailNotify FileAccess::close_fail_notify = nullptr;

bool FileAccess::backup_save = false;

FileAccess *FileAccess::create() {
	return memnew(FileAccess());
}

bool FileAccess::exists(const String &p_name) {
	FileAccess *f = create_and_open(p_name, READ);
	if (!f) {
		return false;
	}
	memdelete(f);
	return true;
}

Error FileAccess::reopen(const String &p_path, int p_mode_flags) {
	return _open(p_path, p_mode_flags);
};

Error FileAccess::open(const String &p_path, int p_mode_flags) {
	return _open(p_path, p_mode_flags);
}

FileAccess *FileAccess::create_and_open(const String &p_path, int p_mode_flags, Error *r_error) {
	//try packed data first

	FileAccess *ret = nullptr;

	ret = create();
	Error err = ret->_open(p_path, p_mode_flags);

	if (r_error) {
		*r_error = err;
	}
	if (err != OK) {
		memdelete(ret);
		ret = nullptr;
	}

	return ret;
}

String FileAccess::fix_path(const String &p_path) const {
	//helper used by file accesses that use a single filesystem

	String r_path = p_path.replace("\\", "/");

	return r_path;
}

/* these are all implemented for ease of porting, then can later be optimized */

uint16_t FileAccess::get_16() const {
	uint16_t res;
	uint8_t a, b;

	a = get_8();
	b = get_8();

	if (endian_swap) {
		SWAP(a, b);
	}

	res = b;
	res <<= 8;
	res |= a;

	return res;
}
uint32_t FileAccess::get_32() const {
	uint32_t res;
	uint16_t a, b;

	a = get_16();
	b = get_16();

	if (endian_swap) {
		SWAP(a, b);
	}

	res = b;
	res <<= 16;
	res |= a;

	return res;
}
uint64_t FileAccess::get_64() const {
	uint64_t res;
	uint32_t a, b;

	a = get_32();
	b = get_32();

	if (endian_swap) {
		SWAP(a, b);
	}

	res = b;
	res <<= 32;
	res |= a;

	return res;
}

float FileAccess::get_float() const {
	MarshallFloat m;
	m.i = get_32();
	return m.f;
};

real_t FileAccess::get_real() const {
	if (real_is_double) {
		return get_double();
	} else {
		return get_float();
	}
}

double FileAccess::get_double() const {
	MarshallDouble m;
	m.l = get_64();
	return m.d;
};

String FileAccess::get_token() const {
	CharString token;

	CharType c = get_8();

	while (!eof_reached()) {
		if (c <= ' ') {
			if (token.length()) {
				break;
			}
		} else {
			token += c;
		}
		c = get_8();
	}

	return String::utf8(token.get_data());
}

class CharBuffer {
	Vector<char> vector;
	char stack_buffer[256];

	char *buffer;
	int capacity;
	int written;

	bool grow() {
		if (vector.resize(next_power_of_2(1 + written)) != OK) {
			return false;
		}

		if (buffer == stack_buffer) { // first chunk?

			for (int i = 0; i < written; i++) {
				vector.write[i] = stack_buffer[i];
			}
		}

		buffer = vector.ptrw();
		capacity = vector.size();
		ERR_FAIL_COND_V(written >= capacity, false);

		return true;
	}

public:
	_FORCE_INLINE_ CharBuffer() :
			buffer(stack_buffer),
			capacity(sizeof(stack_buffer) / sizeof(char)),
			written(0) {
	}

	_FORCE_INLINE_ void push_back(char c) {
		if (written >= capacity) {
			ERR_FAIL_COND(!grow());
		}

		buffer[written++] = c;
	}

	_FORCE_INLINE_ const char *get_data() const {
		return buffer;
	}
};

String FileAccess::get_line() const {
	CharBuffer line;

	CharType c = get_8();

	while (!eof_reached()) {
		if (c == '\n' || c == '\0') {
			line.push_back(0);
			return String::utf8(line.get_data());
		} else if (c != '\r') {
			line.push_back(c);
		}

		c = get_8();
	}
	line.push_back(0);
	return String::utf8(line.get_data());
}

Vector<String> FileAccess::get_csv_line(const String &p_delim) const {
	ERR_FAIL_COND_V_MSG(p_delim.length() != 1, Vector<String>(), "Only single character delimiters are supported to parse CSV lines.");
	ERR_FAIL_COND_V_MSG(p_delim[0] == '"', Vector<String>(), "The double quotation mark character (\") is not supported as a delimiter for CSV lines.");

	String line;

	// CSV can support entries with line breaks as long as they are enclosed
	// in double quotes. So our "line" might be more than a single line in the
	// text file.
	int qc = 0;
	do {
		if (eof_reached()) {
			break;
		}
		line += get_line() + "\n";
		qc = 0;
		for (int i = 0; i < line.length(); i++) {
			if (line[i] == '"') {
				qc++;
			}
		}
	} while (qc % 2);

	// Remove the extraneous newline we've added above.
	line = line.substr(0, line.length() - 1);

	Vector<String> strings;

	bool in_quote = false;
	String current;
	for (int i = 0; i < line.length(); i++) {
		CharType c = line[i];
		// A delimiter ends the current entry, unless it's in a quoted string.
		if (!in_quote && c == p_delim[0]) {
			strings.push_back(current);
			current = String();
		} else if (c == '"') {
			// Doubled quotes are escapes for intentional quotes in the string.
			if (line[i + 1] == '"' && in_quote) {
				current += '"';
				i++;
			} else {
				in_quote = !in_quote;
			}
		} else {
			current += c;
		}
	}
	strings.push_back(current);

	return strings;
}

/*
uint64_t FileAccess::get_buffer(uint8_t *p_dst, uint64_t p_length) const {
	ERR_FAIL_COND_V(!p_dst && p_length > 0, -1);

	uint64_t i = 0;
	for (i = 0; i < p_length && !eof_reached(); i++) {
		p_dst[i] = get_8();
	}

	return i;
}
*/

String FileAccess::get_as_utf8_string(bool p_skip_cr) const {
	Vector<uint8_t> sourcef;
	uint64_t len = get_len();
	sourcef.resize(len + 1);

	uint8_t *w = sourcef.ptrw();
	uint64_t r = get_buffer(w, len);
	ERR_FAIL_COND_V(r != len, String());
	w[len] = 0;

	String s;
	if (s.parse_utf8((const char *)w, -1, p_skip_cr)) {
		return String();
	}

	return s;
}

void FileAccess::store_16(uint16_t p_dest) {
	uint8_t a, b;

	a = p_dest & 0xFF;
	b = p_dest >> 8;

	if (endian_swap) {
		SWAP(a, b);
	}

	store_8(a);
	store_8(b);
}
void FileAccess::store_32(uint32_t p_dest) {
	uint16_t a, b;

	a = p_dest & 0xFFFF;
	b = p_dest >> 16;

	if (endian_swap) {
		SWAP(a, b);
	}

	store_16(a);
	store_16(b);
}
void FileAccess::store_64(uint64_t p_dest) {
	uint32_t a, b;

	a = p_dest & 0xFFFFFFFF;
	b = p_dest >> 32;

	if (endian_swap) {
		SWAP(a, b);
	}

	store_32(a);
	store_32(b);
}

void FileAccess::store_real(real_t p_real) {
	if (sizeof(real_t) == 4) {
		store_float(p_real);
	} else {
		store_double(p_real);
	}
}

void FileAccess::store_float(float p_dest) {
	MarshallFloat m;
	m.f = p_dest;
	store_32(m.i);
};

void FileAccess::store_double(double p_dest) {
	MarshallDouble m;
	m.d = p_dest;
	store_64(m.l);
};

uint64_t FileAccess::get_modified_time(const String &p_file) {
	FileAccess *fa = create();
	ERR_FAIL_COND_V_MSG(!fa, 0, "Cannot create FileAccess for path '" + p_file + "'.");

	uint64_t mt = fa->_get_modified_time(p_file);
	memdelete(fa);
	return mt;
}

uint32_t FileAccess::get_unix_permissions(const String &p_file) {
	FileAccess *fa = create();
	ERR_FAIL_COND_V_MSG(!fa, 0, "Cannot create FileAccess for path '" + p_file + "'.");

	uint32_t mt = fa->_get_unix_permissions(p_file);
	memdelete(fa);
	return mt;
}

Error FileAccess::set_unix_permissions(const String &p_file, uint32_t p_permissions) {
	FileAccess *fa = create();
	ERR_FAIL_COND_V_MSG(!fa, ERR_CANT_CREATE, "Cannot create FileAccess for path '" + p_file + "'.");

	Error err = fa->_set_unix_permissions(p_file, p_permissions);
	memdelete(fa);
	return err;
}

void FileAccess::store_string(const String &p_string) {
	if (p_string.length() == 0) {
		return;
	}

	CharString cs = p_string.utf8();
	store_buffer((uint8_t *)&cs[0], cs.length());
}

void FileAccess::store_pascal_string(const String &p_string) {
	CharString cs = p_string.utf8();
	store_32(cs.length());
	store_buffer((uint8_t *)&cs[0], cs.length());
};

String FileAccess::get_pascal_string() {
	uint32_t sl = get_32();
	CharString cs;
	cs.resize(sl + 1);
	get_buffer((uint8_t *)cs.ptr(), sl);
	cs[sl] = 0;

	String ret;
	ret.parse_utf8(cs.ptr());

	return ret;
};

void FileAccess::store_line(const String &p_line) {
	store_string(p_line);
	store_8('\n');
}

void FileAccess::store_csv_line(const Vector<String> &p_values, const String &p_delim) {
	ERR_FAIL_COND(p_delim.length() != 1);

	String line = "";
	int size = p_values.size();
	for (int i = 0; i < size; ++i) {
		String value = p_values[i];

		if (value.find("\"") != -1 || value.find(p_delim) != -1 || value.find("\n") != -1) {
			value = "\"" + value.replace("\"", "\"\"") + "\"";
		}
		if (i < size - 1) {
			value += p_delim;
		}

		line += value;
	}

	store_line(line);
}

void FileAccess::store_buffer_vec(const Vector<uint8_t> &data) {
	store_buffer(data.ptr(), data.size());
}

/*
void FileAccess::store_buffer(const uint8_t *p_src, uint64_t p_length) {
	ERR_FAIL_COND(!p_src && p_length > 0);
	for (uint64_t i = 0; i < p_length; i++) {
		store_8(p_src[i]);
	}
}
*/

Vector<uint8_t> FileAccess::get_file_as_array(const String &p_path, Error *r_error) {
	FileAccess *f = FileAccess::create_and_open(p_path, READ, r_error);
	if (!f) {
		if (r_error) { // if error requested, do not throw error
			return Vector<uint8_t>();
		}
		ERR_FAIL_V_MSG(Vector<uint8_t>(), "Can't open file from path '" + String(p_path) + "'.");
	}
	Vector<uint8_t> data;
	data.resize(f->get_len());
	f->get_buffer(data.ptrw(), data.size());
	memdelete(f);
	return data;
}

String FileAccess::get_file_as_string(const String &p_path, Error *r_error) {
	Error err;
	Vector<uint8_t> array = get_file_as_array(p_path, &err);
	if (r_error) {
		*r_error = err;
	}
	if (err != OK) {
		if (r_error) {
			return String();
		}
		ERR_FAIL_V_MSG(String(), "Can't get file as string from path '" + String(p_path) + "'.");
	}

	String ret;
	ret.parse_utf8((const char *)array.ptr(), array.size());
	return ret;
}

void FileAccess::write_file(const String &p_path, const String &data, Error *r_error) {
	FileAccess *f = FileAccess::create_and_open(p_path, WRITE, r_error);
	if (!f) {
		if (r_error) { // if error requested, do not throw error
			return;
		}

		ERR_FAIL_MSG("Can't open file from path '" + String(p_path) + "'.");
	}

	f->store_string(data);
	f->close();
	memdelete(f);
}
void FileAccess::write_file_buffer(const String &p_path, const Vector<uint8_t> &data, Error *r_error) {
	FileAccess *f = FileAccess::create_and_open(p_path, WRITE, r_error);
	if (!f) {
		if (r_error) { // if error requested, do not throw error
			return;
		}

		ERR_FAIL_MSG("Can't open file from path '" + String(p_path) + "'.");
	}

	f->store_buffer_vec(data);
	f->close();
	memdelete(f);
}

/*
FileAccess::FileAccess() {
	endian_swap = false;
	real_is_double = false;
};
*/
#line 0

#line 1 "sfw/core/dir_access.cpp"

/*************************************************************************/
/*  dir_access.cpp                                                       */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#if defined(_WIN64) || defined(_WIN32)

#include <stdio.h>
#include <wchar.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#else

#include <dirent.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/types.h>
#include <unistd.h>

#ifdef HAVE_MNTENT
#include <mntent.h>
#endif

#endif

#ifdef _MSC_VER
#pragma comment(lib, "Shlwapi")
#endif

#if defined(_WIN64) || defined(_WIN32)

bool DirAccess::is_link(String p_file) {
	return false;
};
String DirAccess::read_link(String p_file) {
	return p_file;
};
Error DirAccess::create_link(String p_source, String p_target) {
	return FAILED;
};

/*

[03:57] <reduz> yessopie, so i don't havemak to rely on unicows
[03:58] <yessopie> reduz- yeah, all of the functions fail, and then you can call GetLastError () which will return 120
[03:58] <drumstick> CategoryApl, hehe, what? :)
[03:59] <CategoryApl> didn't Verona lead to some trouble
[03:59] <yessopie> 120 = ERROR_CALL_NOT_IMPLEMENTED
[03:59] <yessopie> (you can use that constant if you include winerr.h)
[03:59] <CategoryApl> well answer with winning a compo

[04:02] <yessopie> if ( SetCurrentDirectoryW ( L"." ) == FALSE && GetLastError () == ERROR_CALL_NOT_IMPLEMENTED ) { use ANSI }
*/

struct DirAccessWindowsPrivate {
	HANDLE h; //handle for findfirstfile
	WIN32_FIND_DATA f;
	WIN32_FIND_DATAW fu; //unicode version
};

// CreateFolderAsync

Error DirAccess::list_dir_begin(bool skip_specials) {
	_cisdir = false;
	_cishidden = false;
	_skip_specials = skip_specials;

	list_dir_end();
	p->h = FindFirstFileExW((LPCWSTR)(String(current_dir + "\\*").utf16().get_data()), FindExInfoStandard, &p->fu, FindExSearchNameMatch, NULL, 0);

	return (p->h == INVALID_HANDLE_VALUE) ? ERR_CANT_OPEN : OK;
}

String DirAccess::get_next() {
	if (p->h == INVALID_HANDLE_VALUE) {
		return "";
	}

	_cisdir = (p->fu.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
	_cishidden = (p->fu.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN);

	String name = String::utf16((const char16_t *)(p->fu.cFileName));

	if (FindNextFileW(p->h, &p->fu) == 0) {
		FindClose(p->h);
		p->h = INVALID_HANDLE_VALUE;
	}

	return name;
}

bool DirAccess::current_is_dir() const {
	return _cisdir;
}

bool DirAccess::current_is_hidden() const {
	return _cishidden;
}

bool DirAccess::current_is_file() const {
	return !_cisdir;
}

bool DirAccess::current_is_special_dir() const {
	return _cisspecial;
}

void DirAccess::list_dir_end() {
	if (p->h != INVALID_HANDLE_VALUE) {
		FindClose(p->h);
		p->h = INVALID_HANDLE_VALUE;
	}
}
int DirAccess::get_drive_count() {
	return drive_count;
}
String DirAccess::get_drive(int p_drive) {
	if (p_drive < 0 || p_drive >= drive_count) {
		return "";
	}

	return String::chr(drives[p_drive]) + ":";
}

Error DirAccess::change_dir(String p_dir) {
	GLOBAL_LOCK_FUNCTION

	WCHAR real_current_dir_name[2048];
	GetCurrentDirectoryW(2048, real_current_dir_name);
	String prev_dir = String::utf16((const char16_t *)real_current_dir_name);

	SetCurrentDirectoryW((LPCWSTR)(current_dir.utf16().get_data()));
	bool worked = (SetCurrentDirectoryW((LPCWSTR)(p_dir.utf16().get_data())) != 0);

	String base;
	if (base != "") {
		GetCurrentDirectoryW(2048, real_current_dir_name);
		String new_dir = String::utf16((const char16_t *)real_current_dir_name).replace("\\", "/");
		if (!new_dir.begins_with(base)) {
			worked = false;
		}
	}

	if (worked) {
		GetCurrentDirectoryW(2048, real_current_dir_name);
		current_dir = String::utf16((const char16_t *)real_current_dir_name);
		current_dir = current_dir.replace("\\", "/");
	}

	SetCurrentDirectoryW((LPCWSTR)(prev_dir.utf16().get_data()));

	return worked ? OK : ERR_INVALID_PARAMETER;
}

Error DirAccess::make_dir(String p_dir) {
	GLOBAL_LOCK_FUNCTION

	if (p_dir.is_rel_path()) {
		p_dir = current_dir.plus_file(p_dir);
	}

	p_dir = p_dir.simplify_path().replace("/", "\\");

	bool success;
	int err;

	if (!p_dir.is_network_share_path()) {
		p_dir = "\\\\?\\" + p_dir;
		// Add "\\?\" to the path to extend max. path length past 248, if it's not a network share UNC path.
		// See https://msdn.microsoft.com/en-us/library/windows/desktop/aa363855(v=vs.85).aspx
	}

	success = CreateDirectoryW((LPCWSTR)(p_dir.utf16().get_data()), NULL);
	err = GetLastError();

	if (success) {
		return OK;
	}

	if (err == ERROR_ALREADY_EXISTS || err == ERROR_ACCESS_DENIED) {
		return ERR_ALREADY_EXISTS;
	}

	return ERR_CANT_CREATE;
}

String DirAccess::get_current_dir() {
	String base;
	if (base != "") {
		String bd = current_dir.replace("\\", "/").replace_first(base, "");
		if (bd.begins_with("/")) {
			return bd.substr(1, bd.length());
		} else {
			return bd;
		}
	}

	return current_dir;
}

String DirAccess::get_current_dir_without_drive() {
	String dir = get_current_dir();

	int p = current_dir.find(":");
	if (p != -1) {
		dir = dir.right(p + 1);
	}

	return dir;
}

bool DirAccess::file_exists(String p_file) {
	GLOBAL_LOCK_FUNCTION

	if (!p_file.is_abs_path()) {
		p_file = get_current_dir().plus_file(p_file);
	}

	DWORD fileAttr;

	fileAttr = GetFileAttributesW((LPCWSTR)(p_file.utf16().get_data()));
	if (INVALID_FILE_ATTRIBUTES == fileAttr) {
		return false;
	}

	return !(fileAttr & FILE_ATTRIBUTE_DIRECTORY);
}

bool DirAccess::dir_exists(String p_dir) {
	GLOBAL_LOCK_FUNCTION

	if (p_dir.is_rel_path()) {
		p_dir = get_current_dir().plus_file(p_dir);
	}

	DWORD fileAttr;

	fileAttr = GetFileAttributesW((LPCWSTR)(p_dir.utf16().get_data()));
	if (INVALID_FILE_ATTRIBUTES == fileAttr) {
		return false;
	}

	return (fileAttr & FILE_ATTRIBUTE_DIRECTORY);
}

Error DirAccess::rename(String p_path, String p_new_path) {
	if (p_path.is_rel_path()) {
		p_path = get_current_dir().plus_file(p_path);
	}

	if (p_new_path.is_rel_path()) {
		p_new_path = get_current_dir().plus_file(p_new_path);
	}

	// If we're only changing file name case we need to do a little juggling
	if (p_path.to_lower() == p_new_path.to_lower()) {
		if (dir_exists(p_path)) {
			// The path is a dir; just rename
			return ::_wrename((LPCWSTR)(p_path.utf16().get_data()), (LPCWSTR)(p_new_path.utf16().get_data())) == 0 ? OK : FAILED;
		}

		// The path is a file; juggle
		WCHAR tmpfile[MAX_PATH];

		if (!GetTempFileNameW((LPCWSTR)(get_current_dir().utf16().get_data()), NULL, 0, tmpfile)) {
			return FAILED;
		}

		if (!::ReplaceFileW(tmpfile, (LPCWSTR)(p_path.utf16().get_data()), NULL, 0, NULL, NULL)) {
			DeleteFileW(tmpfile);
			return FAILED;
		}

		return ::_wrename(tmpfile, (LPCWSTR)(p_new_path.utf16().get_data())) == 0 ? OK : FAILED;

	} else {
		if (file_exists(p_new_path)) {
			if (remove(p_new_path) != OK) {
				return FAILED;
			}
		}

		return ::_wrename((LPCWSTR)(p_path.utf16().get_data()), (LPCWSTR)(p_new_path.utf16().get_data())) == 0 ? OK : FAILED;
	}
}

Error DirAccess::remove(String p_path) {
	if (p_path.is_rel_path()) {
		p_path = get_current_dir().plus_file(p_path);
	}

	DWORD fileAttr;

	fileAttr = GetFileAttributesW((LPCWSTR)(p_path.utf16().get_data()));
	if (INVALID_FILE_ATTRIBUTES == fileAttr) {
		return FAILED;
	}

	if ((fileAttr & FILE_ATTRIBUTE_DIRECTORY)) {
		return ::_wrmdir((LPCWSTR)(p_path.utf16().get_data())) == 0 ? OK : FAILED;
	} else {
		return ::_wunlink((LPCWSTR)(p_path.utf16().get_data())) == 0 ? OK : FAILED;
	}
}
/*

FileType DirAccess::get_file_type(const String& p_file) const {
	WCHAR real_current_dir_name[2048];
	GetCurrentDirectoryW(2048, real_current_dir_name);
	String prev_dir = Strong::utf16((const char16_t *)real_current_dir_name);

	bool worked = SetCurrentDirectoryW((LPCWSTR)(current_dir.utf16().get_data()));

	DWORD attr;
	if (worked) {
		WIN32_FILE_ATTRIBUTE_DATA fileInfo;
		attr = GetFileAttributesExW((LPCWSTR)(p_file.utf16().get_data()), GetFileExInfoStandard, &fileInfo);
	}

	SetCurrentDirectoryW((LPCWSTR)(prev_dir.utf16().get_data()));

	if (!worked) {
		return FILE_TYPE_NONE;
	}

	return (attr & FILE_ATTRIBUTE_DIRECTORY) ? FILE_TYPE_
}
*/

uint64_t DirAccess::get_space_left() {
	uint64_t bytes = 0;

	if (!GetDiskFreeSpaceEx(NULL, (PULARGE_INTEGER)&bytes, NULL, NULL)) {
		return 0;
	}

	//this is either 0 or a value in bytes.
	return bytes;
}

String DirAccess::get_filesystem_type() const {
	String path = const_cast<DirAccess *>(this)->get_current_dir();

	if (path.is_network_share_path()) {
		return "Network Share";
	}

	int unit_end = path.find(":");
	ERR_FAIL_COND_V(unit_end == -1, String());
	String unit = path.substr(0, unit_end + 1) + "\\";

	WCHAR szVolumeName[100];
	WCHAR szFileSystemName[10];
	DWORD dwSerialNumber = 0;
	DWORD dwMaxFileNameLength = 0;
	DWORD dwFileSystemFlags = 0;

	if (::GetVolumeInformationW((LPCWSTR)(unit.utf16().get_data()),
				szVolumeName,
				sizeof(szVolumeName),
				&dwSerialNumber,
				&dwMaxFileNameLength,
				&dwFileSystemFlags,
				szFileSystemName,
				sizeof(szFileSystemName)) == TRUE) {
		return String::utf16((const char16_t *)szFileSystemName);
	}

	ERR_FAIL_V("");
}

int DirAccess::get_current_drive() {
	String path = get_current_dir().to_lower();
	for (int i = 0; i < get_drive_count(); i++) {
		String d = get_drive(i).to_lower();
		if (path.begins_with(d)) {
			return i;
		}
	}

	return 0;
}

bool DirAccess::drives_are_shortcuts() {
	return false;
}

uint64_t DirAccess::get_modified_time(String p_file) {
	return 0;
};

DirAccess::DirAccess() {
	p = memnew(DirAccessWindowsPrivate);
	p->h = INVALID_HANDLE_VALUE;
	current_dir = ".";

	drive_count = 0;

#ifdef UWP_ENABLED
	Windows::Storage::StorageFolder ^ install_folder = Windows::ApplicationModel::Package::Current->InstalledLocation;
	change_dir(install_folder->Path->Data());

#else

	DWORD mask = GetLogicalDrives();

	for (int i = 0; i < MAX_DRIVES; i++) {
		if (mask & (1 << i)) { //DRIVE EXISTS

			drives[drive_count] = 'A' + i;
			drive_count++;
		}
	}

	change_dir(".");
#endif
}

DirAccess::~DirAccess() {
	list_dir_end();

	memdelete(p);
}

#else

Error DirAccess::list_dir_begin(bool skip_specials) {
	list_dir_end(); //close any previous dir opening!

	_skip_specials = skip_specials;

	//char real_current_dir_name[2048]; //is this enough?!
	//getcwd(real_current_dir_name,2048);
	//chdir(current_path.utf8().get_data());
	dir_stream = opendir(current_dir.utf8().get_data());
	//chdir(real_current_dir_name);
	if (!dir_stream) {
		return ERR_CANT_OPEN; //error!
	}

	return OK;
}

bool DirAccess::file_exists(String p_file) {
	GLOBAL_LOCK_FUNCTION

	if (p_file.is_rel_path()) {
		p_file = current_dir.plus_file(p_file);
	}

	struct stat flags;
	bool success = (stat(p_file.utf8().get_data(), &flags) == 0);

	if (success && S_ISDIR(flags.st_mode)) {
		success = false;
	}

	return success;
}

bool DirAccess::dir_exists(String p_dir) {
	GLOBAL_LOCK_FUNCTION

	if (p_dir.is_rel_path()) {
		p_dir = get_current_dir().plus_file(p_dir);
	}

	struct stat flags;
	bool success = (stat(p_dir.utf8().get_data(), &flags) == 0);

	return (success && S_ISDIR(flags.st_mode));
}

uint64_t DirAccess::get_modified_time(String p_file) {
	if (p_file.is_rel_path()) {
		p_file = current_dir.plus_file(p_file);
	}

	struct stat flags;
	bool success = (stat(p_file.utf8().get_data(), &flags) == 0);

	if (success) {
		return flags.st_mtime;
	} else {
		ERR_FAIL_V(0);
	};
	return 0;
};

String DirAccess::get_next() {
	if (!dir_stream) {
		return "";
	}

	dirent *entry = readdir(dir_stream);

	if (entry == nullptr) {
		list_dir_end();
		return "";
	}

	String fname = fix_unicode_name(entry->d_name);

	// Look at d_type to determine if the entry is a directory, unless
	// its type is unknown (the file system does not support it) or if
	// the type is a link, in that case we want to resolve the link to
	// known if it points to a directory. stat() will resolve the link
	// for us.
	if (entry->d_type == DT_UNKNOWN || entry->d_type == DT_LNK) {
		String f = current_dir.plus_file(fname);

		struct stat flags;
		if (stat(f.utf8().get_data(), &flags) == 0) {
			_cisdir = S_ISDIR(flags.st_mode);
		} else {
			_cisdir = false;
		}
	} else {
		_cisdir = (entry->d_type == DT_DIR);
	}

	_cishidden = is_hidden(fname);

	_cisspecial = is_special(fname);

	if (_skip_specials && _cisspecial) {
		// Should only happen 2 times max
		return get_next();
	}

	return fname;
}

bool DirAccess::current_is_dir() const {
	return _cisdir;
}

bool DirAccess::current_is_file() const {
	return !_cisdir;
}

bool DirAccess::current_is_special_dir() const {
	return _cisspecial;
}

bool DirAccess::current_is_hidden() const {
	return _cishidden;
}

void DirAccess::list_dir_end() {
	if (dir_stream) {
		closedir(dir_stream);
	}
	dir_stream = nullptr;
	_cisdir = false;
}

#if defined(HAVE_MNTENT) && defined(X11_ENABLED)
static bool _filter_drive(struct mntent *mnt) {
	// Ignore devices that don't point to /dev
	if (strncmp(mnt->mnt_fsname, "/dev", 4) != 0) {
		return false;
	}

	// Accept devices mounted at common locations
	if (strncmp(mnt->mnt_dir, "/media", 6) == 0 ||
			strncmp(mnt->mnt_dir, "/mnt", 4) == 0 ||
			strncmp(mnt->mnt_dir, "/home", 5) == 0 ||
			strncmp(mnt->mnt_dir, "/run/media", 10) == 0) {
		return true;
	}

	// Ignore everything else
	return false;
}
#endif

static void _get_drives(List<String> *list) {
	list->push_back("/");

#if defined(HAVE_MNTENT) && defined(X11_ENABLED)
	// Check /etc/mtab for the list of mounted partitions
	FILE *mtab = setmntent("/etc/mtab", "r");
	if (mtab) {
		struct mntent mnt;
		char strings[4096];

		while (getmntent_r(mtab, &mnt, strings, sizeof(strings))) {
			if (mnt.mnt_dir != nullptr && _filter_drive(&mnt)) {
				// Avoid duplicates
				if (!list->find(mnt.mnt_dir)) {
					list->push_back(mnt.mnt_dir);
				}
			}
		}

		endmntent(mtab);
	}
#endif

	// Add $HOME
	const char *home = getenv("HOME");
	if (home) {
		// Only add if it's not a duplicate
		if (!list->find(home)) {
			list->push_back(home);
		}

		// Check $HOME/.config/gtk-3.0/bookmarks
		char path[1024];
		snprintf(path, 1024, "%s/.config/gtk-3.0/bookmarks", home);
		FILE *fd = fopen(path, "r");
		if (fd) {
			char string[1024];
			while (fgets(string, 1024, fd)) {
				// Parse only file:// links
				if (strncmp(string, "file://", 7) == 0) {
					// Strip any unwanted edges on the strings and push_back if it's not a duplicate
					String fpath = String(string + 7).strip_edges().split_spaces()[0].percent_decode();
					if (!list->find(fpath)) {
						list->push_back(fpath);
					}
				}
			}

			fclose(fd);
		}
	}

	list->sort();
}

int DirAccess::get_drive_count() {
	List<String> list;
	_get_drives(&list);

	return list.size();
}

String DirAccess::get_drive(int p_drive) {
	List<String> list;
	_get_drives(&list);

	ERR_FAIL_INDEX_V(p_drive, list.size(), "");

	return list[p_drive];
}

int DirAccess::get_current_drive() {
	int drive = 0;
	int max_length = -1;
	const String path = get_current_dir().to_lower();
	for (int i = 0; i < get_drive_count(); i++) {
		const String d = get_drive(i).to_lower();
		if (max_length < d.length() && path.begins_with(d)) {
			max_length = d.length();
			drive = i;
		}
	}
	return drive;
}

bool DirAccess::drives_are_shortcuts() {
	return true;
}

Error DirAccess::make_dir(String p_dir) {
	GLOBAL_LOCK_FUNCTION

	if (p_dir.is_rel_path()) {
		p_dir = get_current_dir().plus_file(p_dir);
	}

	bool success = (mkdir(p_dir.utf8().get_data(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) == 0);
	int err = errno;

	if (success) {
		return OK;
	};

	if (err == EEXIST) {
		return ERR_ALREADY_EXISTS;
	};

	return ERR_CANT_CREATE;
}

Error DirAccess::change_dir(String p_dir) {
	GLOBAL_LOCK_FUNCTION

	// prev_dir is the directory we are changing out of
	String prev_dir;
	char real_current_dir_name[2048];
	ERR_FAIL_COND_V(getcwd(real_current_dir_name, 2048) == nullptr, ERR_BUG);
	if (prev_dir.parse_utf8(real_current_dir_name)) {
		prev_dir = real_current_dir_name; //no utf8, maybe latin?
	}

	// try_dir is the directory we are trying to change into
	String try_dir = "";
	if (p_dir.is_rel_path()) {
		String next_dir = current_dir.plus_file(p_dir);
		next_dir = next_dir.simplify_path();
		try_dir = next_dir;
	} else {
		try_dir = p_dir;
	}

	bool worked = (chdir(try_dir.utf8().get_data()) == 0); // we can only give this utf8
	if (!worked) {
		return ERR_INVALID_PARAMETER;
	}

	String base;
	if (base != String() && !try_dir.begins_with(base)) {
		ERR_FAIL_COND_V(getcwd(real_current_dir_name, 2048) == nullptr, ERR_BUG);
		String new_dir;
		new_dir.parse_utf8(real_current_dir_name);

		if (!new_dir.begins_with(base)) {
			try_dir = current_dir; //revert
		}
	}

	// the directory exists, so set current_dir to try_dir
	current_dir = try_dir;
	ERR_FAIL_COND_V(chdir(prev_dir.utf8().get_data()) != 0, ERR_BUG);
	return OK;
}

String DirAccess::get_current_dir() {
	String base;
	if (base != "") {
		String bd = current_dir.replace_first(base, "");
		if (bd.begins_with("/")) {
			return bd.substr(1, bd.length());
		} else {
			return bd;
		}
	}
	return current_dir;
}

Error DirAccess::rename(String p_path, String p_new_path) {
	if (p_path.is_rel_path()) {
		p_path = get_current_dir().plus_file(p_path);
	}

	if (p_new_path.is_rel_path()) {
		p_new_path = get_current_dir().plus_file(p_new_path);
	}

	return ::rename(p_path.utf8().get_data(), p_new_path.utf8().get_data()) == 0 ? OK : FAILED;
}

Error DirAccess::remove(String p_path) {
	if (p_path.is_rel_path()) {
		p_path = get_current_dir().plus_file(p_path);
	}

	struct stat flags;
	if ((stat(p_path.utf8().get_data(), &flags) != 0)) {
		return FAILED;
	}

	if (S_ISDIR(flags.st_mode)) {
		return ::rmdir(p_path.utf8().get_data()) == 0 ? OK : FAILED;
	} else {
		return ::unlink(p_path.utf8().get_data()) == 0 ? OK : FAILED;
	}
}

bool DirAccess::is_link(String p_file) {
	if (p_file.is_rel_path()) {
		p_file = get_current_dir().plus_file(p_file);
	}

	struct stat flags;
	if ((lstat(p_file.utf8().get_data(), &flags) != 0)) {
		return FAILED;
	}

	return S_ISLNK(flags.st_mode);
}

String DirAccess::read_link(String p_file) {
	if (p_file.is_rel_path()) {
		p_file = get_current_dir().plus_file(p_file);
	}

	char buf[256];
	memset(buf, 0, 256);
	ssize_t len = readlink(p_file.utf8().get_data(), buf, sizeof(buf));
	String link;
	if (len > 0) {
		link.parse_utf8(buf, len);
	}
	return link;
}

Error DirAccess::create_link(String p_source, String p_target) {
	if (p_target.is_rel_path()) {
		p_target = get_current_dir().plus_file(p_target);
	}

	if (symlink(p_source.utf8().get_data(), p_target.utf8().get_data()) == 0) {
		return OK;
	} else {
		return FAILED;
	}
}

uint64_t DirAccess::get_space_left() {
#ifndef NO_STATVFS
	struct statvfs vfs;
	if (statvfs(current_dir.utf8().get_data(), &vfs) != 0) {
		return 0;
	};

	return (uint64_t)vfs.f_bavail * (uint64_t)vfs.f_frsize;
#else
	// FIXME: Implement this.
	return 0;
#endif
};

String DirAccess::get_filesystem_type() const {
	return ""; //TODO this should be implemented
}

bool DirAccess::is_hidden(const String &p_name) {
	return p_name != "." && p_name != ".." && p_name.begins_with(".");
}

String DirAccess::get_current_dir_without_drive() {
	return get_current_dir();
}

DirAccess::DirAccess() {
	dir_stream = NULL;
	_cisdir = false;

	next_is_dir = false;
	_skip_specials = false;

	_cishidden = false;
	_cisspecial = false;

	/* determine drive count */

	// set current directory to an absolute path of the current directory
	char real_current_dir_name[2048];
	ERR_FAIL_COND(getcwd(real_current_dir_name, 2048) == nullptr);
	if (current_dir.parse_utf8(real_current_dir_name)) {
		current_dir = real_current_dir_name;
	}

	change_dir(current_dir);
}

DirAccess::~DirAccess() {
	list_dir_end();
}

#endif

static Error _erase_recursive(DirAccess *da) {
	List<String> dirs;
	List<String> files;

	da->list_dir_begin();
	String n = da->get_next();
	while (n != String()) {
		if (n != "." && n != "..") {
			if (da->current_is_dir()) {
				dirs.push_back(n);
			} else {
				files.push_back(n);
			}
		}

		n = da->get_next();
	}

	da->list_dir_end();

	for (List<String>::Element *E = dirs.front(); E; E = E->next()) {
		Error err = da->change_dir(E->get());
		if (err == OK) {
			err = _erase_recursive(da);
			if (err) {
				da->change_dir("..");
				return err;
			}
			err = da->change_dir("..");
			if (err) {
				return err;
			}
			err = da->remove(da->get_current_dir().plus_file(E->get()));
			if (err) {
				return err;
			}
		} else {
			return err;
		}
	}

	for (List<String>::Element *E = files.front(); E; E = E->next()) {
		Error err = da->remove(da->get_current_dir().plus_file(E->get()));
		if (err) {
			return err;
		}
	}

	return OK;
}

Error DirAccess::erase_contents_recursive() {
	return _erase_recursive(this);
}

Error DirAccess::make_dir_recursive(String p_dir) {
	if (p_dir.length() < 1) {
		return OK;
	};

	String full_dir;

	if (p_dir.is_rel_path()) {
		//append current
		full_dir = get_current_dir().plus_file(p_dir);

	} else {
		full_dir = p_dir;
	}

	full_dir = full_dir.replace("\\", "/");

	String base;

	if (full_dir.is_network_share_path()) {
		int pos = full_dir.find("/", 2);
		ERR_FAIL_COND_V(pos < 0, ERR_INVALID_PARAMETER);
		pos = full_dir.find("/", pos + 1);
		ERR_FAIL_COND_V(pos < 0, ERR_INVALID_PARAMETER);
		base = full_dir.substr(0, pos + 1);
	} else if (full_dir.begins_with("/")) {
		base = "/";
	} else if (full_dir.find(":/") != -1) {
		base = full_dir.substr(0, full_dir.find(":/") + 2);
	} else {
		ERR_FAIL_V(ERR_INVALID_PARAMETER);
	}

	full_dir = full_dir.replace_first(base, "").simplify_path();

	Vector<String> subdirs = full_dir.split("/");

	String curpath = base;
	for (int i = 0; i < subdirs.size(); i++) {
		curpath = curpath.plus_file(subdirs[i]);
		Error err = make_dir(curpath);
		if (err != OK && err != ERR_ALREADY_EXISTS) {
			ERR_FAIL_V_MSG(err, "Could not create directory: " + curpath);
		}
	}

	return OK;
}

DirAccess *DirAccess::create_for_path(const String &p_path) {
	DirAccess *d = memnew(DirAccess());
	d->open(p_path);
	return d;
}
DirAccess *DirAccess::create() {
	return memnew(DirAccess());
}

Error DirAccess::open(const String &p_path) {
	return change_dir(p_path);
}

String DirAccess::get_full_path(const String &p_path) {
	DirAccess d;

	d.change_dir(p_path);
	String full = d.get_current_dir();

	return full;
}

Error DirAccess::copy(String p_from, String p_to, int p_chmod_flags) {
	//printf("copy %s -> %s\n",p_from.ascii().get_data(),p_to.ascii().get_data());
	Error err;
	FileAccess *fsrc = FileAccess::create_and_open(p_from, FileAccess::READ, &err);

	if (err) {
		ERR_PRINT("Failed to open " + p_from);
		return err;
	}

	FileAccess *fdst = FileAccess::create_and_open(p_to, FileAccess::WRITE, &err);
	if (err) {
		fsrc->close();
		memdelete(fsrc);
		ERR_PRINT("Failed to open " + p_to);
		return err;
	}

	const size_t copy_buffer_limit = 65536; // 64 KB

	fsrc->seek_end(0);
	uint64_t size = fsrc->get_position();
	fsrc->seek(0);
	err = OK;
	size_t buffer_size = MIN(size * sizeof(uint8_t), copy_buffer_limit);
	LocalVector<uint8_t> buffer;
	buffer.resize(buffer_size);
	while (size > 0) {
		if (fsrc->get_error() != OK) {
			err = fsrc->get_error();
			break;
		}
		if (fdst->get_error() != OK) {
			err = fdst->get_error();
			break;
		}

		int bytes_read = fsrc->get_buffer(buffer.ptr(), buffer_size);
		if (bytes_read <= 0) {
			err = FAILED;
			break;
		}
		fdst->store_buffer(buffer.ptr(), bytes_read);

		size -= bytes_read;
	}

	if (err == OK && p_chmod_flags != -1) {
		fdst->close();
		err = FileAccess::set_unix_permissions(p_to, p_chmod_flags);
		// If running on a platform with no chmod support (i.e., Windows), don't fail
		if (err == ERR_UNAVAILABLE) {
			err = OK;
		}
	}

	memdelete(fsrc);
	memdelete(fdst);

	return err;
}

// Changes dir for the current scope, returning back to the original dir
// when scope exits
class DirChanger {
	DirAccess *da;
	String original_dir;

public:
	DirChanger(DirAccess *p_da, String p_dir) :
			da(p_da),
			original_dir(p_da->get_current_dir()) {
		p_da->change_dir(p_dir);
	}

	~DirChanger() {
		da->change_dir(original_dir);
	}
};

Error DirAccess::_copy_dir(DirAccess *p_target_da, String p_to, int p_chmod_flags, bool p_copy_links) {
	List<String> dirs;

	String curdir = get_current_dir();
	list_dir_begin();
	String n = get_next();
	while (n != String()) {
		if (n != "." && n != "..") {
			if (p_copy_links && is_link(get_current_dir().plus_file(n))) {
				create_link(read_link(get_current_dir().plus_file(n)), p_to + n);
			} else if (current_is_dir()) {
				dirs.push_back(n);
			} else {
				const String &rel_path = n;
				if (!n.is_rel_path()) {
					list_dir_end();
					return ERR_BUG;
				}
				Error err = copy(get_current_dir().plus_file(n), p_to + rel_path, p_chmod_flags);
				if (err) {
					list_dir_end();
					return err;
				}
			}
		}

		n = get_next();
	}

	list_dir_end();

	for (List<String>::Element *E = dirs.front(); E; E = E->next()) {
		String rel_path = E->get();
		String target_dir = p_to + rel_path;
		if (!p_target_da->dir_exists(target_dir)) {
			Error err = p_target_da->make_dir(target_dir);
			ERR_FAIL_COND_V_MSG(err != OK, err, "Cannot create directory '" + target_dir + "'.");
		}

		Error err = change_dir(E->get());
		ERR_FAIL_COND_V_MSG(err != OK, err, "Cannot change current directory to '" + E->get() + "'.");

		err = _copy_dir(p_target_da, p_to + rel_path + "/", p_chmod_flags, p_copy_links);
		if (err) {
			change_dir("..");
			ERR_FAIL_V_MSG(err, "Failed to copy recursively.");
		}
		err = change_dir("..");
		ERR_FAIL_COND_V_MSG(err != OK, err, "Failed to go back.");
	}

	return OK;
}

Error DirAccess::copy_dir(String p_from, String p_to, int p_chmod_flags, bool p_copy_links) {
	ERR_FAIL_COND_V_MSG(!dir_exists(p_from), ERR_FILE_NOT_FOUND, "Source directory doesn't exist.");

	DirAccess *target_da = DirAccess::create_for_path(p_to);
	ERR_FAIL_COND_V_MSG(!target_da, ERR_CANT_CREATE, "Cannot create DirAccess for path '" + p_to + "'.");

	if (!target_da->dir_exists(p_to)) {
		Error err = target_da->make_dir_recursive(p_to);
		if (err) {
			memdelete(target_da);
		}
		ERR_FAIL_COND_V_MSG(err != OK, err, "Cannot create directory '" + p_to + "'.");
	}

	if (!p_to.ends_with("/")) {
		p_to = p_to + "/";
	}

	DirChanger dir_changer(this, p_from);
	Error err = _copy_dir(target_da, p_to, p_chmod_flags, p_copy_links);
	memdelete(target_da);

	return err;
}

bool DirAccess::exists(String p_dir) {
	DirAccess *da = DirAccess::create_for_path(p_dir);
	bool valid = da->change_dir(p_dir) == OK;
	memdelete(da);
	return valid;
}

String DirAccess::get_filesystem_abspath_for(String p_path) {
	DirAccess d;

	d.change_dir(p_path);
	String full = d.get_current_dir();

	return full;
}

bool DirAccess::is_special(const String &p_path) {
	if (p_path.size() > 2) {
		return false;
	}

	return p_path == "." || p_path == "..";
}
#line 0

#line 1 "sfw/core/inet_address.cpp"
//Based on:

// Copyright 2010, Shuo Chen.  All rights reserved.
// http://code.google.com/p/muduo/
//
// Use of this source code is governed by a BSD-style license
// that can be found in the License file.

// Author: Shuo Chen (chenshuo at chenshuo dot com)

#include <cstdio>
#include <cstring>

#if defined(_WIN64) || defined(_WIN32)

#ifdef __GNUC__
#define GCCWIN
// Mingw / gcc on windows
//   #define _WIN32_WINNT 0x0501
#include <winsock2.h>
#include <ws2tcpip.h>

extern "C" {
WINSOCK_API_LINKAGE INT WSAAPI inet_pton(INT Family, PCSTR pszAddrString, PVOID pAddrBuf);

#ifdef __MINGW64_VERSION_MAJOR
#if __MINGW64_VERSION_MAJOR >= 7
WINSOCK_API_LINKAGE PCSTR WSAAPI inet_ntop(INT Family, const VOID *pAddr, PSTR pStringBuf, size_t StringBufSize);
#else
WINSOCK_API_LINKAGE PCSTR WSAAPI inet_ntop(INT Family, VOID *pAddr, PSTR pStringBuf, size_t StringBufSize);
#endif

#else
WINSOCK_API_LINKAGE PCSTR WSAAPI inet_ntop(INT Family, VOID *pAddr, PSTR pStringBuf, size_t StringBufSize);
#endif
}
#else
// Windows...

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#include <in6addr.h>
#include <winsock2.h>
#include <ws2tcpip.h>

extern "C" {

PCSTR WSAAPI inet_ntop(_In_ INT Family, _In_ const VOID *pAddr, _Out_writes_(StringBufSize) PSTR pStringBuf, _In_ size_t StringBufSize);

WINSOCK_API_LINKAGE INT WSAAPI inet_pton(_In_ INT Family, _In_ PCSTR pszAddrString, _When_(Family == AF_INET, _Out_writes_bytes_(sizeof(IN_ADDR))) _When_(Family == AF_INET6, _Out_writes_bytes_(sizeof(IN6_ADDR))) PVOID pAddrBuf);
}

#endif

struct in6__addruint {
	union {
		u_char Byte[16];
		u_short Word[8];
		uint32_t __s6_addr32[4];
	} uext;
};
#else
#include <netdb.h>
#include <netinet/tcp.h>
#include <strings.h> // memset
#endif

#ifdef _MSC_VER
#pragma comment(lib, "ws2_32")
#endif

// INADDR_ANY use (type)value casting.
static const in_addr_t kInaddrAny = INADDR_ANY;
static const in_addr_t kInaddrLoopback = INADDR_ANY;

//     /* Structure describing an Internet socket address.  */
//     struct sock_addrin {
//         sa_family_t    sin_family; /* address family: AF_INET */
//         uint16_t       sin_port;   /* port in network byte order */
//         struct in_addr sin_addr;   /* internet address */
//     };

//     /* Internet address. */
//     typedef uint32_t in_addr_t;
//     struct in_addr {
//         in_addr_t       s_addr;     /* address in network byte order */
//     };

//     struct sockaddr_in6 {
//         sa_family_t     sin6_family;   /* address family: AF_INET6 */
//         uint16_t        sin6_port;     /* port in network byte order */
//         uint32_t        sin6_flowinfo; /* IPv6 flow information */
//         struct in6_addr sin6_addr;     /* IPv6 address */
//         uint32_t        sin6_scope_id; /* IPv6 scope-id */
//     };

/*
#ifdef __linux__
#if !(__GNUC_PREREQ(4, 6))
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif
#endif
*/

// Defined here so we don't need to include <windows.h> in the header
struct InetAddress::InetAddressData {
	union {
		struct sockaddr_in _addr;
		struct sockaddr_in6 _addr6;
	};
};

String InetAddress::to_ip_port() const {
	char buf[64] = "";
	uint16_t port = ntohs(_data->_addr.sin_port);
	snprintf(buf, sizeof(buf), ":%u", port);

	return to_ip() + String(buf);
}

bool InetAddress::is_intranet_ip() const {
	if (_data->_addr.sin_family == AF_INET) {
		uint32_t ip_addr = ntohl(_data->_addr.sin_addr.s_addr);
		if ((ip_addr >= 0x0A000000 && ip_addr <= 0x0AFFFFFF) ||
				(ip_addr >= 0xAC100000 && ip_addr <= 0xAC1FFFFF) ||
				(ip_addr >= 0xC0A80000 && ip_addr <= 0xC0A8FFFF) ||
				ip_addr == 0x7f000001)

		{
			return true;
		}
	} else {
		auto addrP = ip6_net_endian();
		// Loopback ip
		if (*addrP == 0 && *(addrP + 1) == 0 && *(addrP + 2) == 0 &&
				ntohl(*(addrP + 3)) == 1) {
			return true;
		}

		// Privated ip is prefixed by FEC0::/10 or FE80::/10, need testing
		auto i32 = (ntohl(*addrP) & 0xffc00000);
		if (i32 == 0xfec00000 || i32 == 0xfe800000) {
			return true;
		}

		if (*addrP == 0 && *(addrP + 1) == 0 && ntohl(*(addrP + 2)) == 0xffff) {
			// the IPv6 version of an IPv4 IP address
			uint32_t ip_addr = ntohl(*(addrP + 3));
			if ((ip_addr >= 0x0A000000 && ip_addr <= 0x0AFFFFFF) ||
					(ip_addr >= 0xAC100000 && ip_addr <= 0xAC1FFFFF) ||
					(ip_addr >= 0xC0A80000 && ip_addr <= 0xC0A8FFFF) ||
					ip_addr == 0x7f000001)

			{
				return true;
			}
		}
	}
	return false;
}

bool InetAddress::is_loopback_ip() const {
	if (!is_ip_v6()) {
		uint32_t ip_addr = ntohl(_data->_addr.sin_addr.s_addr);
		if (ip_addr == 0x7f000001) {
			return true;
		}
	} else {
		auto addrP = ip6_net_endian();
		if (*addrP == 0 && *(addrP + 1) == 0 && *(addrP + 2) == 0 &&
				ntohl(*(addrP + 3)) == 1) {
			return true;
		}
		// the IPv6 version of an IPv4 loopback address
		if (*addrP == 0 && *(addrP + 1) == 0 && ntohl(*(addrP + 2)) == 0xffff &&
				ntohl(*(addrP + 3)) == 0x7f000001) {
			return true;
		}
	}
	return false;
}

const struct sockaddr *InetAddress::get_sock_addr() const {
	return static_cast<const struct sockaddr *>((void *)(&_data->_addr6));
}

void InetAddress::set_sock_addr_inet6(const struct sockaddr_in6 &addr6) {
	_data->_addr6 = addr6;
	_is_ip_v6 = (_data->_addr6.sin6_family == AF_INET6);
	_is_unspecified = false;
}

sa_family_t InetAddress::family() const {
	return _data->_addr.sin_family;
}

String InetAddress::to_ip() const {
	char buf[64];
	if (_data->_addr.sin_family == AF_INET) {
#if defined GCCWIN || (_MSC_VER && _MSC_VER >= 1900)
		::inet_ntop(AF_INET, (PVOID)&_data->_addr.sin_addr, buf, sizeof(buf));
#else
		::inet_ntop(AF_INET, &_data->_addr.sin_addr, buf, sizeof(buf));
#endif
	} else if (_data->_addr.sin_family == AF_INET6) {
#if defined GCCWIN || (_MSC_VER && _MSC_VER >= 1900)
		::inet_ntop(AF_INET6, (PVOID)&_data->_addr6.sin6_addr, buf, sizeof(buf));
#else
		::inet_ntop(AF_INET6, &_data->_addr6.sin6_addr, buf, sizeof(buf));
#endif
	}

	return buf;
}

uint32_t InetAddress::ip_net_endian() const {
	// assert(family() == AF_INET);
	return _data->_addr.sin_addr.s_addr;
}

const uint32_t *InetAddress::ip6_net_endian() const {
// assert(family() == AF_INET6);
#if defined __linux__ || defined __HAIKU__
	return _data->_addr6.sin6_addr.s6_addr32;
#elif defined(_WIN64) || defined(_WIN32)
	// TODO is this OK ?
	const struct in6__addruint *_addrtemp =
			reinterpret_cast<const struct in6__addruint *>(&_data->_addr6.sin6_addr);
	return (*_addrtemp).uext.__s6_addr32;
#else
	return _data->_addr6.sin6_addr.__u6_addr.__u6_addr32;
#endif
}

uint16_t InetAddress::port_net_endian() const {
	return _data->_addr.sin_port;
}

void InetAddress::set_port_net_endian(uint16_t port) {
	_data->_addr.sin_port = port;
}

inline bool InetAddress::is_unspecified() const {
	return _is_unspecified;
}

uint16_t InetAddress::to_port() const {
	return ntohs(port_net_endian());
}

bool InetAddress::is_ip_v6() const {
	return _is_ip_v6;
}

InetAddress::InetAddress(uint16_t port, bool loopbackOnly, bool ipv6) {
	_data = memnew(InetAddressData);

	_is_ip_v6 = ipv6;

	if (ipv6) {
		memset(&_data->_addr6, 0, sizeof(_data->_addr6));
		_data->_addr6.sin6_family = AF_INET6;

		in6_addr ip = loopbackOnly ? in6addr_loopback : in6addr_any;

		_data->_addr6.sin6_addr = ip;
		_data->_addr6.sin6_port = htons(port);
	} else {
		memset(&_data->_addr, 0, sizeof(_data->_addr));
		_data->_addr.sin_family = AF_INET;

		in_addr_t ip = loopbackOnly ? kInaddrLoopback : kInaddrAny;

		_data->_addr.sin_addr.s_addr = htonl(ip);
		_data->_addr.sin_port = htons(port);
	}

	_is_unspecified = false;
}

InetAddress::InetAddress(const String &ip, uint16_t port, bool ipv6) {
	_data = memnew(InetAddressData);

	_is_ip_v6 = ipv6;

	if (ipv6) {
		memset(&_data->_addr6, 0, sizeof(_data->_addr6));
		_data->_addr6.sin6_family = AF_INET6;
		_data->_addr6.sin6_port = htons(port);

		if (::inet_pton(AF_INET6, ip.utf8().get_data(), &_data->_addr6.sin6_addr) <= 0) {
			return;
		}
	} else {
		memset(&_data->_addr, 0, sizeof(_data->_addr));
		_data->_addr.sin_family = AF_INET;
		_data->_addr.sin_port = htons(port);

		if (::inet_pton(AF_INET, ip.utf8().get_data(), &_data->_addr.sin_addr) <= 0) {
			return;
		}
	}

	_is_unspecified = false;
}

InetAddress::InetAddress(const struct sockaddr_in &addr) {
	_data = memnew(InetAddressData);

	_data->_addr = addr;
	_is_unspecified = false;
}

InetAddress::InetAddress(const struct sockaddr_in6 &addr) {
	_data = memnew(InetAddressData);

	_data->_addr6 = addr;
	_is_ip_v6 = true;
	_is_unspecified = false;
}

InetAddress::~InetAddress() {
	memdelete(_data);
}
#line 0

#line 1 "sfw/core/socket.cpp"

//Based on:

/**
 *
 *  Socket.cc
 *  An Tao
 *
 *  Public header file in trantor lib.
 *
 *  Copyright 2018, An Tao.  All rights reserved.
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the License file.
 *
 *
 */

#if !defined(_WIN64) && !defined(_WIN32)
#include <unistd.h>
#endif
#include <fcntl.h>

///usr/include/asm-generic/errno-base.h
//http://www.virtsync.com/c-error-codes-include-errno
#include <cerrno>

#if defined(_WIN64) || defined(_WIN32)
#include <ws2tcpip.h>
#else
#include <netinet/tcp.h>
#include <sys/socket.h>
#endif

void Socket::create_net_socket() {
	create(AF_INET);
}

void Socket::create(int family) {
#ifdef __linux__
	_socket = ::socket(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);
#else
	_socket = static_cast<int>(::socket(family, SOCK_STREAM, IPPROTO_TCP));
#endif
}

void Socket::close_socket() {
	if (!_socket) {
		return;
	}

#if !defined(_WIN64) && !defined(_WIN32)
	close(_socket);
#else
	closesocket(_socket);
#endif

	_socket = 0;
}

// taken from muduo
int Socket::set_non_block() {
	ERR_FAIL_COND_V(_socket == 0, -1);

#if defined(_WIN64) || defined(_WIN32)
	// TODO how to set FD_CLOEXEC on windows? is it necessary?
	u_long arg = 1;
	auto ret = ioctlsocket(_socket, (long)FIONBIO, &arg);

	if (ret) {
		//LOG_ERR("ioctlsocket error");
		return -1;
	}

	return 0;
#else
	// non-block
	int flags = ::fcntl(_socket, F_GETFL, 0);
	flags |= O_NONBLOCK;
	int ret = ::fcntl(_socket, F_SETFL, flags);
	// TODO check

	return ret;
#endif
}

// taken from muduo
int Socket::set_close_on_exit() {
	ERR_FAIL_COND_V(_socket == 0, -1);

#if defined(_WIN64) || defined(_WIN32)
	// TODO how to set FD_CLOEXEC on windows? is it necessary?
	return 0;
#else
	// close-on-exec
	int flags = ::fcntl(_socket, F_GETFD, 0);
	flags |= FD_CLOEXEC;
	int ret = ::fcntl(_socket, F_SETFD, flags);
	// TODO check

	return ret;
#endif
}

int Socket::get_error() {
	ERR_FAIL_COND_V(_socket == 0, -1);

	int optval;

	socklen_t optlen = static_cast<socklen_t>(sizeof optval);

#if defined(_WIN64) || defined(_WIN32)
	if (::getsockopt(_socket, SOL_SOCKET, SO_ERROR, (char *)&optval, &optlen) < 0)
#else
	if (::getsockopt(_socket, SOL_SOCKET, SO_ERROR, &optval, &optlen) < 0)
#endif
	{
		return errno;
	} else {
		return optval;
	}
}

int Socket::connect(const InetAddress &addr) {
	ERR_FAIL_COND_V(_socket == 0, -1);

	if (addr.is_ip_v6()) {
		return ::connect(_socket, addr.get_sock_addr(), static_cast<socklen_t>(sizeof(struct sockaddr_in6)));
	} else {
		return ::connect(_socket, addr.get_sock_addr(), static_cast<socklen_t>(sizeof(struct sockaddr_in)));
	}
}

bool Socket::is_self_connect() {
	ERR_FAIL_COND_V(_socket == 0, false);

	struct sockaddr_in6 localaddr = get_local_addr();
	struct sockaddr_in6 peeraddr = get_peer_addr();

	if (localaddr.sin6_family == AF_INET) {
		const struct sockaddr_in *laddr4 = reinterpret_cast<struct sockaddr_in *>(&localaddr);
		const struct sockaddr_in *raddr4 = reinterpret_cast<struct sockaddr_in *>(&peeraddr);
		return laddr4->sin_port == raddr4->sin_port && laddr4->sin_addr.s_addr == raddr4->sin_addr.s_addr;
	} else if (localaddr.sin6_family == AF_INET6) {
		return localaddr.sin6_port == peeraddr.sin6_port && memcmp(&localaddr.sin6_addr, &peeraddr.sin6_addr, sizeof localaddr.sin6_addr) == 0;
	} else {
		return false;
	}
}

int Socket::bind_address(const InetAddress &address) {
	ERR_FAIL_COND_V(_socket == 0, -1);

	int ret;
	if (address.is_ip_v6()) {
		ret = ::bind(_socket, address.get_sock_addr(), sizeof(sockaddr_in6));
	} else {
		ret = ::bind(_socket, address.get_sock_addr(), sizeof(sockaddr_in));
	}

	if (ret != 0) {
#if defined(_WIN64) || defined(_WIN32)
		return WSAGetLastError();
#else
		return errno;
#endif
	}

	return ret;
}

int Socket::listen() {
	ERR_FAIL_COND_V(_socket == 0, -1);

	return ::listen(_socket, SOMAXCONN);
}

int Socket::accept(Socket *sock) {
	ERR_FAIL_COND_V(!sock, -1);

	struct sockaddr_in6 addr6;
	memset(&addr6, 0, sizeof(addr6));
	socklen_t size = sizeof(addr6);

#ifdef __linux__
	int connfd = ::accept4(_socket, (struct sockaddr *)&addr6, &size, SOCK_NONBLOCK | SOCK_CLOEXEC);
#else
	int connfd = static_cast<int>(::accept(_socket, (struct sockaddr *)&addr6, &size));
#endif

	if (connfd >= 0) {
		sock->_socket = connfd;
		sock->_address.set_sock_addr_inet6(addr6);
#ifndef __linux__
		sock->set_non_block();
		sock->set_close_on_exit();
#endif
	}

	return connfd;
}

int Socket::close_write() {
	ERR_FAIL_COND_V(_socket == 0, -1);

#if !defined(_WIN64) && !defined(_WIN32)
	return ::shutdown(_socket, SHUT_WR);
#else
	return ::shutdown(_socket, SD_SEND);
#endif
}

int Socket::read(char *buffer, uint64_t len) {
	//ERR_FAIL_COND_V(_socket == 0, -1);

#if !defined(_WIN64) && !defined(_WIN32)
	return ::read(_socket, buffer, len);
#else
	return recv(_socket, buffer, static_cast<int>(len), 0);
#endif
}

int Socket::send(const char *buffer, uint64_t len) {
	//ERR_FAIL_COND_V(_socket == 0, -1);

#if !defined(_WIN64) && !defined(_WIN32)
	return write(_socket, buffer, len);
#else
	errno = 0;
	return ::send(_socket, buffer, static_cast<int>(len), 0);
#endif
}

void Socket::set_tcp_nodelay(bool on) {
	ERR_FAIL_COND(_socket == 0);

#if defined(_WIN64) || defined(_WIN32)
	char optval = on ? 1 : 0;
#else
	int optval = on ? 1 : 0;
#endif
	::setsockopt(_socket, IPPROTO_TCP, TCP_NODELAY, &optval, static_cast<socklen_t>(sizeof optval));
}

void Socket::set_reuse_addr(bool on) {
	ERR_FAIL_COND(_socket == 0);

#if defined(_WIN64) || defined(_WIN32)
	char optval = on ? 1 : 0;
#else
	int optval = on ? 1 : 0;
#endif
	::setsockopt(_socket, SOL_SOCKET, SO_REUSEADDR, &optval, static_cast<socklen_t>(sizeof optval));
}

int Socket::set_reuse_port(bool on) {
	ERR_FAIL_COND_V(_socket == 0, -1);

#ifdef SO_REUSEPORT
#if defined(_WIN64) || defined(_WIN32)
	char optval = on ? 1 : 0;
#else
	int optval = on ? 1 : 0;
#endif
	int ret = ::setsockopt(_socket, SOL_SOCKET, SO_REUSEPORT, &optval, static_cast<socklen_t>(sizeof optval));

	return ret;
#else
	if (on) {
		//LOG_ERR("SO_REUSEPORT is not supported.");
		return -1;
	}

	return 0;
#endif
}

void Socket::set_keep_alive(bool on) {
	ERR_FAIL_COND(_socket == 0);

#if defined(_WIN64) || defined(_WIN32)
	char optval = on ? 1 : 0;
#else
	int optval = on ? 1 : 0;
#endif
	::setsockopt(_socket, SOL_SOCKET, SO_KEEPALIVE, &optval, static_cast<socklen_t>(sizeof optval));
}

struct sockaddr_in6 Socket::get_local_addr(int *r_err) {
	struct sockaddr_in6 localaddr = { 0 };

	ERR_FAIL_COND_V(_socket == 0, localaddr);

	memset(&localaddr, 0, sizeof(localaddr));
	socklen_t addrlen = static_cast<socklen_t>(sizeof localaddr);

	int err = ::getsockname(_socket, static_cast<struct sockaddr *>((void *)(&localaddr)), &addrlen);

	if (r_err) {
		*r_err = err;
	}

	return localaddr;
}

struct sockaddr_in6 Socket::get_peer_addr(int *r_err) {
	struct sockaddr_in6 peeraddr = { 0 };

	ERR_FAIL_COND_V(_socket == 0, peeraddr);

	memset(&peeraddr, 0, sizeof(peeraddr));
	socklen_t addrlen = static_cast<socklen_t>(sizeof peeraddr);

	int err = ::getpeername(_socket, static_cast<struct sockaddr *>((void *)(&peeraddr)), &addrlen);

	if (r_err) {
		*r_err = err;
	}

	return peeraddr;
}

int Socket::global_init() {
#if defined(_WIN64) || defined(_WIN32)
	int r;
	WSADATA wsa_data;

	r = WSAStartup(MAKEWORD(2, 2), &wsa_data);

	return r;
#else
	return 0;
#endif
}

Socket::Socket() {
	_socket = 0;
}

Socket::Socket(int socketFD, const InetAddress &address) {
	_socket = socketFD;
	_address = address;
}

Socket::~Socket() {
	if (_socket >= 0) {
		close_socket();
	}
}
#line 0

#line 1 "sfw/core/os.cpp"

#if defined(_WIN64) || defined(_WIN32)
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winnt.h>
#else
#include <unistd.h>
#endif

#if defined(_WIN64) || defined(_WIN32)
// From the Pandemonium Engine.

// We need this because GetSystemInfo() is unreliable on WOW64
// see https://msdn.microsoft.com/en-us/library/windows/desktop/ms724381(v=vs.85).aspx
// Taken from MSDN
typedef BOOL(WINAPI *LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);
LPFN_ISWOW64PROCESS fnIsWow64Process;

BOOL is_wow64() {
	BOOL wow64 = FALSE;

	fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");

	if (fnIsWow64Process) {
		if (!fnIsWow64Process(GetCurrentProcess(), &wow64)) {
			wow64 = FALSE;
		}
	}

	return wow64;
}
#endif

// From the Pandemonium Engine.
int OS::get_processor_count() {
#if defined(_WIN64) || defined(_WIN32)
	SYSTEM_INFO sysinfo;
	if (is_wow64())
		GetNativeSystemInfo(&sysinfo);
	else
		GetSystemInfo(&sysinfo);

	return sysinfo.dwNumberOfProcessors;
#else
	return sysconf(_SC_NPROCESSORS_CONF);
#endif
}
#line 0

#line 1 "sfw/core/sub_process.cpp"
/*************************************************************************/
/*  sub_process.cpp                                                      */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#if defined(_WIN64) || defined(_WIN32)

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

typedef struct tagLOGCONTEXTW {
	WCHAR lcName[40];
	UINT lcOptions;
	UINT lcStatus;
	UINT lcLocks;
	UINT lcMsgBase;
	UINT lcDevice;
	UINT lcPktRate;
	DWORD lcPktData;
	DWORD lcPktMode;
	DWORD lcMoveMask;
	DWORD lcBtnDnMask;
	DWORD lcBtnUpMask;
	LONG lcInOrgX;
	LONG lcInOrgY;
	LONG lcInOrgZ;
	LONG lcInExtX;
	LONG lcInExtY;
	LONG lcInExtZ;
	LONG lcOutOrgX;
	LONG lcOutOrgY;
	LONG lcOutOrgZ;
	LONG lcOutExtX;
	LONG lcOutExtY;
	LONG lcOutExtZ;
	DWORD lcSensX;
	DWORD lcSensY;
	DWORD lcSensZ;
	BOOL lcSysMode;
	int lcSysOrgX;
	int lcSysOrgY;
	int lcSysExtX;
	int lcSysExtY;
	DWORD lcSysSensX;
	DWORD lcSysSensY;
} LOGCONTEXTW;

typedef HANDLE(WINAPI *WTOpenPtr)(HWND p_window, LOGCONTEXTW *p_ctx, BOOL p_enable);

// TODO clean these up
#include <avrt.h>
#include <direct.h>
#include <knownfolders.h>
#include <process.h>
#include <regstr.h>
#include <shlobj.h>
#include <wchar.h>

struct SubProcess::SubProcessWindowsData {
	struct ProcessInfo {
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
	};

	HANDLE _pipe_handles[2];
	ProcessInfo _process_info;
};

Error SubProcess::start() {
	if (_executable_path.empty()) {
		return ERR_FILE_BAD_PATH;
	}

	if (is_process_running()) {
		return ERR_BUSY;
	}

	String path = _executable_path.replace("/", "\\");

	String cmdline = _quote_command_line_argument(path);
	for (int i = 0; i < _arguments.size(); ++i) {
		cmdline += " " + _quote_command_line_argument(_arguments[i]);
	}

	ZeroMemory(&_data->_process_info.si, sizeof(_data->_process_info.si));
	_data->_process_info.si.cb = sizeof(_data->_process_info.si);
	ZeroMemory(&_data->_process_info.pi, sizeof(_data->_process_info.pi));
	LPSTARTUPINFOW si_w = (LPSTARTUPINFOW)&_data->_process_info.si;

	Char16String modstr = cmdline.utf16(); // Windows wants to change this no idea why.

	bool inherit_handles = false;

	if (_read_output) {
		// Create pipe for StdOut and StdErr.
		SECURITY_ATTRIBUTES sa;
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.bInheritHandle = true;
		sa.lpSecurityDescriptor = NULL;

		ERR_FAIL_COND_V(!CreatePipe(&_data->_pipe_handles[0], &_data->_pipe_handles[1], &sa, 0), ERR_CANT_FORK);
		ERR_FAIL_COND_V(!SetHandleInformation(_data->_pipe_handles[0], HANDLE_FLAG_INHERIT, 0), ERR_CANT_FORK); // Read handle is for host process only and should not be inherited.

		_data->_process_info.si.dwFlags |= STARTF_USESTDHANDLES;
		_data->_process_info.si.hStdOutput = _data->_pipe_handles[1];
		if (_read_std_err) {
			_data->_process_info.si.hStdError = _data->_pipe_handles[1];
		}
		inherit_handles = true;
	}

	DWORD creaton_flags = NORMAL_PRIORITY_CLASS;
	if (_open_console) {
		creaton_flags |= CREATE_NEW_CONSOLE;
	} else {
		creaton_flags |= CREATE_NO_WINDOW;
	}

	int ret = CreateProcessW(nullptr, (LPWSTR)(modstr.ptrw()), nullptr, nullptr, inherit_handles, creaton_flags, nullptr, nullptr, si_w, &_data->_process_info.pi);
	if (!ret && _read_output) {
		CloseHandle(_data->_pipe_handles[0]); // Cleanup pipe handles.
		CloseHandle(_data->_pipe_handles[1]);

		_data->_pipe_handles[0] = NULL;
		_data->_pipe_handles[1] = NULL;
	}

	ERR_FAIL_COND_V(ret == 0, ERR_CANT_FORK);

	if (_blocking) {
		if (_read_output) {
			CloseHandle(_data->_pipe_handles[1]); // Close pipe write handle (only child process is writing).

			int bytes_in_buffer = 0;

			const int CHUNK_SIZE = 4096;
			DWORD read = 0;
			for (;;) { // Read StdOut and StdErr from pipe.
				_bytes.resize(bytes_in_buffer + CHUNK_SIZE);
				const bool success = ReadFile(_data->_pipe_handles[0], _bytes.ptr() + bytes_in_buffer, CHUNK_SIZE, &read, NULL);
				if (!success || read == 0) {
					break;
				}
				// Assume that all possible encodings are ASCII-compatible.
				// Break at newline to allow receiving long output in portions.
				int newline_index = -1;
				for (int i = read - 1; i >= 0; i--) {
					if (_bytes[bytes_in_buffer + i] == '\n') {
						newline_index = i;
						break;
					}
				}

				if (newline_index == -1) {
					bytes_in_buffer += read;
					continue;
				}

				const int bytes_to_convert = bytes_in_buffer + (newline_index + 1);
				_append_to_pipe(_bytes.ptr(), bytes_to_convert);

				bytes_in_buffer = read - (newline_index + 1);
				memmove(_bytes.ptr(), _bytes.ptr() + bytes_to_convert, bytes_in_buffer);
			}

			if (bytes_in_buffer > 0) {
				_append_to_pipe(_bytes.ptr(), bytes_in_buffer);
			}

			CloseHandle(_data->_pipe_handles[0]); // Close pipe read handle.
		}

		WaitForSingleObject(_data->_process_info.pi.hProcess, INFINITE);

		DWORD ret2;
		GetExitCodeProcess(_data->_process_info.pi.hProcess, &ret2);
		_exitcode = ret2;

		CloseHandle(_data->_process_info.pi.hProcess);
		CloseHandle(_data->_process_info.pi.hThread);
	} else {
		if (_read_output) {
			//eventually we will need to keep this
			CloseHandle(_data->_pipe_handles[1]); // Close pipe write handle (only child process is writing).
			_data->_pipe_handles[1] = NULL;
		}

		_process_started = true;

		ProcessID pid = _data->_process_info.pi.dwProcessId;
		_process_id = pid;
	}

	return OK;
}

Error SubProcess::stop() {
	if (!_process_started) {
		return OK;
	}

	if (_data->_pipe_handles[0]) {
		CloseHandle(_data->_pipe_handles[0]); // Cleanup pipe handles.
		_data->_pipe_handles[0] = NULL;
	}

	if (_data->_pipe_handles[1]) {
		CloseHandle(_data->_pipe_handles[1]);
		_data->_pipe_handles[1] = NULL;
	}

	const int ret = TerminateProcess(_data->_process_info.pi.hProcess, 0);

	CloseHandle(_data->_process_info.pi.hProcess);
	CloseHandle(_data->_process_info.pi.hThread);

	ZeroMemory(&_data->_process_info.si, sizeof(_data->_process_info.si));
	_data->_process_info.si.cb = sizeof(_data->_process_info.si);
	ZeroMemory(&_data->_process_info.pi, sizeof(_data->_process_info.pi));

	_process_started = false;

	return ret != 0 ? OK : FAILED;
}

Error SubProcess::poll() {
	if (!_process_started) {
		return FAILED;
	}

	if (!_data->_pipe_handles[0]) {
		return FAILED;
	}

	_pipe.clear();

	int bytes_in_buffer = 0;

	const int CHUNK_SIZE = 4096;
	DWORD read = 0;

	_bytes.resize(bytes_in_buffer + CHUNK_SIZE);
	const bool success = ReadFile(_data->_pipe_handles[0], _bytes.ptr() + bytes_in_buffer, CHUNK_SIZE, &read, NULL);

	if (!success) {
		stop();
		return ERR_FILE_EOF;
	}

	if (read == 0) {
		return OK;
	}

	// Assume that all possible encodings are ASCII-compatible.
	// Break at newline to allow receiving long output in portions.
	int newline_index = -1;
	for (int i = read - 1; i >= 0; i--) {
		if (_bytes[bytes_in_buffer + i] == '\n') {
			newline_index = i;
			break;
		}
	}

	if (newline_index == -1) {
		bytes_in_buffer += read;
		return OK;
	}

	const int bytes_to_convert = bytes_in_buffer + (newline_index + 1);
	_append_to_pipe(_bytes.ptr(), bytes_to_convert);

	bytes_in_buffer = read - (newline_index + 1);
	memmove(_bytes.ptr(), _bytes.ptr() + bytes_to_convert, bytes_in_buffer);

	if (bytes_in_buffer > 0) {
		_append_to_pipe(_bytes.ptr(), bytes_in_buffer);
	}

	return OK;
}

Error SubProcess::send_signal(const int p_signal) {
	//Not Yet Impl
	ERR_FAIL_V(ERR_BUG);
}

Error SubProcess::send_data(const String &p_data) {
	//Not Yet Impl
	ERR_FAIL_V(ERR_BUG);
}

bool SubProcess::is_process_running() const {
	if (_process_id == 0) {
		return false;
	}

	if (!_process_started) {
		return false;
	}

	DWORD dw_exit_code = 0;
	if (!GetExitCodeProcess(_data->_process_info.pi.hProcess, &dw_exit_code)) {
		return false;
	}

	if (dw_exit_code != STILL_ACTIVE) {
		return false;
	}

	return true;
}

String SubProcess::_quote_command_line_argument(const String &p_text) const {
	for (int i = 0; i < p_text.size(); i++) {
		CharType c = p_text[i];
		if (c == ' ' || c == '&' || c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '^' || c == '=' || c == ';' || c == '!' || c == '\'' || c == '+' || c == ',' || c == '`' || c == '~') {
			return "\"" + p_text + "\"";
		}
	}
	return p_text;
}

void SubProcess::_append_to_pipe(char *p_bytes, int p_size) {
	// Try to convert from default ANSI code page to Unicode.
	LocalVector<wchar_t> wchars;
	int total_wchars = MultiByteToWideChar(CP_ACP, 0, p_bytes, p_size, nullptr, 0);
	if (total_wchars > 0) {
		wchars.resize(total_wchars);
		if (MultiByteToWideChar(CP_ACP, 0, p_bytes, p_size, wchars.ptr(), total_wchars) == 0) {
			wchars.clear();
		}
	}

	if (_pipe_mutex) {
		_pipe_mutex->lock();
	}
	if (wchars.empty()) {
		// Let's hope it's compatible with UTF-8.
		_pipe += String::utf8(p_bytes, p_size);
	} else {
		_pipe += String(wchars.ptr(), total_wchars);
	}
	if (_pipe_mutex) {
		_pipe_mutex->unlock();
	}
}

SubProcess::SubProcess() {
	_data = memnew(SubProcessWindowsData);

	_blocking = false;

	_read_output = true;

	_read_std = true;
	_read_std_err = false;

	_use_pipe_mutex = false;

	_pipe_mutex = NULL;

	_open_console = false;

	_process_id = ProcessID();
	_exitcode = 0;

	_data->_pipe_handles[0] = NULL;
	_data->_pipe_handles[1] = NULL;

	_process_started = false;

	ZeroMemory(&_data->_process_info.si, sizeof(_data->_process_info.si));
	_data->_process_info.si.cb = sizeof(_data->_process_info.si);
	ZeroMemory(&_data->_process_info.pi, sizeof(_data->_process_info.pi));
}
SubProcess::~SubProcess() {
	stop();

	memdelete(_data);
}

#else

#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

Error SubProcess::start() {
#ifdef __EMSCRIPTEN__
	// Don't compile this code at all to avoid undefined references.
	// Actual virtual call goes to OS_JavaScript.
	ERR_FAIL_V(ERR_BUG);
#else
	if (_executable_path.empty()) {
		return ERR_FILE_BAD_PATH;
	}

	if (is_process_running()) {
		return ERR_BUSY;
	}

	if (_blocking && _read_output) {
		String argss;
		argss = "\"" + _executable_path + "\"";

		for (int i = 0; i < _arguments.size(); i++) {
			argss += String(" \"") + _arguments[i] + "\"";
		}

		if (_read_std_err) {
			argss += " 2>&1"; // Read stderr too
		} else {
			argss += " 2>/dev/null"; //silence stderr
		}
		FILE *f = popen(argss.utf8().get_data(), "r");

		ERR_FAIL_COND_V_MSG(!f, ERR_CANT_OPEN, "Cannot pipe stream from process running with following arguments '" + argss + "'.");

		char buf[65535];

		while (fgets(buf, 65535, f)) {
			if (_pipe_mutex) {
				_pipe_mutex->lock();
			}
			_pipe += String::utf8(buf);
			if (_pipe_mutex) {
				_pipe_mutex->unlock();
			}
		}
		int rv = pclose(f);

		_exitcode = WEXITSTATUS(rv);

		return OK;
	}

	if (!_blocking && _read_output) {
		String argss;
		argss = "\"" + _executable_path + "\"";

		for (int i = 0; i < _arguments.size(); i++) {
			argss += String(" \"") + _arguments[i] + "\"";
		}

		if (_read_std_err) {
			argss += " 2>&1"; // Read stderr too
		} else {
			argss += " 2>/dev/null"; //silence stderr
		}

		_process_fp = popen(argss.utf8().get_data(), "r");

		ERR_FAIL_COND_V_MSG(!_process_fp, ERR_CANT_OPEN, "Cannot pipe stream from process running with following arguments '" + argss + "'.");

		return OK;
	}

	// We just run it, no need to worry about output

	pid_t pid = fork();
	ERR_FAIL_COND_V(pid < 0, ERR_CANT_FORK);

	if (pid == 0) {
		// is child

		if (!_blocking) {
			// For non blocking calls, create a new session-ID so parent won't wait for it.
			// This ensures the process won't go zombie at end.
			setsid();
		}

		Vector<CharString> cs;
		cs.push_back(_executable_path.utf8());
		for (int i = 0; i < _arguments.size(); i++) {
			cs.push_back(_arguments[i].utf8());
		}

		Vector<char *> args;
		for (int i = 0; i < cs.size(); i++) {
			args.push_back((char *)cs[i].get_data());
		}
		args.push_back(0);

		execvp(_executable_path.utf8().get_data(), &args[0]);
		// still alive? something failed..
		fprintf(stderr, "**ERROR** SubProcess::execute - Could not create child process while executing: %s\n", _executable_path.utf8().get_data());
		raise(SIGKILL);
	}

	if (_blocking) {
		int status;
		waitpid(pid, &status, 0);

		_exitcode = WIFEXITED(status) ? WEXITSTATUS(status) : status;
	} else {
		_process_id = pid;
	}

	return OK;
#endif
}

Error SubProcess::stop() {
#ifdef __EMSCRIPTEN__
	// Don't compile this code at all to avoid undefined references.
	// Actual virtual call goes to OS_JavaScript.
	ERR_FAIL_V(ERR_BUG);
#else
	if (_process_fp) {
		int rv = pclose(_process_fp);
		_process_fp = NULL;
		_exitcode = WEXITSTATUS(rv);
		_process_id = 0;
		return OK;
	}

	if (_process_id) {
		int ret = ::kill(_process_id, SIGKILL);

		if (!ret) {
			//avoid zombie process
			int st;
			::waitpid(_process_id, &st, 0);
		}

		_process_id = 0;

		return ret ? ERR_INVALID_PARAMETER : OK;
	}

	return OK;
#endif
}

Error SubProcess::poll() {
#ifdef __EMSCRIPTEN__
	// Don't compile this code at all to avoid undefined references.
	// Actual virtual call goes to OS_JavaScript.
	ERR_FAIL_V(ERR_BUG);
#else

	if (_process_fp) {
		if (fgets(_process_buf, 65535, _process_fp)) {
			if (_pipe_mutex) {
				_pipe_mutex->lock();
			}
			_pipe = String::utf8(_process_buf);
			if (_pipe_mutex) {
				_pipe_mutex->unlock();
			}
		} else {
			// The process finished
			// Cleanup:
			stop();
			return ERR_FILE_EOF;
		}
	}

	return OK;
#endif
}

Error SubProcess::send_signal(const int p_signal) {
	//Not Yet Impl
	ERR_FAIL_V(ERR_BUG);
}

Error SubProcess::send_data(const String &p_data) {
	//Not Yet Impl
	ERR_FAIL_V(ERR_BUG);
}

bool SubProcess::is_process_running() const {
#ifdef __EMSCRIPTEN__
	// Don't compile this code at all to avoid undefined references.
	// Actual virtual call goes to OS_JavaScript.
	ERR_FAIL_V(false);
#else

	if (_process_fp) {
		return !feof(_process_fp);
	}

	if (_process_id == 0) {
		return false;
	}

	int status = 0;
	if (waitpid(_process_id, &status, WNOHANG) != 0) {
		return false;
	}

	return true;
#endif
}

SubProcess::SubProcess() {
	_blocking = false;

	_read_output = true;

	_read_std = true;
	_read_std_err = false;

	_use_pipe_mutex = false;

	_pipe_mutex = NULL;

	_open_console = false;

	_process_id = ProcessID();
	_exitcode = 0;

	_process_fp = NULL;
}
SubProcess::~SubProcess() {
	stop();
}

#endif

SubProcess *SubProcess::create() {
	return memnew(SubProcess());
}

String SubProcess::get_executable_path() const {
	return _executable_path;
}
void SubProcess::set_executable_path(const String &p_executable_path) {
	ERR_FAIL_COND(is_process_running());

	_executable_path = p_executable_path;
}

Vector<String> SubProcess::get_arguments() const {
	return _arguments;
}
void SubProcess::set_arguments(const Vector<String> &p_arguments) {
	ERR_FAIL_COND(is_process_running());

	_arguments = p_arguments;
}

bool SubProcess::get_blocking() const {
	return _blocking;
}
void SubProcess::set_blocking(const bool p_value) {
	ERR_FAIL_COND(is_process_running());

	_blocking = p_value;
}

bool SubProcess::get_read_output() const {
	return _read_output;
}
void SubProcess::set_read_output(const bool p_value) {
	ERR_FAIL_COND(is_process_running());

	_read_output = p_value;
}

bool SubProcess::get_read_std() const {
	return _read_std;
}
void SubProcess::set_read_std(const bool p_value) {
	ERR_FAIL_COND(is_process_running());

	_read_std = p_value;
}

bool SubProcess::get_read_std_err() const {
	return _read_std_err;
}
void SubProcess::set_read_std_err(const bool p_value) {
	ERR_FAIL_COND(is_process_running());

	_read_std_err = p_value;
}

bool SubProcess::get_use_pipe_mutex() const {
	return _use_pipe_mutex;
}
void SubProcess::set_use_pipe_mutex(const bool p_value) {
	ERR_FAIL_COND(is_process_running());

	_use_pipe_mutex = p_value;
}

bool SubProcess::get_open_console() const {
	return _open_console;
}
void SubProcess::set_open_console(const bool p_value) {
	ERR_FAIL_COND(is_process_running());

	_open_console = p_value;
}

Error SubProcess::run(const String &p_executable_path, const Vector<String> &p_arguments, bool p_output, bool p_blocking, bool p_read_std_err, bool p_use_pipe_mutex, bool p_open_console) {
	if (is_process_running()) {
		return ERR_ALREADY_IN_USE;
	}

	_executable_path = p_executable_path;
	_arguments = p_arguments;

	_blocking = p_blocking;

	_read_output = p_output;

	_read_std = true;
	_read_std_err = p_read_std_err;

	_use_pipe_mutex = p_use_pipe_mutex;

	_open_console = p_open_console;

	_setup_pipe_mutex();

	return start();
}

/*
SubProcess::SubProcess() {
	_blocking = false;

	_read_output = true;

	_read_std = true;
	_read_std_err = false;

	_use_pipe_mutex = false;

	_pipe_mutex = NULL;

	_open_console = false;

	_process_id = ProcessID();
	_exitcode = 0;
};
*/

void SubProcess::_setup_pipe_mutex() {
	if (_use_pipe_mutex) {
		if (!_pipe_mutex) {
			_pipe_mutex = memnew(Mutex);
		}
	} else {
		if (_pipe_mutex) {
			memdelete(_pipe_mutex);
			_pipe_mutex = NULL;
		}
	}
}
#line 0

#line 1 "sfw/core/sfw_core.cpp"

void SFWCore::setup() {
	if (_initialized) {
		return;
	}

	_initialized = true;

	StringName::setup();
	MemoryPool::setup();
}

void SFWCore::cleanup() {
	if (!_initialized) {
		return;
	}

	_initialized = false;

	StringName::cleanup();
	MemoryPool::cleanup();
}

bool SFWCore::_initialized = false;
#line 0

//===================  OBJECT SECTION  ===================

#line 1 "sfw/object/resource.cpp"

void Resource::emit_changed() {
	changed.emit(this);
}

Error Resource::load(const String &path) {
	return ERR_UNAVAILABLE;
}
Error Resource::save(const String &path) {
	return ERR_UNAVAILABLE;
}

Resource::Resource() :
		Reference() {
}

Resource::~Resource() {
}
#line 0

#line 1 "sfw/object/reference.cpp"

/*************************************************************************/
/*  reference.cpp                                                        */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

bool Reference::init_ref() {
	if (reference()) {
		if (!is_referenced() && refcount_init.unref()) {
			unreference(); // first referencing is already 1, so compensate for the ref above
		}

		return true;
	} else {
		return false;
	}
}

int Reference::reference_get_count() const {
	return refcount.get();
}

bool Reference::reference() {
	uint32_t rc_val = refcount.refval();
	bool success = rc_val != 0;

	return success;
}

bool Reference::unreference() {
	uint32_t rc_val = refcount.unrefval();
	bool die = rc_val == 0;

	return die;
}

Reference::Reference() :
		Object() {
	refcount.init();
	refcount_init.init();
}

Reference::~Reference() {
}

/*                                                           \
void WeakRef::set_obj(Object *p_object) {                    \
	//ref = p_object ? p_object->get_instance_id() : 0;      \
}                                                            \
                                                             \
void WeakRef::set_ref(const REF &p_ref) {                    \
	//ref = p_ref.is_valid() ? p_ref->get_instance_id() : 0; \
}                                                            \
                                                             \
WeakRef::WeakRef() :                                         \
		ref(0) {                                             \
}                                                            \
*/                                                           \
#line 0

#line 1 "sfw/object/object.cpp"

void Object::set(const StringName &p_name, const Variant &p_value, bool *r_valid) {
	if (p_name == CoreStringNames::get_singleton()->_meta) {
		//set_meta(p_name,p_value);
		metadata = p_value.duplicate();
		if (r_valid) {
			*r_valid = true;
		}
		return;
	}

	//something inside the object... :|
	bool success = _setv(p_name, p_value);
	if (success) {
		if (r_valid) {
			*r_valid = true;
		}
		return;
	}

	if (r_valid) {
		*r_valid = false;
	}
}

Variant Object::get(const StringName &p_name, bool *r_valid) const {
	Variant ret;

	if (p_name == CoreStringNames::get_singleton()->_meta) {
		ret = metadata;
		if (r_valid) {
			*r_valid = true;
		}
		return ret;

	} else {
		//something inside the object... :|
		bool success = _getv(p_name, ret);
		if (success) {
			if (r_valid) {
				*r_valid = true;
			}
			return ret;
		}

		if (r_valid) {
			*r_valid = false;
		}

		return Variant();
	}
}

bool Object::lt(const Variant &p_value_l, const Variant &p_value_r) {
	return p_value_l < p_value_r;
}

void Object::notification(int p_notification, bool p_reversed) {
	_notificationv(p_notification, p_reversed);
}

String Object::to_string() {
	return "[" + get_class() + ":" + itos(get_instance_id()) + "]";
}

bool Object::_predelete() {
	_predelete_ok = 1;
	notification(NOTIFICATION_PREDELETE, true);
	if (_predelete_ok) {
		_class_ptr = nullptr; //must restore so destructors can access class ptr correctly
	}
	return _predelete_ok;
}

void Object::_postinitialize() {
	_class_ptr = _get_class_namev();
	notification(NOTIFICATION_POSTINITIALIZE);
}

bool Object::has_meta(const String &p_name) const {
	return metadata.has(p_name);
}

void Object::set_meta(const String &p_name, const Variant &p_value) {
	if (p_value.get_type() == Variant::NIL) {
		metadata.erase(p_name);
		return;
	};

	metadata[p_name] = p_value;
}

Variant Object::get_meta(const String &p_name, const Variant &p_default) const {
	if (!metadata.has(p_name)) {
		return p_default;
	}
	return metadata[p_name];
}

void Object::remove_meta(const String &p_name) {
	metadata.erase(p_name);
}

void Object::cancel_free() {
	_predelete_ok = 0;
}

Object::Object() {
	_is_queued_for_deletion = false;
	_predelete_ok = 0;
	_instance_id = 0;
	_instance_id = ObjectDB::add_instance(this);
}

Object::~Object() {
}

ObjectRC *Object::_use_rc() {
	// The RC object is lazily created the first time it's requested;
	// that way, there's no need to allocate and release it at all if this Object
	// is not being referred by any Variant at all.

	// Although when dealing with Objects from multiple threads some locking
	// mechanism should be used, this at least makes safe the case of first
	// assignment.

	ObjectRC *rc = nullptr;
	ObjectRC *const creating = reinterpret_cast<ObjectRC *>(1);
	if (unlikely(_rc.compare_exchange_strong(rc, creating, std::memory_order_acq_rel))) {
		// Not created yet
		rc = memnew(ObjectRC(this));
		_rc.store(rc, std::memory_order_release);
		return rc;
	}

	// Spin-wait until we know it's created (or just return if it's already created)
	for (;;) {
		if (likely(rc != creating)) {
			rc->increment();
			return rc;
		}
		rc = _rc.load(std::memory_order_acquire);
	}
}

bool predelete_handler(Object *p_object) {
	return p_object->_predelete();
}

void postinitialize_handler(Object *p_object) {
	p_object->_postinitialize();
}

HashMap<ObjectID, Object *> ObjectDB::instances;
ObjectID ObjectDB::instance_counter = 1;
HashMap<Object *, ObjectID, ObjectDB::ObjectPtrHash> ObjectDB::instance_checks;
ObjectID ObjectDB::add_instance(Object *p_object) {
	ERR_FAIL_COND_V(p_object->get_instance_id() != 0, 0);

	rw_lock.write_lock();
	ObjectID instance_id = ++instance_counter;
	instances[instance_id] = p_object;
	instance_checks[p_object] = instance_id;

	rw_lock.write_unlock();

	return instance_id;
}

void ObjectDB::remove_instance(Object *p_object) {
	rw_lock.write_lock();

	instances.erase(p_object->get_instance_id());
	instance_checks.erase(p_object);

	rw_lock.write_unlock();
}
Object *ObjectDB::get_instance(ObjectID p_instance_id) {
	rw_lock.read_lock();
	Object **obj = instances.getptr(p_instance_id);
	rw_lock.read_unlock();

	if (!obj) {
		return nullptr;
	}
	return *obj;
}

void ObjectDB::debug_objects(DebugFunc p_func) {
	rw_lock.read_lock();

	const ObjectID *K = nullptr;
	while ((K = instances.next(K))) {
		p_func(instances[*K]);
	}

	rw_lock.read_unlock();
}

int ObjectDB::get_object_count() {
	rw_lock.read_lock();
	int count = instances.size();
	rw_lock.read_unlock();

	return count;
}

RWLock ObjectDB::rw_lock;

void ObjectDB::cleanup() {
	rw_lock.write_lock();
	if (instances.size()) {
		LOG_WARN("ObjectDB instances leaked at exit!");
	}
	instances.clear();
	instance_checks.clear();
	rw_lock.write_unlock();
}
#line 0

#line 1 "sfw/object/ref_ptr.cpp"
/*************************************************************************/
/*  ref_ptr.cpp                                                          */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void RefPtr::operator=(const RefPtr &p_other) {
	Ref<Reference> *ref = reinterpret_cast<Ref<Reference> *>(&data[0]);
	Ref<Reference> *ref_other = reinterpret_cast<Ref<Reference> *>(const_cast<char *>(&p_other.data[0]));

	*ref = *ref_other;
}

bool RefPtr::operator==(const RefPtr &p_other) const {
	Ref<Reference> *ref = reinterpret_cast<Ref<Reference> *>(&data[0]);
	Ref<Reference> *ref_other = reinterpret_cast<Ref<Reference> *>(const_cast<char *>(&p_other.data[0]));

	return *ref == *ref_other;
}

bool RefPtr::operator!=(const RefPtr &p_other) const {
	Ref<Reference> *ref = reinterpret_cast<Ref<Reference> *>(&data[0]);
	Ref<Reference> *ref_other = reinterpret_cast<Ref<Reference> *>(const_cast<char *>(&p_other.data[0]));

	return *ref != *ref_other;
}

RefPtr::RefPtr(const RefPtr &p_other) {
	memnew_placement(&data[0], Ref<Reference>);

	Ref<Reference> *ref = reinterpret_cast<Ref<Reference> *>(&data[0]);
	Ref<Reference> *ref_other = reinterpret_cast<Ref<Reference> *>(const_cast<char *>(&p_other.data[0]));

	*ref = *ref_other;
}

bool RefPtr::is_null() const {
	Ref<Reference> *ref = reinterpret_cast<Ref<Reference> *>(&data[0]);
	return ref->is_null();
}

void RefPtr::unref() {
	Ref<Reference> *ref = reinterpret_cast<Ref<Reference> *>(&data[0]);
	ref->unref();
}

RefPtr::RefPtr() {
	ERR_FAIL_COND(sizeof(Ref<Reference>) > DATASIZE);
	memnew_placement(&data[0], Ref<Reference>);
}

RefPtr::~RefPtr() {
	Ref<Reference> *ref = reinterpret_cast<Ref<Reference> *>(&data[0]);
	ref->~Ref<Reference>();
}
#line 0

#line 1 "sfw/object/core_string_names.cpp"
/*************************************************************************/
/*  core_string_names.cpp                                                */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

CoreStringNames *CoreStringNames::singleton = nullptr;

CoreStringNames::CoreStringNames() :
		_free(StaticCString::create("free")),
		changed(StaticCString::create("changed")),
		_meta(StaticCString::create("__meta__")),
		_script(StaticCString::create("script")),
		script_changed(StaticCString::create("script_changed")),
		___pdcdata(StaticCString::create("___pdcdata")),
		__getvar(StaticCString::create("__getvar")),
		_iter_init(StaticCString::create("_iter_init")),
		_iter_next(StaticCString::create("_iter_next")),
		_iter_get(StaticCString::create("_iter_get")),
		get_rid(StaticCString::create("get_rid")),
		_to_string(StaticCString::create("_to_string")),
#ifdef TOOLS_ENABLED
		_sections_unfolded(StaticCString::create("_sections_unfolded")),
#endif
		_custom_features(StaticCString::create("_custom_features")),
		x(StaticCString::create("x")),
		y(StaticCString::create("y")),
		z(StaticCString::create("z")),
		w(StaticCString::create("w")),
		r(StaticCString::create("r")),
		g(StaticCString::create("g")),
		b(StaticCString::create("b")),
		a(StaticCString::create("a")),
		position(StaticCString::create("position")),
		size(StaticCString::create("size")),
		end(StaticCString::create("end")),
		basis(StaticCString::create("basis")),
		origin(StaticCString::create("origin")),
		normal(StaticCString::create("normal")),
		d(StaticCString::create("d")),
		h(StaticCString::create("h")),
		s(StaticCString::create("s")),
		v(StaticCString::create("v")),
		r8(StaticCString::create("r8")),
		g8(StaticCString::create("g8")),
		b8(StaticCString::create("b8")),
		a8(StaticCString::create("a8")) {
}
#line 0

#line 1 "sfw/object/dictionary.cpp"
/*************************************************************************/
/*  dictionary.cpp                                                       */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

struct DictionaryPrivate {
	SafeRefCount refcount;
	OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator> variant_map;
};

void Dictionary::get_key_list(List<Variant> *p_keys) const {
	if (_p->variant_map.empty()) {
		return;
	}

	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.front(); E; E = E.next()) {
		p_keys->push_back(E.key());
	}
}

Variant Dictionary::get_key_at_index(int p_index) const {
	int index = 0;
	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.front(); E; E = E.next()) {
		if (index == p_index) {
			return E.key();
		}
		index++;
	}

	return Variant();
}

Variant Dictionary::get_value_at_index(int p_index) const {
	int index = 0;
	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.front(); E; E = E.next()) {
		if (index == p_index) {
			return E.value();
		}
		index++;
	}

	return Variant();
}

Variant &Dictionary::operator[](const Variant &p_key) {
	return _p->variant_map[p_key];
}

const Variant &Dictionary::operator[](const Variant &p_key) const {
	return _p->variant_map[p_key];
}
const Variant *Dictionary::getptr(const Variant &p_key) const {
	OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::ConstElement E = ((const OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator> *)&_p->variant_map)->find(p_key);

	if (!E) {
		return nullptr;
	}
	return &E.get();
}

Variant *Dictionary::getptr(const Variant &p_key) {
	OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.find(p_key);

	if (!E) {
		return nullptr;
	}
	return &E.get();
}

Variant Dictionary::get_valid(const Variant &p_key) const {
	OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::ConstElement E = ((const OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator> *)&_p->variant_map)->find(p_key);

	if (!E) {
		return Variant();
	}
	return E.get();
}

Variant Dictionary::get(const Variant &p_key, const Variant &p_default) const {
	const Variant *result = getptr(p_key);
	if (!result) {
		return p_default;
	}

	return *result;
}

Variant Dictionary::get_or_add(const Variant &p_key, const Variant &p_default) {
	const Variant *result = getptr(p_key);

	if (!result) {
		operator[](p_key) = p_default;

		return p_default;
	}

	return *result;
}

int Dictionary::size() const {
	return _p->variant_map.size();
}
bool Dictionary::empty() const {
	return !_p->variant_map.size();
}

bool Dictionary::has(const Variant &p_key) const {
	return _p->variant_map.has(p_key);
}

bool Dictionary::has_all(const Array &p_keys) const {
	for (int i = 0; i < p_keys.size(); i++) {
		if (!has(p_keys[i])) {
			return false;
		}
	}
	return true;
}

Variant Dictionary::find_key(const Variant &p_value) const {
	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.front(); E; E = E.next()) {
		if (E.value() == p_value) {
			return E.key();
		}
	}
	return Variant();
}

bool Dictionary::erase(const Variant &p_key) {
	return _p->variant_map.erase(p_key);
}

bool Dictionary::deep_equal(const Dictionary &p_dictionary, int p_recursion_count) const {
	// Cheap checks
	ERR_FAIL_COND_V_MSG(p_recursion_count > MAX_RECURSION, 0, "Max recursion reached");
	if (_p == p_dictionary._p) {
		return true;
	}
	if (_p->variant_map.size() != p_dictionary._p->variant_map.size()) {
		return false;
	}

	// Heavy O(n) check
	OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element this_E = _p->variant_map.front();
	OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element other_E = p_dictionary._p->variant_map.front();
	p_recursion_count++;
	while (this_E && other_E) {
		if (
				!this_E.key().deep_equal(other_E.key(), p_recursion_count) ||
				!this_E.value().deep_equal(other_E.value(), p_recursion_count)) {
			return false;
		}

		this_E = this_E.next();
		other_E = other_E.next();
	}

	return !this_E && !other_E;
}

bool Dictionary::operator==(const Dictionary &p_dictionary) const {
	return _p == p_dictionary._p;
}

bool Dictionary::operator!=(const Dictionary &p_dictionary) const {
	return _p != p_dictionary._p;
}

void Dictionary::_ref(const Dictionary &p_from) const {
	//make a copy first (thread safe)
	if (!p_from._p->refcount.ref()) {
		return; // couldn't copy
	}

	//if this is the same, unreference the other one
	if (p_from._p == _p) {
		_p->refcount.unref();
		return;
	}
	if (_p) {
		_unref();
	}
	_p = p_from._p;
}

void Dictionary::clear() {
	_p->variant_map.clear();
}

void Dictionary::merge(const Dictionary &p_dictionary, bool p_overwrite) {
	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = p_dictionary._p->variant_map.front(); E; E = E.next()) {
		if (p_overwrite || !has(E.key())) {
			this->operator[](E.key()) = E.value();
		}
	}
}

void Dictionary::_unref() const {
	ERR_FAIL_COND(!_p);
	if (_p->refcount.unref()) {
		memdelete(_p);
	}
	_p = nullptr;
}

uint32_t Dictionary::hash() const {
	return recursive_hash(0);
}

uint32_t Dictionary::recursive_hash(int p_recursion_count) const {
	ERR_FAIL_COND_V_MSG(p_recursion_count > MAX_RECURSION, 0, "Max recursion reached");
	p_recursion_count++;

	uint32_t h = hash_murmur3_one_32(Variant::DICTIONARY);

	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.front(); E; E = E.next()) {
		h = hash_murmur3_one_32(E.key().recursive_hash(p_recursion_count), h);
		h = hash_murmur3_one_32(E.value().recursive_hash(p_recursion_count), h);
	}

	return hash_fmix32(h);
}

Array Dictionary::keys() const {
	Array varr;
	if (_p->variant_map.empty()) {
		return varr;
	}

	varr.resize(size());

	int i = 0;
	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.front(); E; E = E.next()) {
		varr[i] = E.key();
		i++;
	}

	return varr;
}

Array Dictionary::values() const {
	Array varr;
	if (_p->variant_map.empty()) {
		return varr;
	}

	varr.resize(size());

	int i = 0;
	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.front(); E; E = E.next()) {
		varr[i] = E.get();
		i++;
	}

	return varr;
}

const Variant *Dictionary::next(const Variant *p_key) const {
	if (p_key == nullptr) {
		// caller wants to get the first element
		if (_p->variant_map.front()) {
			return &_p->variant_map.front().key();
		}
		return nullptr;
	}
	OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.find(*p_key);

	if (E && E.next()) {
		return &E.next().key();
	}
	return nullptr;
}

Dictionary Dictionary::duplicate(bool p_deep) const {
	Dictionary n;

	for (OrderedHashMap<Variant, Variant, VariantHasher, VariantComparator>::Element E = _p->variant_map.front(); E; E = E.next()) {
		n[E.key()] = p_deep ? E.value().duplicate(true) : E.value();
	}

	return n;
}

void Dictionary::operator=(const Dictionary &p_dictionary) {
	_ref(p_dictionary);
}

const void *Dictionary::id() const {
	return _p;
}

Dictionary::Dictionary(const Dictionary &p_from) {
	_p = nullptr;
	_ref(p_from);
}

Dictionary::Dictionary() {
	_p = memnew(DictionaryPrivate);
	_p->refcount.init();
}
Dictionary::~Dictionary() {
	_unref();
}
#line 0

#line 1 "sfw/object/array.cpp"
/*************************************************************************/
/*  array.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

class ArrayPrivate {
public:
	SafeRefCount refcount;
	Vector<Variant> array;
};

void Array::_ref(const Array &p_from) const {
	ArrayPrivate *_fp = p_from._p;

	ERR_FAIL_COND(!_fp); // should NOT happen.

	if (_fp == _p) {
		return; // whatever it is, nothing to do here move along
	}

	bool success = _fp->refcount.ref();

	ERR_FAIL_COND(!success); // should really not happen either

	_unref();

	_p = p_from._p;
}

void Array::_unref() const {
	if (!_p) {
		return;
	}

	if (_p->refcount.unref()) {
		memdelete(_p);
	}
	_p = nullptr;
}

Variant &Array::operator[](int p_idx) {
	return _p->array.write[p_idx];
}

const Variant &Array::operator[](int p_idx) const {
	return _p->array[p_idx];
}

int Array::size() const {
	return _p->array.size();
}
bool Array::empty() const {
	return _p->array.empty();
}
void Array::clear() {
	_p->array.clear();
}

bool Array::deep_equal(const Array &p_array, int p_recursion_count) const {
	// Cheap checks
	ERR_FAIL_COND_V_MSG(p_recursion_count > MAX_RECURSION, true, "Max recursion reached");
	if (_p == p_array._p) {
		return true;
	}
	const Vector<Variant> &a1 = _p->array;
	const Vector<Variant> &a2 = p_array._p->array;
	const int size = a1.size();
	if (size != a2.size()) {
		return false;
	}

	// Heavy O(n) check
	p_recursion_count++;
	for (int i = 0; i < size; i++) {
		if (!a1[i].deep_equal(a2[i], p_recursion_count)) {
			return false;
		}
	}

	return true;
}

bool Array::operator==(const Array &p_array) const {
	return _p == p_array._p;
}

uint32_t Array::hash() const {
	return recursive_hash(0);
}

uint32_t Array::recursive_hash(int p_recursion_count) const {
	ERR_FAIL_COND_V_MSG(p_recursion_count > MAX_RECURSION, 0, "Max recursion reached");
	p_recursion_count++;

	uint32_t h = hash_murmur3_one_32(0);

	for (int i = 0; i < _p->array.size(); i++) {
		h = hash_murmur3_one_32(_p->array[i].recursive_hash(p_recursion_count), h);
	}
	return hash_fmix32(h);
}

void Array::operator=(const Array &p_array) {
	_ref(p_array);
}

void Array::push_back(const Variant &p_value) {
	_p->array.push_back(p_value);
}

void Array::append_array(const Array &p_array) {
	_p->array.append_array(p_array._p->array);
}

Error Array::resize(int p_new_size) {
	return _p->array.resize(p_new_size);
}

void Array::insert(int p_pos, const Variant &p_value) {
	_p->array.insert(p_pos, p_value);
}

void Array::fill(const Variant &p_value) {
	_p->array.fill(p_value);
}

void Array::erase(const Variant &p_value) {
	_p->array.erase(p_value);
}

Variant Array::front() const {
	ERR_FAIL_COND_V_MSG(_p->array.size() == 0, Variant(), "Can't take value from empty array.");
	return operator[](0);
}

Variant Array::back() const {
	ERR_FAIL_COND_V_MSG(_p->array.size() == 0, Variant(), "Can't take value from empty array.");
	return operator[](_p->array.size() - 1);
}

int Array::find(const Variant &p_value, int p_from) const {
	return _p->array.find(p_value, p_from);
}

int Array::rfind(const Variant &p_value, int p_from) const {
	if (_p->array.size() == 0) {
		return -1;
	}

	if (p_from < 0) {
		// Relative offset from the end
		p_from = _p->array.size() + p_from;
	}
	if (p_from < 0 || p_from >= _p->array.size()) {
		// Limit to array boundaries
		p_from = _p->array.size() - 1;
	}

	for (int i = p_from; i >= 0; i--) {
		if (_p->array[i] == p_value) {
			return i;
		}
	}

	return -1;
}

int Array::find_last(const Variant &p_value) const {
	return rfind(p_value);
}

int Array::count(const Variant &p_value) const {
	if (_p->array.size() == 0) {
		return 0;
	}

	int amount = 0;
	for (int i = 0; i < _p->array.size(); i++) {
		if (_p->array[i] == p_value) {
			amount++;
		}
	}

	return amount;
}

bool Array::has(const Variant &p_value) const {
	return _p->array.find(p_value, 0) != -1;
}

void Array::remove(int p_pos) {
	_p->array.remove(p_pos);
}

void Array::set(int p_idx, const Variant &p_value) {
	operator[](p_idx) = p_value;
}

const Variant &Array::get(int p_idx) const {
	return operator[](p_idx);
}

Array Array::duplicate(bool p_deep) const {
	Array new_arr;
	int element_count = size();
	new_arr.resize(element_count);
	for (int i = 0; i < element_count; i++) {
		new_arr[i] = p_deep ? get(i).duplicate(p_deep) : get(i);
	}

	return new_arr;
}

int Array::_clamp_slice_index(int p_index) const {
	int arr_size = size();
	int fixed_index = CLAMP(p_index, -arr_size, arr_size - 1);
	if (fixed_index < 0) {
		fixed_index = arr_size + fixed_index;
	}
	return fixed_index;
}

Array Array::slice(int p_begin, int p_end, int p_step, bool p_deep) const { // like python, but inclusive on upper bound

	Array new_arr;

	ERR_FAIL_COND_V_MSG(p_step == 0, new_arr, "Array slice step size cannot be zero.");

	if (empty()) { // Don't try to slice empty arrays.
		return new_arr;
	}
	if (p_step > 0) {
		if (p_begin >= size() || p_end < -size()) {
			return new_arr;
		}
	} else { // p_step < 0
		if (p_begin < -size() || p_end >= size()) {
			return new_arr;
		}
	}

	int begin = _clamp_slice_index(p_begin);
	int end = _clamp_slice_index(p_end);

	int new_arr_size = MAX(((end - begin + p_step) / p_step), 0);
	new_arr.resize(new_arr_size);

	if (p_step > 0) {
		int dest_idx = 0;
		for (int idx = begin; idx <= end; idx += p_step) {
			ERR_FAIL_COND_V_MSG(dest_idx < 0 || dest_idx >= new_arr_size, Array(), "Bug in Array slice()");
			new_arr[dest_idx++] = p_deep ? get(idx).duplicate(p_deep) : get(idx);
		}
	} else { // p_step < 0
		int dest_idx = 0;
		for (int idx = begin; idx >= end; idx += p_step) {
			ERR_FAIL_COND_V_MSG(dest_idx < 0 || dest_idx >= new_arr_size, Array(), "Bug in Array slice()");
			new_arr[dest_idx++] = p_deep ? get(idx).duplicate(p_deep) : get(idx);
		}
	}

	return new_arr;
}

struct _ArrayVariantSort {
	_FORCE_INLINE_ bool operator()(const Variant &p_l, const Variant &p_r) const {
		bool valid = false;
		Variant res;
		Variant::evaluate(Variant::OP_LESS, p_l, p_r, res, valid);
		if (!valid) {
			res = false;
		}
		return res;
	}
};

Array &Array::sort() {
	_p->array.sort_custom<_ArrayVariantSort>();
	return *this;
}

struct _ArrayVariantSortCustom {
	Object *obj;

	_FORCE_INLINE_ bool operator()(const Variant &p_l, const Variant &p_r) const {
		return obj->lt(p_l, p_r);
	}
};
Array &Array::sort_custom(Object *p_obj) {
	ERR_FAIL_COND_V(!p_obj, *this);

	SortArray<Variant, _ArrayVariantSortCustom, true> avs;
	avs.compare.obj = p_obj;
	avs.sort(_p->array.ptrw(), _p->array.size());
	return *this;
}

void Array::shuffle() {
	const int n = _p->array.size();
	if (n < 2) {
		return;
	}
	Variant *data = _p->array.ptrw();
	for (int i = n - 1; i >= 1; i--) {
		const int j = Math::rand() % (i + 1);
		const Variant tmp = data[j];
		data[j] = data[i];
		data[i] = tmp;
	}
}

template <typename Less>
_FORCE_INLINE_ int bisect(const Vector<Variant> &p_array, const Variant &p_value, bool p_before, const Less &p_less) {
	int lo = 0;
	int hi = p_array.size();
	if (p_before) {
		while (lo < hi) {
			const int mid = (lo + hi) / 2;
			if (p_less(p_array.get(mid), p_value)) {
				lo = mid + 1;
			} else {
				hi = mid;
			}
		}
	} else {
		while (lo < hi) {
			const int mid = (lo + hi) / 2;
			if (p_less(p_value, p_array.get(mid))) {
				hi = mid;
			} else {
				lo = mid + 1;
			}
		}
	}
	return lo;
}

int Array::bsearch(const Variant &p_value, bool p_before) {
	return bisect(_p->array, p_value, p_before, _ArrayVariantSort());
}

int Array::bsearch_custom(const Variant &p_value, Object *p_obj, const StringName &p_function, bool p_before) {
	ERR_FAIL_COND_V(!p_obj, 0);

	_ArrayVariantSortCustom less;
	less.obj = p_obj;

	return bisect(_p->array, p_value, p_before, less);
}

Array &Array::invert() {
	_p->array.invert();
	return *this;
}

void Array::push_front(const Variant &p_value) {
	_p->array.insert(0, p_value);
}

Variant Array::pop_back() {
	if (!_p->array.empty()) {
		const int n = _p->array.size() - 1;
		const Variant ret = _p->array.get(n);
		_p->array.resize(n);
		return ret;
	}
	return Variant();
}

Variant Array::pop_front() {
	if (!_p->array.empty()) {
		const Variant ret = _p->array.get(0);
		_p->array.remove(0);
		return ret;
	}
	return Variant();
}

Variant Array::pop_at(int p_pos) {
	if (_p->array.empty()) {
		// Return `null` without printing an error to mimic `pop_back()` and `pop_front()` behavior.
		return Variant();
	}

	if (p_pos < 0) {
		// Relative offset from the end
		p_pos = _p->array.size() + p_pos;
	}

	ERR_FAIL_INDEX_V_MSG(
			p_pos,
			_p->array.size(),
			Variant(),
			vformat(
					"The calculated index %s is out of bounds (the array has %s elements). Leaving the array untouched and returning `null`.",
					p_pos,
					_p->array.size()));

	const Variant ret = _p->array.get(p_pos);
	_p->array.remove(p_pos);
	return ret;
}

#if defined(_WIN64) || defined(_WIN32)
// Windows...
#undef min
#undef max
#endif

Variant Array::min() const {
	Variant minval;
	for (int i = 0; i < size(); i++) {
		if (i == 0) {
			minval = get(i);
		} else {
			bool valid;
			Variant ret;
			Variant test = get(i);
			Variant::evaluate(Variant::OP_LESS, test, minval, ret, valid);
			if (!valid) {
				return Variant(); //not a valid comparison
			}
			if (bool(ret)) {
				//is less
				minval = test;
			}
		}
	}
	return minval;
}

Variant Array::max() const {
	Variant maxval;
	for (int i = 0; i < size(); i++) {
		if (i == 0) {
			maxval = get(i);
		} else {
			bool valid;
			Variant ret;
			Variant test = get(i);
			Variant::evaluate(Variant::OP_GREATER, test, maxval, ret, valid);
			if (!valid) {
				return Variant(); //not a valid comparison
			}
			if (bool(ret)) {
				//is less
				maxval = test;
			}
		}
	}
	return maxval;
}

bool Array::operator<(const Array &p_array) const {
	int a_len = size();

	int b_len = p_array.size();

	int min_cmp = MIN(a_len, b_len);

	for (int i = 0; i < min_cmp; i++) {
		if (operator[](i) < p_array[i]) {
			return true;

		} else if (p_array[i] < operator[](i)) {
			return false;
		}
	}

	return a_len < b_len;
}

bool Array::operator<=(const Array &p_array) const {
	return !operator>(p_array);
}

bool Array::operator>(const Array &p_array) const {
	return p_array < *this;
}

bool Array::operator>=(const Array &p_array) const {
	return !operator<(p_array);
}

const void *Array::id() const {
	return _p;
}

String Array::sprintf(const String &p_format, bool *error) const {
	String formatted;
	CharType *self = (CharType *)p_format.get_data();
	bool in_format = false;
	int value_index = 0;
	int min_chars = 0;
	int min_decimals = 0;
	bool in_decimals = false;
	bool pad_with_zeros = false;
	bool left_justified = false;
	bool show_sign = false;

	const Array &values = *this;

	if (error) {
		*error = true;
	}

	for (; *self; self++) {
		const CharType c = *self;

		if (in_format) { // We have % - let's see what else we get.
			switch (c) {
				case '%': { // Replace %% with %
					formatted += p_format.chr(c);
					in_format = false;
					break;
				}
				case 'd': // Integer (signed)
				case 'o': // Octal
				case 'x': // Hexadecimal (lowercase)
				case 'X': { // Hexadecimal (uppercase)
					if (value_index >= values.size()) {
						return "not enough arguments for format string";
					}

					if (!values[value_index].is_num()) {
						return "a number is required";
					}

					int64_t value = values[value_index];
					int base = 16;
					bool capitalize = false;
					switch (c) {
						case 'd':
							base = 10;
							break;
						case 'o':
							base = 8;
							break;
						case 'x':
							break;
						case 'X':
							base = 16;
							capitalize = true;
							break;
					}
					// Get basic number.
					String str = String::num_int64(ABS(value), base, capitalize);
					int number_len = str.length();

					// Padding.
					int pad_chars_count = (value < 0 || show_sign) ? min_chars - 1 : min_chars;
					String pad_char = pad_with_zeros ? String("0") : String(" ");
					if (left_justified) {
						str = str.rpad(pad_chars_count, pad_char);
					} else {
						str = str.lpad(pad_chars_count, pad_char);
					}

					// Sign.
					if (show_sign || value < 0) {
						String sign_char = value < 0 ? "-" : "+";
						if (left_justified) {
							str = str.insert(0, sign_char);
						} else {
							str = str.insert(pad_with_zeros ? 0 : str.length() - number_len, sign_char);
						}
					}

					formatted += str;
					++value_index;
					in_format = false;

					break;
				}
				case 'f': { // Float
					if (value_index >= values.size()) {
						return "not enough arguments for format string";
					}

					if (!values[value_index].is_num()) {
						return "a number is required";
					}

					double value = values[value_index];
					bool is_negative = (value < 0);
					String str = String::num(ABS(value), min_decimals);
					bool not_numeric = isinf(value) || isnan(value);

					// Pad decimals out.
					if (!not_numeric) {
						str = str.pad_decimals(min_decimals);
					}

					int initial_len = str.length();

					// Padding. Leave room for sign later if required.
					int pad_chars_count = (is_negative || show_sign) ? min_chars - 1 : min_chars;
					String pad_char = (pad_with_zeros && !not_numeric) ? String("0") : String(" "); // Never pad NaN or inf with zeros
					if (left_justified) {
						str = str.rpad(pad_chars_count, pad_char);
					} else {
						str = str.lpad(pad_chars_count, pad_char);
					}

					// Add sign if needed.
					if (show_sign || is_negative) {
						String sign_char = is_negative ? "-" : "+";
						if (left_justified) {
							str = str.insert(0, sign_char);
						} else {
							str = str.insert(pad_with_zeros ? 0 : str.length() - initial_len, sign_char);
						}
					}

					formatted += str;
					++value_index;
					in_format = false;
					break;
				}
				case 's': { // String
					if (value_index >= values.size()) {
						return "not enough arguments for format string";
					}

					String str = values[value_index];
					// Padding.
					if (left_justified) {
						str = str.rpad(min_chars);
					} else {
						str = str.lpad(min_chars);
					}

					formatted += str;
					++value_index;
					in_format = false;
					break;
				}
				case 'c': {
					if (value_index >= values.size()) {
						return "not enough arguments for format string";
					}

					// Convert to character.
					String str;
					if (values[value_index].is_num()) {
						int value = values[value_index];
						if (value < 0) {
							return "unsigned integer is lower than minimum";
						} else if (value >= 0xd800 && value <= 0xdfff) {
							return "unsigned integer is invalid Unicode character";
						} else if (value > 0x10ffff) {
							return "unsigned integer is greater than maximum";
						}
						str = p_format.chr(values[value_index]);
					} else if (values[value_index].get_type() == Variant::STRING) {
						str = values[value_index];
						if (str.length() != 1) {
							return "%c requires number or single-character string";
						}
					} else {
						return "%c requires number or single-character string";
					}

					// Padding.
					if (left_justified) {
						str = str.rpad(min_chars);
					} else {
						str = str.lpad(min_chars);
					}

					formatted += str;
					++value_index;
					in_format = false;
					break;
				}
				case '-': { // Left justify
					left_justified = true;
					break;
				}
				case '+': { // Show + if positive.
					show_sign = true;
					break;
				}
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': {
					int n = c - '0';
					if (in_decimals) {
						min_decimals *= 10;
						min_decimals += n;
					} else {
						if (c == '0' && min_chars == 0) {
							if (left_justified) {
								LOG_WARN("'0' flag ignored with '-' flag in string format");
							} else {
								pad_with_zeros = true;
							}
						} else {
							min_chars *= 10;
							min_chars += n;
						}
					}
					break;
				}
				case '.': { // Float separator.
					if (in_decimals) {
						return "too many decimal points in format";
					}
					in_decimals = true;
					min_decimals = 0; // We want to add the value manually.
					break;
				}

				case '*': { // Dynamic width, based on value.
					if (value_index >= values.size()) {
						return "not enough arguments for format string";
					}

					if (!values[value_index].is_num()) {
						return "* wants number";
					}

					int size = values[value_index];

					if (in_decimals) {
						min_decimals = size;
					} else {
						min_chars = size;
					}

					++value_index;
					break;
				}

				default: {
					return "unsupported format character";
				}
			}
		} else { // Not in format string.
			switch (c) {
				case '%':
					in_format = true;
					// Back to defaults:
					min_chars = 0;
					min_decimals = 6;
					pad_with_zeros = false;
					left_justified = false;
					show_sign = false;
					in_decimals = false;
					break;
				default:
					formatted += p_format.chr(c);
			}
		}
	}

	if (in_format) {
		return "incomplete format";
	}

	if (value_index != values.size()) {
		return "not all arguments converted during string formatting";
	}

	if (error) {
		*error = false;
	}
	return formatted;
}

Array::Array(const Array &p_from) {
	_p = nullptr;
	_ref(p_from);
}

Array::Array() {
	_p = memnew(ArrayPrivate);
	_p->refcount.init();
}
Array::~Array() {
	_unref();
}
#line 0

#line 1 "sfw/object/psignal.cpp"

void Signal::connect_static(void (*func)(Signal *)) {
	StaticSignalEntry *se = memnew(StaticSignalEntry());
	se->func = func;

	entries.push_back(se);
}
void Signal::disconnect_static(void (*func)(Signal *)) {
	for (int i = 0; i < entries.size(); ++i) {
		SignalEntry *e = entries[i];

		if (e->type == SIGNAL_ENTRY_TYPE_STATIC) {
			StaticSignalEntry *se = static_cast<StaticSignalEntry *>(e);

			if (se->func == func) {
				entries.remove(i);
				return;
			}
		}
	}
}
bool Signal::is_connected_static(void (*func)(Signal *)) {
	for (int i = 0; i < entries.size(); ++i) {
		SignalEntry *e = entries[i];

		if (e->type == SIGNAL_ENTRY_TYPE_STATIC) {
			StaticSignalEntry *se = static_cast<StaticSignalEntry *>(e);

			if (se->func == func) {
				return true;
			}
		}
	}

	return false;
}

void Signal::emit(Object *p_emitter) {
	emitter = p_emitter;

	for (int i = 0; i < entries.size(); ++i) {
		entries[i]->call(this);
	}
}

void Signal::emit(Object *p_emitter, const Variant &p1) {
	emitter = p_emitter;

	params.push_back(p1);

	for (int i = 0; i < entries.size(); ++i) {
		entries[i]->call(this);
	}

	params.clear();
}
void Signal::emit(Object *p_emitter, const Variant &p1, const Variant &p2) {
	emitter = p_emitter;

	params.push_back(p1);
	params.push_back(p2);

	for (int i = 0; i < entries.size(); ++i) {
		entries[i]->call(this);
	}

	params.clear();
}
void Signal::emit(Object *p_emitter, const Variant &p1, const Variant &p2, const Variant &p3) {
	emitter = p_emitter;

	params.push_back(p1);
	params.push_back(p2);
	params.push_back(p3);

	for (int i = 0; i < entries.size(); ++i) {
		entries[i]->call(this);
	}

	params.clear();
}

void Signal::emit(Object *p_emitter, const Variant &p1, const Variant &p2, const Variant &p3, const Variant &p4) {
	emitter = p_emitter;

	params.push_back(p1);
	params.push_back(p2);
	params.push_back(p3);
	params.push_back(p4);

	for (int i = 0; i < entries.size(); ++i) {
		entries[i]->call(this);
	}

	params.clear();
}

void Signal::emit(Object *p_emitter, const Variant &p1, const Variant &p2, const Variant &p3, const Variant &p4, const Variant &p5) {
	emitter = p_emitter;

	params.push_back(p1);
	params.push_back(p2);
	params.push_back(p3);
	params.push_back(p4);
	params.push_back(p5);

	for (int i = 0; i < entries.size(); ++i) {
		entries[i]->call(this);
	}

	params.clear();
}

Signal::Signal() {
}
Signal::~Signal() {
}
#line 0

#line 1 "sfw/object/variant.cpp"
/*************************************************************************/
/*  variant.cpp                                                          */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

String Variant::get_type_name(Variant::Type p_type) {
	switch (p_type) {
		case NIL: {
			return "Nil";
		} break;

		// atomic types
		case BOOL: {
			return "bool";
		} break;
		case INT: {
			return "int";

		} break;
		case REAL: {
			return "float";

		} break;
		case STRING: {
			return "String";
		} break;

		// math types
		case RECT2: {
			return "Rect2";
		} break;
		case RECT2I: {
			return "Rect2i";
		} break;
		case VECTOR2: {
			return "Vector2";
		} break;
		case VECTOR2I: {
			return "Vector2i";
		} break;
		case VECTOR3: {
			return "Vector3";
		} break;
		case VECTOR3I: {
			return "Vector3i";
		} break;
		case VECTOR4: {
			return "Vector4";
		} break;
		case VECTOR4I: {
			return "Vector4i";
		} break;

		case PLANE: {
			return "Plane";
		} break;
		case QUATERNION: {
			return "Quaternion";
		} break;
		case AABB: {
			return "AABB";
		} break;
		case BASIS: {
			return "Basis";
		} break;
		case TRANSFORM: {
			return "Transform";
		} break;
		case TRANSFORM2D: {
			return "Transform2D";
		} break;
		case PROJECTION: {
			return "Projection";
		} break;

		// misc types
		case COLOR: {
			return "Color";
		} break;
		case OBJECT: {
			return "Object";
		} break;
		case STRING_NAME: {
			return "StringName";
		} break;
		case DICTIONARY: {
			return "Dictionary";
		} break;
		case ARRAY: {
			return "Array";
		} break;

		// arrays
		case POOL_BYTE_ARRAY: {
			return "PoolByteArray";
		} break;
		case POOL_INT_ARRAY: {
			return "PoolIntArray";
		} break;
		case POOL_REAL_ARRAY: {
			return "PoolRealArray";
		} break;
		case POOL_STRING_ARRAY: {
			return "PoolStringArray";
		} break;
		case POOL_VECTOR2_ARRAY: {
			return "PoolVector2Array";
		} break;
		case POOL_VECTOR2I_ARRAY: {
			return "PoolVector2iArray";
		} break;
		case POOL_VECTOR3_ARRAY: {
			return "PoolVector3Array";
		} break;
		case POOL_VECTOR3I_ARRAY: {
			return "PoolVector3iArray";
		} break;
		case POOL_VECTOR4_ARRAY: {
			return "PoolVector4Array";
		} break;
		case POOL_VECTOR4I_ARRAY: {
			return "PoolVector4iArray";
		} break;
		case POOL_COLOR_ARRAY: {
			return "PoolColorArray";
		} break;
		default: {
		}
	}

	return "";
}

bool Variant::can_convert(Variant::Type p_type_from, Variant::Type p_type_to) {
	if (p_type_from == p_type_to) {
		return true;
	}
	if (p_type_to == NIL && p_type_from != NIL) { //nil can convert to anything
		return true;
	}

	if (p_type_from == NIL) {
		return (p_type_to == OBJECT);
	};

	const Type *valid_types = nullptr;
	const Type *invalid_types = nullptr;

	switch (p_type_to) {
		case NIL: {
			//can't
		} break;
		case BOOL: {
			static const Type valid[] = {
				INT,
				REAL,
				STRING,
				NIL,
			};

			valid_types = valid;
		} break;
		case INT: {
			static const Type valid[] = {
				BOOL,
				REAL,
				STRING,
				NIL,
			};

			valid_types = valid;
		} break;
		case REAL: {
			static const Type valid[] = {
				BOOL,
				INT,
				STRING,
				NIL,
			};

			valid_types = valid;
		} break;
		case STRING: {
			static const Type invalid[] = {
				OBJECT,
				NIL
			};

			invalid_types = invalid;
		} break;
		case RECT2: {
			static const Type valid[] = {
				RECT2I,
				NIL
			};

			valid_types = valid;
		} break;
		case RECT2I: {
			static const Type valid[] = {
				RECT2,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR2: {
			static const Type valid[] = {
				VECTOR2I,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR2I: {
			static const Type valid[] = {
				VECTOR2,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR3: {
			static const Type valid[] = {
				VECTOR3I,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR3I: {
			static const Type valid[] = {
				VECTOR3,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR4: {
			static const Type valid[] = {
				VECTOR4I,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR4I: {
			static const Type valid[] = {
				VECTOR4,
				NIL
			};

			valid_types = valid;
		} break;
		case PLANE: {
			//can't
		} break;
		case QUATERNION: {
			static const Type valid[] = {
				BASIS,
				NIL
			};

			valid_types = valid;
		} break;
		case AABB: {
			//can't
		} break;
		case BASIS: {
			static const Type valid[] = {
				QUATERNION,
				VECTOR3,
				NIL
			};

			valid_types = valid;
		} break;
		case TRANSFORM: {
			static const Type valid[] = {
				TRANSFORM2D,
				QUATERNION,
				BASIS,
				NIL
			};

			valid_types = valid;
		} break;
		case TRANSFORM2D: {
			static const Type valid[] = {
				TRANSFORM,
				NIL
			};

			valid_types = valid;
		} break;
		case PROJECTION: {
			static const Type valid[] = {
				TRANSFORM,
				NIL
			};

			valid_types = valid;
		} break;
		// misc types
		case COLOR: {
			static const Type valid[] = {
				STRING,
				INT,
				NIL,
			};

			valid_types = valid;
		} break;
		case OBJECT: {
			static const Type valid[] = {
				NIL
			};

			valid_types = valid;
		} break;
		case STRING_NAME: {
			static const Type valid[] = {
				STRING,
				NIL
			};

			valid_types = valid;
		} break;
		case DICTIONARY: {
			//can't
		} break;
		case ARRAY: {
			static const Type valid[] = {
				POOL_BYTE_ARRAY,
				POOL_INT_ARRAY,
				POOL_STRING_ARRAY,
				POOL_REAL_ARRAY,
				POOL_COLOR_ARRAY,
				POOL_VECTOR2_ARRAY,
				POOL_VECTOR2I_ARRAY,
				POOL_VECTOR3_ARRAY,
				POOL_VECTOR3I_ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		// arrays
		case POOL_BYTE_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_INT_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_REAL_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_STRING_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_VECTOR2_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_VECTOR2I_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_VECTOR3_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_VECTOR3I_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_VECTOR4_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_VECTOR4I_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_COLOR_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		default: {
		}
	}

	if (valid_types) {
		int i = 0;
		while (valid_types[i] != NIL) {
			if (p_type_from == valid_types[i]) {
				return true;
			}
			i++;
		}

	} else if (invalid_types) {
		int i = 0;
		while (invalid_types[i] != NIL) {
			if (p_type_from == invalid_types[i]) {
				return false;
			}
			i++;
		}

		return true;
	}

	return false;
}

bool Variant::can_convert_strict(Variant::Type p_type_from, Variant::Type p_type_to) {
	if (p_type_from == p_type_to) {
		return true;
	}
	if (p_type_to == NIL && p_type_from != NIL) { //nil can convert to anything
		return true;
	}

	if (p_type_from == NIL) {
		return (p_type_to == OBJECT);
	};

	const Type *valid_types = nullptr;

	switch (p_type_to) {
		case NIL: {
			//can't, also already handled
		} break;
		case BOOL: {
			static const Type valid[] = {
				INT,
				REAL,
				//STRING,
				NIL,
			};

			valid_types = valid;
		} break;
		case INT: {
			static const Type valid[] = {
				BOOL,
				REAL,
				//STRING,
				NIL,
			};

			valid_types = valid;

		} break;
		case REAL: {
			static const Type valid[] = {
				BOOL,
				INT,
				//STRING,
				NIL,
			};

			valid_types = valid;

		} break;
		case STRING: {
			static const Type valid[] = {
				STRING_NAME,
				NIL
			};

			valid_types = valid;
		} break;
		case RECT2: {
			static const Type valid[] = {
				RECT2I,
				NIL
			};

			valid_types = valid;
		} break;
		case RECT2I: {
			static const Type valid[] = {
				RECT2,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR2: {
			static const Type valid[] = {
				VECTOR2I,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR2I: {
			static const Type valid[] = {
				VECTOR2,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR3: {
			static const Type valid[] = {
				VECTOR3I,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR3I: {
			static const Type valid[] = {
				VECTOR3,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR4: {
			static const Type valid[] = {
				VECTOR4I,
				NIL
			};

			valid_types = valid;
		} break;
		case VECTOR4I: {
			static const Type valid[] = {
				VECTOR4,
				NIL
			};

			valid_types = valid;
		} break;
		case PLANE: {
			//Can't
		} break;
		case QUATERNION: {
			static const Type valid[] = {
				BASIS,
				NIL
			};

			valid_types = valid;
		} break;
		case AABB: {
			//Can't
		} break;
		case BASIS: {
			static const Type valid[] = {
				QUATERNION,
				VECTOR3,
				NIL
			};

			valid_types = valid;
		} break;
		case TRANSFORM: {
			static const Type valid[] = {
				TRANSFORM2D,
				QUATERNION,
				BASIS,
				NIL
			};

			valid_types = valid;
		} break;
		case TRANSFORM2D: {
			static const Type valid[] = {
				TRANSFORM,
				NIL
			};

			valid_types = valid;
		} break;
		case PROJECTION: {
			static const Type valid[] = {
				TRANSFORM,
				NIL
			};

			valid_types = valid;
		} break;
		case COLOR: {
			static const Type valid[] = {
				STRING,
				INT,
				NIL,
			};

			valid_types = valid;
		} break;
		case OBJECT: {
			static const Type valid[] = {
				NIL
			};

			valid_types = valid;
		} break;
		case STRING_NAME: {
			static const Type valid[] = {
				STRING,
				NIL
			};

			valid_types = valid;
		} break;
		case DICTIONARY: {
			//Can't
		} break;
		case ARRAY: {
			static const Type valid[] = {
				POOL_BYTE_ARRAY,
				POOL_INT_ARRAY,
				POOL_STRING_ARRAY,
				POOL_REAL_ARRAY,
				POOL_COLOR_ARRAY,
				POOL_VECTOR2_ARRAY,
				POOL_VECTOR2I_ARRAY,
				POOL_VECTOR3_ARRAY,
				POOL_VECTOR3I_ARRAY,
				POOL_VECTOR4_ARRAY,
				POOL_VECTOR4I_ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		// arrays
		case POOL_BYTE_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_INT_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};
			valid_types = valid;
		} break;
		case POOL_REAL_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_STRING_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_VECTOR2_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_VECTOR2I_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_VECTOR3_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_VECTOR3I_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_VECTOR4_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_VECTOR4I_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		case POOL_COLOR_ARRAY: {
			static const Type valid[] = {
				ARRAY,
				NIL
			};

			valid_types = valid;
		} break;
		default: {
		}
	}

	if (valid_types) {
		int i = 0;
		while (valid_types[i] != NIL) {
			if (p_type_from == valid_types[i]) {
				return true;
			}
			i++;
		}
	}

	return false;
}

bool Variant::deep_equal(const Variant &p_variant, int p_recursion_count) const {
	ERR_FAIL_COND_V_MSG(p_recursion_count > MAX_RECURSION, true, "Max recursion reached");

	// Containers must be handled with recursivity checks
	switch (type) {
		case Variant::Type::DICTIONARY: {
			if (p_variant.type != Variant::Type::DICTIONARY) {
				return false;
			}

			const Dictionary v1_as_d = Dictionary(*this);
			const Dictionary v2_as_d = Dictionary(p_variant);

			return v1_as_d.deep_equal(v2_as_d, p_recursion_count + 1);
		} break;
		case Variant::Type::ARRAY: {
			if (p_variant.type != Variant::Type::ARRAY) {
				return false;
			}

			const Array v1_as_a = Array(*this);
			const Array v2_as_a = Array(p_variant);

			return v1_as_a.deep_equal(v2_as_a, p_recursion_count + 1);
		} break;
		default: {
			return *this == p_variant;
		} break;
	}
}

bool Variant::operator==(const Variant &p_variant) const {
	if (type != p_variant.type) { //evaluation of operator== needs to be more strict
		return false;
	}
	bool v;
	Variant r;
	evaluate(OP_EQUAL, *this, p_variant, r, v);
	return r;
}

bool Variant::operator!=(const Variant &p_variant) const {
	if (type != p_variant.type) { //evaluation of operator== needs to be more strict
		return true;
	}
	bool v;
	Variant r;
	evaluate(OP_NOT_EQUAL, *this, p_variant, r, v);
	return r;
}

bool Variant::operator<(const Variant &p_variant) const {
	if (type != p_variant.type) { //if types differ, then order by type first
		return type < p_variant.type;
	}
	bool v;
	Variant r;
	evaluate(OP_LESS, *this, p_variant, r, v);
	return r;
}

bool Variant::is_zero() const {
	switch (type) {
		case NIL: {
			return true;
		} break;

		// atomic types
		case BOOL: {
			return !(_data._bool);
		} break;
		case INT: {
			return _data._int == 0;
		} break;
		case REAL: {
			return _data._real == 0;
		} break;
		case STRING: {
			return *reinterpret_cast<const String *>(_data._mem) == String();
		} break;

		// math types
		case RECT2: {
			return *reinterpret_cast<const Rect2 *>(_data._mem) == Rect2();
		} break;
		case RECT2I: {
			return *reinterpret_cast<const Rect2i *>(_data._mem) == Rect2i();
		} break;
		case VECTOR2: {
			return *reinterpret_cast<const Vector2 *>(_data._mem) == Vector2();
		} break;
		case VECTOR2I: {
			return *reinterpret_cast<const Vector2i *>(_data._mem) == Vector2i();
		} break;
		case VECTOR3: {
			return *reinterpret_cast<const Vector3 *>(_data._mem) == Vector3();
		} break;
		case VECTOR3I: {
			return *reinterpret_cast<const Vector3i *>(_data._mem) == Vector3i();
		} break;
		case VECTOR4: {
			return *reinterpret_cast<const Vector4 *>(_data._mem) == Vector4();
		} break;
		case VECTOR4I: {
			return *reinterpret_cast<const Vector4i *>(_data._mem) == Vector4i();
		} break;

		case PLANE: {
			return *reinterpret_cast<const Plane *>(_data._mem) == Plane();
		} break;
		case QUATERNION: {
			return *reinterpret_cast<const Quaternion *>(_data._mem) == Quaternion();
		} break;
		case AABB: {
			return *_data._aabb == ::AABB();
		} break;
		case BASIS: {
			return *_data._basis == Basis();
		} break;
		case TRANSFORM: {
			return *_data._transform == Transform();
		} break;
		case TRANSFORM2D: {
			return *_data._transform2d == Transform2D();
		} break;
		case PROJECTION: {
			return *_data._projection == Projection();
		} break;

		// misc types
		case COLOR: {
			return *reinterpret_cast<const Color *>(_data._mem) == Color();
		} break;
		case OBJECT: {
			return _UNSAFE_OBJ_PROXY_PTR(*this) == nullptr;
		} break;
		case STRING_NAME: {
			return *reinterpret_cast<const StringName *>(_data._mem) != StringName();
		} break;
		case DICTIONARY: {
			return reinterpret_cast<const Dictionary *>(_data._mem)->empty();
		} break;
		case ARRAY: {
			return reinterpret_cast<const Array *>(_data._mem)->empty();
		} break;

		// arrays
		case POOL_BYTE_ARRAY: {
			return reinterpret_cast<const PoolVector<uint8_t> *>(_data._mem)->size() == 0;
		} break;
		case POOL_INT_ARRAY: {
			return reinterpret_cast<const PoolVector<int> *>(_data._mem)->size() == 0;
		} break;
		case POOL_REAL_ARRAY: {
			return reinterpret_cast<const PoolVector<real_t> *>(_data._mem)->size() == 0;
		} break;
		case POOL_STRING_ARRAY: {
			return reinterpret_cast<const PoolVector<String> *>(_data._mem)->size() == 0;
		} break;
		case POOL_VECTOR2_ARRAY: {
			return reinterpret_cast<const PoolVector<Vector2> *>(_data._mem)->size() == 0;
		} break;
		case POOL_VECTOR2I_ARRAY: {
			return reinterpret_cast<const PoolVector<Vector2i> *>(_data._mem)->size() == 0;
		} break;
		case POOL_VECTOR3_ARRAY: {
			return reinterpret_cast<const PoolVector<Vector3> *>(_data._mem)->size() == 0;
		} break;
		case POOL_VECTOR3I_ARRAY: {
			return reinterpret_cast<const PoolVector<Vector3i> *>(_data._mem)->size() == 0;
		} break;
		case POOL_VECTOR4_ARRAY: {
			return reinterpret_cast<const PoolVector<Vector4> *>(_data._mem)->size() == 0;
		} break;
		case POOL_VECTOR4I_ARRAY: {
			return reinterpret_cast<const PoolVector<Vector4i> *>(_data._mem)->size() == 0;
		} break;
		case POOL_COLOR_ARRAY: {
			return reinterpret_cast<const PoolVector<Color> *>(_data._mem)->size() == 0;
		} break;
		default: {
		}
	}

	return false;
}

bool Variant::is_one() const {
	switch (type) {
		case NIL: {
			return true;
		} break;

		// atomic types
		case BOOL: {
			return _data._bool;
		} break;
		case INT: {
			return _data._int == 1;
		} break;
		case REAL: {
			return _data._real == 1;
		} break;
		case RECT2: {
			return *reinterpret_cast<const Rect2 *>(_data._mem) == Rect2(1, 1, 1, 1);
		} break;
		case RECT2I: {
			return *reinterpret_cast<const Rect2i *>(_data._mem) == Rect2i(1, 1, 1, 1);
		} break;
		case VECTOR2: {
			return *reinterpret_cast<const Vector2 *>(_data._mem) == Vector2(1, 1);
		} break;
		case VECTOR2I: {
			return *reinterpret_cast<const Vector2i *>(_data._mem) == Vector2i(1, 1);
		} break;
		case VECTOR3: {
			return *reinterpret_cast<const Vector3 *>(_data._mem) == Vector3(1, 1, 1);
		} break;
		case VECTOR3I: {
			return *reinterpret_cast<const Vector3i *>(_data._mem) == Vector3i(1, 1, 1);
		} break;
		case VECTOR4: {
			return *reinterpret_cast<const Vector4 *>(_data._mem) == Vector4(1, 1, 1, 1);
		} break;
		case VECTOR4I: {
			return *reinterpret_cast<const Vector4i *>(_data._mem) == Vector4i(1, 1, 1, 1);
		} break;
		case PLANE: {
			return *reinterpret_cast<const Plane *>(_data._mem) == Plane(1, 1, 1, 1);
		} break;
		case COLOR: {
			return *reinterpret_cast<const Color *>(_data._mem) == Color(1, 1, 1, 1);
		} break;

		default: {
			return !is_zero();
		}
	}

	return false;
}

ObjectID Variant::get_object_instance_id() const {
	if (unlikely(type != OBJECT)) {
		return 0;
	} else if (likely(_get_obj().rc)) {
		return _get_obj().rc->instance_id;
	} else if (likely(!_get_obj().ref.is_null())) {
		return _REF_OBJ_PTR(*this)->get_instance_id();
	} else {
		return 0;
	}
}

bool Variant::is_invalid_object() const {
	return type == OBJECT && _get_obj().rc && !_get_obj().rc->get_ptr();
}

void Variant::reference(const Variant &p_variant) {
	switch (type) {
		case NIL:
		case BOOL:
		case INT:
		case REAL:
			break;
		default:
			clear();
	}

	type = p_variant.type;

	switch (p_variant.type) {
		case NIL: {
			// none
		} break;

		// atomic types
		case BOOL: {
			_data._bool = p_variant._data._bool;
		} break;
		case INT: {
			_data._int = p_variant._data._int;
		} break;
		case REAL: {
			_data._real = p_variant._data._real;
		} break;
		case STRING: {
			memnew_placement(_data._mem, String(*reinterpret_cast<const String *>(p_variant._data._mem)));
		} break;

		// math types
		case RECT2: {
			memnew_placement(_data._mem, Rect2(*reinterpret_cast<const Rect2 *>(p_variant._data._mem)));
		} break;
		case RECT2I: {
			memnew_placement(_data._mem, Rect2i(*reinterpret_cast<const Rect2i *>(p_variant._data._mem)));
		} break;
		case VECTOR2: {
			memnew_placement(_data._mem, Vector2(*reinterpret_cast<const Vector2 *>(p_variant._data._mem)));
		} break;
		case VECTOR2I: {
			memnew_placement(_data._mem, Vector2i(*reinterpret_cast<const Vector2i *>(p_variant._data._mem)));
		} break;
		case VECTOR3: {
			memnew_placement(_data._mem, Vector3(*reinterpret_cast<const Vector3 *>(p_variant._data._mem)));
		} break;
		case VECTOR3I: {
			memnew_placement(_data._mem, Vector3i(*reinterpret_cast<const Vector3i *>(p_variant._data._mem)));
		} break;
		case VECTOR4: {
			memnew_placement(_data._mem, Vector4(*reinterpret_cast<const Vector4 *>(p_variant._data._mem)));
		} break;
		case VECTOR4I: {
			memnew_placement(_data._mem, Vector4i(*reinterpret_cast<const Vector4i *>(p_variant._data._mem)));
		} break;

		case PLANE: {
			memnew_placement(_data._mem, Plane(*reinterpret_cast<const Plane *>(p_variant._data._mem)));
		} break;
		case QUATERNION: {
			memnew_placement(_data._mem, Quaternion(*reinterpret_cast<const Quaternion *>(p_variant._data._mem)));
		} break;
		case AABB: {
			_data._aabb = memnew(::AABB(*p_variant._data._aabb));
		} break;
		case BASIS: {
			_data._basis = memnew(Basis(*p_variant._data._basis));
		} break;
		case TRANSFORM: {
			_data._transform = memnew(Transform(*p_variant._data._transform));
		} break;
		case TRANSFORM2D: {
			_data._transform2d = memnew(Transform2D(*p_variant._data._transform2d));
		} break;
		case PROJECTION: {
			_data._projection = memnew(Projection(*p_variant._data._projection));
		} break;

		// misc types
		case COLOR: {
			memnew_placement(_data._mem, Color(*reinterpret_cast<const Color *>(p_variant._data._mem)));
		} break;
		case OBJECT: {
			memnew_placement(_data._mem, ObjData(p_variant._get_obj()));
			if (likely(_get_obj().rc)) {
				_get_obj().rc->increment();
			}
		} break;
		case STRING_NAME: {
			memnew_placement(_data._mem, StringName(*reinterpret_cast<const StringName *>(p_variant._data._mem)));
		} break;
		case DICTIONARY: {
			memnew_placement(_data._mem, Dictionary(*reinterpret_cast<const Dictionary *>(p_variant._data._mem)));
		} break;
		case ARRAY: {
			memnew_placement(_data._mem, Array(*reinterpret_cast<const Array *>(p_variant._data._mem)));
		} break;

		// arrays
		case POOL_BYTE_ARRAY: {
			memnew_placement(_data._mem, PoolVector<uint8_t>(*reinterpret_cast<const PoolVector<uint8_t> *>(p_variant._data._mem)));
		} break;
		case POOL_INT_ARRAY: {
			memnew_placement(_data._mem, PoolVector<int>(*reinterpret_cast<const PoolVector<int> *>(p_variant._data._mem)));
		} break;
		case POOL_REAL_ARRAY: {
			memnew_placement(_data._mem, PoolVector<real_t>(*reinterpret_cast<const PoolVector<real_t> *>(p_variant._data._mem)));
		} break;
		case POOL_STRING_ARRAY: {
			memnew_placement(_data._mem, PoolVector<String>(*reinterpret_cast<const PoolVector<String> *>(p_variant._data._mem)));
		} break;
		case POOL_VECTOR2_ARRAY: {
			memnew_placement(_data._mem, PoolVector<Vector2>(*reinterpret_cast<const PoolVector<Vector2> *>(p_variant._data._mem)));
		} break;
		case POOL_VECTOR2I_ARRAY: {
			memnew_placement(_data._mem, PoolVector<Vector2i>(*reinterpret_cast<const PoolVector<Vector2i> *>(p_variant._data._mem)));
		} break;
		case POOL_VECTOR3_ARRAY: {
			memnew_placement(_data._mem, PoolVector<Vector3>(*reinterpret_cast<const PoolVector<Vector3> *>(p_variant._data._mem)));
		} break;
		case POOL_VECTOR3I_ARRAY: {
			memnew_placement(_data._mem, PoolVector<Vector3i>(*reinterpret_cast<const PoolVector<Vector3i> *>(p_variant._data._mem)));
		} break;
		case POOL_VECTOR4_ARRAY: {
			memnew_placement(_data._mem, PoolVector<Vector4>(*reinterpret_cast<const PoolVector<Vector4> *>(p_variant._data._mem)));
		} break;
		case POOL_VECTOR4I_ARRAY: {
			memnew_placement(_data._mem, PoolVector<Vector4i>(*reinterpret_cast<const PoolVector<Vector4i> *>(p_variant._data._mem)));
		} break;
		case POOL_COLOR_ARRAY: {
			memnew_placement(_data._mem, PoolVector<Color>(*reinterpret_cast<const PoolVector<Color> *>(p_variant._data._mem)));
		} break;
		default: {
		}
	}
}

void Variant::zero() {
	switch (type) {
		case NIL:
			break;
		case BOOL:
			this->_data._bool = false;
			break;
		case INT:
			this->_data._int = 0;
			break;
		case REAL:
			this->_data._real = 0;
			break;
		case RECT2:
			*reinterpret_cast<Rect2 *>(this->_data._mem) = Rect2();
			break;
		case RECT2I:
			*reinterpret_cast<Rect2i *>(this->_data._mem) = Rect2i();
			break;
		case VECTOR2:
			*reinterpret_cast<Vector2 *>(this->_data._mem) = Vector2();
			break;
		case VECTOR2I:
			*reinterpret_cast<Vector2i *>(this->_data._mem) = Vector2i();
			break;
		case VECTOR3:
			*reinterpret_cast<Vector3 *>(this->_data._mem) = Vector3();
			break;
		case VECTOR3I:
			*reinterpret_cast<Vector3i *>(this->_data._mem) = Vector3i();
			break;
		case VECTOR4:
			*reinterpret_cast<Vector4 *>(this->_data._mem) = Vector4();
			break;
		case VECTOR4I:
			*reinterpret_cast<Vector4i *>(this->_data._mem) = Vector4i();
			break;
		case PLANE:
			*reinterpret_cast<Plane *>(this->_data._mem) = Plane();
			break;
		case QUATERNION:
			*reinterpret_cast<Quaternion *>(this->_data._mem) = Quaternion();
			break;
		case AABB:
			*reinterpret_cast<::AABB *>(this->_data._mem) = ::AABB();
			break;
		case COLOR:
			*reinterpret_cast<Color *>(this->_data._mem) = Color();
			break;
		case PROJECTION:
			*reinterpret_cast<Projection *>(this->_data._mem) = Projection();
			break;
		default:
			this->clear();
			break;
	}
}

void Variant::clear() {
	switch (type) {
		/*
		// no point, they don't allocate memory
		BOOL,
		INT,
		REAL,
		*/
		case STRING: {
			reinterpret_cast<String *>(_data._mem)->~String();
		} break;
		/*
		RECT2,
		RECT2I
		VECTOR2,
		VECTOR2I,
		VECTOR3,
		VECTOR3i,
		VECTOR4,
		VECTOR4i,

		PLANE,
		QUATERNION,
		*/
		case AABB: {
			memdelete(_data._aabb);
		} break;
		case BASIS: {
			memdelete(_data._basis);
		} break;
		case TRANSFORM: {
			memdelete(_data._transform);
		} break;
		case TRANSFORM2D: {
			memdelete(_data._transform2d);
		} break;
		case PROJECTION: {
			memdelete(_data._projection);
		} break;
		//COLOR

		// misc types
		case OBJECT: {
			if (likely(_get_obj().rc)) {
				if (unlikely(_get_obj().rc->decrement())) {
					memdelete(_get_obj().rc);
				}
			} else {
				_get_obj().ref.unref();
			}
		} break;
		case STRING_NAME: {
			reinterpret_cast<StringName *>(_data._mem)->~StringName();
		} break;
		case DICTIONARY: {
			reinterpret_cast<Dictionary *>(_data._mem)->~Dictionary();
		} break;
		case ARRAY: {
			reinterpret_cast<Array *>(_data._mem)->~Array();
		} break;

		// arrays
		case POOL_BYTE_ARRAY: {
			reinterpret_cast<PoolVector<uint8_t> *>(_data._mem)->~PoolVector<uint8_t>();
		} break;
		case POOL_INT_ARRAY: {
			reinterpret_cast<PoolVector<int> *>(_data._mem)->~PoolVector<int>();
		} break;
		case POOL_REAL_ARRAY: {
			reinterpret_cast<PoolVector<real_t> *>(_data._mem)->~PoolVector<real_t>();
		} break;
		case POOL_STRING_ARRAY: {
			reinterpret_cast<PoolVector<String> *>(_data._mem)->~PoolVector<String>();
		} break;
		case POOL_VECTOR2_ARRAY: {
			reinterpret_cast<PoolVector<Vector2> *>(_data._mem)->~PoolVector<Vector2>();
		} break;
		case POOL_VECTOR2I_ARRAY: {
			reinterpret_cast<PoolVector<Vector2i> *>(_data._mem)->~PoolVector<Vector2i>();
		} break;
		case POOL_VECTOR3_ARRAY: {
			reinterpret_cast<PoolVector<Vector3> *>(_data._mem)->~PoolVector<Vector3>();
		} break;
		case POOL_VECTOR3I_ARRAY: {
			reinterpret_cast<PoolVector<Vector3i> *>(_data._mem)->~PoolVector<Vector3i>();
		} break;
		case POOL_VECTOR4_ARRAY: {
			reinterpret_cast<PoolVector<Vector4> *>(_data._mem)->~PoolVector<Vector4>();
		} break;
		case POOL_VECTOR4I_ARRAY: {
			reinterpret_cast<PoolVector<Vector4i> *>(_data._mem)->~PoolVector<Vector4i>();
		} break;
		case POOL_COLOR_ARRAY: {
			reinterpret_cast<PoolVector<Color> *>(_data._mem)->~PoolVector<Color>();
		} break;
		default: {
		} /* not needed */
	}

	type = NIL;
}

Variant::operator signed int() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}
}
Variant::operator unsigned int() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}
}

Variant::operator int64_t() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int64();
		default: {
			return 0;
		}
	}
}

/*
Variant::operator long unsigned int() const {

	switch( type ) {

		case NIL: return 0;
		case BOOL: return _data._bool ? 1 : 0;
		case INT: return _data._int;
		case REAL: return _data._real;
		case STRING: return operator String().to_int();
		default: {

			return 0;
		}
	}

	return 0;
};
*/

Variant::operator uint64_t() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}
}

#ifdef NEED_LONG_INT
Variant::operator signed long() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}

	return 0;
};

Variant::operator unsigned long() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}

	return 0;
};
#endif

Variant::operator signed short() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}
}
Variant::operator unsigned short() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}
}
Variant::operator signed char() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}
}
Variant::operator unsigned char() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1 : 0;
		case INT:
			return _data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_int();
		default: {
			return 0;
		}
	}
}

Variant::operator CharType() const {
	return operator unsigned int();
}

Variant::operator float() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1.0 : 0.0;
		case INT:
			return (float)_data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_double();
		default: {
			return 0;
		}
	}
}
Variant::operator double() const {
	switch (type) {
		case NIL:
			return 0;
		case BOOL:
			return _data._bool ? 1.0 : 0.0;
		case INT:
			return (double)_data._int;
		case REAL:
			return _data._real;
		case STRING:
			return operator String().to_double();
		default: {
			return 0;
		}
	}
}

Variant::operator StringName() const {
	if (type == STRING_NAME) {
		return *reinterpret_cast<const StringName *>(_data._mem);
	}

	return StringName(operator String());
}

struct _VariantStrPair {
	String key;
	String value;

	bool operator<(const _VariantStrPair &p) const {
		return key < p.key;
	}
};

Variant::operator String() const {
	List<const void *> stack;

	return stringify(stack);
}

template <class T>
String stringify_vector(const T &vec, List<const void *> &stack) {
	String str("[");
	for (int i = 0; i < vec.size(); i++) {
		if (i > 0) {
			str += ", ";
		}
		str = str + Variant(vec[i]).stringify(stack);
	}
	str += "]";
	return str;
}

String Variant::stringify(List<const void *> &stack) const {
	switch (type) {
		case NIL:
			return "Null";
		case BOOL:
			return _data._bool ? "True" : "False";
		case INT:
			return itos(_data._int);
		case REAL:
			return rtos(_data._real);
		case STRING:
			return *reinterpret_cast<const String *>(_data._mem);
		case RECT2:
			return operator Rect2();
		case RECT2I:
			return operator Rect2i();
		case VECTOR2:
			return operator Vector2();
		case VECTOR2I:
			return operator Vector2i();
		case VECTOR3:
			return operator Vector3();
		case VECTOR3I:
			return operator Vector3i();
		case VECTOR4:
			return operator Vector4();
		case VECTOR4I:
			return operator Vector4i();
		case PLANE:
			return operator Plane();
		case QUATERNION:
			return operator Quaternion();
		case AABB:
			return operator ::AABB();
		case BASIS: {
			return operator Basis();
		} break;
		case TRANSFORM:
			return operator Transform();
		case TRANSFORM2D: {
			return operator Transform2D();
		} break;
		case PROJECTION:
			return operator Projection();
		case COLOR:
			return operator Color();
		case OBJECT: {
			Object *obj = _OBJ_PTR(*this);
			if (likely(obj)) {
				return obj->to_string();
			} else {
				if (_get_obj().rc) {
					return "[Deleted Object]";
				}
				return "[Object:null]";
			}
		} break;
		case STRING_NAME:
			return operator StringName();
		case DICTIONARY: {
			const Dictionary &d = *reinterpret_cast<const Dictionary *>(_data._mem);
			if (stack.find(d.id())) {
				return "{...}";
			}

			stack.push_back(d.id());

			//const String *K=NULL;
			String str("{");
			List<Variant> keys;
			d.get_key_list(&keys);

			Vector<_VariantStrPair> pairs;

			for (List<Variant>::Element *E = keys.front(); E; E = E->next()) {
				_VariantStrPair sp;
				sp.key = E->get().stringify(stack);
				sp.value = d[E->get()].stringify(stack);

				pairs.push_back(sp);
			}

			pairs.sort();

			for (int i = 0; i < pairs.size(); i++) {
				if (i > 0) {
					str += ", ";
				}
				str += pairs[i].key + ":" + pairs[i].value;
			}
			str += "}";

			stack.erase(d.id());
			return str;
		} break;
		case ARRAY: {
			Array arr = operator Array();
			if (stack.find(arr.id())) {
				return "[...]";
			}
			stack.push_back(arr.id());
			String str = stringify_vector(arr, stack);
			stack.erase(arr.id());
			return str;

		} break;

		case POOL_BYTE_ARRAY: {
			return stringify_vector(operator PoolVector<uint8_t>(), stack);
		} break;
		case POOL_INT_ARRAY: {
			return stringify_vector(operator PoolVector<int>(), stack);
		} break;
		case POOL_REAL_ARRAY: {
			return stringify_vector(operator PoolVector<real_t>(), stack);
		} break;
		case POOL_STRING_ARRAY: {
			return stringify_vector(operator PoolVector<String>(), stack);
		} break;
		case POOL_VECTOR2_ARRAY: {
			return stringify_vector(operator PoolVector<Vector2>(), stack);
		} break;
		case POOL_VECTOR2I_ARRAY: {
			return stringify_vector(operator PoolVector<Vector2i>(), stack);
		} break;
		case POOL_VECTOR3_ARRAY: {
			return stringify_vector(operator PoolVector<Vector3>(), stack);
		} break;
		case POOL_VECTOR3I_ARRAY: {
			return stringify_vector(operator PoolVector<Vector3i>(), stack);
		} break;
		case POOL_VECTOR4_ARRAY: {
			return stringify_vector(operator PoolVector<Vector4>(), stack);
		} break;
		case POOL_VECTOR4I_ARRAY: {
			return stringify_vector(operator PoolVector<Vector4i>(), stack);
		} break;
		case POOL_COLOR_ARRAY: {
			return stringify_vector(operator PoolVector<Color>(), stack);
		} break;

		default: {
			return "[" + get_type_name(type) + "]";
		}
	}

	return "";
}

Variant::operator Rect2() const {
	if (type == RECT2) {
		return *reinterpret_cast<const Rect2 *>(_data._mem);
	} else if (type == RECT2I) {
		return Rect2(*reinterpret_cast<const Rect2i *>(_data._mem));
	} else {
		return Rect2();
	}
}
Variant::operator Rect2i() const {
	if (type == RECT2I) {
		return *reinterpret_cast<const Rect2i *>(_data._mem);
	} else if (type == RECT2) {
		return Rect2i(*reinterpret_cast<const Rect2 *>(_data._mem));
	} else {
		return Rect2i();
	}
}

Variant::operator Vector2() const {
	if (type == VECTOR2) {
		return *reinterpret_cast<const Vector2 *>(_data._mem);
	} else if (type == VECTOR2I) {
		return Vector2(reinterpret_cast<const Vector2i *>(_data._mem)->x, reinterpret_cast<const Vector2i *>(_data._mem)->y);
	} else if (type == VECTOR3) {
		return Vector2(reinterpret_cast<const Vector3 *>(_data._mem)->x, reinterpret_cast<const Vector3 *>(_data._mem)->y);
	} else if (type == VECTOR3I) {
		return Vector2(reinterpret_cast<const Vector3i *>(_data._mem)->x, reinterpret_cast<const Vector3i *>(_data._mem)->y);
	} else if (type == VECTOR4) {
		return Vector2(reinterpret_cast<const Vector4 *>(_data._mem)->x, reinterpret_cast<const Vector4 *>(_data._mem)->y);
	} else if (type == VECTOR4I) {
		return Vector2(reinterpret_cast<const Vector4i *>(_data._mem)->x, reinterpret_cast<const Vector4i *>(_data._mem)->y);
	} else {
		return Vector2();
	}
}
Variant::operator Vector2i() const {
	if (type == VECTOR2I) {
		return *reinterpret_cast<const Vector2i *>(_data._mem);
	} else if (type == VECTOR2) {
		return Vector2i(reinterpret_cast<const Vector2 *>(_data._mem)->x, reinterpret_cast<const Vector2 *>(_data._mem)->y);
	} else if (type == VECTOR3) {
		return Vector2i(reinterpret_cast<const Vector3 *>(_data._mem)->x, reinterpret_cast<const Vector3 *>(_data._mem)->y);
	} else if (type == VECTOR3I) {
		return Vector2i(reinterpret_cast<const Vector3i *>(_data._mem)->x, reinterpret_cast<const Vector3i *>(_data._mem)->y);
	} else if (type == VECTOR4) {
		return Vector2i(reinterpret_cast<const Vector4 *>(_data._mem)->x, reinterpret_cast<const Vector4 *>(_data._mem)->y);
	} else if (type == VECTOR4I) {
		return Vector2i(reinterpret_cast<const Vector4i *>(_data._mem)->x, reinterpret_cast<const Vector4i *>(_data._mem)->y);
	} else {
		return Vector2i();
	}
}

Variant::operator Vector3() const {
	if (type == VECTOR3) {
		return *reinterpret_cast<const Vector3 *>(_data._mem);
	} else if (type == VECTOR3I) {
		return Vector3(*reinterpret_cast<const Vector3i *>(_data._mem));
	} else if (type == VECTOR2) {
		return Vector3(reinterpret_cast<const Vector2 *>(_data._mem)->x, reinterpret_cast<const Vector2 *>(_data._mem)->y, 0.0);
	} else if (type == VECTOR2I) {
		return Vector3(reinterpret_cast<const Vector2i *>(_data._mem)->x, reinterpret_cast<const Vector2i *>(_data._mem)->y, 0.0);
	} else if (type == VECTOR4) {
		return Vector3(reinterpret_cast<const Vector4 *>(_data._mem)->x, reinterpret_cast<const Vector4 *>(_data._mem)->y, reinterpret_cast<const Vector4 *>(_data._mem)->z);
	} else if (type == VECTOR4I) {
		return Vector3(reinterpret_cast<const Vector4i *>(_data._mem)->x, reinterpret_cast<const Vector4i *>(_data._mem)->y, reinterpret_cast<const Vector4i *>(_data._mem)->z);
	} else {
		return Vector3();
	}
}
Variant::operator Vector3i() const {
	if (type == VECTOR3I) {
		return *reinterpret_cast<const Vector3i *>(_data._mem);
	} else if (type == VECTOR3) {
		return Vector3i(reinterpret_cast<const Vector3 *>(_data._mem)->x, reinterpret_cast<const Vector3 *>(_data._mem)->y, reinterpret_cast<const Vector3 *>(_data._mem)->z);
	} else if (type == VECTOR2) {
		return Vector3i(reinterpret_cast<const Vector2 *>(_data._mem)->x, reinterpret_cast<const Vector2 *>(_data._mem)->y, 0.0);
	} else if (type == VECTOR2I) {
		return Vector3i(reinterpret_cast<const Vector2i *>(_data._mem)->x, reinterpret_cast<const Vector2i *>(_data._mem)->y, 0.0);
	} else if (type == VECTOR4) {
		return Vector3i(reinterpret_cast<const Vector4 *>(_data._mem)->x, reinterpret_cast<const Vector4 *>(_data._mem)->y, reinterpret_cast<const Vector4 *>(_data._mem)->z);
	} else if (type == VECTOR4I) {
		return Vector3i(reinterpret_cast<const Vector4i *>(_data._mem)->x, reinterpret_cast<const Vector4i *>(_data._mem)->y, reinterpret_cast<const Vector4i *>(_data._mem)->z);
	} else {
		return Vector3i();
	}
}

Variant::operator Vector4() const {
	if (type == VECTOR4) {
		return *reinterpret_cast<const Vector4 *>(_data._mem);
	} else if (type == VECTOR4I) {
		return *reinterpret_cast<const Vector4i *>(_data._mem);
	} else if (type == VECTOR2) {
		return Vector4(reinterpret_cast<const Vector2 *>(_data._mem)->x, reinterpret_cast<const Vector2 *>(_data._mem)->y, 0.0, 0.0);
	} else if (type == VECTOR2I) {
		return Vector4(reinterpret_cast<const Vector2i *>(_data._mem)->x, reinterpret_cast<const Vector2i *>(_data._mem)->y, 0.0, 0.0);
	} else if (type == VECTOR3) {
		return Vector4(reinterpret_cast<const Vector3 *>(_data._mem)->x, reinterpret_cast<const Vector3 *>(_data._mem)->y, reinterpret_cast<const Vector3 *>(_data._mem)->z, 0.0);
	} else if (type == VECTOR3I) {
		return Vector4(reinterpret_cast<const Vector3i *>(_data._mem)->x, reinterpret_cast<const Vector3i *>(_data._mem)->y, reinterpret_cast<const Vector3i *>(_data._mem)->z, 0.0);
	} else {
		return Vector4();
	}
}

Variant::operator Vector4i() const {
	if (type == VECTOR4I) {
		return *reinterpret_cast<const Vector4i *>(_data._mem);
	} else if (type == VECTOR4) {
		const Vector4 &v4 = *reinterpret_cast<const Vector4 *>(_data._mem);
		return Vector4i(v4.x, v4.y, v4.z, v4.w);
	} else if (type == VECTOR2) {
		return Vector4i(reinterpret_cast<const Vector2 *>(_data._mem)->x, reinterpret_cast<const Vector2 *>(_data._mem)->y, 0.0, 0.0);
	} else if (type == VECTOR2I) {
		return Vector4i(reinterpret_cast<const Vector2i *>(_data._mem)->x, reinterpret_cast<const Vector2i *>(_data._mem)->y, 0.0, 0.0);
	} else if (type == VECTOR3) {
		return Vector4i(reinterpret_cast<const Vector3 *>(_data._mem)->x, reinterpret_cast<const Vector3 *>(_data._mem)->y, reinterpret_cast<const Vector3 *>(_data._mem)->z, 0.0);
	} else if (type == VECTOR3I) {
		return Vector4i(reinterpret_cast<const Vector3i *>(_data._mem)->x, reinterpret_cast<const Vector3i *>(_data._mem)->y, reinterpret_cast<const Vector3i *>(_data._mem)->z, 0.0);
	} else {
		return Vector4i();
	}
}

Variant::operator Plane() const {
	if (type == PLANE) {
		return *reinterpret_cast<const Plane *>(_data._mem);
	} else {
		return Plane();
	}
}
Variant::operator ::AABB() const {
	if (type == AABB) {
		return *_data._aabb;
	} else {
		return ::AABB();
	}
}

Variant::operator Basis() const {
	if (type == BASIS) {
		return *_data._basis;
	} else if (type == QUATERNION) {
		return *reinterpret_cast<const Quaternion *>(_data._mem);
	} else if (type == VECTOR3) {
		return Basis(*reinterpret_cast<const Vector3 *>(_data._mem));
	} else if (type == TRANSFORM) { // unexposed in Variant::can_convert?
		return _data._transform->basis;
	} else {
		return Basis();
	}
}

Variant::operator Quaternion() const {
	if (type == QUATERNION) {
		return *reinterpret_cast<const Quaternion *>(_data._mem);
	} else if (type == BASIS) {
		return *_data._basis;
	} else if (type == TRANSFORM) {
		return _data._transform->basis;
	} else {
		return Quaternion();
	}
}

Variant::operator Transform2D() const {
	if (type == TRANSFORM2D) {
		return *_data._transform2d;
	} else if (type == TRANSFORM) {
		const Transform &t = *_data._transform;
		Transform2D m;
		m.columns[0][0] = t.basis.rows[0][0];
		m.columns[0][1] = t.basis.rows[1][0];
		m.columns[1][0] = t.basis.rows[0][1];
		m.columns[1][1] = t.basis.rows[1][1];
		m.columns[2][0] = t.origin[0];
		m.columns[2][1] = t.origin[1];
		return m;
	} else {
		return Transform2D();
	}
}

Variant::operator Transform() const {
	if (type == TRANSFORM) {
		return *_data._transform;
	} else if (type == BASIS) {
		return Transform(*_data._basis, Vector3());
	} else if (type == QUATERNION) {
		return Transform(Basis(*reinterpret_cast<const Quaternion *>(_data._mem)), Vector3());
	} else if (type == TRANSFORM2D) {
		const Transform2D &t = *_data._transform2d;
		Transform m;
		m.basis.rows[0][0] = t.columns[0][0];
		m.basis.rows[1][0] = t.columns[0][1];
		m.basis.rows[0][1] = t.columns[1][0];
		m.basis.rows[1][1] = t.columns[1][1];
		m.origin[0] = t.columns[2][0];
		m.origin[1] = t.columns[2][1];
		return m;
	} else if (type == PROJECTION) {
		return *_data._projection;
	} else {
		return Transform();
	}
}

Variant::operator Projection() const {
	if (type == TRANSFORM) {
		return *_data._transform;
	} else if (type == BASIS) {
		return Transform(*_data._basis, Vector3());
	} else if (type == QUATERNION) {
		return Transform(Basis(*reinterpret_cast<const Quaternion *>(_data._mem)), Vector3());
	} else if (type == TRANSFORM2D) {
		const Transform2D &t = *_data._transform2d;
		Transform m;
		m.basis.rows[0][0] = t.columns[0][0];
		m.basis.rows[1][0] = t.columns[0][1];
		m.basis.rows[0][1] = t.columns[1][0];
		m.basis.rows[1][1] = t.columns[1][1];
		m.origin[0] = t.columns[2][0];
		m.origin[1] = t.columns[2][1];
		return m;
	} else if (type == PROJECTION) {
		return *_data._projection;
	} else {
		return Projection();
	}
}

Variant::operator Color() const {
	if (type == COLOR) {
		return *reinterpret_cast<const Color *>(_data._mem);
	} else if (type == STRING) {
		return Color::html(operator String());
	} else if (type == INT) {
		return Color::hex(operator int());
	} else {
		return Color();
	}
}

Variant::operator RefPtr() const {
	if (type == OBJECT) {
		return _get_obj().ref;
	} else {
		return RefPtr();
	}
}

Variant::operator Object *() const {
	if (type == OBJECT) {
		return _OBJ_PTR(*this);
	} else {
		return nullptr;
	}
}

template <class DA, class SA>
inline DA _convert_array(const SA &p_array) {
	DA da;
	da.resize(p_array.size());

	for (int i = 0; i < p_array.size(); i++) {
		da.set(i, Variant(p_array.get(i)));
	}

	return da;
}

template <class DA>
inline DA _convert_array_from_variant(const Variant &p_variant) {
	switch (p_variant.get_type()) {
		case Variant::ARRAY: {
			return _convert_array<DA, Array>(p_variant.operator Array());
		}
		case Variant::POOL_BYTE_ARRAY: {
			return _convert_array<DA, PoolVector<uint8_t>>(p_variant.operator PoolVector<uint8_t>());
		}
		case Variant::POOL_INT_ARRAY: {
			return _convert_array<DA, PoolVector<int>>(p_variant.operator PoolVector<int>());
		}
		case Variant::POOL_REAL_ARRAY: {
			return _convert_array<DA, PoolVector<real_t>>(p_variant.operator PoolVector<real_t>());
		}
		case Variant::POOL_STRING_ARRAY: {
			return _convert_array<DA, PoolVector<String>>(p_variant.operator PoolVector<String>());
		}
		case Variant::POOL_VECTOR2_ARRAY: {
			return _convert_array<DA, PoolVector<Vector2>>(p_variant.operator PoolVector<Vector2>());
		}
		case Variant::POOL_VECTOR2I_ARRAY: {
			return _convert_array<DA, PoolVector<Vector2i>>(p_variant.operator PoolVector<Vector2i>());
		}
		case Variant::POOL_VECTOR3_ARRAY: {
			return _convert_array<DA, PoolVector<Vector3>>(p_variant.operator PoolVector<Vector3>());
		}
		case Variant::POOL_VECTOR3I_ARRAY: {
			return _convert_array<DA, PoolVector<Vector3i>>(p_variant.operator PoolVector<Vector3i>());
		}
		case Variant::POOL_VECTOR4_ARRAY: {
			return _convert_array<DA, PoolVector<Vector4>>(p_variant.operator PoolVector<Vector4>());
		}
		case Variant::POOL_VECTOR4I_ARRAY: {
			return _convert_array<DA, PoolVector<Vector4i>>(p_variant.operator PoolVector<Vector4i>());
		}
		case Variant::POOL_COLOR_ARRAY: {
			return _convert_array<DA, PoolVector<Color>>(p_variant.operator PoolVector<Color>());
		}
		default: {
			return DA();
		}
	}
}

Variant::operator Dictionary() const {
	if (type == DICTIONARY) {
		return *reinterpret_cast<const Dictionary *>(_data._mem);
	} else {
		return Dictionary();
	}
}

Variant::operator Array() const {
	if (type == ARRAY) {
		return *reinterpret_cast<const Array *>(_data._mem);
	} else {
		return _convert_array_from_variant<Array>(*this);
	}
}

Variant::operator PoolVector<uint8_t>() const {
	if (type == POOL_BYTE_ARRAY) {
		return *reinterpret_cast<const PoolVector<uint8_t> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<uint8_t>>(*this);
	}
}
Variant::operator PoolVector<int>() const {
	if (type == POOL_INT_ARRAY) {
		return *reinterpret_cast<const PoolVector<int> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<int>>(*this);
	}
}
Variant::operator PoolVector<real_t>() const {
	if (type == POOL_REAL_ARRAY) {
		return *reinterpret_cast<const PoolVector<real_t> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<real_t>>(*this);
	}
}

Variant::operator PoolVector<String>() const {
	if (type == POOL_STRING_ARRAY) {
		return *reinterpret_cast<const PoolVector<String> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<String>>(*this);
	}
}
Variant::operator PoolVector<Vector2>() const {
	if (type == POOL_VECTOR2_ARRAY) {
		return *reinterpret_cast<const PoolVector<Vector2> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<Vector2>>(*this);
	}
}
Variant::operator PoolVector<Vector2i>() const {
	if (type == POOL_VECTOR2I_ARRAY) {
		return *reinterpret_cast<const PoolVector<Vector2i> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<Vector2i>>(*this);
	}
}
Variant::operator PoolVector<Vector3>() const {
	if (type == POOL_VECTOR3_ARRAY) {
		return *reinterpret_cast<const PoolVector<Vector3> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<Vector3>>(*this);
	}
}
Variant::operator PoolVector<Vector3i>() const {
	if (type == POOL_VECTOR3I_ARRAY) {
		return *reinterpret_cast<const PoolVector<Vector3i> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<Vector3i>>(*this);
	}
}
Variant::operator PoolVector<Vector4>() const {
	if (type == POOL_VECTOR4_ARRAY) {
		return *reinterpret_cast<const PoolVector<Vector4> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<Vector4>>(*this);
	}
}
Variant::operator PoolVector<Vector4i>() const {
	if (type == POOL_VECTOR4I_ARRAY) {
		return *reinterpret_cast<const PoolVector<Vector4i> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<Vector4i>>(*this);
	}
}
Variant::operator PoolVector<Color>() const {
	if (type == POOL_COLOR_ARRAY) {
		return *reinterpret_cast<const PoolVector<Color> *>(_data._mem);
	} else {
		return _convert_array_from_variant<PoolVector<Color>>(*this);
	}
}

/* helpers */

Variant::operator PoolVector<Plane>() const {
	Array va = operator Array();
	PoolVector<Plane> planes;
	int va_size = va.size();
	if (va_size == 0) {
		return planes;
	}

	planes.resize(va_size);
	PoolVector<Plane>::Write w = planes.write();

	for (int i = 0; i < va_size; i++) {
		w[i] = va[i];
	}

	return planes;
}

Variant::operator PoolVector<Face3>() const {
	PoolVector<Vector3> va = operator PoolVector<Vector3>();
	PoolVector<Face3> faces;
	int va_size = va.size();
	if (va_size == 0) {
		return faces;
	}

	faces.resize(va_size / 3);
	PoolVector<Face3>::Write w = faces.write();
	PoolVector<Vector3>::Read r = va.read();

	for (int i = 0; i < va_size; i++) {
		w[i / 3].vertex[i % 3] = r[i];
	}

	return faces;
}

Variant::operator Vector<Plane>() const {
	Array va = operator Array();
	Vector<Plane> planes;
	int va_size = va.size();
	if (va_size == 0) {
		return planes;
	}

	planes.resize(va_size);

	for (int i = 0; i < va_size; i++) {
		planes.write[i] = va[i];
	}

	return planes;
}

Variant::operator Vector<Variant>() const {
	Array from = operator Array();
	Vector<Variant> to;
	int len = from.size();
	to.resize(len);
	for (int i = 0; i < len; i++) {
		to.write[i] = from[i];
	}
	return to;
}

Variant::operator Vector<uint8_t>() const {
	PoolVector<uint8_t> from = operator PoolVector<uint8_t>();
	Vector<uint8_t> to;
	int len = from.size();
	to.resize(len);
	for (int i = 0; i < len; i++) {
		to.write[i] = from[i];
	}
	return to;
}
Variant::operator Vector<int>() const {
	PoolVector<int> from = operator PoolVector<int>();
	Vector<int> to;
	int len = from.size();
	to.resize(len);
	for (int i = 0; i < len; i++) {
		to.write[i] = from[i];
	}
	return to;
}
Variant::operator Vector<real_t>() const {
	PoolVector<real_t> from = operator PoolVector<real_t>();
	Vector<real_t> to;
	int len = from.size();
	to.resize(len);
	for (int i = 0; i < len; i++) {
		to.write[i] = from[i];
	}
	return to;
}

Variant::operator Vector<String>() const {
	PoolVector<String> from = operator PoolVector<String>();
	Vector<String> to;
	int len = from.size();
	to.resize(len);
	for (int i = 0; i < len; i++) {
		to.write[i] = from[i];
	}
	return to;
}
Variant::operator Vector<StringName>() const {
	PoolVector<String> from = operator PoolVector<String>();
	Vector<StringName> to;
	int len = from.size();
	to.resize(len);
	for (int i = 0; i < len; i++) {
		to.write[i] = from[i];
	}
	return to;
}

Variant::operator Vector<Vector2>() const {
	PoolVector<Vector2> from = operator PoolVector<Vector2>();
	Vector<Vector2> to;
	int len = from.size();
	if (len == 0) {
		return Vector<Vector2>();
	}
	to.resize(len);
	PoolVector<Vector2>::Read r = from.read();
	Vector2 *w = to.ptrw();
	for (int i = 0; i < len; i++) {
		w[i] = r[i];
	}
	return to;
}
Variant::operator Vector<Vector2i>() const {
	PoolVector<Vector2i> from = operator PoolVector<Vector2i>();
	Vector<Vector2i> to;
	int len = from.size();
	if (len == 0) {
		return Vector<Vector2i>();
	}
	to.resize(len);
	PoolVector<Vector2i>::Read r = from.read();
	Vector2i *w = to.ptrw();
	for (int i = 0; i < len; i++) {
		w[i] = r[i];
	}
	return to;
}

Variant::operator Vector<Vector3>() const {
	PoolVector<Vector3> from = operator PoolVector<Vector3>();
	Vector<Vector3> to;
	int len = from.size();
	if (len == 0) {
		return Vector<Vector3>();
	}
	to.resize(len);
	PoolVector<Vector3>::Read r = from.read();
	Vector3 *w = to.ptrw();
	for (int i = 0; i < len; i++) {
		w[i] = r[i];
	}
	return to;
}
Variant::operator Vector<Vector3i>() const {
	PoolVector<Vector3i> from = operator PoolVector<Vector3i>();
	Vector<Vector3i> to;
	int len = from.size();
	if (len == 0) {
		return Vector<Vector3i>();
	}
	to.resize(len);
	PoolVector<Vector3i>::Read r = from.read();
	Vector3i *w = to.ptrw();
	for (int i = 0; i < len; i++) {
		w[i] = r[i];
	}
	return to;
}

Variant::operator Vector<Vector4>() const {
	PoolVector<Vector4> from = operator PoolVector<Vector4>();
	Vector<Vector4> to;
	int len = from.size();
	if (len == 0) {
		return Vector<Vector4>();
	}
	to.resize(len);
	PoolVector<Vector4>::Read r = from.read();
	Vector4 *w = to.ptrw();
	for (int i = 0; i < len; i++) {
		w[i] = r[i];
	}
	return to;
}
Variant::operator Vector<Vector4i>() const {
	PoolVector<Vector4i> from = operator PoolVector<Vector4i>();
	Vector<Vector4i> to;
	int len = from.size();
	if (len == 0) {
		return Vector<Vector4i>();
	}
	to.resize(len);
	PoolVector<Vector4i>::Read r = from.read();
	Vector4i *w = to.ptrw();
	for (int i = 0; i < len; i++) {
		w[i] = r[i];
	}
	return to;
}

Variant::operator Vector<Color>() const {
	PoolVector<Color> from = operator PoolVector<Color>();
	Vector<Color> to;
	int len = from.size();
	if (len == 0) {
		return Vector<Color>();
	}
	to.resize(len);
	PoolVector<Color>::Read r = from.read();
	Color *w = to.ptrw();
	for (int i = 0; i < len; i++) {
		w[i] = r[i];
	}
	return to;
}

Variant::operator Margin() const {
	return (Margin) operator int();
}
Variant::operator Side() const {
	return (Side) operator int();
}
Variant::operator Orientation() const {
	return (Orientation) operator int();
}

Variant::Variant(bool p_bool) {
	type = BOOL;
	_data._bool = p_bool;
}

/*
Variant::Variant(long unsigned int p_long) {

	type=INT;
	_data._int=p_long;
};
*/

Variant::Variant(signed int p_int) {
	type = INT;
	_data._int = p_int;
}
Variant::Variant(unsigned int p_int) {
	type = INT;
	_data._int = p_int;
}

#ifdef NEED_LONG_INT

Variant::Variant(signed long p_int) {
	type = INT;
	_data._int = p_int;
}
Variant::Variant(unsigned long p_int) {
	type = INT;
	_data._int = p_int;
}
#endif

Variant::Variant(int64_t p_int) {
	type = INT;
	_data._int = p_int;
}

Variant::Variant(uint64_t p_int) {
	type = INT;
	_data._int = p_int;
}

Variant::Variant(signed short p_short) {
	type = INT;
	_data._int = p_short;
}
Variant::Variant(unsigned short p_short) {
	type = INT;
	_data._int = p_short;
}
Variant::Variant(signed char p_char) {
	type = INT;
	_data._int = p_char;
}
Variant::Variant(unsigned char p_char) {
	type = INT;
	_data._int = p_char;
}
Variant::Variant(float p_float) {
	type = REAL;
	_data._real = p_float;
}
Variant::Variant(double p_double) {
	type = REAL;
	_data._real = p_double;
}

Variant::Variant(const StringName &p_string) {
	type = STRING_NAME;
	memnew_placement(_data._mem, StringName(p_string));
}
Variant::Variant(const String &p_string) {
	type = STRING;
	memnew_placement(_data._mem, String(p_string));
}

Variant::Variant(const char *const p_cstring) {
	type = STRING;
	memnew_placement(_data._mem, String((const char *)p_cstring));
}

Variant::Variant(const CharType *p_wstring) {
	type = STRING;
	memnew_placement(_data._mem, String(p_wstring));
}

Variant::Variant(const Rect2 &p_rect2) {
	type = RECT2;
	memnew_placement(_data._mem, Rect2(p_rect2));
}
Variant::Variant(const Rect2i &p_rect2) {
	type = RECT2I;
	memnew_placement(_data._mem, Rect2i(p_rect2));
}

Variant::Variant(const Vector2 &p_vector2) {
	type = VECTOR2;
	memnew_placement(_data._mem, Vector2(p_vector2));
}
Variant::Variant(const Vector2i &p_vector2) {
	type = VECTOR2I;
	memnew_placement(_data._mem, Vector2i(p_vector2));
}

Variant::Variant(const Vector3 &p_vector3) {
	type = VECTOR3;
	memnew_placement(_data._mem, Vector3(p_vector3));
}
Variant::Variant(const Vector3i &p_vector3) {
	type = VECTOR3I;
	memnew_placement(_data._mem, Vector3i(p_vector3));
}

Variant::Variant(const Vector4 &p_vector4) {
	type = VECTOR4;
	memnew_placement(_data._mem, Vector4(p_vector4));
}
Variant::Variant(const Vector4i &p_vector4) {
	type = VECTOR4I;
	memnew_placement(_data._mem, Vector4i(p_vector4));
}

Variant::Variant(const Plane &p_plane) {
	type = PLANE;
	memnew_placement(_data._mem, Plane(p_plane));
}
Variant::Variant(const ::AABB &p_aabb) {
	type = AABB;
	_data._aabb = memnew(::AABB(p_aabb));
}

Variant::Variant(const Basis &p_matrix) {
	type = BASIS;
	_data._basis = memnew(Basis(p_matrix));
}

Variant::Variant(const Quaternion &p_quat) {
	type = QUATERNION;
	memnew_placement(_data._mem, Quaternion(p_quat));
}
Variant::Variant(const Transform &p_transform) {
	type = TRANSFORM;
	_data._transform = memnew(Transform(p_transform));
}

Variant::Variant(const Transform2D &p_transform) {
	type = TRANSFORM2D;
	_data._transform2d = memnew(Transform2D(p_transform));
}

Variant::Variant(const Projection &p_projection) {
	type = PROJECTION;
	_data._projection = memnew(Projection(p_projection));
}

Variant::Variant(const Color &p_color) {
	type = COLOR;
	memnew_placement(_data._mem, Color(p_color));
}

Variant::Variant(const RefPtr &p_resource) {
	type = OBJECT;
	memnew_placement(_data._mem, ObjData);
	_get_obj().rc = nullptr;
	_get_obj().ref = p_resource;
}

Variant::Variant(const Object *p_object) {
	type = OBJECT;
	Object *obj = const_cast<Object *>(p_object);

	memnew_placement(_data._mem, ObjData);
	Reference *ref = Object::cast_to<Reference>(obj);
	if (unlikely(ref)) {
		*reinterpret_cast<Ref<Reference> *>(_get_obj().ref.get_data()) = Ref<Reference>(ref);
		_get_obj().rc = nullptr;
	} else {
		_get_obj().rc = likely(obj) ? obj->_use_rc() : nullptr;
	}
}

Variant::Variant(const Dictionary &p_dictionary) {
	type = DICTIONARY;
	memnew_placement(_data._mem, Dictionary(p_dictionary));
}

Variant::Variant(const Array &p_array) {
	type = ARRAY;
	memnew_placement(_data._mem, Array(p_array));
}

Variant::Variant(const PoolVector<Plane> &p_array) {
	type = ARRAY;

	Array *plane_array = memnew_placement(_data._mem, Array);

	plane_array->resize(p_array.size());

	for (int i = 0; i < p_array.size(); i++) {
		plane_array->operator[](i) = Variant(p_array[i]);
	}
}

Variant::Variant(const Vector<Plane> &p_array) {
	type = ARRAY;

	Array *plane_array = memnew_placement(_data._mem, Array);

	plane_array->resize(p_array.size());

	for (int i = 0; i < p_array.size(); i++) {
		plane_array->operator[](i) = Variant(p_array[i]);
	}
}

Variant::Variant(const PoolVector<uint8_t> &p_raw_array) {
	type = POOL_BYTE_ARRAY;
	memnew_placement(_data._mem, PoolVector<uint8_t>(p_raw_array));
}
Variant::Variant(const PoolVector<int> &p_int_array) {
	type = POOL_INT_ARRAY;
	memnew_placement(_data._mem, PoolVector<int>(p_int_array));
}
Variant::Variant(const PoolVector<real_t> &p_real_array) {
	type = POOL_REAL_ARRAY;
	memnew_placement(_data._mem, PoolVector<real_t>(p_real_array));
}
Variant::Variant(const PoolVector<String> &p_string_array) {
	type = POOL_STRING_ARRAY;
	memnew_placement(_data._mem, PoolVector<String>(p_string_array));
}
Variant::Variant(const PoolVector<Vector2> &p_vector2_array) {
	type = POOL_VECTOR2_ARRAY;
	memnew_placement(_data._mem, PoolVector<Vector2>(p_vector2_array));
}
Variant::Variant(const PoolVector<Vector2i> &p_vector2_array) {
	type = POOL_VECTOR2I_ARRAY;
	memnew_placement(_data._mem, PoolVector<Vector2i>(p_vector2_array));
}
Variant::Variant(const PoolVector<Vector3> &p_vector3_array) {
	type = POOL_VECTOR3_ARRAY;
	memnew_placement(_data._mem, PoolVector<Vector3>(p_vector3_array));
}
Variant::Variant(const PoolVector<Vector3i> &p_vector3_array) {
	type = POOL_VECTOR3I_ARRAY;
	memnew_placement(_data._mem, PoolVector<Vector3i>(p_vector3_array));
}

Variant::Variant(const PoolVector<Vector4> &p_vector4_array) {
	type = POOL_VECTOR4_ARRAY;
	memnew_placement(_data._mem, PoolVector<Vector4>(p_vector4_array));
}
Variant::Variant(const PoolVector<Vector4i> &p_vector4_array) {
	type = POOL_VECTOR4I_ARRAY;
	memnew_placement(_data._mem, PoolVector<Vector4i>(p_vector4_array));
}

Variant::Variant(const PoolVector<Color> &p_color_array) {
	type = POOL_COLOR_ARRAY;
	memnew_placement(_data._mem, PoolVector<Color>(p_color_array));
}

Variant::Variant(const PoolVector<Face3> &p_face_array) {
	PoolVector<Vector3> vertices;
	int face_count = p_face_array.size();
	vertices.resize(face_count * 3);

	if (face_count) {
		PoolVector<Face3>::Read r = p_face_array.read();
		PoolVector<Vector3>::Write w = vertices.write();

		for (int i = 0; i < face_count; i++) {
			for (int j = 0; j < 3; j++) {
				w[i * 3 + j] = r[i].vertex[j];
			}
		}
	}

	type = NIL;

	*this = vertices;
}

/* helpers */

Variant::Variant(const Vector<Variant> &p_array) {
	type = NIL;
	Array v;
	int len = p_array.size();
	v.resize(len);
	for (int i = 0; i < len; i++) {
		v.set(i, p_array[i]);
	}
	*this = v;
}

Variant::Variant(const Vector<uint8_t> &p_array) {
	type = NIL;
	PoolVector<uint8_t> v;
	int len = p_array.size();
	v.resize(len);
	for (int i = 0; i < len; i++) {
		v.set(i, p_array[i]);
	}
	*this = v;
}

Variant::Variant(const Vector<int> &p_array) {
	type = NIL;
	PoolVector<int> v;
	int len = p_array.size();
	v.resize(len);
	for (int i = 0; i < len; i++) {
		v.set(i, p_array[i]);
	}
	*this = v;
}

Variant::Variant(const Vector<real_t> &p_array) {
	type = NIL;
	PoolVector<real_t> v;
	int len = p_array.size();
	v.resize(len);
	for (int i = 0; i < len; i++) {
		v.set(i, p_array[i]);
	}
	*this = v;
}

Variant::Variant(const Vector<String> &p_array) {
	type = NIL;
	PoolVector<String> v;
	int len = p_array.size();
	v.resize(len);
	for (int i = 0; i < len; i++) {
		v.set(i, p_array[i]);
	}
	*this = v;
}

Variant::Variant(const Vector<StringName> &p_array) {
	type = NIL;
	PoolVector<String> v;
	int len = p_array.size();
	v.resize(len);
	for (int i = 0; i < len; i++) {
		v.set(i, p_array[i]);
	}
	*this = v;
}

Variant::Variant(const Vector<Vector2> &p_array) {
	type = NIL;
	PoolVector<Vector2> v;
	int len = p_array.size();
	if (len > 0) {
		v.resize(len);
		PoolVector<Vector2>::Write w = v.write();
		const Vector2 *r = p_array.ptr();

		for (int i = 0; i < len; i++) {
			w[i] = r[i];
		}
	}
	*this = v;
}
Variant::Variant(const Vector<Vector2i> &p_array) {
	type = NIL;
	PoolVector<Vector2i> v;
	int len = p_array.size();
	if (len > 0) {
		v.resize(len);
		PoolVector<Vector2i>::Write w = v.write();
		const Vector2i *r = p_array.ptr();

		for (int i = 0; i < len; i++) {
			w[i] = r[i];
		}
	}
	*this = v;
}

Variant::Variant(const Vector<Vector3> &p_array) {
	type = NIL;
	PoolVector<Vector3> v;
	int len = p_array.size();
	if (len > 0) {
		v.resize(len);
		PoolVector<Vector3>::Write w = v.write();
		const Vector3 *r = p_array.ptr();

		for (int i = 0; i < len; i++) {
			w[i] = r[i];
		}
	}
	*this = v;
}
Variant::Variant(const Vector<Vector3i> &p_array) {
	type = NIL;
	PoolVector<Vector3i> v;
	int len = p_array.size();
	if (len > 0) {
		v.resize(len);
		PoolVector<Vector3i>::Write w = v.write();
		const Vector3i *r = p_array.ptr();

		for (int i = 0; i < len; i++) {
			w[i] = r[i];
		}
	}
	*this = v;
}

Variant::Variant(const Vector<Vector4> &p_array) {
	type = NIL;
	PoolVector<Vector4> v;
	int len = p_array.size();
	if (len > 0) {
		v.resize(len);
		PoolVector<Vector4>::Write w = v.write();
		const Vector4 *r = p_array.ptr();

		for (int i = 0; i < len; i++) {
			w[i] = r[i];
		}
	}
	*this = v;
}
Variant::Variant(const Vector<Vector4i> &p_array) {
	type = NIL;
	PoolVector<Vector4i> v;
	int len = p_array.size();
	if (len > 0) {
		v.resize(len);
		PoolVector<Vector4i>::Write w = v.write();
		const Vector4i *r = p_array.ptr();

		for (int i = 0; i < len; i++) {
			w[i] = r[i];
		}
	}
	*this = v;
}

Variant::Variant(const Vector<Color> &p_array) {
	type = NIL;
	PoolVector<Color> v;
	int len = p_array.size();
	v.resize(len);
	for (int i = 0; i < len; i++) {
		v.set(i, p_array[i]);
	}
	*this = v;
}

void Variant::operator=(const Variant &p_variant) {
	if (unlikely(this == &p_variant)) {
		return;
	}

	if (unlikely(type != p_variant.type)) {
		reference(p_variant);
		return;
	}

	switch (p_variant.type) {
		case NIL: {
			// none
		} break;

		// atomic types
		case BOOL: {
			_data._bool = p_variant._data._bool;
		} break;
		case INT: {
			_data._int = p_variant._data._int;
		} break;
		case REAL: {
			_data._real = p_variant._data._real;
		} break;
		case STRING: {
			*reinterpret_cast<String *>(_data._mem) = *reinterpret_cast<const String *>(p_variant._data._mem);
		} break;

			// math types
		case RECT2: {
			*reinterpret_cast<Rect2 *>(_data._mem) = *reinterpret_cast<const Rect2 *>(p_variant._data._mem);
		} break;
		case RECT2I: {
			*reinterpret_cast<Rect2i *>(_data._mem) = *reinterpret_cast<const Rect2i *>(p_variant._data._mem);
		} break;
		case VECTOR2: {
			*reinterpret_cast<Vector2 *>(_data._mem) = *reinterpret_cast<const Vector2 *>(p_variant._data._mem);
		} break;
		case VECTOR2I: {
			*reinterpret_cast<Vector2i *>(_data._mem) = *reinterpret_cast<const Vector2i *>(p_variant._data._mem);
		} break;
		case VECTOR3: {
			*reinterpret_cast<Vector3 *>(_data._mem) = *reinterpret_cast<const Vector3 *>(p_variant._data._mem);
		} break;
		case VECTOR3I: {
			*reinterpret_cast<Vector3i *>(_data._mem) = *reinterpret_cast<const Vector3i *>(p_variant._data._mem);
		} break;
		case VECTOR4: {
			*reinterpret_cast<Vector4 *>(_data._mem) = *reinterpret_cast<const Vector4 *>(p_variant._data._mem);
		} break;
		case VECTOR4I: {
			*reinterpret_cast<Vector4i *>(_data._mem) = *reinterpret_cast<const Vector4i *>(p_variant._data._mem);
		} break;

		case PLANE: {
			*reinterpret_cast<Plane *>(_data._mem) = *reinterpret_cast<const Plane *>(p_variant._data._mem);
		} break;
		case QUATERNION: {
			*reinterpret_cast<Quaternion *>(_data._mem) = *reinterpret_cast<const Quaternion *>(p_variant._data._mem);
		} break;
		case AABB: {
			*_data._aabb = *(p_variant._data._aabb);
		} break;
		case BASIS: {
			*_data._basis = *(p_variant._data._basis);
		} break;
		case TRANSFORM: {
			*_data._transform = *(p_variant._data._transform);
		} break;
		case TRANSFORM2D: {
			*_data._transform2d = *(p_variant._data._transform2d);
		} break;
		case PROJECTION: {
			*_data._projection = *(p_variant._data._projection);
		} break;

		// misc types
		case COLOR: {
			*reinterpret_cast<Color *>(_data._mem) = *reinterpret_cast<const Color *>(p_variant._data._mem);
		} break;
		case OBJECT: {
			if (likely(_get_obj().rc)) {
				if (unlikely(_get_obj().rc->decrement())) {
					memdelete(_get_obj().rc);
				}
			}
			*reinterpret_cast<ObjData *>(_data._mem) = p_variant._get_obj();
			if (likely(_get_obj().rc)) {
				_get_obj().rc->increment();
			}
		} break;
		case STRING_NAME: {
			*reinterpret_cast<StringName *>(_data._mem) = *reinterpret_cast<const StringName *>(p_variant._data._mem);
		} break;
		case DICTIONARY: {
			*reinterpret_cast<Dictionary *>(_data._mem) = *reinterpret_cast<const Dictionary *>(p_variant._data._mem);
		} break;
		case ARRAY: {
			*reinterpret_cast<Array *>(_data._mem) = *reinterpret_cast<const Array *>(p_variant._data._mem);
		} break;

		// arrays
		case POOL_BYTE_ARRAY: {
			*reinterpret_cast<PoolVector<uint8_t> *>(_data._mem) = *reinterpret_cast<const PoolVector<uint8_t> *>(p_variant._data._mem);
		} break;
		case POOL_INT_ARRAY: {
			*reinterpret_cast<PoolVector<int> *>(_data._mem) = *reinterpret_cast<const PoolVector<int> *>(p_variant._data._mem);
		} break;
		case POOL_REAL_ARRAY: {
			*reinterpret_cast<PoolVector<real_t> *>(_data._mem) = *reinterpret_cast<const PoolVector<real_t> *>(p_variant._data._mem);
		} break;
		case POOL_STRING_ARRAY: {
			*reinterpret_cast<PoolVector<String> *>(_data._mem) = *reinterpret_cast<const PoolVector<String> *>(p_variant._data._mem);
		} break;
		case POOL_VECTOR2_ARRAY: {
			*reinterpret_cast<PoolVector<Vector2> *>(_data._mem) = *reinterpret_cast<const PoolVector<Vector2> *>(p_variant._data._mem);
		} break;
		case POOL_VECTOR2I_ARRAY: {
			*reinterpret_cast<PoolVector<Vector2i> *>(_data._mem) = *reinterpret_cast<const PoolVector<Vector2i> *>(p_variant._data._mem);
		} break;
		case POOL_VECTOR3_ARRAY: {
			*reinterpret_cast<PoolVector<Vector3> *>(_data._mem) = *reinterpret_cast<const PoolVector<Vector3> *>(p_variant._data._mem);
		} break;
		case POOL_VECTOR3I_ARRAY: {
			*reinterpret_cast<PoolVector<Vector3i> *>(_data._mem) = *reinterpret_cast<const PoolVector<Vector3i> *>(p_variant._data._mem);
		} break;
		case POOL_VECTOR4_ARRAY: {
			*reinterpret_cast<PoolVector<Vector4> *>(_data._mem) = *reinterpret_cast<const PoolVector<Vector4> *>(p_variant._data._mem);
		} break;
		case POOL_VECTOR4I_ARRAY: {
			*reinterpret_cast<PoolVector<Vector4i> *>(_data._mem) = *reinterpret_cast<const PoolVector<Vector4i> *>(p_variant._data._mem);
		} break;
		case POOL_COLOR_ARRAY: {
			*reinterpret_cast<PoolVector<Color> *>(_data._mem) = *reinterpret_cast<const PoolVector<Color> *>(p_variant._data._mem);
		} break;
		default: {
		}
	}
}

Variant::Variant(const Variant &p_variant) {
	type = NIL;
	reference(p_variant);
}

/*
Variant::~Variant() {

	clear();
}*/

uint32_t Variant::hash() const {
	return recursive_hash(0);
}

uint32_t Variant::recursive_hash(int p_recursion_count) const {
	switch (type) {
		case NIL: {
			return 0;
		} break;

		case BOOL: {
			return _data._bool ? 1 : 0;
		} break;
		case INT: {
			return hash_one_uint64((uint64_t)_data._int);
		} break;
		case REAL: {
			return hash_murmur3_one_float(_data._real);
		} break;
		case STRING: {
			return reinterpret_cast<const String *>(_data._mem)->hash();
		} break;

			// math types
		case RECT2: {
			return HashMapHasherDefault::hash(*reinterpret_cast<const Rect2 *>(_data._mem));
		} break;
		case RECT2I: {
			return HashMapHasherDefault::hash(*reinterpret_cast<const Rect2i *>(_data._mem));
		} break;
		case VECTOR2: {
			return HashMapHasherDefault::hash(*reinterpret_cast<const Vector2 *>(_data._mem));
		} break;
		case VECTOR2I: {
			return HashMapHasherDefault::hash(*reinterpret_cast<const Vector2i *>(_data._mem));
		} break;
		case VECTOR3: {
			return HashMapHasherDefault::hash(*reinterpret_cast<const Vector3 *>(_data._mem));
		} break;
		case VECTOR3I: {
			return HashMapHasherDefault::hash(*reinterpret_cast<const Vector3i *>(_data._mem));
		} break;
		case VECTOR4: {
			return HashMapHasherDefault::hash(*reinterpret_cast<const Vector4 *>(_data._mem));
		} break;
		case VECTOR4I: {
			return HashMapHasherDefault::hash(*reinterpret_cast<const Vector4i *>(_data._mem));
		} break;
		case PLANE: {
			uint32_t h = HASH_MURMUR3_SEED;
			const Plane &p = *reinterpret_cast<const Plane *>(_data._mem);
			h = hash_murmur3_one_real(p.normal.x, h);
			h = hash_murmur3_one_real(p.normal.y, h);
			h = hash_murmur3_one_real(p.normal.z, h);
			h = hash_murmur3_one_real(p.d, h);
			return hash_fmix32(h);
		} break;
		case QUATERNION: {
			uint32_t h = HASH_MURMUR3_SEED;
			const Quaternion &q = *reinterpret_cast<const Quaternion *>(_data._mem);
			h = hash_murmur3_one_real(q.x, h);
			h = hash_murmur3_one_real(q.y, h);
			h = hash_murmur3_one_real(q.z, h);
			h = hash_murmur3_one_real(q.w, h);
			return hash_fmix32(h);
		} break;
		case AABB: {
			return HashMapHasherDefault::hash(*_data._aabb);
		} break;
		case BASIS: {
			uint32_t h = HASH_MURMUR3_SEED;
			const Basis &b = *_data._basis;
			h = hash_murmur3_one_real(b[0].x, h);
			h = hash_murmur3_one_real(b[0].y, h);
			h = hash_murmur3_one_real(b[0].z, h);
			h = hash_murmur3_one_real(b[1].x, h);
			h = hash_murmur3_one_real(b[1].y, h);
			h = hash_murmur3_one_real(b[1].z, h);
			h = hash_murmur3_one_real(b[2].x, h);
			h = hash_murmur3_one_real(b[2].y, h);
			h = hash_murmur3_one_real(b[2].z, h);
			return hash_fmix32(h);
		} break;
		case TRANSFORM: {
			uint32_t h = HASH_MURMUR3_SEED;
			const Transform &t = *_data._transform;
			h = hash_murmur3_one_real(t.basis[0].x, h);
			h = hash_murmur3_one_real(t.basis[0].y, h);
			h = hash_murmur3_one_real(t.basis[0].z, h);
			h = hash_murmur3_one_real(t.basis[1].x, h);
			h = hash_murmur3_one_real(t.basis[1].y, h);
			h = hash_murmur3_one_real(t.basis[1].z, h);
			h = hash_murmur3_one_real(t.basis[2].x, h);
			h = hash_murmur3_one_real(t.basis[2].y, h);
			h = hash_murmur3_one_real(t.basis[2].z, h);
			h = hash_murmur3_one_real(t.origin.x, h);
			h = hash_murmur3_one_real(t.origin.y, h);
			h = hash_murmur3_one_real(t.origin.z, h);
			return hash_fmix32(h);
		} break;
		case TRANSFORM2D: {
			uint32_t h = HASH_MURMUR3_SEED;
			const Transform2D &t = *_data._transform2d;
			h = hash_murmur3_one_real(t[0].x, h);
			h = hash_murmur3_one_real(t[0].y, h);
			h = hash_murmur3_one_real(t[1].x, h);
			h = hash_murmur3_one_real(t[1].y, h);
			h = hash_murmur3_one_real(t[2].x, h);
			h = hash_murmur3_one_real(t[2].y, h);

			return hash_fmix32(h);
		} break;
		case PROJECTION: {
			uint32_t h = HASH_MURMUR3_SEED;
			const Projection &t = *_data._projection;
			h = hash_murmur3_one_real(t.matrix[0].x, h);
			h = hash_murmur3_one_real(t.matrix[0].y, h);
			h = hash_murmur3_one_real(t.matrix[0].z, h);
			h = hash_murmur3_one_real(t.matrix[0].w, h);
			h = hash_murmur3_one_real(t.matrix[1].x, h);
			h = hash_murmur3_one_real(t.matrix[1].y, h);
			h = hash_murmur3_one_real(t.matrix[1].z, h);
			h = hash_murmur3_one_real(t.matrix[1].w, h);
			h = hash_murmur3_one_real(t.matrix[2].x, h);
			h = hash_murmur3_one_real(t.matrix[2].y, h);
			h = hash_murmur3_one_real(t.matrix[2].z, h);
			h = hash_murmur3_one_real(t.matrix[2].w, h);
			h = hash_murmur3_one_real(t.matrix[3].x, h);
			h = hash_murmur3_one_real(t.matrix[3].y, h);
			h = hash_murmur3_one_real(t.matrix[3].z, h);
			h = hash_murmur3_one_real(t.matrix[3].w, h);
			return hash_fmix32(h);
		} break;

		// misc types
		case COLOR: {
			uint32_t h = HASH_MURMUR3_SEED;
			const Color &c = *reinterpret_cast<const Color *>(_data._mem);
			h = hash_murmur3_one_float(c.r, h);
			h = hash_murmur3_one_float(c.g, h);
			h = hash_murmur3_one_float(c.b, h);
			h = hash_murmur3_one_float(c.a, h);
			return hash_fmix32(h);
		} break;
		case OBJECT: {
			return hash_one_uint64(hash_make_uint64_t(_UNSAFE_OBJ_PROXY_PTR(*this)));
		} break;
		case STRING_NAME: {
			return reinterpret_cast<const StringName *>(_data._mem)->hash();
		} break;
		case DICTIONARY: {
			return reinterpret_cast<const Dictionary *>(_data._mem)->recursive_hash(p_recursion_count);
		} break;
		case ARRAY: {
			const Array &arr = *reinterpret_cast<const Array *>(_data._mem);
			return arr.recursive_hash(p_recursion_count);
		} break;

		case POOL_BYTE_ARRAY: {
			const PoolVector<uint8_t> &arr = *reinterpret_cast<const PoolVector<uint8_t> *>(_data._mem);
			int len = arr.size();
			if (likely(len)) {
				PoolVector<uint8_t>::Read r = arr.read();
				return hash_murmur3_buffer((uint8_t *)&r[0], len);
			} else {
				return hash_murmur3_one_64(0);
			}

		} break;
		case POOL_INT_ARRAY: {
			const PoolVector<int> &arr = *reinterpret_cast<const PoolVector<int> *>(_data._mem);
			int len = arr.size();
			if (likely(len)) {
				PoolVector<int>::Read r = arr.read();
				return hash_murmur3_buffer((uint8_t *)&r[0], len * sizeof(int));
			} else {
				return hash_murmur3_one_64(0);
			}

		} break;
		case POOL_REAL_ARRAY: {
			const PoolVector<real_t> &arr = *reinterpret_cast<const PoolVector<real_t> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<real_t>::Read r = arr.read();
				uint32_t h = HASH_MURMUR3_SEED;

				for (int i = 0; i < len; i++) {
					h = hash_murmur3_one_real(r[i], h);
				}

				return hash_fmix32(h);
			} else {
				return hash_murmur3_one_real(0.0);
			}

		} break;
		case POOL_STRING_ARRAY: {
			uint32_t hash = HASH_MURMUR3_SEED;
			const PoolVector<String> &arr = *reinterpret_cast<const PoolVector<String> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<String>::Read r = arr.read();

				for (int i = 0; i < len; i++) {
					hash = hash_murmur3_one_32(r[i].hash(), hash);
				}

				hash = hash_fmix32(hash);
			}

			return hash;
		} break;
		case POOL_VECTOR2_ARRAY: {
			uint32_t hash = HASH_MURMUR3_SEED;
			const PoolVector<Vector2> &arr = *reinterpret_cast<const PoolVector<Vector2> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<Vector2>::Read r = arr.read();

				for (int i = 0; i < len; i++) {
					hash = hash_murmur3_one_real(r[i].x, hash);
					hash = hash_murmur3_one_real(r[i].y, hash);
				}

				hash = hash_fmix32(hash);
			}

			return hash;
		} break;
		case POOL_VECTOR2I_ARRAY: {
			uint32_t hash = HASH_MURMUR3_SEED;
			const PoolVector<Vector2i> &arr = *reinterpret_cast<const PoolVector<Vector2i> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<Vector2i>::Read r = arr.read();

				for (int i = 0; i < len; i++) {
					hash = hash_murmur3_one_32(r[i].x, hash);
					hash = hash_murmur3_one_32(r[i].y, hash);
				}

				hash = hash_fmix32(hash);
			}

			return hash;
		} break;
		case POOL_VECTOR3_ARRAY: {
			uint32_t hash = HASH_MURMUR3_SEED;
			const PoolVector<Vector3> &arr = *reinterpret_cast<const PoolVector<Vector3> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<Vector3>::Read r = arr.read();

				for (int i = 0; i < len; i++) {
					hash = hash_murmur3_one_real(r[i].x, hash);
					hash = hash_murmur3_one_real(r[i].y, hash);
					hash = hash_murmur3_one_real(r[i].z, hash);
				}

				hash = hash_fmix32(hash);
			}

			return hash;
		} break;
		case POOL_VECTOR3I_ARRAY: {
			uint32_t hash = HASH_MURMUR3_SEED;
			const PoolVector<Vector3i> &arr = *reinterpret_cast<const PoolVector<Vector3i> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<Vector3i>::Read r = arr.read();

				for (int i = 0; i < len; i++) {
					hash = hash_murmur3_one_32(r[i].x, hash);
					hash = hash_murmur3_one_32(r[i].y, hash);
					hash = hash_murmur3_one_32(r[i].z, hash);
				}

				hash = hash_fmix32(hash);
			}

			return hash;
		} break;
		case POOL_VECTOR4_ARRAY: {
			uint32_t hash = HASH_MURMUR3_SEED;
			const PoolVector<Vector4> &arr = *reinterpret_cast<const PoolVector<Vector4> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<Vector4>::Read r = arr.read();

				for (int i = 0; i < len; i++) {
					hash = hash_murmur3_one_real(r[i].x, hash);
					hash = hash_murmur3_one_real(r[i].y, hash);
					hash = hash_murmur3_one_real(r[i].z, hash);
					hash = hash_murmur3_one_real(r[i].w, hash);
				}

				hash = hash_fmix32(hash);
			}

			return hash;
		} break;
		case POOL_VECTOR4I_ARRAY: {
			uint32_t hash = HASH_MURMUR3_SEED;
			const PoolVector<Vector4i> &arr = *reinterpret_cast<const PoolVector<Vector4i> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<Vector4i>::Read r = arr.read();

				for (int i = 0; i < len; i++) {
					hash = hash_murmur3_one_32(r[i].x, hash);
					hash = hash_murmur3_one_32(r[i].y, hash);
					hash = hash_murmur3_one_32(r[i].z, hash);
					hash = hash_murmur3_one_32(r[i].w, hash);
				}

				hash = hash_fmix32(hash);
			}

			return hash;
		} break;
		case POOL_COLOR_ARRAY: {
			uint32_t hash = HASH_MURMUR3_SEED;
			const PoolVector<Color> &arr = *reinterpret_cast<const PoolVector<Color> *>(_data._mem);
			int len = arr.size();

			if (likely(len)) {
				PoolVector<Color>::Read r = arr.read();

				for (int i = 0; i < len; i++) {
					hash = hash_murmur3_one_real(r[i].r, hash);
					hash = hash_murmur3_one_real(r[i].g, hash);
					hash = hash_murmur3_one_real(r[i].b, hash);
					hash = hash_murmur3_one_real(r[i].a, hash);
				}

				hash = hash_fmix32(hash);
			}

			return hash;
		} break;
		default: {
		}
	}

	return 0;
}

#define hash_compare_scalar(p_lhs, p_rhs) \
	(((p_lhs) == (p_rhs)) || (Math::is_nan(p_lhs) && Math::is_nan(p_rhs)))

#define hash_compare_vector2(p_lhs, p_rhs)        \
	(hash_compare_scalar((p_lhs).x, (p_rhs).x) && \
			hash_compare_scalar((p_lhs).y, (p_rhs).y))

#define hash_compare_vector2i(p_lhs, p_rhs) \
	(((p_lhs).x == (p_rhs).x) &&            \
			((p_lhs).y == (p_rhs).y))

#define hash_compare_vector3(p_lhs, p_rhs)               \
	(hash_compare_scalar((p_lhs).x, (p_rhs).x) &&        \
			hash_compare_scalar((p_lhs).y, (p_rhs).y) && \
			hash_compare_scalar((p_lhs).z, (p_rhs).z))

#define hash_compare_vector3i(p_lhs, p_rhs) \
	(((p_lhs).x == (p_rhs).x) &&            \
			((p_lhs).y == (p_rhs).y) &&     \
			((p_lhs).z == (p_rhs).z))

#define hash_compare_vector4(p_lhs, p_rhs)               \
	(hash_compare_scalar((p_lhs).x, (p_rhs).x) &&        \
			hash_compare_scalar((p_lhs).y, (p_rhs).y) && \
			hash_compare_scalar((p_lhs).z, (p_rhs).z) && \
			hash_compare_scalar((p_lhs).w, (p_rhs).w))

#define hash_compare_vector4i(p_lhs, p_rhs) \
	(((p_lhs).x == (p_rhs).x) &&            \
			((p_lhs).y == (p_rhs).y) &&     \
			((p_lhs).z == (p_rhs).z) &&     \
			((p_lhs).w == (p_rhs).w))

#define hash_compare_quat(p_lhs, p_rhs)                  \
	(hash_compare_scalar((p_lhs).x, (p_rhs).x) &&        \
			hash_compare_scalar((p_lhs).y, (p_rhs).y) && \
			hash_compare_scalar((p_lhs).z, (p_rhs).z) && \
			hash_compare_scalar((p_lhs).w, (p_rhs).w))

#define hash_compare_color(p_lhs, p_rhs)                 \
	(hash_compare_scalar((p_lhs).r, (p_rhs).r) &&        \
			hash_compare_scalar((p_lhs).g, (p_rhs).g) && \
			hash_compare_scalar((p_lhs).b, (p_rhs).b) && \
			hash_compare_scalar((p_lhs).a, (p_rhs).a))

#define hash_compare_pool_array(p_lhs, p_rhs, p_type, p_compare_func)                   \
	const PoolVector<p_type> &l = *reinterpret_cast<const PoolVector<p_type> *>(p_lhs); \
	const PoolVector<p_type> &r = *reinterpret_cast<const PoolVector<p_type> *>(p_rhs); \
                                                                                        \
	if (l.size() != r.size())                                                           \
		return false;                                                                   \
                                                                                        \
	PoolVector<p_type>::Read lr = l.read();                                             \
	PoolVector<p_type>::Read rr = r.read();                                             \
                                                                                        \
	for (int i = 0; i < l.size(); ++i) {                                                \
		if (!p_compare_func((lr[i]), (rr[i])))                                          \
			return false;                                                               \
	}                                                                                   \
                                                                                        \
	return true

bool Variant::hash_compare(const Variant &p_variant) const {
	if (type != p_variant.type) {
		return false;
	}

	switch (type) {
		//BOOL
		case INT: {
			return _data._int == p_variant._data._int;
		} break;
		case REAL: {
			return hash_compare_scalar(_data._real, p_variant._data._real);
		} break;
		case STRING: {
			return *reinterpret_cast<const String *>(_data._mem) == *reinterpret_cast<const String *>(p_variant._data._mem);
		} break;

		case RECT2: {
			const Rect2 *l = reinterpret_cast<const Rect2 *>(_data._mem);
			const Rect2 *r = reinterpret_cast<const Rect2 *>(p_variant._data._mem);

			return hash_compare_vector2(l->position, r->position) &&
					hash_compare_vector2(l->size, r->size);
		} break;
		case RECT2I: {
			const Rect2i *l = reinterpret_cast<const Rect2i *>(_data._mem);
			const Rect2i *r = reinterpret_cast<const Rect2i *>(p_variant._data._mem);

			return hash_compare_vector2i(l->position, r->position) &&
					hash_compare_vector2i(l->size, r->size);
		} break;
		case VECTOR2: {
			const Vector2 *l = reinterpret_cast<const Vector2 *>(_data._mem);
			const Vector2 *r = reinterpret_cast<const Vector2 *>(p_variant._data._mem);

			return hash_compare_vector2(*l, *r);
		} break;
		case VECTOR2I: {
			const Vector2i *l = reinterpret_cast<const Vector2i *>(_data._mem);
			const Vector2i *r = reinterpret_cast<const Vector2i *>(p_variant._data._mem);

			return hash_compare_vector2i(*l, *r);
		} break;
		case VECTOR3: {
			const Vector3 *l = reinterpret_cast<const Vector3 *>(_data._mem);
			const Vector3 *r = reinterpret_cast<const Vector3 *>(p_variant._data._mem);

			return hash_compare_vector3(*l, *r);
		} break;
		case VECTOR3I: {
			const Vector3i *l = reinterpret_cast<const Vector3i *>(_data._mem);
			const Vector3i *r = reinterpret_cast<const Vector3i *>(p_variant._data._mem);

			return hash_compare_vector3i(*l, *r);
		} break;
		case VECTOR4: {
			const Vector4 *l = reinterpret_cast<const Vector4 *>(_data._mem);
			const Vector4 *r = reinterpret_cast<const Vector4 *>(p_variant._data._mem);

			return hash_compare_vector4(*l, *r);
		} break;
		case VECTOR4I: {
			const Vector4i *l = reinterpret_cast<const Vector4i *>(_data._mem);
			const Vector4i *r = reinterpret_cast<const Vector4i *>(p_variant._data._mem);

			return hash_compare_vector4i(*l, *r);
		} break;

		case PLANE: {
			const Plane *l = reinterpret_cast<const Plane *>(_data._mem);
			const Plane *r = reinterpret_cast<const Plane *>(p_variant._data._mem);

			return hash_compare_vector3(l->normal, r->normal) &&
					hash_compare_scalar(l->d, r->d);
		} break;
		case QUATERNION: {
			const Quaternion *l = reinterpret_cast<const Quaternion *>(_data._mem);
			const Quaternion *r = reinterpret_cast<const Quaternion *>(p_variant._data._mem);

			return hash_compare_quat(*l, *r);
		} break;
		case AABB: {
			const ::AABB *l = _data._aabb;
			const ::AABB *r = p_variant._data._aabb;

			return hash_compare_vector3(l->position, r->position) &&
					hash_compare_vector3(l->size, r->size);

		} break;
		case BASIS: {
			const Basis *l = _data._basis;
			const Basis *r = p_variant._data._basis;

			for (int i = 0; i < 3; i++) {
				if (!hash_compare_vector3(l->rows[i], r->rows[i])) {
					return false;
				}
			}

			return true;
		} break;
		case TRANSFORM: {
			const Transform *l = _data._transform;
			const Transform *r = p_variant._data._transform;

			for (int i = 0; i < 3; i++) {
				if (!hash_compare_vector3(l->basis.rows[i], r->basis.rows[i])) {
					return false;
				}
			}

			return hash_compare_vector3(l->origin, r->origin);
		} break;
		case TRANSFORM2D: {
			Transform2D *l = _data._transform2d;
			Transform2D *r = p_variant._data._transform2d;

			for (int i = 0; i < 3; i++) {
				if (!hash_compare_vector2(l->columns[i], r->columns[i])) {
					return false;
				}
			}

			return true;
		} break;
		case PROJECTION: {
			const Projection *l = _data._projection;
			const Projection *r = p_variant._data._projection;

			for (int i = 0; i < 4; i++) {
				if (!hash_compare_vector4(l->matrix[i], r->matrix[i])) {
					return false;
				}
			}

			return true;
		} break;

		case COLOR: {
			const Color *l = reinterpret_cast<const Color *>(_data._mem);
			const Color *r = reinterpret_cast<const Color *>(p_variant._data._mem);

			return hash_compare_color(*l, *r);
		} break;
		case ARRAY: {
			const Array &l = *(reinterpret_cast<const Array *>(_data._mem));
			const Array &r = *(reinterpret_cast<const Array *>(p_variant._data._mem));

			if (l.size() != r.size()) {
				return false;
			}

			for (int i = 0; i < l.size(); ++i) {
				if (!l[i].hash_compare(r[i])) {
					return false;
				}
			}

			return true;
		} break;

		case POOL_REAL_ARRAY: {
			hash_compare_pool_array(_data._mem, p_variant._data._mem, real_t, hash_compare_scalar);
		} break;
		case POOL_VECTOR2_ARRAY: {
			hash_compare_pool_array(_data._mem, p_variant._data._mem, Vector2, hash_compare_vector2);
		} break;
		case POOL_VECTOR2I_ARRAY: {
			hash_compare_pool_array(_data._mem, p_variant._data._mem, Vector2i, hash_compare_vector2i);
		} break;
		case POOL_VECTOR3_ARRAY: {
			hash_compare_pool_array(_data._mem, p_variant._data._mem, Vector3, hash_compare_vector3);
		} break;
		case POOL_VECTOR3I_ARRAY: {
			hash_compare_pool_array(_data._mem, p_variant._data._mem, Vector3i, hash_compare_vector3i);
		} break;
		case POOL_VECTOR4_ARRAY: {
			hash_compare_pool_array(_data._mem, p_variant._data._mem, Vector4, hash_compare_vector4);
		} break;
		case POOL_VECTOR4I_ARRAY: {
			hash_compare_pool_array(_data._mem, p_variant._data._mem, Vector4i, hash_compare_vector4i);
		} break;
		case POOL_COLOR_ARRAY: {
			hash_compare_pool_array(_data._mem, p_variant._data._mem, Color, hash_compare_color);
		} break;

		default:
			bool v;
			Variant r;
			evaluate(OP_EQUAL, *this, p_variant, r, v);
			return r;
	}

	return false;
}

bool Variant::is_ref() const {
	return type == OBJECT && !_get_obj().ref.is_null();
}

Vector<Variant> varray() {
	return Vector<Variant>();
}

Vector<Variant> varray(const Variant &p_arg1) {
	Vector<Variant> v;
	v.push_back(p_arg1);
	return v;
}
Vector<Variant> varray(const Variant &p_arg1, const Variant &p_arg2) {
	Vector<Variant> v;
	v.push_back(p_arg1);
	v.push_back(p_arg2);
	return v;
}
Vector<Variant> varray(const Variant &p_arg1, const Variant &p_arg2, const Variant &p_arg3) {
	Vector<Variant> v;
	v.push_back(p_arg1);
	v.push_back(p_arg2);
	v.push_back(p_arg3);
	return v;
}
Vector<Variant> varray(const Variant &p_arg1, const Variant &p_arg2, const Variant &p_arg3, const Variant &p_arg4) {
	Vector<Variant> v;
	v.push_back(p_arg1);
	v.push_back(p_arg2);
	v.push_back(p_arg3);
	v.push_back(p_arg4);
	return v;
}

Vector<Variant> varray(const Variant &p_arg1, const Variant &p_arg2, const Variant &p_arg3, const Variant &p_arg4, const Variant &p_arg5) {
	Vector<Variant> v;
	v.push_back(p_arg1);
	v.push_back(p_arg2);
	v.push_back(p_arg3);
	v.push_back(p_arg4);
	v.push_back(p_arg5);
	return v;
}

bool Variant::is_shared() const {
	switch (type) {
		case OBJECT:
			return true;
		case ARRAY:
			return true;
		case DICTIONARY:
			return true;
		default: {
		}
	}

	return false;
}

String vformat(const String &p_text, const Variant &p1, const Variant &p2, const Variant &p3, const Variant &p4, const Variant &p5) {
	Array args;
	if (p1.get_type() != Variant::NIL) {
		args.push_back(p1);

		if (p2.get_type() != Variant::NIL) {
			args.push_back(p2);

			if (p3.get_type() != Variant::NIL) {
				args.push_back(p3);

				if (p4.get_type() != Variant::NIL) {
					args.push_back(p4);

					if (p5.get_type() != Variant::NIL) {
						args.push_back(p5);
					}
				}
			}
		}
	}

	bool error = false;
	String fmt = args.sprintf(p_text, &error);

	ERR_FAIL_COND_V_MSG(error, String(), fmt);

	return fmt;
}
#line 0

#line 1 "sfw/object/variant_op.cpp"
/*************************************************************************/
/*  variant_op.cpp                                                       */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

#define CASE_TYPE_ALL(PREFIX, OP) \
	CASE_TYPE(PREFIX, OP, INT)    \
	CASE_TYPE_ALL_BUT_INT(PREFIX, OP)

#define CASE_TYPE_ALL_BUT_INT(PREFIX, OP)      \
	CASE_TYPE(PREFIX, OP, NIL)                 \
	CASE_TYPE(PREFIX, OP, BOOL)                \
	CASE_TYPE(PREFIX, OP, REAL)                \
	CASE_TYPE(PREFIX, OP, STRING)              \
	CASE_TYPE(PREFIX, OP, RECT2)               \
	CASE_TYPE(PREFIX, OP, RECT2I)              \
	CASE_TYPE(PREFIX, OP, VECTOR2)             \
	CASE_TYPE(PREFIX, OP, VECTOR2I)            \
	CASE_TYPE(PREFIX, OP, VECTOR3)             \
	CASE_TYPE(PREFIX, OP, VECTOR3I)            \
	CASE_TYPE(PREFIX, OP, VECTOR4)             \
	CASE_TYPE(PREFIX, OP, VECTOR4I)            \
	CASE_TYPE(PREFIX, OP, PLANE)               \
	CASE_TYPE(PREFIX, OP, QUATERNION)          \
	CASE_TYPE(PREFIX, OP, AABB)                \
	CASE_TYPE(PREFIX, OP, BASIS)               \
	CASE_TYPE(PREFIX, OP, TRANSFORM)           \
	CASE_TYPE(PREFIX, OP, TRANSFORM2D)         \
	CASE_TYPE(PREFIX, OP, PROJECTION)          \
	CASE_TYPE(PREFIX, OP, COLOR)               \
	CASE_TYPE(PREFIX, OP, OBJECT)              \
	CASE_TYPE(PREFIX, OP, STRING_NAME)         \
	CASE_TYPE(PREFIX, OP, DICTIONARY)          \
	CASE_TYPE(PREFIX, OP, ARRAY)               \
	CASE_TYPE(PREFIX, OP, POOL_BYTE_ARRAY)     \
	CASE_TYPE(PREFIX, OP, POOL_INT_ARRAY)      \
	CASE_TYPE(PREFIX, OP, POOL_REAL_ARRAY)     \
	CASE_TYPE(PREFIX, OP, POOL_STRING_ARRAY)   \
	CASE_TYPE(PREFIX, OP, POOL_VECTOR2_ARRAY)  \
	CASE_TYPE(PREFIX, OP, POOL_VECTOR2I_ARRAY) \
	CASE_TYPE(PREFIX, OP, POOL_VECTOR3_ARRAY)  \
	CASE_TYPE(PREFIX, OP, POOL_VECTOR3I_ARRAY) \
	CASE_TYPE(PREFIX, OP, POOL_VECTOR4_ARRAY)  \
	CASE_TYPE(PREFIX, OP, POOL_VECTOR4I_ARRAY) \
	CASE_TYPE(PREFIX, OP, POOL_COLOR_ARRAY)

#ifdef __GNUC__
#define TYPE(PREFIX, OP, TYPE) &&PREFIX##_##OP##_##TYPE

/* clang-format off */

#define TYPES(PREFIX, OP) {                    \
		TYPE(PREFIX, OP, NIL),                 \
		TYPE(PREFIX, OP, BOOL),                \
		TYPE(PREFIX, OP, INT),                 \
		TYPE(PREFIX, OP, REAL),                \
		TYPE(PREFIX, OP, STRING),              \
		TYPE(PREFIX, OP, RECT2),               \
		TYPE(PREFIX, OP, RECT2I),              \
		TYPE(PREFIX, OP, VECTOR2),             \
		TYPE(PREFIX, OP, VECTOR2I),            \
		TYPE(PREFIX, OP, VECTOR3),             \
		TYPE(PREFIX, OP, VECTOR3I),            \
		TYPE(PREFIX, OP, VECTOR4),             \
		TYPE(PREFIX, OP, VECTOR4I),            \
		TYPE(PREFIX, OP, PLANE),               \
		TYPE(PREFIX, OP, QUATERNION),          \
		TYPE(PREFIX, OP, AABB),                \
		TYPE(PREFIX, OP, BASIS),               \
		TYPE(PREFIX, OP, TRANSFORM),           \
		TYPE(PREFIX, OP, TRANSFORM2D),         \
		TYPE(PREFIX, OP, PROJECTION),          \
		TYPE(PREFIX, OP, COLOR),               \
		TYPE(PREFIX, OP, OBJECT),              \
		TYPE(PREFIX, OP, STRING_NAME),         \
		TYPE(PREFIX, OP, DICTIONARY),          \
		TYPE(PREFIX, OP, ARRAY),               \
		TYPE(PREFIX, OP, POOL_BYTE_ARRAY),     \
		TYPE(PREFIX, OP, POOL_INT_ARRAY),      \
		TYPE(PREFIX, OP, POOL_REAL_ARRAY),     \
		TYPE(PREFIX, OP, POOL_STRING_ARRAY),   \
		TYPE(PREFIX, OP, POOL_VECTOR2_ARRAY),  \
		TYPE(PREFIX, OP, POOL_VECTOR2I_ARRAY), \
		TYPE(PREFIX, OP, POOL_VECTOR3_ARRAY),  \
		TYPE(PREFIX, OP, POOL_VECTOR3I_ARRAY), \
		TYPE(PREFIX, OP, POOL_VECTOR4_ARRAY),  \
		TYPE(PREFIX, OP, POOL_VECTOR4I_ARRAY), \
		TYPE(PREFIX, OP, POOL_COLOR_ARRAY),    \
}

/* clang-format on */

#define CASES(PREFIX) static const void *switch_table_##PREFIX[25][38] = { \
	TYPES(PREFIX, OP_EQUAL),                                               \
	TYPES(PREFIX, OP_NOT_EQUAL),                                           \
	TYPES(PREFIX, OP_LESS),                                                \
	TYPES(PREFIX, OP_LESS_EQUAL),                                          \
	TYPES(PREFIX, OP_GREATER),                                             \
	TYPES(PREFIX, OP_GREATER_EQUAL),                                       \
	TYPES(PREFIX, OP_ADD),                                                 \
	TYPES(PREFIX, OP_SUBTRACT),                                            \
	TYPES(PREFIX, OP_MULTIPLY),                                            \
	TYPES(PREFIX, OP_DIVIDE),                                              \
	TYPES(PREFIX, OP_NEGATE),                                              \
	TYPES(PREFIX, OP_POSITIVE),                                            \
	TYPES(PREFIX, OP_MODULE),                                              \
	TYPES(PREFIX, OP_STRING_CONCAT),                                       \
	TYPES(PREFIX, OP_SHIFT_LEFT),                                          \
	TYPES(PREFIX, OP_SHIFT_RIGHT),                                         \
	TYPES(PREFIX, OP_BIT_AND),                                             \
	TYPES(PREFIX, OP_BIT_OR),                                              \
	TYPES(PREFIX, OP_BIT_XOR),                                             \
	TYPES(PREFIX, OP_BIT_NEGATE),                                          \
	TYPES(PREFIX, OP_AND),                                                 \
	TYPES(PREFIX, OP_OR),                                                  \
	TYPES(PREFIX, OP_XOR),                                                 \
	TYPES(PREFIX, OP_NOT),                                                 \
	TYPES(PREFIX, OP_IN),                                                  \
}

#define SWITCH(PREFIX, op, val) goto *switch_table_##PREFIX[op][val];
#define SWITCH_OP(PREFIX, OP, val)
#define CASE_TYPE(PREFIX, OP, TYPE) PREFIX##_##OP##_##TYPE:

#else
#define CASES(PREFIX)
#define SWITCH(PREFIX, op, val) switch (op)
#define SWITCH_OP(PREFIX, OP, val) \
	case OP:                       \
		switch (val)
#define CASE_TYPE(PREFIX, OP, TYPE) case TYPE:
#endif

Variant::operator bool() const {
	return booleanize();
}

// We consider all uninitialized or empty types to be false based on the type's
// zeroiness.
bool Variant::booleanize() const {
	return !is_zero();
}

#define _RETURN(m_what) \
	{                   \
		r_ret = m_what; \
		return;         \
	}

#define _RETURN_FAIL     \
	{                    \
		r_valid = false; \
		return;          \
	}

#define DEFAULT_OP_NUM(m_prefix, m_op_name, m_name, m_op, m_type) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                      \
		if (p_b.type == INT)                                      \
			_RETURN(p_a._data.m_type m_op p_b._data._int);        \
		if (p_b.type == REAL)                                     \
			_RETURN(p_a._data.m_type m_op p_b._data._real);       \
                                                                  \
		_RETURN_FAIL                                              \
	};

#define DEFAULT_OP_NUM_NULL(m_prefix, m_op_name, m_name, m_op, m_type) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                           \
		if (p_b.type == INT)                                           \
			_RETURN(p_a._data.m_type m_op p_b._data._int);             \
		if (p_b.type == REAL)                                          \
			_RETURN(p_a._data.m_type m_op p_b._data._real);            \
		if (p_b.type == NIL)                                           \
			_RETURN(!(p_b.type m_op NIL));                             \
                                                                       \
		_RETURN_FAIL                                                   \
	};

#ifdef DEBUG_ENABLED
#define DEFAULT_OP_NUM_DIV(m_prefix, m_op_name, m_name, m_type) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                    \
		if (p_b.type == INT) {                                  \
			if (p_b._data._int == 0) {                          \
				r_valid = false;                                \
				_RETURN("Division By Zero");                    \
			}                                                   \
			_RETURN(p_a._data.m_type / p_b._data._int);         \
		}                                                       \
		if (p_b.type == REAL) {                                 \
			if (p_b._data._real == 0) {                         \
				r_valid = false;                                \
				_RETURN("Division By Zero");                    \
			}                                                   \
			_RETURN(p_a._data.m_type / p_b._data._real);        \
		}                                                       \
                                                                \
		_RETURN_FAIL                                            \
	};
#else
#define DEFAULT_OP_NUM_DIV(m_prefix, m_op_name, m_name, m_type) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                    \
		if (p_b.type == INT)                                    \
			_RETURN(p_a._data.m_type / p_b._data._int);         \
		if (p_b.type == REAL)                                   \
			_RETURN(p_a._data.m_type / p_b._data._real);        \
                                                                \
		_RETURN_FAIL                                            \
	};
#endif

#define DEFAULT_OP_NUM_NEG(m_prefix, m_op_name, m_name, m_type) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                    \
		_RETURN(-p_a._data.m_type);                             \
	};

#define DEFAULT_OP_NUM_POS(m_prefix, m_op_name, m_name, m_type) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                    \
		_RETURN(p_a._data.m_type);                              \
	};

#define DEFAULT_OP_NUM_VEC(m_prefix, m_op_name, m_name, m_op, m_type)                            \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                     \
		if (p_b.type == INT)                                                                     \
			_RETURN(p_a._data.m_type m_op p_b._data._int);                                       \
		if (p_b.type == REAL)                                                                    \
			_RETURN(p_a._data.m_type m_op p_b._data._real);                                      \
		if (p_b.type == VECTOR2)                                                                 \
			_RETURN(p_a._data.m_type m_op * reinterpret_cast<const Vector2 *>(p_b._data._mem));  \
		if (p_b.type == VECTOR2I)                                                                \
			_RETURN(p_a._data.m_type m_op * reinterpret_cast<const Vector2i *>(p_b._data._mem)); \
		if (p_b.type == VECTOR3)                                                                 \
			_RETURN(p_a._data.m_type m_op * reinterpret_cast<const Vector3 *>(p_b._data._mem));  \
		if (p_b.type == VECTOR3I)                                                                \
			_RETURN(p_a._data.m_type m_op * reinterpret_cast<const Vector3i *>(p_b._data._mem)); \
		if (p_b.type == VECTOR4)                                                                 \
			_RETURN(p_a._data.m_type m_op * reinterpret_cast<const Vector4 *>(p_b._data._mem));  \
		if (p_b.type == VECTOR4I)                                                                \
			_RETURN(p_a._data.m_type m_op * reinterpret_cast<const Vector4i *>(p_b._data._mem)); \
                                                                                                 \
		_RETURN_FAIL                                                                             \
	};

#define DEFAULT_OP_STR_REV(m_prefix, m_op_name, m_name, m_op, m_type)                                                               \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                        \
		if (p_b.type == STRING)                                                                                                     \
			_RETURN(*reinterpret_cast<const m_type *>(p_b._data._mem) m_op * reinterpret_cast<const String *>(p_a._data._mem));     \
		if (p_b.type == STRING_NAME)                                                                                                \
			_RETURN(*reinterpret_cast<const m_type *>(p_b._data._mem) m_op * reinterpret_cast<const StringName *>(p_a._data._mem)); \
                                                                                                                                    \
		_RETURN_FAIL                                                                                                                \
	};

#define DEFAULT_OP_STR(m_prefix, m_op_name, m_name, m_op, m_type)                                                                   \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                        \
		if (p_b.type == STRING)                                                                                                     \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const String *>(p_b._data._mem));     \
		if (p_b.type == STRING_NAME)                                                                                                \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const StringName *>(p_b._data._mem)); \
                                                                                                                                    \
		_RETURN_FAIL                                                                                                                \
	};

#define DEFAULT_OP_STR_NULL(m_prefix, m_op_name, m_name, m_op, m_type)                                                              \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                        \
		if (p_b.type == STRING)                                                                                                     \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const String *>(p_b._data._mem));     \
		if (p_b.type == STRING_NAME)                                                                                                \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const StringName *>(p_b._data._mem)); \
		if (p_b.type == NIL)                                                                                                        \
			_RETURN(!(p_b.type m_op NIL));                                                                                          \
                                                                                                                                    \
		_RETURN_FAIL                                                                                                                \
	};

#define DEFAULT_OP_STR_NULL_NP(m_prefix, m_op_name, m_name, m_op, m_type)                                                       \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                    \
		if (p_b.type == STRING)                                                                                                 \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const String *>(p_b._data._mem)); \
		if (p_b.type == NIL)                                                                                                    \
			_RETURN(!(p_b.type m_op NIL));                                                                                      \
                                                                                                                                \
		_RETURN_FAIL                                                                                                            \
	};

#define DEFAULT_OP_STR_NULL_SN(m_prefix, m_op_name, m_name, m_op, m_type)                                                           \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                        \
		if (p_b.type == STRING)                                                                                                     \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const String *>(p_b._data._mem));     \
		if (p_b.type == STRING_NAME)                                                                                                \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const StringName *>(p_b._data._mem)); \
		if (p_b.type == NIL)                                                                                                        \
			_RETURN(!(p_b.type m_op NIL));                                                                                          \
                                                                                                                                    \
		_RETURN_FAIL                                                                                                                \
	};

#define DEFAULT_OP_LOCALMEM_REV(m_prefix, m_op_name, m_name, m_op, m_type)                                                      \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                    \
		if (p_b.type == m_name)                                                                                                 \
			_RETURN(*reinterpret_cast<const m_type *>(p_b._data._mem) m_op * reinterpret_cast<const m_type *>(p_a._data._mem)); \
                                                                                                                                \
		_RETURN_FAIL                                                                                                            \
	};

#define DEFAULT_OP_LOCALMEM(m_prefix, m_op_name, m_name, m_op, m_type)                                                          \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                    \
		if (p_b.type == m_name)                                                                                                 \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const m_type *>(p_b._data._mem)); \
                                                                                                                                \
		_RETURN_FAIL                                                                                                            \
	};

#define DEFAULT_OP_LOCALMEM_NULL(m_prefix, m_op_name, m_name, m_op, m_type)                                                     \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                    \
		if (p_b.type == m_name)                                                                                                 \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const m_type *>(p_b._data._mem)); \
		if (p_b.type == NIL)                                                                                                    \
			_RETURN(!(p_b.type m_op NIL));                                                                                      \
                                                                                                                                \
		_RETURN_FAIL                                                                                                            \
	};

#define DEFAULT_OP_LOCALMEM_NEG(m_prefix, m_op_name, m_name, m_type) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                         \
		_RETURN(-*reinterpret_cast<const m_type *>(p_a._data._mem)); \
	}

#define DEFAULT_OP_LOCALMEM_POS(m_prefix, m_op_name, m_name, m_type) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                         \
		_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem));  \
	}

#define DEFAULT_OP_LOCALMEM_NUM(m_prefix, m_op_name, m_name, m_op, m_type)                                                      \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                                                    \
		if (p_b.type == m_name)                                                                                                 \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op * reinterpret_cast<const m_type *>(p_b._data._mem)); \
		if (p_b.type == INT)                                                                                                    \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op p_b._data._int);                                     \
		if (p_b.type == REAL)                                                                                                   \
			_RETURN(*reinterpret_cast<const m_type *>(p_a._data._mem) m_op p_b._data._real);                                    \
                                                                                                                                \
		_RETURN_FAIL                                                                                                            \
	}

#define DEFAULT_OP_PTR(m_op, m_name, m_sub)                \
	CASE_TYPE(m_prefix, m_op_name, m_name) {               \
		if (p_b.type == m_name)                            \
			_RETURN(p_a._data.m_sub m_op p_b._data.m_sub); \
                                                           \
		_RETURN_FAIL                                       \
	}

#define DEFAULT_OP_PTRREF(m_prefix, m_op_name, m_name, m_op, m_sub) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                        \
		if (p_b.type == m_name)                                     \
			_RETURN(*p_a._data.m_sub m_op * p_b._data.m_sub);       \
                                                                    \
		_RETURN_FAIL                                                \
	}

#define DEFAULT_OP_PTRREF_NULL(m_prefix, m_op_name, m_name, m_op, m_sub) \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                             \
		if (p_b.type == m_name)                                          \
			_RETURN(*p_a._data.m_sub m_op * p_b._data.m_sub);            \
		if (p_b.type == NIL)                                             \
			_RETURN(!(p_b.type m_op NIL));                               \
                                                                         \
		_RETURN_FAIL                                                     \
	}

#define DEFAULT_OP_ARRAY_EQ(m_prefix, m_op_name, m_name, m_type)                                  \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                      \
		if (p_b.type == NIL)                                                                      \
			_RETURN(false)                                                                        \
		DEFAULT_OP_ARRAY_OP_BODY(m_prefix, m_op_name, m_name, m_type, !=, !=, true, false, false) \
	}

#define DEFAULT_OP_ARRAY_NEQ(m_prefix, m_op_name, m_name, m_type)                                \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                     \
		if (p_b.type == NIL)                                                                     \
			_RETURN(true)                                                                        \
		DEFAULT_OP_ARRAY_OP_BODY(m_prefix, m_op_name, m_name, m_type, !=, !=, false, true, true) \
	}

#define DEFAULT_OP_ARRAY_LT(m_prefix, m_op_name, m_name, m_type) \
	DEFAULT_OP_ARRAY_OP(m_prefix, m_op_name, m_name, m_type, <, !=, false, a_len < array_b.size(), true)

#define DEFAULT_OP_ARRAY_GT(m_prefix, m_op_name, m_name, m_type) \
	DEFAULT_OP_ARRAY_OP(m_prefix, m_op_name, m_name, m_type, >, !=, false, a_len < array_b.size(), true)

#define DEFAULT_OP_ARRAY_OP(m_prefix, m_op_name, m_name, m_type, m_opa, m_opb, m_ret_def, m_ret_s, m_ret_f)      \
	CASE_TYPE(m_prefix, m_op_name, m_name){                                                                      \
		DEFAULT_OP_ARRAY_OP_BODY(m_prefix, m_op_name, m_name, m_type, m_opa, m_opb, m_ret_def, m_ret_s, m_ret_f) \
	}

#define DEFAULT_OP_ARRAY_OP_BODY(m_prefix, m_op_name, m_name, m_type, m_opa, m_opb, m_ret_def, m_ret_s, m_ret_f) \
	if (p_a.type != p_b.type)                                                                                    \
		_RETURN_FAIL                                                                                             \
                                                                                                                 \
	const PoolVector<m_type> &array_a = *reinterpret_cast<const PoolVector<m_type> *>(p_a._data._mem);           \
	const PoolVector<m_type> &array_b = *reinterpret_cast<const PoolVector<m_type> *>(p_b._data._mem);           \
                                                                                                                 \
	int a_len = array_a.size();                                                                                  \
	if (a_len m_opa array_b.size()) {                                                                            \
		_RETURN(m_ret_s);                                                                                        \
	} else {                                                                                                     \
		PoolVector<m_type>::Read ra = array_a.read();                                                            \
		PoolVector<m_type>::Read rb = array_b.read();                                                            \
                                                                                                                 \
		for (int i = 0; i < a_len; i++) {                                                                        \
			if (ra[i] m_opb rb[i])                                                                               \
				_RETURN(m_ret_f);                                                                                \
		}                                                                                                        \
                                                                                                                 \
		_RETURN(m_ret_def);                                                                                      \
	}

#define DEFAULT_OP_ARRAY_ADD(m_prefix, m_op_name, m_name, m_type)                                          \
	CASE_TYPE(m_prefix, m_op_name, m_name) {                                                               \
		if (p_a.type != p_b.type)                                                                          \
			_RETURN_FAIL;                                                                                  \
                                                                                                           \
		const PoolVector<m_type> &array_a = *reinterpret_cast<const PoolVector<m_type> *>(p_a._data._mem); \
		const PoolVector<m_type> &array_b = *reinterpret_cast<const PoolVector<m_type> *>(p_b._data._mem); \
		PoolVector<m_type> sum = array_a;                                                                  \
		sum.append_array(array_b);                                                                         \
		_RETURN(sum);                                                                                      \
	}

void Variant::evaluate(const Operator &p_op, const Variant &p_a,
		const Variant &p_b, Variant &r_ret, bool &r_valid) {
	CASES(math);
	r_valid = true;

	SWITCH(math, p_op, p_a.type) {
		SWITCH_OP(math, OP_EQUAL, p_a.type) {
			CASE_TYPE(math, OP_EQUAL, NIL) {
				if (p_b.type == NIL)
					_RETURN(true);
				if (p_b.type == OBJECT)
					_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_b) == nullptr);

				_RETURN(false);
			}

			CASE_TYPE(math, OP_EQUAL, BOOL) {
				if (p_b.type != BOOL) {
					if (p_b.type == NIL)
						_RETURN(false);
					_RETURN_FAIL;
				}

				_RETURN(p_a._data._bool == p_b._data._bool);
			}

			CASE_TYPE(math, OP_EQUAL, OBJECT) {
				if (p_b.type == OBJECT)
					_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_a) == _UNSAFE_OBJ_PROXY_PTR(p_b));
				if (p_b.type == NIL)
					_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_a) == nullptr);

				_RETURN_FAIL;
			}

			CASE_TYPE(math, OP_EQUAL, DICTIONARY) {
				if (p_b.type != DICTIONARY) {
					if (p_b.type == NIL)
						_RETURN(false);
					_RETURN_FAIL;
				}

				const Dictionary *arr_a = reinterpret_cast<const Dictionary *>(p_a._data._mem);
				const Dictionary *arr_b = reinterpret_cast<const Dictionary *>(p_b._data._mem);

				_RETURN(*arr_a == *arr_b);
			}

			CASE_TYPE(math, OP_EQUAL, ARRAY) {
				if (p_b.type != ARRAY) {
					if (p_b.type == NIL)
						_RETURN(false);
					_RETURN_FAIL;
				}
				const Array *arr_a = reinterpret_cast<const Array *>(p_a._data._mem);
				const Array *arr_b = reinterpret_cast<const Array *>(p_b._data._mem);

				int l = arr_a->size();
				if (arr_b->size() != l)
					_RETURN(false);
				for (int i = 0; i < l; i++) {
					if (!((*arr_a)[i] == (*arr_b)[i])) {
						_RETURN(false);
					}
				}

				_RETURN(true);
			}

			DEFAULT_OP_NUM_NULL(math, OP_EQUAL, INT, ==, _int);
			DEFAULT_OP_NUM_NULL(math, OP_EQUAL, REAL, ==, _real);
			DEFAULT_OP_STR_NULL(math, OP_EQUAL, STRING, ==, String);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, RECT2, ==, Rect2);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, RECT2I, ==, Rect2i);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, VECTOR2, ==, Vector2);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, VECTOR2I, ==, Vector2i);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, VECTOR3, ==, Vector3);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, VECTOR3I, ==, Vector3i);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, VECTOR4, ==, Vector4);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, VECTOR4I, ==, Vector4i);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, PLANE, ==, Plane);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, QUATERNION, ==, Quaternion);
			DEFAULT_OP_PTRREF_NULL(math, OP_EQUAL, AABB, ==, _aabb);
			DEFAULT_OP_PTRREF_NULL(math, OP_EQUAL, BASIS, ==, _basis);
			DEFAULT_OP_PTRREF_NULL(math, OP_EQUAL, TRANSFORM, ==, _transform);
			DEFAULT_OP_PTRREF_NULL(math, OP_EQUAL, TRANSFORM2D, ==, _transform2d);
			DEFAULT_OP_PTRREF_NULL(math, OP_EQUAL, PROJECTION, ==, _projection);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_EQUAL, COLOR, ==, Color);
			DEFAULT_OP_STR_NULL_SN(math, OP_EQUAL, STRING_NAME, ==, StringName);

			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_BYTE_ARRAY, uint8_t);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_INT_ARRAY, int);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_REAL_ARRAY, real_t);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_STRING_ARRAY, String);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_VECTOR2_ARRAY, Vector2);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_VECTOR2I_ARRAY, Vector2i);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_VECTOR3_ARRAY, Vector3);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_VECTOR3I_ARRAY, Vector3i);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_VECTOR4_ARRAY, Vector4);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_VECTOR4I_ARRAY, Vector4i);
			DEFAULT_OP_ARRAY_EQ(math, OP_EQUAL, POOL_COLOR_ARRAY, Color);
		}

		SWITCH_OP(math, OP_NOT_EQUAL, p_a.type) {
			CASE_TYPE(math, OP_NOT_EQUAL, NIL) {
				if (p_b.type == NIL)
					_RETURN(false);
				if (p_b.type == OBJECT)
					_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_b) != nullptr);

				_RETURN(true);
			}

			CASE_TYPE(math, OP_NOT_EQUAL, BOOL) {
				if (p_b.type != BOOL) {
					if (p_b.type == NIL)
						_RETURN(true);

					_RETURN_FAIL;
				}

				_RETURN(p_a._data._bool != p_b._data._bool);
			}

			CASE_TYPE(math, OP_NOT_EQUAL, OBJECT) {
				if (p_b.type == OBJECT)
					_RETURN((_UNSAFE_OBJ_PROXY_PTR(p_a) != _UNSAFE_OBJ_PROXY_PTR(p_b)));
				if (p_b.type == NIL)
					_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_a) != nullptr);

				_RETURN_FAIL;
			}

			CASE_TYPE(math, OP_NOT_EQUAL, DICTIONARY) {
				if (p_b.type != DICTIONARY) {
					if (p_b.type == NIL)
						_RETURN(true);
					_RETURN_FAIL;
				}

				const Dictionary *arr_a = reinterpret_cast<const Dictionary *>(p_a._data._mem);
				const Dictionary *arr_b = reinterpret_cast<const Dictionary *>(p_b._data._mem);

				_RETURN(*arr_a != *arr_b);
			}

			CASE_TYPE(math, OP_NOT_EQUAL, ARRAY) {
				if (p_b.type != ARRAY) {
					if (p_b.type == NIL)
						_RETURN(true);

					_RETURN_FAIL;
				}

				const Array *arr_a = reinterpret_cast<const Array *>(p_a._data._mem);
				const Array *arr_b = reinterpret_cast<const Array *>(p_b._data._mem);

				int l = arr_a->size();
				if (arr_b->size() != l)
					_RETURN(true);
				for (int i = 0; i < l; i++) {
					if (((*arr_a)[i] != (*arr_b)[i])) {
						_RETURN(true);
					}
				}

				_RETURN(false);
			}

			DEFAULT_OP_NUM_NULL(math, OP_NOT_EQUAL, INT, !=, _int);
			DEFAULT_OP_NUM_NULL(math, OP_NOT_EQUAL, REAL, !=, _real);
			DEFAULT_OP_STR_NULL(math, OP_NOT_EQUAL, STRING, !=, String);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, RECT2, !=, Rect2);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, RECT2I, !=, Rect2i);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, VECTOR2, !=, Vector2);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, VECTOR2I, !=, Vector2i);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, VECTOR3, !=, Vector3);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, VECTOR3I, !=, Vector3i);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, VECTOR4, !=, Vector4);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, VECTOR4I, !=, Vector4i);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, PLANE, !=, Plane);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, QUATERNION, !=, Quaternion);
			DEFAULT_OP_PTRREF_NULL(math, OP_NOT_EQUAL, AABB, !=, _aabb);
			DEFAULT_OP_PTRREF_NULL(math, OP_NOT_EQUAL, BASIS, !=, _basis);
			DEFAULT_OP_PTRREF_NULL(math, OP_NOT_EQUAL, TRANSFORM, !=, _transform);
			DEFAULT_OP_PTRREF_NULL(math, OP_NOT_EQUAL, TRANSFORM2D, !=, _transform2d);
			DEFAULT_OP_PTRREF_NULL(math, OP_NOT_EQUAL, PROJECTION, !=, _projection);
			DEFAULT_OP_LOCALMEM_NULL(math, OP_NOT_EQUAL, COLOR, !=, Color);
			DEFAULT_OP_STR_NULL_SN(math, OP_NOT_EQUAL, STRING_NAME, !=, StringName);

			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_BYTE_ARRAY, uint8_t);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_INT_ARRAY, int);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_REAL_ARRAY, real_t);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_STRING_ARRAY, String);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_VECTOR2_ARRAY, Vector2);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_VECTOR2I_ARRAY, Vector2i);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_VECTOR3_ARRAY, Vector3);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_VECTOR3I_ARRAY, Vector3i);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_VECTOR4_ARRAY, Vector4);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_VECTOR4I_ARRAY, Vector4i);
			DEFAULT_OP_ARRAY_NEQ(math, OP_NOT_EQUAL, POOL_COLOR_ARRAY, Color);
		}

		SWITCH_OP(math, OP_LESS, p_a.type) {
			CASE_TYPE(math, OP_LESS, BOOL) {
				if (p_b.type != BOOL)
					_RETURN_FAIL;

				if (p_a._data._bool == p_b._data._bool)
					_RETURN(false);

				if (p_a._data._bool && !p_b._data._bool)
					_RETURN(false);

				_RETURN(true);
			}

			CASE_TYPE(math, OP_LESS, OBJECT) {
				if (p_b.type != OBJECT)
					_RETURN_FAIL;
				_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_a) < _UNSAFE_OBJ_PROXY_PTR(p_b));
			}

			CASE_TYPE(math, OP_LESS, ARRAY) {
				if (p_b.type != ARRAY)
					_RETURN_FAIL;

				const Array *arr_a = reinterpret_cast<const Array *>(p_a._data._mem);
				const Array *arr_b = reinterpret_cast<const Array *>(p_b._data._mem);

				int l = arr_a->size();
				if (arr_b->size() < l)
					_RETURN(false);
				for (int i = 0; i < l; i++) {
					if (!((*arr_a)[i] < (*arr_b)[i])) {
						_RETURN(true);
					}
				}

				_RETURN(false);
			}

			DEFAULT_OP_NUM(math, OP_LESS, INT, <, _int);
			DEFAULT_OP_NUM(math, OP_LESS, REAL, <, _real);
			DEFAULT_OP_STR(math, OP_LESS, STRING, <, String);
			DEFAULT_OP_LOCALMEM(math, OP_LESS, VECTOR2, <, Vector2);
			DEFAULT_OP_LOCALMEM(math, OP_LESS, VECTOR2I, <, Vector2i);
			DEFAULT_OP_LOCALMEM(math, OP_LESS, VECTOR3, <, Vector3);
			DEFAULT_OP_LOCALMEM(math, OP_LESS, VECTOR3I, <, Vector3i);
			DEFAULT_OP_LOCALMEM(math, OP_LESS, VECTOR4, <, Vector4);
			DEFAULT_OP_LOCALMEM(math, OP_LESS, VECTOR4I, <, Vector4i);

			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_BYTE_ARRAY, uint8_t);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_INT_ARRAY, int);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_REAL_ARRAY, real_t);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_STRING_ARRAY, String);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_VECTOR2_ARRAY, Vector2);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_VECTOR2I_ARRAY, Vector2i);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_VECTOR3_ARRAY, Vector3);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_VECTOR3I_ARRAY, Vector3i);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_VECTOR4_ARRAY, Vector4);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_VECTOR4I_ARRAY, Vector4i);
			DEFAULT_OP_ARRAY_LT(math, OP_LESS, POOL_COLOR_ARRAY, Color);

			CASE_TYPE(math, OP_LESS, NIL)
			CASE_TYPE(math, OP_LESS, RECT2)
			CASE_TYPE(math, OP_LESS, RECT2I)
			CASE_TYPE(math, OP_LESS, PLANE)
			CASE_TYPE(math, OP_LESS, QUATERNION)
			CASE_TYPE(math, OP_LESS, AABB)
			CASE_TYPE(math, OP_LESS, BASIS)
			CASE_TYPE(math, OP_LESS, TRANSFORM)
			CASE_TYPE(math, OP_LESS, TRANSFORM2D)
			CASE_TYPE(math, OP_LESS, PROJECTION)
			CASE_TYPE(math, OP_LESS, STRING_NAME)
			CASE_TYPE(math, OP_LESS, COLOR)
			CASE_TYPE(math, OP_LESS, DICTIONARY)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_LESS_EQUAL, p_a.type) {
			CASE_TYPE(math, OP_LESS_EQUAL, OBJECT) {
				if (p_b.type != OBJECT)
					_RETURN_FAIL;
				_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_a) <= _UNSAFE_OBJ_PROXY_PTR(p_b));
			}

			DEFAULT_OP_NUM(math, OP_LESS_EQUAL, INT, <=, _int);
			DEFAULT_OP_NUM(math, OP_LESS_EQUAL, REAL, <=, _real);
			DEFAULT_OP_STR(math, OP_LESS_EQUAL, STRING, <=, String);
			DEFAULT_OP_LOCALMEM(math, OP_LESS_EQUAL, VECTOR2, <=, Vector2);
			DEFAULT_OP_LOCALMEM(math, OP_LESS_EQUAL, VECTOR2I, <=, Vector2i);
			DEFAULT_OP_LOCALMEM(math, OP_LESS_EQUAL, VECTOR3, <=, Vector3);
			DEFAULT_OP_LOCALMEM(math, OP_LESS_EQUAL, VECTOR3I, <=, Vector3i);
			DEFAULT_OP_LOCALMEM(math, OP_LESS_EQUAL, VECTOR4, <=, Vector4);
			DEFAULT_OP_LOCALMEM(math, OP_LESS_EQUAL, VECTOR4I, <=, Vector4i);

			CASE_TYPE(math, OP_LESS_EQUAL, NIL)
			CASE_TYPE(math, OP_LESS_EQUAL, BOOL)
			CASE_TYPE(math, OP_LESS_EQUAL, RECT2)
			CASE_TYPE(math, OP_LESS_EQUAL, RECT2I)
			CASE_TYPE(math, OP_LESS_EQUAL, PLANE)
			CASE_TYPE(math, OP_LESS_EQUAL, QUATERNION)
			CASE_TYPE(math, OP_LESS_EQUAL, AABB)
			CASE_TYPE(math, OP_LESS_EQUAL, BASIS)
			CASE_TYPE(math, OP_LESS_EQUAL, TRANSFORM)
			CASE_TYPE(math, OP_LESS_EQUAL, TRANSFORM2D)
			CASE_TYPE(math, OP_LESS_EQUAL, PROJECTION)
			CASE_TYPE(math, OP_LESS_EQUAL, COLOR)
			CASE_TYPE(math, OP_LESS_EQUAL, STRING_NAME)
			CASE_TYPE(math, OP_LESS_EQUAL, DICTIONARY)
			CASE_TYPE(math, OP_LESS_EQUAL, ARRAY)
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_BYTE_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_INT_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_REAL_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_STRING_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_VECTOR2_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_VECTOR2I_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_VECTOR3_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_VECTOR3I_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_VECTOR4_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_VECTOR4I_ARRAY);
			CASE_TYPE(math, OP_LESS_EQUAL, POOL_COLOR_ARRAY);
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_GREATER, p_a.type) {
			CASE_TYPE(math, OP_GREATER, BOOL) {
				if (p_b.type != BOOL)
					_RETURN_FAIL;

				if (p_a._data._bool == p_b._data._bool)
					_RETURN(false);

				if (!p_a._data._bool && p_b._data._bool)
					_RETURN(false);

				_RETURN(true);
			}

			CASE_TYPE(math, OP_GREATER, OBJECT) {
				if (p_b.type != OBJECT)
					_RETURN_FAIL;
				_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_a) > _UNSAFE_OBJ_PROXY_PTR(p_b));
			}

			CASE_TYPE(math, OP_GREATER, ARRAY) {
				if (p_b.type != ARRAY)
					_RETURN_FAIL;

				const Array *arr_a = reinterpret_cast<const Array *>(p_a._data._mem);
				const Array *arr_b = reinterpret_cast<const Array *>(p_b._data._mem);

				int l = arr_a->size();
				if (arr_b->size() > l)
					_RETURN(false);
				for (int i = 0; i < l; i++) {
					if (((*arr_a)[i] < (*arr_b)[i])) {
						_RETURN(false);
					}
				}

				_RETURN(true);
			}

			DEFAULT_OP_NUM(math, OP_GREATER, INT, >, _int);
			DEFAULT_OP_NUM(math, OP_GREATER, REAL, >, _real);
			DEFAULT_OP_STR_REV(math, OP_GREATER, STRING, <, String);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER, VECTOR2, <, Vector2);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER, VECTOR2I, <, Vector2i);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER, VECTOR3, <, Vector3);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER, VECTOR3I, <, Vector3i);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER, VECTOR4, <, Vector4);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER, VECTOR4I, <, Vector4i);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_BYTE_ARRAY, uint8_t);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_INT_ARRAY, int);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_REAL_ARRAY, real_t);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_STRING_ARRAY, String);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_VECTOR2_ARRAY, Vector2);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_VECTOR2I_ARRAY, Vector2i);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_VECTOR3_ARRAY, Vector3);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_VECTOR3I_ARRAY, Vector3i);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_VECTOR4_ARRAY, Vector4);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_VECTOR4I_ARRAY, Vector4i);
			DEFAULT_OP_ARRAY_GT(math, OP_GREATER, POOL_COLOR_ARRAY, Color);

			CASE_TYPE(math, OP_GREATER, NIL)
			CASE_TYPE(math, OP_GREATER, RECT2)
			CASE_TYPE(math, OP_GREATER, RECT2I)
			CASE_TYPE(math, OP_GREATER, PLANE)
			CASE_TYPE(math, OP_GREATER, QUATERNION)
			CASE_TYPE(math, OP_GREATER, AABB)
			CASE_TYPE(math, OP_GREATER, BASIS)
			CASE_TYPE(math, OP_GREATER, STRING_NAME)
			CASE_TYPE(math, OP_GREATER, TRANSFORM)
			CASE_TYPE(math, OP_GREATER, TRANSFORM2D)
			CASE_TYPE(math, OP_GREATER, PROJECTION)
			CASE_TYPE(math, OP_GREATER, COLOR)
			CASE_TYPE(math, OP_GREATER, DICTIONARY)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_GREATER_EQUAL, p_a.type) {
			CASE_TYPE(math, OP_GREATER_EQUAL, OBJECT) {
				if (p_b.type != OBJECT)
					_RETURN_FAIL;
				_RETURN(_UNSAFE_OBJ_PROXY_PTR(p_a) >= _UNSAFE_OBJ_PROXY_PTR(p_b));
			}

			DEFAULT_OP_NUM(math, OP_GREATER_EQUAL, INT, >=, _int);
			DEFAULT_OP_NUM(math, OP_GREATER_EQUAL, REAL, >=, _real);
			DEFAULT_OP_STR_REV(math, OP_GREATER_EQUAL, STRING, <=, String);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER_EQUAL, VECTOR2, <=, Vector2);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER_EQUAL, VECTOR2I, <=, Vector2i);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER_EQUAL, VECTOR3, <=, Vector3);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER_EQUAL, VECTOR3I, <=, Vector3i);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER_EQUAL, VECTOR4, <=, Vector4);
			DEFAULT_OP_LOCALMEM_REV(math, OP_GREATER_EQUAL, VECTOR4I, <=, Vector4i);

			CASE_TYPE(math, OP_GREATER_EQUAL, NIL)
			CASE_TYPE(math, OP_GREATER_EQUAL, BOOL)
			CASE_TYPE(math, OP_GREATER_EQUAL, RECT2)
			CASE_TYPE(math, OP_GREATER_EQUAL, RECT2I)
			CASE_TYPE(math, OP_GREATER_EQUAL, PLANE)
			CASE_TYPE(math, OP_GREATER_EQUAL, QUATERNION)
			CASE_TYPE(math, OP_GREATER_EQUAL, AABB)
			CASE_TYPE(math, OP_GREATER_EQUAL, BASIS)
			CASE_TYPE(math, OP_GREATER_EQUAL, TRANSFORM)
			CASE_TYPE(math, OP_GREATER_EQUAL, TRANSFORM2D)
			CASE_TYPE(math, OP_GREATER_EQUAL, PROJECTION)
			CASE_TYPE(math, OP_GREATER_EQUAL, COLOR)
			CASE_TYPE(math, OP_GREATER_EQUAL, DICTIONARY)
			CASE_TYPE(math, OP_GREATER_EQUAL, STRING_NAME)
			CASE_TYPE(math, OP_GREATER_EQUAL, ARRAY)
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_BYTE_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_INT_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_REAL_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_STRING_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_VECTOR2_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_VECTOR2I_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_VECTOR3_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_VECTOR3I_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_VECTOR4_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_VECTOR4I_ARRAY);
			CASE_TYPE(math, OP_GREATER_EQUAL, POOL_COLOR_ARRAY);
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_ADD, p_a.type) {
			CASE_TYPE(math, OP_ADD, ARRAY) {
				if (p_a.type != p_b.type)
					_RETURN_FAIL;

				const Array &array_a = *reinterpret_cast<const Array *>(p_a._data._mem);
				const Array &array_b = *reinterpret_cast<const Array *>(p_b._data._mem);
				Array sum;
				int asize = array_a.size();
				int bsize = array_b.size();
				sum.resize(asize + bsize);
				for (int i = 0; i < asize; i++) {
					sum[i] = array_a[i];
				}
				for (int i = 0; i < bsize; i++) {
					sum[i + asize] = array_b[i];
				}
				_RETURN(sum);
			}

			DEFAULT_OP_NUM(math, OP_ADD, INT, +, _int);
			DEFAULT_OP_NUM(math, OP_ADD, REAL, +, _real);
			DEFAULT_OP_STR(math, OP_ADD, STRING, +, String);
			DEFAULT_OP_LOCALMEM(math, OP_ADD, VECTOR2, +, Vector2);
			DEFAULT_OP_LOCALMEM(math, OP_ADD, VECTOR2I, +, Vector2i);
			DEFAULT_OP_LOCALMEM(math, OP_ADD, VECTOR3, +, Vector3);
			DEFAULT_OP_LOCALMEM(math, OP_ADD, VECTOR3I, +, Vector3i);
			DEFAULT_OP_LOCALMEM(math, OP_ADD, VECTOR4, +, Vector4);
			DEFAULT_OP_LOCALMEM(math, OP_ADD, VECTOR4I, +, Vector4i);
			DEFAULT_OP_LOCALMEM(math, OP_ADD, QUATERNION, +, Quaternion);
			DEFAULT_OP_LOCALMEM(math, OP_ADD, COLOR, +, Color);

			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_BYTE_ARRAY, uint8_t);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_INT_ARRAY, int);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_REAL_ARRAY, real_t);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_STRING_ARRAY, String);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_VECTOR2_ARRAY, Vector2);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_VECTOR2I_ARRAY, Vector2i);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_VECTOR3_ARRAY, Vector3);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_VECTOR3I_ARRAY, Vector3i);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_VECTOR4_ARRAY, Vector4);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_VECTOR4I_ARRAY, Vector4i);
			DEFAULT_OP_ARRAY_ADD(math, OP_ADD, POOL_COLOR_ARRAY, Color);

			CASE_TYPE(math, OP_ADD, NIL)
			CASE_TYPE(math, OP_ADD, BOOL)
			CASE_TYPE(math, OP_ADD, RECT2)
			CASE_TYPE(math, OP_ADD, RECT2I)
			CASE_TYPE(math, OP_ADD, PLANE)
			CASE_TYPE(math, OP_ADD, AABB)
			CASE_TYPE(math, OP_ADD, BASIS)
			CASE_TYPE(math, OP_ADD, TRANSFORM)
			CASE_TYPE(math, OP_ADD, TRANSFORM2D)
			CASE_TYPE(math, OP_ADD, PROJECTION)
			CASE_TYPE(math, OP_ADD, OBJECT)
			CASE_TYPE(math, OP_ADD, DICTIONARY)
			CASE_TYPE(math, OP_ADD, STRING_NAME)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_SUBTRACT, p_a.type) {
			DEFAULT_OP_NUM(math, OP_SUBTRACT, INT, -, _int);
			DEFAULT_OP_NUM(math, OP_SUBTRACT, REAL, -, _real);
			DEFAULT_OP_LOCALMEM(math, OP_SUBTRACT, VECTOR2, -, Vector2);
			DEFAULT_OP_LOCALMEM(math, OP_SUBTRACT, VECTOR2I, -, Vector2i);
			DEFAULT_OP_LOCALMEM(math, OP_SUBTRACT, VECTOR3, -, Vector3);
			DEFAULT_OP_LOCALMEM(math, OP_SUBTRACT, VECTOR3I, -, Vector3i);
			DEFAULT_OP_LOCALMEM(math, OP_SUBTRACT, VECTOR4, -, Vector4);
			DEFAULT_OP_LOCALMEM(math, OP_SUBTRACT, VECTOR4I, -, Vector4i);
			DEFAULT_OP_LOCALMEM(math, OP_SUBTRACT, QUATERNION, -, Quaternion);
			DEFAULT_OP_LOCALMEM(math, OP_SUBTRACT, COLOR, -, Color);

			CASE_TYPE(math, OP_SUBTRACT, NIL)
			CASE_TYPE(math, OP_SUBTRACT, BOOL)
			CASE_TYPE(math, OP_SUBTRACT, STRING)
			CASE_TYPE(math, OP_SUBTRACT, RECT2)
			CASE_TYPE(math, OP_SUBTRACT, RECT2I)
			CASE_TYPE(math, OP_SUBTRACT, PLANE)
			CASE_TYPE(math, OP_SUBTRACT, AABB)
			CASE_TYPE(math, OP_SUBTRACT, BASIS)
			CASE_TYPE(math, OP_SUBTRACT, TRANSFORM)
			CASE_TYPE(math, OP_SUBTRACT, TRANSFORM2D)
			CASE_TYPE(math, OP_SUBTRACT, PROJECTION)
			CASE_TYPE(math, OP_SUBTRACT, OBJECT)
			CASE_TYPE(math, OP_SUBTRACT, STRING_NAME)
			CASE_TYPE(math, OP_SUBTRACT, DICTIONARY)
			CASE_TYPE(math, OP_SUBTRACT, ARRAY)
			CASE_TYPE(math, OP_SUBTRACT, POOL_BYTE_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_INT_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_REAL_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_STRING_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_VECTOR2_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_VECTOR2I_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_VECTOR3_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_VECTOR3I_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_VECTOR4_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_VECTOR4I_ARRAY);
			CASE_TYPE(math, OP_SUBTRACT, POOL_COLOR_ARRAY);
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_MULTIPLY, p_a.type) {
			CASE_TYPE(math, OP_MULTIPLY, QUATERNION) {
				switch (p_b.type) {
					case VECTOR3: {
						_RETURN(reinterpret_cast<const Quaternion *>(p_a._data._mem)->xform(*(const Vector3 *)p_b._data._mem));
					}
					case VECTOR3I: {
						_RETURN(reinterpret_cast<const Quaternion *>(p_a._data._mem)->xform(*(const Vector3i *)p_b._data._mem));
					}
					case QUATERNION: {
						_RETURN(*reinterpret_cast<const Quaternion *>(p_a._data._mem) * *reinterpret_cast<const Quaternion *>(p_b._data._mem));
					}
					case REAL: {
						_RETURN(*reinterpret_cast<const Quaternion *>(p_a._data._mem) * p_b._data._real);
					}
					default:
						_RETURN_FAIL;
				}
			}

			CASE_TYPE(math, OP_MULTIPLY, BASIS) {
				switch (p_b.type) {
					case VECTOR3: {
						_RETURN(p_a._data._basis->xform(*(const Vector3 *)p_b._data._mem));
					}
					case VECTOR3I: {
						_RETURN(p_a._data._basis->xform(*(const Vector3i *)p_b._data._mem));
					}
					case BASIS: {
						_RETURN(*p_a._data._basis * *p_b._data._basis);
					}
					default:
						_RETURN_FAIL;
				}
			}

			CASE_TYPE(math, OP_MULTIPLY, TRANSFORM) {
				switch (p_b.type) {
					case VECTOR3: {
						_RETURN(p_a._data._transform->xform(*(const Vector3 *)p_b._data._mem));
					}
					case VECTOR3I: {
						_RETURN(p_a._data._transform->xform(*(const Vector3i *)p_b._data._mem));
					}
					case TRANSFORM: {
						_RETURN(*p_a._data._transform * *p_b._data._transform);
					}
					default:
						_RETURN_FAIL;
				}
			}

			CASE_TYPE(math, OP_MULTIPLY, TRANSFORM2D) {
				switch (p_b.type) {
					case TRANSFORM2D: {
						_RETURN(*p_a._data._transform2d * *p_b._data._transform2d);
					}
					case VECTOR2: {
						_RETURN(p_a._data._transform2d->xform(*(const Vector2 *)p_b._data._mem));
					}
					case VECTOR2I: {
						_RETURN(p_a._data._transform2d->xform(*(const Vector2i *)p_b._data._mem));
					}
					default:
						_RETURN_FAIL;
				}
			}

			CASE_TYPE(math, OP_MULTIPLY, PROJECTION) {
				switch (p_b.type) {
					case VECTOR4: {
						_RETURN(p_a._data._projection->xform(*(const Vector4 *)p_b._data._mem));
					}
					case VECTOR3: {
						_RETURN(p_a._data._projection->xform(*(const Vector3 *)p_b._data._mem));
					}
					case PLANE: {
						_RETURN(p_a._data._projection->xform(*(const Plane *)p_b._data._mem));
					}
					case PROJECTION: {
						_RETURN(p_a._data._projection->operator*(*(const Projection *)p_b._data._mem));
					}
					default:
						_RETURN_FAIL;
				}
			}

			DEFAULT_OP_NUM_VEC(math, OP_MULTIPLY, INT, *, _int);
			DEFAULT_OP_NUM_VEC(math, OP_MULTIPLY, REAL, *, _real);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_MULTIPLY, VECTOR2, *, Vector2);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_MULTIPLY, VECTOR2I, *, Vector2i);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_MULTIPLY, VECTOR3, *, Vector3);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_MULTIPLY, VECTOR3I, *, Vector3i);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_MULTIPLY, VECTOR4, *, Vector4);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_MULTIPLY, VECTOR4I, *, Vector4i);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_MULTIPLY, COLOR, *, Color);

			CASE_TYPE(math, OP_MULTIPLY, NIL)
			CASE_TYPE(math, OP_MULTIPLY, BOOL)
			CASE_TYPE(math, OP_MULTIPLY, STRING)
			CASE_TYPE(math, OP_MULTIPLY, RECT2)
			CASE_TYPE(math, OP_MULTIPLY, RECT2I)
			CASE_TYPE(math, OP_MULTIPLY, PLANE)
			CASE_TYPE(math, OP_MULTIPLY, AABB)
			CASE_TYPE(math, OP_MULTIPLY, OBJECT)
			CASE_TYPE(math, OP_MULTIPLY, STRING_NAME)
			CASE_TYPE(math, OP_MULTIPLY, DICTIONARY)
			CASE_TYPE(math, OP_MULTIPLY, ARRAY)
			CASE_TYPE(math, OP_MULTIPLY, POOL_BYTE_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_INT_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_REAL_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_STRING_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_VECTOR2_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_VECTOR2I_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_VECTOR3_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_VECTOR3I_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_VECTOR4_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_VECTOR4I_ARRAY);
			CASE_TYPE(math, OP_MULTIPLY, POOL_COLOR_ARRAY);
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_DIVIDE, p_a.type) {
			CASE_TYPE(math, OP_DIVIDE, QUATERNION) {
				if (p_b.type != REAL)
					_RETURN_FAIL;
#ifdef DEBUG_ENABLED
				if (p_b._data._real == 0) {
					r_valid = false;
					_RETURN("Division By Zero");
				}
#endif
				_RETURN(*reinterpret_cast<const Quaternion *>(p_a._data._mem) / p_b._data._real);
			}

			DEFAULT_OP_NUM_DIV(math, OP_DIVIDE, INT, _int);
			DEFAULT_OP_NUM_DIV(math, OP_DIVIDE, REAL, _real);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_DIVIDE, VECTOR2, /, Vector2);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_DIVIDE, VECTOR2I, /, Vector2i);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_DIVIDE, VECTOR3, /, Vector3);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_DIVIDE, VECTOR3I, /, Vector3i);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_DIVIDE, VECTOR4, /, Vector4);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_DIVIDE, VECTOR4I, /, Vector4i);
			DEFAULT_OP_LOCALMEM_NUM(math, OP_DIVIDE, COLOR, /, Color);

			CASE_TYPE(math, OP_DIVIDE, NIL)
			CASE_TYPE(math, OP_DIVIDE, BOOL)
			CASE_TYPE(math, OP_DIVIDE, STRING)
			CASE_TYPE(math, OP_DIVIDE, RECT2)
			CASE_TYPE(math, OP_DIVIDE, RECT2I)
			CASE_TYPE(math, OP_DIVIDE, PLANE)
			CASE_TYPE(math, OP_DIVIDE, AABB)
			CASE_TYPE(math, OP_DIVIDE, BASIS)
			CASE_TYPE(math, OP_DIVIDE, TRANSFORM)
			CASE_TYPE(math, OP_DIVIDE, TRANSFORM2D)
			CASE_TYPE(math, OP_DIVIDE, PROJECTION)
			CASE_TYPE(math, OP_DIVIDE, OBJECT)
			CASE_TYPE(math, OP_DIVIDE, STRING_NAME)
			CASE_TYPE(math, OP_DIVIDE, DICTIONARY)
			CASE_TYPE(math, OP_DIVIDE, ARRAY)
			CASE_TYPE(math, OP_DIVIDE, POOL_BYTE_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_INT_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_REAL_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_STRING_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_VECTOR2_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_VECTOR2I_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_VECTOR3_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_VECTOR3I_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_VECTOR4_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_VECTOR4I_ARRAY);
			CASE_TYPE(math, OP_DIVIDE, POOL_COLOR_ARRAY);
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_POSITIVE, p_a.type) {
			DEFAULT_OP_NUM_POS(math, OP_POSITIVE, INT, _int);
			DEFAULT_OP_NUM_POS(math, OP_POSITIVE, REAL, _real);
			DEFAULT_OP_LOCALMEM_POS(math, OP_POSITIVE, VECTOR2, Vector2);
			DEFAULT_OP_LOCALMEM_POS(math, OP_POSITIVE, VECTOR2I, Vector2i);
			DEFAULT_OP_LOCALMEM_POS(math, OP_POSITIVE, VECTOR3, Vector3);
			DEFAULT_OP_LOCALMEM_POS(math, OP_POSITIVE, VECTOR3I, Vector3i);
			DEFAULT_OP_LOCALMEM_POS(math, OP_POSITIVE, VECTOR4, Vector4);
			DEFAULT_OP_LOCALMEM_POS(math, OP_POSITIVE, VECTOR4I, Vector4i);
			DEFAULT_OP_LOCALMEM_POS(math, OP_POSITIVE, PLANE, Plane);
			DEFAULT_OP_LOCALMEM_POS(math, OP_POSITIVE, QUATERNION, Quaternion);

			CASE_TYPE(math, OP_POSITIVE, NIL)
			CASE_TYPE(math, OP_POSITIVE, BOOL)
			CASE_TYPE(math, OP_POSITIVE, STRING)
			CASE_TYPE(math, OP_POSITIVE, RECT2)
			CASE_TYPE(math, OP_POSITIVE, RECT2I)
			CASE_TYPE(math, OP_POSITIVE, AABB)
			CASE_TYPE(math, OP_POSITIVE, BASIS)
			CASE_TYPE(math, OP_POSITIVE, TRANSFORM)
			CASE_TYPE(math, OP_POSITIVE, TRANSFORM2D)
			CASE_TYPE(math, OP_POSITIVE, PROJECTION)
			CASE_TYPE(math, OP_POSITIVE, COLOR)
			CASE_TYPE(math, OP_POSITIVE, OBJECT)
			CASE_TYPE(math, OP_POSITIVE, STRING_NAME)
			CASE_TYPE(math, OP_POSITIVE, DICTIONARY)
			CASE_TYPE(math, OP_POSITIVE, ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_BYTE_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_INT_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_REAL_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_STRING_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_VECTOR2_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_VECTOR2I_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_VECTOR3_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_VECTOR3I_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_VECTOR4_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_VECTOR4I_ARRAY)
			CASE_TYPE(math, OP_POSITIVE, POOL_COLOR_ARRAY)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_NEGATE, p_a.type) {
			DEFAULT_OP_NUM_NEG(math, OP_NEGATE, INT, _int);
			DEFAULT_OP_NUM_NEG(math, OP_NEGATE, REAL, _real);

			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, VECTOR2, Vector2);
			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, VECTOR2I, Vector2i);
			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, VECTOR3, Vector3);
			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, VECTOR3I, Vector3i);
			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, VECTOR4, Vector4);
			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, VECTOR4I, Vector4i);
			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, PLANE, Plane);
			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, QUATERNION, Quaternion);
			DEFAULT_OP_LOCALMEM_NEG(math, OP_NEGATE, COLOR, Color);

			CASE_TYPE(math, OP_NEGATE, NIL)
			CASE_TYPE(math, OP_NEGATE, BOOL)
			CASE_TYPE(math, OP_NEGATE, STRING)
			CASE_TYPE(math, OP_NEGATE, RECT2)
			CASE_TYPE(math, OP_NEGATE, RECT2I)
			CASE_TYPE(math, OP_NEGATE, AABB)
			CASE_TYPE(math, OP_NEGATE, BASIS)
			CASE_TYPE(math, OP_NEGATE, TRANSFORM)
			CASE_TYPE(math, OP_NEGATE, TRANSFORM2D)
			CASE_TYPE(math, OP_NEGATE, PROJECTION)
			CASE_TYPE(math, OP_NEGATE, OBJECT)
			CASE_TYPE(math, OP_NEGATE, STRING_NAME)
			CASE_TYPE(math, OP_NEGATE, DICTIONARY)
			CASE_TYPE(math, OP_NEGATE, ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_BYTE_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_INT_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_REAL_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_STRING_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_VECTOR2_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_VECTOR2I_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_VECTOR3_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_VECTOR3I_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_VECTOR4_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_VECTOR4I_ARRAY)
			CASE_TYPE(math, OP_NEGATE, POOL_COLOR_ARRAY)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_MODULE, p_a.type) {
			CASE_TYPE(math, OP_MODULE, INT) {
				if (p_b.type != INT)
					_RETURN_FAIL;
#ifdef DEBUG_ENABLED
				if (p_b._data._int == 0) {
					r_valid = false;
					_RETURN("Division By Zero");
				}
#endif
				_RETURN(p_a._data._int % p_b._data._int);
			}

			CASE_TYPE(math, OP_MODULE, STRING) {
				const String *format = reinterpret_cast<const String *>(p_a._data._mem);

				String result;
				bool error;
				if (p_b.type == ARRAY) {
					// e.g. "frog %s %d" % ["fish", 12]
					const Array *args = reinterpret_cast<const Array *>(p_b._data._mem);
					result = args->sprintf(*format, &error);
				} else {
					// e.g. "frog %d" % 12
					Array args;
					args.push_back(p_b);
					result = args.sprintf(*format, &error);
				}
				r_valid = !error;
				_RETURN(result);
			}

			CASE_TYPE(math, OP_MODULE, NIL)
			CASE_TYPE(math, OP_MODULE, BOOL)
			CASE_TYPE(math, OP_MODULE, REAL)
			CASE_TYPE(math, OP_MODULE, RECT2)
			CASE_TYPE(math, OP_MODULE, RECT2I)
			CASE_TYPE(math, OP_MODULE, VECTOR2)
			CASE_TYPE(math, OP_MODULE, VECTOR2I)
			CASE_TYPE(math, OP_MODULE, VECTOR3)
			CASE_TYPE(math, OP_MODULE, VECTOR3I)
			CASE_TYPE(math, OP_MODULE, VECTOR4)
			CASE_TYPE(math, OP_MODULE, VECTOR4I)
			CASE_TYPE(math, OP_MODULE, PLANE)
			CASE_TYPE(math, OP_MODULE, QUATERNION)
			CASE_TYPE(math, OP_MODULE, AABB)
			CASE_TYPE(math, OP_MODULE, BASIS)
			CASE_TYPE(math, OP_MODULE, TRANSFORM)
			CASE_TYPE(math, OP_MODULE, TRANSFORM2D)
			CASE_TYPE(math, OP_MODULE, PROJECTION)
			CASE_TYPE(math, OP_MODULE, COLOR)
			CASE_TYPE(math, OP_MODULE, OBJECT)
			CASE_TYPE(math, OP_MODULE, STRING_NAME)
			CASE_TYPE(math, OP_MODULE, DICTIONARY)
			CASE_TYPE(math, OP_MODULE, ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_BYTE_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_INT_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_REAL_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_STRING_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_VECTOR2_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_VECTOR2I_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_VECTOR3_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_VECTOR3I_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_VECTOR4_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_VECTOR4I_ARRAY)
			CASE_TYPE(math, OP_MODULE, POOL_COLOR_ARRAY)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_STRING_CONCAT, p_a.type) {
			CASE_TYPE_ALL(math, OP_STRING_CONCAT)

			_RETURN(p_a.operator String() + p_b.operator String());
		}

		SWITCH_OP(math, OP_SHIFT_LEFT, p_a.type) {
			CASE_TYPE(math, OP_SHIFT_LEFT, INT) {
				if (p_b.type != INT)
					_RETURN_FAIL;
				if (p_b._data._int < 0 || p_b._data._int >= 64)
					_RETURN_FAIL;
				_RETURN(p_a._data._int << p_b._data._int);
			}

			CASE_TYPE_ALL_BUT_INT(math, OP_SHIFT_LEFT)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_SHIFT_RIGHT, p_a.type) {
			CASE_TYPE(math, OP_SHIFT_RIGHT, INT) {
				if (p_b.type != INT)
					_RETURN_FAIL;
				if (p_b._data._int < 0 || p_b._data._int >= 64)
					_RETURN_FAIL;
				_RETURN(p_a._data._int >> p_b._data._int);
			}

			CASE_TYPE_ALL_BUT_INT(math, OP_SHIFT_RIGHT)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_BIT_AND, p_a.type) {
			CASE_TYPE(math, OP_BIT_AND, INT) {
				if (p_b.type != INT)
					_RETURN_FAIL;
				_RETURN(p_a._data._int & p_b._data._int);
			}

			CASE_TYPE_ALL_BUT_INT(math, OP_BIT_AND)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_BIT_OR, p_a.type) {
			CASE_TYPE(math, OP_BIT_OR, INT) {
				if (p_b.type != INT)
					_RETURN_FAIL;
				_RETURN(p_a._data._int | p_b._data._int);
			}

			CASE_TYPE_ALL_BUT_INT(math, OP_BIT_OR)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_BIT_XOR, p_a.type) {
			CASE_TYPE(math, OP_BIT_XOR, INT) {
				if (p_b.type != INT)
					_RETURN_FAIL;
				_RETURN(p_a._data._int ^ p_b._data._int);
			}

			CASE_TYPE_ALL_BUT_INT(math, OP_BIT_XOR)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_BIT_NEGATE, p_a.type) {
			CASE_TYPE(math, OP_BIT_NEGATE, INT) {
				_RETURN(~p_a._data._int);
			}

			CASE_TYPE_ALL_BUT_INT(math, OP_BIT_NEGATE)
			_RETURN_FAIL;
		}

		SWITCH_OP(math, OP_AND, p_a.type) {
			CASE_TYPE_ALL(math, OP_AND) {
				bool l = p_a.booleanize();
				bool r = p_b.booleanize();

				_RETURN(l && r);
			}
		}

		SWITCH_OP(math, OP_OR, p_a.type) {
			CASE_TYPE_ALL(math, OP_OR) {
				bool l = p_a.booleanize();
				bool r = p_b.booleanize();

				_RETURN(l || r);
			}
		}

		SWITCH_OP(math, OP_XOR, p_a.type) {
			CASE_TYPE_ALL(math, OP_XOR) {
				bool l = p_a.booleanize();
				bool r = p_b.booleanize();

				_RETURN((l || r) && !(l && r));
			}
		}

		SWITCH_OP(math, OP_NOT, p_a.type) {
			CASE_TYPE_ALL(math, OP_NOT) {
				bool l = p_a.booleanize();
				_RETURN(!l);
			}
		}

		SWITCH_OP(math, OP_IN, p_a.type) {
			CASE_TYPE_ALL(math, OP_IN)
			_RETURN(p_b.in(p_a, &r_valid));
		}
	}
}

void Variant::set_named(const StringName &p_index, const Variant &p_value, bool *r_valid) {
	bool valid = false;
	switch (type) {
		case RECT2: {
			if (p_value.type == Variant::VECTOR2) {
				Rect2 *v = reinterpret_cast<Rect2 *>(_data._mem);
				//scalar name
				if (p_index == CoreStringNames::singleton->position) {
					v->position = *reinterpret_cast<const Vector2 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->size) {
					v->size = *reinterpret_cast<const Vector2 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->end) {
					v->size = *reinterpret_cast<const Vector2 *>(p_value._data._mem) - v->position;
					valid = true;
				}
			} else if (p_value.type == Variant::VECTOR2I) {
				Rect2 *v = reinterpret_cast<Rect2 *>(_data._mem);
				//scalar name
				if (p_index == CoreStringNames::singleton->position) {
					v->position = *reinterpret_cast<const Vector2i *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->size) {
					v->size = *reinterpret_cast<const Vector2i *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->end) {
					v->size = *reinterpret_cast<const Vector2i *>(p_value._data._mem) - v->position;
					valid = true;
				}
			}
		} break;
		case RECT2I: {
			if (p_value.type == Variant::VECTOR2) {
				Rect2i *v = reinterpret_cast<Rect2i *>(_data._mem);
				//scalar name
				if (p_index == CoreStringNames::singleton->position) {
					v->position = *reinterpret_cast<const Vector2 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->size) {
					v->size = *reinterpret_cast<const Vector2 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->end) {
					v->size = *reinterpret_cast<const Vector2 *>(p_value._data._mem) - v->position;
					valid = true;
				}
			} else if (p_value.type == Variant::VECTOR2I) {
				Rect2i *v = reinterpret_cast<Rect2i *>(_data._mem);
				//scalar name
				if (p_index == CoreStringNames::singleton->position) {
					v->position = *reinterpret_cast<const Vector2i *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->size) {
					v->size = *reinterpret_cast<const Vector2i *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->end) {
					v->size = *reinterpret_cast<const Vector2i *>(p_value._data._mem) - v->position;
					valid = true;
				}
			}
		} break;
		case VECTOR2: {
			if (p_value.type == Variant::INT) {
				Vector2 *v = reinterpret_cast<Vector2 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._int;
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Vector2 *v = reinterpret_cast<Vector2 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._real;
					valid = true;
				}
			}

		} break;
		case VECTOR2I: {
			if (p_value.type == Variant::INT) {
				Vector2i *v = reinterpret_cast<Vector2i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._int;
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Vector2i *v = reinterpret_cast<Vector2i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = static_cast<int>(p_value._data._real);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = static_cast<int>(p_value._data._real);
					valid = true;
				}
			}

		} break;
		case VECTOR3: {
			if (p_value.type == Variant::INT) {
				Vector3 *v = reinterpret_cast<Vector3 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._int;
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Vector3 *v = reinterpret_cast<Vector3 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._real;
					valid = true;
				}
			}

		} break;
		case VECTOR3I: {
			if (p_value.type == Variant::INT) {
				Vector3i *v = reinterpret_cast<Vector3i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._int;
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Vector3i *v = reinterpret_cast<Vector3i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._real;
					valid = true;
				}
			}

		} break;
		case VECTOR4: {
			if (p_value.type == Variant::INT) {
				Vector4 *v = reinterpret_cast<Vector4 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->w) {
					v->w = p_value._data._int;
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Vector4 *v = reinterpret_cast<Vector4 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->w) {
					v->w = p_value._data._real;
					valid = true;
				}
			}

		} break;
		case VECTOR4I: {
			if (p_value.type == Variant::INT) {
				Vector4i *v = reinterpret_cast<Vector4i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->w) {
					v->w = p_value._data._int;
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Vector4i *v = reinterpret_cast<Vector4i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->w) {
					v->w = p_value._data._real;
					valid = true;
				}
			}

		} break;
		case PLANE: {
			if (p_value.type == Variant::INT) {
				Plane *v = reinterpret_cast<Plane *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->normal.x = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->normal.y = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->normal.z = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->d) {
					v->d = p_value._data._int;
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Plane *v = reinterpret_cast<Plane *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->normal.x = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->normal.y = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->normal.z = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->d) {
					v->d = p_value._data._real;
					valid = true;
				}

			} else if (p_value.type == Variant::VECTOR3) {
				Plane *v = reinterpret_cast<Plane *>(_data._mem);
				if (p_index == CoreStringNames::singleton->normal) {
					v->normal = *reinterpret_cast<const Vector3 *>(p_value._data._mem);
					valid = true;
				}
			}

		} break;
		case QUATERNION: {
			if (p_value.type == Variant::INT) {
				Quaternion *v = reinterpret_cast<Quaternion *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->w) {
					v->w = p_value._data._int;
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Quaternion *v = reinterpret_cast<Quaternion *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					v->x = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->y = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->z = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->w) {
					v->w = p_value._data._real;
					valid = true;
				}
			}

		} break; // 10
		case AABB: {
			if (p_value.type == Variant::VECTOR3) {
				::AABB *v = _data._aabb;
				//scalar name
				if (p_index == CoreStringNames::singleton->position) {
					v->position = *reinterpret_cast<const Vector3 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->size) {
					v->size = *reinterpret_cast<const Vector3 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->end) {
					v->size = *reinterpret_cast<const Vector3 *>(p_value._data._mem) - v->position;
					valid = true;
				}
			} else if (p_value.type == Variant::VECTOR3I) {
				::AABB *v = _data._aabb;
				//scalar name
				if (p_index == CoreStringNames::singleton->position) {
					v->position = *reinterpret_cast<const Vector3i *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->size) {
					v->size = *reinterpret_cast<const Vector3i *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->end) {
					v->size = Vector3(*reinterpret_cast<const Vector3i *>(p_value._data._mem)) - v->position;
					valid = true;
				}
			}
		} break;
		case BASIS: {
			if (p_value.type == Variant::VECTOR3) {
				Basis *v = _data._basis;
				//scalar name
				if (p_index == CoreStringNames::singleton->x) {
					v->set_axis(0, *reinterpret_cast<const Vector3 *>(p_value._data._mem));
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->set_axis(1, *reinterpret_cast<const Vector3 *>(p_value._data._mem));
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->set_axis(2, *reinterpret_cast<const Vector3 *>(p_value._data._mem));
					valid = true;
				}
			} else if (p_value.type == Variant::VECTOR3I) {
				Basis *v = _data._basis;
				//scalar name
				if (p_index == CoreStringNames::singleton->x) {
					v->set_axis(0, *reinterpret_cast<const Vector3i *>(p_value._data._mem));
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->set_axis(1, *reinterpret_cast<const Vector3i *>(p_value._data._mem));
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->set_axis(2, *reinterpret_cast<const Vector3i *>(p_value._data._mem));
					valid = true;
				}
			}
		} break;
		case TRANSFORM: {
			if (p_value.type == Variant::BASIS && p_index == CoreStringNames::singleton->basis) {
				_data._transform->basis = *p_value._data._basis;
				valid = true;
			} else if (p_value.type == Variant::VECTOR3 && p_index == CoreStringNames::singleton->origin) {
				_data._transform->origin = *reinterpret_cast<const Vector3 *>(p_value._data._mem);
				valid = true;
			} else if (p_value.type == Variant::VECTOR3I && p_index == CoreStringNames::singleton->origin) {
				_data._transform->origin = *reinterpret_cast<const Vector3i *>(p_value._data._mem);
				valid = true;
			}

		} break;
		case TRANSFORM2D: {
			if (p_value.type == Variant::VECTOR2) {
				Transform2D *v = _data._transform2d;
				if (p_index == CoreStringNames::singleton->x) {
					v->columns[0] = *reinterpret_cast<const Vector2 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->columns[1] = *reinterpret_cast<const Vector2 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->origin) {
					v->columns[2] = *reinterpret_cast<const Vector2 *>(p_value._data._mem);
					valid = true;
				}
			} else if (p_value.type == Variant::VECTOR2I) {
				Transform2D *v = _data._transform2d;
				if (p_index == CoreStringNames::singleton->x) {
					v->columns[0] = *reinterpret_cast<const Vector2i *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->columns[1] = *reinterpret_cast<const Vector2i *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->origin) {
					v->columns[2] = *reinterpret_cast<const Vector2i *>(p_value._data._mem);
					valid = true;
				}
			}

		} break;
		case PROJECTION: {
			if (p_value.type == Variant::VECTOR4) {
				Projection *v = _data._projection;
				if (p_index == CoreStringNames::singleton->x) {
					v->matrix[0] = *reinterpret_cast<const Vector4 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->y) {
					v->matrix[1] = *reinterpret_cast<const Vector4 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->z) {
					v->matrix[2] = *reinterpret_cast<const Vector4 *>(p_value._data._mem);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->w) {
					v->matrix[3] = *reinterpret_cast<const Vector4 *>(p_value._data._mem);
					valid = true;
				}
			}

		} break;
		case COLOR: {
			if (p_value.type == Variant::INT) {
				Color *v = reinterpret_cast<Color *>(_data._mem);
				if (p_index == CoreStringNames::singleton->r) {
					v->r = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->g) {
					v->g = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->b) {
					v->b = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->a) {
					v->a = p_value._data._int;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->r8) {
					v->r = p_value._data._int / 255.0;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->g8) {
					v->g = p_value._data._int / 255.0;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->b8) {
					v->b = p_value._data._int / 255.0;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->a8) {
					v->a = p_value._data._int / 255.0;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->h) {
					v->set_hsv(p_value._data._int, v->get_s(), v->get_v(), v->a);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->s) {
					v->set_hsv(v->get_h(), p_value._data._int, v->get_v(), v->a);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->v) {
					v->set_hsv(v->get_h(), v->get_s(), p_value._data._int, v->a);
					valid = true;
				}
			} else if (p_value.type == Variant::REAL) {
				Color *v = reinterpret_cast<Color *>(_data._mem);
				if (p_index == CoreStringNames::singleton->r) {
					v->r = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->g) {
					v->g = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->b) {
					v->b = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->a) {
					v->a = p_value._data._real;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->r8) {
					v->r = p_value._data._real / 255.0;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->g8) {
					v->g = p_value._data._real / 255.0;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->b8) {
					v->b = p_value._data._real / 255.0;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->a8) {
					v->a = p_value._data._real / 255.0;
					valid = true;
				} else if (p_index == CoreStringNames::singleton->h) {
					v->set_hsv(p_value._data._real, v->get_s(), v->get_v(), v->a);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->s) {
					v->set_hsv(v->get_h(), p_value._data._real, v->get_v(), v->a);
					valid = true;
				} else if (p_index == CoreStringNames::singleton->v) {
					v->set_hsv(v->get_h(), v->get_s(), p_value._data._real, v->a);
					valid = true;
				}
			}
		} break;
		case OBJECT: {
			Object *obj = _OBJ_PTR(*this);
			if (unlikely(!obj)) {
#ifdef DEBUG_ENABLED
				if (_get_obj().rc) {
					ERR_PRINT("Attempted set on a deleted object.");
				}
#endif
				break;
			}
			obj->set(p_index, p_value, &valid);

		} break;
		default: {
			set(p_index.operator String(), p_value, &valid);
		} break;
	}

	if (r_valid) {
		*r_valid = valid;
	}
}

Variant Variant::get_named(const StringName &p_index, bool *r_valid) const {
	if (r_valid) {
		*r_valid = true;
	}
	switch (type) {
		case RECT2: {
			const Rect2 *v = reinterpret_cast<const Rect2 *>(_data._mem);
			//scalar name
			if (p_index == CoreStringNames::singleton->position) {
				return v->position;
			} else if (p_index == CoreStringNames::singleton->size) {
				return v->size;
			} else if (p_index == CoreStringNames::singleton->end) {
				return v->size + v->position;
			}
		} break;
		case RECT2I: {
			const Rect2i *v = reinterpret_cast<const Rect2i *>(_data._mem);
			//scalar name
			if (p_index == CoreStringNames::singleton->position) {
				return v->position;
			} else if (p_index == CoreStringNames::singleton->size) {
				return v->size;
			} else if (p_index == CoreStringNames::singleton->end) {
				return v->size + v->position;
			}
		} break;
		case VECTOR2: {
			const Vector2 *v = reinterpret_cast<const Vector2 *>(_data._mem);
			if (p_index == CoreStringNames::singleton->x) {
				return v->x;
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->y;
			}

		} break;
		case VECTOR2I: {
			const Vector2i *v = reinterpret_cast<const Vector2i *>(_data._mem);
			if (p_index == CoreStringNames::singleton->x) {
				return v->x;
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->y;
			}

		} break;
		case VECTOR3: {
			const Vector3 *v = reinterpret_cast<const Vector3 *>(_data._mem);
			if (p_index == CoreStringNames::singleton->x) {
				return v->x;
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->y;
			} else if (p_index == CoreStringNames::singleton->z) {
				return v->z;
			}

		} break;
		case VECTOR3I: {
			const Vector3i *v = reinterpret_cast<const Vector3i *>(_data._mem);
			if (p_index == CoreStringNames::singleton->x) {
				return v->x;
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->y;
			} else if (p_index == CoreStringNames::singleton->z) {
				return v->z;
			}

		} break;
		case VECTOR4: {
			const Vector4 *v = reinterpret_cast<const Vector4 *>(_data._mem);
			if (p_index == CoreStringNames::singleton->x) {
				return v->x;
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->y;
			} else if (p_index == CoreStringNames::singleton->z) {
				return v->z;
			} else if (p_index == CoreStringNames::singleton->w) {
				return v->w;
			}

		} break;
		case VECTOR4I: {
			const Vector4i *v = reinterpret_cast<const Vector4i *>(_data._mem);
			if (p_index == CoreStringNames::singleton->x) {
				return v->x;
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->y;
			} else if (p_index == CoreStringNames::singleton->z) {
				return v->z;
			} else if (p_index == CoreStringNames::singleton->w) {
				return v->w;
			}

		} break;
		case PLANE: {
			const Plane *v = reinterpret_cast<const Plane *>(_data._mem);
			if (p_index == CoreStringNames::singleton->x) {
				return v->normal.x;
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->normal.y;
			} else if (p_index == CoreStringNames::singleton->z) {
				return v->normal.z;
			} else if (p_index == CoreStringNames::singleton->d) {
				return v->d;
			} else if (p_index == CoreStringNames::singleton->normal) {
				return v->normal;
			}

		} break;
		case QUATERNION: {
			const Quaternion *v = reinterpret_cast<const Quaternion *>(_data._mem);
			if (p_index == CoreStringNames::singleton->x) {
				return v->x;
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->y;
			} else if (p_index == CoreStringNames::singleton->z) {
				return v->z;
			} else if (p_index == CoreStringNames::singleton->w) {
				return v->w;
			}

		} break; // 10
		case AABB: {
			const ::AABB *v = _data._aabb;
			//scalar name
			if (p_index == CoreStringNames::singleton->position) {
				return v->position;
			} else if (p_index == CoreStringNames::singleton->size) {
				return v->size;
			} else if (p_index == CoreStringNames::singleton->end) {
				return v->size + v->position;
			}
		} break;
		case BASIS: {
			const Basis *v = _data._basis;
			//scalar name
			if (p_index == CoreStringNames::singleton->x) {
				return v->get_axis(0);
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->get_axis(1);
			} else if (p_index == CoreStringNames::singleton->z) {
				return v->get_axis(2);
			}

		} break;
		case TRANSFORM: {
			if (p_index == CoreStringNames::singleton->basis) {
				return _data._transform->basis;
			} else if (p_index == CoreStringNames::singleton->origin) {
				return _data._transform->origin;
			}

		} break;
		case TRANSFORM2D: {
			const Transform2D *v = _data._transform2d;
			if (p_index == CoreStringNames::singleton->x) {
				return v->columns[0];
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->columns[1];
			} else if (p_index == CoreStringNames::singleton->origin) {
				return v->columns[2];
			}

		} break;
		case PROJECTION: {
			const Projection *v = _data._projection;
			if (p_index == CoreStringNames::singleton->x) {
				return v->matrix[0];
			} else if (p_index == CoreStringNames::singleton->y) {
				return v->matrix[1];
			} else if (p_index == CoreStringNames::singleton->z) {
				return v->matrix[2];
			} else if (p_index == CoreStringNames::singleton->w) {
				return v->matrix[3];
			}

		} break;
		case COLOR: {
			const Color *v = reinterpret_cast<const Color *>(_data._mem);
			if (p_index == CoreStringNames::singleton->r) {
				return v->r;
			} else if (p_index == CoreStringNames::singleton->g) {
				return v->g;
			} else if (p_index == CoreStringNames::singleton->b) {
				return v->b;
			} else if (p_index == CoreStringNames::singleton->a) {
				return v->a;
			} else if (p_index == CoreStringNames::singleton->r8) {
				return int(Math::round(v->r * 255.0));
			} else if (p_index == CoreStringNames::singleton->g8) {
				return int(Math::round(v->g * 255.0));
			} else if (p_index == CoreStringNames::singleton->b8) {
				return int(Math::round(v->b * 255.0));
			} else if (p_index == CoreStringNames::singleton->a8) {
				return int(Math::round(v->a * 255.0));
			} else if (p_index == CoreStringNames::singleton->h) {
				return v->get_h();
			} else if (p_index == CoreStringNames::singleton->s) {
				return v->get_s();
			} else if (p_index == CoreStringNames::singleton->v) {
				return v->get_v();
			}
		} break;
		case OBJECT: {
			Object *obj = _OBJ_PTR(*this);
			if (unlikely(!obj)) {
				if (r_valid) {
					*r_valid = false;
				}
#ifdef DEBUG_ENABLED
				if (_get_obj().rc) {
					ERR_PRINT("Attempted get on a deleted object.");
				}
#endif
				return Variant();
			}

			return obj->get(p_index, r_valid);

		} break;
		case DICTIONARY: {
			const Dictionary *dic = reinterpret_cast<const Dictionary *>(_data._mem);
			const Variant *res = dic->getptr(p_index);
			if (!res) {
				// Backwards compatibility for before variants supported stringnames.
				const Variant *res2 = dic->getptr(p_index.operator String());

				if (res2) {
					if (r_valid) {
						*r_valid = true;
					}
					return *res2;
				}
			} else {
				if (r_valid) {
					*r_valid = true;
				}
				return *res;
			}
		} break;
		default: {
			return get(p_index.operator String(), r_valid);
		}
	}

	if (r_valid) {
		*r_valid = false;
	}
	return Variant();
}

#define DEFAULT_OP_ARRAY_CMD(m_name, m_type, skip_test, cmd)                             \
	case m_name: {                                                                       \
		skip_test;                                                                       \
                                                                                         \
		if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) { \
			int index = p_index;                                                         \
			m_type *arr = reinterpret_cast<m_type *>(_data._mem);                        \
                                                                                         \
			if (index < 0)                                                               \
				index += arr->size();                                                    \
			if (index >= 0 && index < arr->size()) {                                     \
				valid = true;                                                            \
				cmd;                                                                     \
			}                                                                            \
		}                                                                                \
	} break;

// clang-format 14 wants to add a space after the last return,
// and clang-format 15 removes it...
/* clang-format off */
#define DEFAULT_OP_DVECTOR_SET(m_name, dv_type, skip_cond) \
	DEFAULT_OP_ARRAY_CMD(m_name, PoolVector<dv_type>, if (skip_cond) return;, arr->set(index, p_value); return)
/* clang-format on */

#define DEFAULT_OP_DVECTOR_GET(m_name, dv_type) \
	DEFAULT_OP_ARRAY_CMD(m_name, const PoolVector<dv_type>, ;, return arr->get(index))

void Variant::set(const Variant &p_index, const Variant &p_value, bool *r_valid) {
	static bool _dummy = false;

	bool &valid = r_valid ? *r_valid : _dummy;
	valid = false;

	switch (type) {
		case NIL: {
			return;
		} break;
		case BOOL: {
			return;
		} break;
		case INT: {
			return;
		} break;
		case REAL: {
			return;
		} break;
		case STRING: {
			if (p_index.type != Variant::INT && p_index.type != Variant::REAL) {
				return;
			}

			int idx = p_index;
			String *str = reinterpret_cast<String *>(_data._mem);
			int len = str->length();
			if (idx < 0) {
				idx += len;
			}
			if (idx < 0 || idx >= len) {
				return;
			}

			String chr;
			if (p_value.type == Variant::INT || p_value.type == Variant::REAL) {
				chr = String::chr(p_value);
			} else if (p_value.type == Variant::STRING) {
				chr = p_value;
			} else {
				return;
			}

			*str = str->substr(0, idx) + chr + str->substr(idx + 1, len);
			valid = true;
			return;

		} break;
		case RECT2: {
			if (p_value.type == Variant::VECTOR2 || p_value.type == Variant::VECTOR2I) {
				if (p_index.get_type() == Variant::STRING) {
					//scalar name

					const String *str = reinterpret_cast<const String *>(p_index._data._mem);
					Rect2 *v = reinterpret_cast<Rect2 *>(_data._mem);
					if (*str == "position") {
						valid = true;
						v->position = p_value;
						return;
					} else if (*str == "size") {
						valid = true;
						v->size = p_value;
						return;
					} else if (*str == "end") {
						valid = true;
						v->size = Vector2(p_value) - v->position;
						return;
					}
				} else if (p_index.get_type() == Variant::STRING_NAME) {
					//scalar name

					Rect2 *v = reinterpret_cast<Rect2 *>(_data._mem);
					if (p_index == CoreStringNames::singleton->position) {
						valid = true;
						v->position = p_value;
						return;
					} else if (p_index == CoreStringNames::singleton->size) {
						valid = true;
						v->size = p_value;
						return;
					} else if (p_index == CoreStringNames::singleton->end) {
						valid = true;
						v->size = Vector2(p_value) - v->position;
						return;
					}
				}
			} else {
				return;
			}
		} break; //7
		case RECT2I: {
			if (p_value.type == Variant::VECTOR2 || p_value.type == Variant::VECTOR2I) {
				if (p_index.get_type() == Variant::STRING) {
					//scalar name

					const String *str = reinterpret_cast<const String *>(p_index._data._mem);
					Rect2i *v = reinterpret_cast<Rect2i *>(_data._mem);
					if (*str == "position") {
						valid = true;
						v->position = p_value;
						return;
					} else if (*str == "size") {
						valid = true;
						v->size = p_value;
						return;
					} else if (*str == "end") {
						valid = true;
						//TODO fix
						v->size = Vector2i(Vector2(p_value)) - v->position;
						return;
					}
				} else if (p_index.get_type() == Variant::STRING_NAME) {
					//scalar name

					Rect2i *v = reinterpret_cast<Rect2i *>(_data._mem);
					if (p_index == CoreStringNames::singleton->position) {
						valid = true;
						v->position = p_value;
						return;
					} else if (p_index == CoreStringNames::singleton->size) {
						valid = true;
						v->size = p_value;
						return;
					} else if (p_index == CoreStringNames::singleton->end) {
						valid = true;
						v->size = Vector2(p_value) - v->position;
						return;
					}
				}
			} else {
				return;
			}
		} break;
		case VECTOR2: {
			if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
				return;
			}

			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				// scalar index
				int idx = p_index;

				if (idx < 0) {
					idx += 2;
				}
				if (idx >= 0 && idx < 2) {
					Vector2 *v = reinterpret_cast<Vector2 *>(_data._mem);
					valid = true;
					(*v)[idx] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name

				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Vector2 *v = reinterpret_cast<Vector2 *>(_data._mem);
				if (*str == "x") {
					valid = true;
					v->x = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->y = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				Vector2 *v = reinterpret_cast<Vector2 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->x = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->y = p_value;
					return;
				}
			}
		} break; // 5
		case VECTOR2I: {
			if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
				return;
			}

			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				// scalar index
				int idx = p_index;

				if (idx < 0) {
					idx += 2;
				}
				if (idx >= 0 && idx < 2) {
					Vector2i *v = reinterpret_cast<Vector2i *>(_data._mem);
					valid = true;
					(*v)[idx] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name

				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Vector2i *v = reinterpret_cast<Vector2i *>(_data._mem);
				if (*str == "x") {
					valid = true;
					v->x = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->y = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				Vector2i *v = reinterpret_cast<Vector2i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->x = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->y = p_value;
					return;
				}
			}

		} break; //6

		case VECTOR3: {
			if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
				return;
			}

			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 3;
				}
				if (idx >= 0 && idx < 3) {
					Vector3 *v = reinterpret_cast<Vector3 *>(_data._mem);
					valid = true;
					(*v)[idx] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Vector3 *v = reinterpret_cast<Vector3 *>(_data._mem);
				if (*str == "x") {
					valid = true;
					v->x = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->y = p_value;
					return;
				} else if (*str == "z") {
					valid = true;
					v->z = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				Vector3 *v = reinterpret_cast<Vector3 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->x = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->y = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					v->z = p_value;
					return;
				}
			}

		} break;
		case VECTOR3I: {
			if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
				return;
			}

			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 3;
				}
				if (idx >= 0 && idx < 3) {
					Vector3i *v = reinterpret_cast<Vector3i *>(_data._mem);
					valid = true;
					(*v)[idx] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Vector3 *v = reinterpret_cast<Vector3 *>(_data._mem);
				if (*str == "x") {
					valid = true;
					v->x = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->y = p_value;
					return;
				} else if (*str == "z") {
					valid = true;
					v->z = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				Vector3i *v = reinterpret_cast<Vector3i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->x = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->y = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					v->z = p_value;
					return;
				}
			}

		} break;
		case VECTOR4: {
			if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
				return;
			}

			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 4;
				}
				if (idx >= 0 && idx < 4) {
					Vector4 *v = reinterpret_cast<Vector4 *>(_data._mem);
					valid = true;
					(*v)[idx] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Vector4 *v = reinterpret_cast<Vector4 *>(_data._mem);
				if (*str == "x") {
					valid = true;
					v->x = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->y = p_value;
					return;
				} else if (*str == "z") {
					valid = true;
					v->z = p_value;
					return;
				} else if (*str == "w") {
					valid = true;
					v->w = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				Vector4 *v = reinterpret_cast<Vector4 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->x = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->y = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					v->z = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->w) {
					valid = true;
					v->w = p_value;
					return;
				}
			}
		} break;
		case VECTOR4I: {
			if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
				return;
			}

			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 4;
				}
				if (idx >= 0 && idx < 4) {
					Vector4i *v = reinterpret_cast<Vector4i *>(_data._mem);
					valid = true;
					(*v)[idx] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Vector4 *v = reinterpret_cast<Vector4 *>(_data._mem);
				if (*str == "x") {
					valid = true;
					v->x = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->y = p_value;
					return;
				} else if (*str == "z") {
					valid = true;
					v->z = p_value;
					return;
				} else if (*str == "w") {
					valid = true;
					v->w = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				Vector4i *v = reinterpret_cast<Vector4i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->x = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->y = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					v->z = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->w) {
					valid = true;
					v->w = p_value;
					return;
				}
			}

		} break;
		case PLANE: {
			if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Plane *v = reinterpret_cast<Plane *>(_data._mem);
				if (*str == "x") {
					if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
						return;
					}

					valid = true;
					v->normal.x = p_value;
					return;
				} else if (*str == "y") {
					if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
						return;
					}

					valid = true;
					v->normal.y = p_value;
					return;
				} else if (*str == "z") {
					if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
						return;
					}

					valid = true;
					v->normal.z = p_value;
					return;
				} else if (*str == "normal") {
					if (p_value.type != Variant::VECTOR3) {
						return;
					}

					valid = true;
					v->normal = p_value;
					return;
				} else if (*str == "d") {
					valid = true;
					v->d = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				Plane *v = reinterpret_cast<Plane *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
						return;
					}

					valid = true;
					v->normal.x = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
						return;
					}

					valid = true;
					v->normal.y = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->z) {
					if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
						return;
					}

					valid = true;
					v->normal.z = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->normal) {
					if (p_value.type != Variant::VECTOR3) {
						return;
					}

					valid = true;
					v->normal = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->d) {
					valid = true;
					v->d = p_value;
					return;
				}
			}

		} break;
		case QUATERNION: {
			if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
				return;
			}

			if (p_index.get_type() == Variant::STRING) {
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Quaternion *v = reinterpret_cast<Quaternion *>(_data._mem);
				if (*str == "x") {
					valid = true;
					v->x = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->y = p_value;
					return;
				} else if (*str == "z") {
					valid = true;
					v->z = p_value;
					return;
				} else if (*str == "w") {
					valid = true;
					v->w = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				Quaternion *v = reinterpret_cast<Quaternion *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->x = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->y = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					v->z = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->w) {
					valid = true;
					v->w = p_value;
					return;
				}
			}

		} break; // 10
		case AABB: {
			if (p_value.type != Variant::VECTOR3) {
				return;
			}

			if (p_index.get_type() == Variant::STRING) {
				//scalar name

				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				::AABB *v = _data._aabb;
				if (*str == "position") {
					valid = true;
					v->position = p_value;
					return;
				} else if (*str == "size") {
					valid = true;
					v->size = p_value;
					return;
				} else if (*str == "end") {
					valid = true;
					v->size = Vector3(p_value) - v->position;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				::AABB *v = _data._aabb;
				if (p_index == CoreStringNames::singleton->position) {
					valid = true;
					v->position = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->size) {
					valid = true;
					v->size = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->end) {
					valid = true;
					v->size = Vector3(p_value) - v->position;
					return;
				}
			}
		} break;
		case BASIS: {
			if (p_value.type != Variant::VECTOR3) {
				return;
			}

			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				int index = p_index;

				if (index < 0) {
					index += 3;
				}
				if (index >= 0 && index < 3) {
					Basis *v = _data._basis;

					valid = true;
					v->set_axis(index, p_value);
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Basis *v = _data._basis;

				if (*str == "x") {
					valid = true;
					v->set_axis(0, p_value);
					return;
				} else if (*str == "y") {
					valid = true;
					v->set_axis(1, p_value);
					return;
				} else if (*str == "z") {
					valid = true;
					v->set_axis(2, p_value);
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				Basis *v = _data._basis;

				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->set_axis(0, p_value);
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->set_axis(1, p_value);
					return;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					v->set_axis(2, p_value);
					return;
				}
			}

		} break;
		case TRANSFORM: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				if (p_value.type != Variant::VECTOR3) {
					return;
				}

				int index = p_index;

				if (index < 0) {
					index += 4;
				}
				if (index >= 0 && index < 4) {
					Transform *v = _data._transform;
					valid = true;
					if (index == 3) {
						v->origin = p_value;
					} else {
						v->basis.set_axis(index, p_value);
					}
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				Transform *v = _data._transform;
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);

				if (*str == "basis") {
					if (p_value.type != Variant::BASIS) {
						return;
					}
					valid = true;
					v->basis = p_value;
					return;
				}
				if (*str == "origin") {
					if (p_value.type != Variant::VECTOR3) {
						return;
					}
					valid = true;
					v->origin = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				Transform *v = _data._transform;

				if (p_index == CoreStringNames::singleton->basis) {
					if (p_value.type != Variant::BASIS) {
						return;
					}
					valid = true;
					v->basis = p_value;
					return;
				}
				if (p_index == CoreStringNames::singleton->origin) {
					if (p_value.type != Variant::VECTOR3) {
						return;
					}
					valid = true;
					v->origin = p_value;
					return;
				}
			}

		} break;
		case TRANSFORM2D: {
			if (p_value.type != Variant::VECTOR2 || p_value.get_type() != Variant::VECTOR2I) {
				return;
			}

			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				int index = p_index;

				if (index < 0) {
					index += 3;
				}
				if (index >= 0 && index < 3) {
					Transform2D *v = _data._transform2d;

					valid = true;
					v->columns[index] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Transform2D *v = _data._transform2d;
				if (*str == "x") {
					valid = true;
					v->columns[0] = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->columns[1] = p_value;
					return;
				} else if (*str == "origin") {
					valid = true;
					v->columns[2] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				Transform2D *v = _data._transform2d;
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->columns[0] = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->columns[1] = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->origin) {
					valid = true;
					v->columns[2] = p_value;
					return;
				}
			}

		} break;
		case PROJECTION: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				if (p_value.type != Variant::VECTOR4) {
					return;
				}

				int index = p_index;

				if (index < 0) {
					index += 4;
				}
				if (index >= 0 && index < 4) {
					Projection *v = _data._projection;
					valid = true;
					v->matrix[index] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING) {
				Projection *v = _data._projection;
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);

				if (p_value.type != Variant::VECTOR4) {
					return;
				}

				if (*str == "x") {
					valid = true;
					v->matrix[0] = p_value;
					return;
				} else if (*str == "y") {
					valid = true;
					v->matrix[1] = p_value;
					return;
				} else if (*str == "z") {
					valid = true;
					v->matrix[2] = p_value;
					return;
				} else if (*str == "w") {
					valid = true;
					v->matrix[3] = p_value;
					return;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				Projection *v = _data._projection;

				if (p_value.type != Variant::VECTOR4) {
					return;
				}

				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					v->matrix[0] = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					v->matrix[1] = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					v->matrix[2] = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->w) {
					valid = true;
					v->matrix[3] = p_value;
					return;
				}
			}

		} break;
		case COLOR: {
			if (p_value.type != Variant::INT && p_value.type != Variant::REAL) {
				return;
			}

			if (p_index.get_type() == Variant::STRING) {
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				Color *v = reinterpret_cast<Color *>(_data._mem);
				if (*str == "r") {
					valid = true;
					v->r = p_value;
					return;
				} else if (*str == "g") {
					valid = true;
					v->g = p_value;
					return;
				} else if (*str == "b") {
					valid = true;
					v->b = p_value;
					return;
				} else if (*str == "a") {
					valid = true;
					v->a = p_value;
					return;
				} else if (*str == "h") {
					valid = true;
					v->set_hsv(p_value, v->get_s(), v->get_v(), v->a);
					return;
				} else if (*str == "s") {
					valid = true;
					v->set_hsv(v->get_h(), p_value, v->get_v(), v->a);
					return;
				} else if (*str == "v") {
					valid = true;
					v->set_hsv(v->get_h(), v->get_s(), p_value, v->a);
					return;
				} else if (*str == "r8") {
					valid = true;
					v->r = float(p_value) / 255.0;
					return;
				} else if (*str == "g8") {
					valid = true;
					v->g = float(p_value) / 255.0;
					return;
				} else if (*str == "b8") {
					valid = true;
					v->b = float(p_value) / 255.0;
					return;
				} else if (*str == "a8") {
					valid = true;
					v->a = float(p_value) / 255.0;
					return;
				}
			} else if (p_index.get_type() == Variant::INT) {
				int idx = p_index;
				if (idx < 0) {
					idx += 4;
				}
				if (idx >= 0 && idx < 4) {
					Color *v = reinterpret_cast<Color *>(_data._mem);
					(*v)[idx] = p_value;
					valid = true;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				Color *v = reinterpret_cast<Color *>(_data._mem);
				if (p_index == CoreStringNames::singleton->r) {
					valid = true;
					v->r = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->g) {
					valid = true;
					v->g = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->b) {
					valid = true;
					v->b = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->a) {
					valid = true;
					v->a = p_value;
					return;
				} else if (p_index == CoreStringNames::singleton->h) {
					valid = true;
					v->set_hsv(p_value, v->get_s(), v->get_v(), v->a);
					return;
				} else if (p_index == CoreStringNames::singleton->s) {
					valid = true;
					v->set_hsv(v->get_h(), p_value, v->get_v(), v->a);
					return;
				} else if (p_index == CoreStringNames::singleton->v) {
					valid = true;
					v->set_hsv(v->get_h(), v->get_s(), p_value, v->a);
					return;
				} else if (p_index == CoreStringNames::singleton->r8) {
					valid = true;
					v->r = float(p_value) / 255.0;
					return;
				} else if (p_index == CoreStringNames::singleton->g8) {
					valid = true;
					v->g = float(p_value) / 255.0;
					return;
				} else if (p_index == CoreStringNames::singleton->b8) {
					valid = true;
					v->b = float(p_value) / 255.0;
					return;
				} else if (p_index == CoreStringNames::singleton->a8) {
					valid = true;
					v->a = float(p_value) / 255.0;
					return;
				}
			}

		} break;
		case OBJECT: {
			Object *obj = _OBJ_PTR(*this);
			if (unlikely(!obj)) {
				valid = false;
#ifdef DEBUG_ENABLED
				if (_get_obj().rc) {
					ERR_PRINT("Attempted set on a deleted object.");
				}
#endif
				return;
			}

			obj->set(p_index, p_value, r_valid);
			return;
		} break;
		case STRING_NAME: {
		} break;
		case DICTIONARY: {
			Dictionary *dic = reinterpret_cast<Dictionary *>(_data._mem);
			dic->operator[](p_index) = p_value;
			valid = true; //always valid, i guess? should this really be ok?
			return;
		} break;
			// clang-format 14 wants to add a space after the last return,
			// and clang-format 15 removes it...
			/* clang-format off */
			DEFAULT_OP_ARRAY_CMD(ARRAY, Array, ;, (*arr)[index] = p_value; return) // 20
			/* clang-format on */
			DEFAULT_OP_DVECTOR_SET(POOL_BYTE_ARRAY, uint8_t, p_value.type != Variant::REAL && p_value.type != Variant::INT)
			DEFAULT_OP_DVECTOR_SET(POOL_INT_ARRAY, int, p_value.type != Variant::REAL && p_value.type != Variant::INT)
			DEFAULT_OP_DVECTOR_SET(POOL_REAL_ARRAY, real_t, p_value.type != Variant::REAL && p_value.type != Variant::INT)
			DEFAULT_OP_DVECTOR_SET(POOL_STRING_ARRAY, String, p_value.type != Variant::STRING)
			DEFAULT_OP_DVECTOR_SET(POOL_VECTOR2_ARRAY, Vector2, p_value.type != Variant::VECTOR2) // 25
			DEFAULT_OP_DVECTOR_SET(POOL_VECTOR2I_ARRAY, Vector2i, p_value.type != Variant::VECTOR2I)
			DEFAULT_OP_DVECTOR_SET(POOL_VECTOR3_ARRAY, Vector3, p_value.type != Variant::VECTOR3)
			DEFAULT_OP_DVECTOR_SET(POOL_VECTOR3I_ARRAY, Vector3i, p_value.type != Variant::VECTOR3I)
			DEFAULT_OP_DVECTOR_SET(POOL_VECTOR4_ARRAY, Vector4, p_value.type != Variant::VECTOR4)
			DEFAULT_OP_DVECTOR_SET(POOL_VECTOR4I_ARRAY, Vector4i, p_value.type != Variant::VECTOR4I)
			DEFAULT_OP_DVECTOR_SET(POOL_COLOR_ARRAY, Color, p_value.type != Variant::COLOR)
		default:
			return;
	}
}

Variant Variant::get(const Variant &p_index, bool *r_valid) const {
	static bool _dummy = false;

	bool &valid = r_valid ? *r_valid : _dummy;

	valid = false;

	switch (type) {
		case NIL: {
			return Variant();
		} break;
		case BOOL: {
			return Variant();
		} break;
		case INT: {
			return Variant();
		} break;
		case REAL: {
			return Variant();
		} break;
		case STRING: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//string index

				int idx = p_index;
				const String *str = reinterpret_cast<const String *>(_data._mem);
				if (idx < 0) {
					idx += str->length();
				}
				if (idx >= 0 && idx < str->length()) {
					valid = true;
					return str->substr(idx, 1);
				}
			}

		} break;
		case RECT2: {
			if (p_index.get_type() == Variant::STRING) {
				//scalar name

				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Rect2 *v = reinterpret_cast<const Rect2 *>(_data._mem);
				if (*str == "position") {
					valid = true;
					return v->position;
				} else if (*str == "size") {
					valid = true;
					return v->size;
				} else if (*str == "end") {
					valid = true;
					return v->size + v->position;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Rect2 *v = reinterpret_cast<const Rect2 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->position) {
					valid = true;
					return v->position;
				} else if (p_index == CoreStringNames::singleton->size) {
					valid = true;
					return v->size;
				} else if (p_index == CoreStringNames::singleton->end) {
					valid = true;
					return v->size + v->position;
				}
			}
		} break;
		case RECT2I: {
			if (p_index.get_type() == Variant::STRING) {
				//scalar name

				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Rect2i *v = reinterpret_cast<const Rect2i *>(_data._mem);
				if (*str == "position") {
					valid = true;
					return v->position;
				} else if (*str == "size") {
					valid = true;
					return v->size;
				} else if (*str == "end") {
					valid = true;
					return v->size + v->position;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Rect2i *v = reinterpret_cast<const Rect2i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->position) {
					valid = true;
					return v->position;
				} else if (p_index == CoreStringNames::singleton->size) {
					valid = true;
					return v->size;
				} else if (p_index == CoreStringNames::singleton->end) {
					valid = true;
					return v->size + v->position;
				}
			}
		} break;
		case VECTOR2: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				// scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 2;
				}
				if (idx >= 0 && idx < 2) {
					const Vector2 *v = reinterpret_cast<const Vector2 *>(_data._mem);
					valid = true;
					return (*v)[idx];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name

				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Vector2 *v = reinterpret_cast<const Vector2 *>(_data._mem);
				if (*str == "x") {
					valid = true;
					return v->x;
				} else if (*str == "y") {
					valid = true;
					return v->y;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Vector2 *v = reinterpret_cast<const Vector2 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->x;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->y;
				}
			}

		} break; // 5
		case VECTOR2I: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				// scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 2;
				}
				if (idx >= 0 && idx < 2) {
					const Vector2i *v = reinterpret_cast<const Vector2i *>(_data._mem);
					valid = true;
					return (*v)[idx];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name

				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Vector2i *v = reinterpret_cast<const Vector2i *>(_data._mem);
				if (*str == "x") {
					valid = true;
					return v->x;
				} else if (*str == "y") {
					valid = true;
					return v->y;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Vector2i *v = reinterpret_cast<const Vector2i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->x;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->y;
				}
			}

		} break; // 6
		case VECTOR3: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 3;
				}
				if (idx >= 0 && idx < 3) {
					const Vector3 *v = reinterpret_cast<const Vector3 *>(_data._mem);
					valid = true;
					return (*v)[idx];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Vector3 *v = reinterpret_cast<const Vector3 *>(_data._mem);
				if (*str == "x") {
					valid = true;
					return v->x;
				} else if (*str == "y") {
					valid = true;
					return v->y;
				} else if (*str == "z") {
					valid = true;
					return v->z;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Vector3 *v = reinterpret_cast<const Vector3 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->x;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->y;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					return v->z;
				}
			}

		} break;
		case VECTOR3I: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 3;
				}
				if (idx >= 0 && idx < 3) {
					const Vector3i *v = reinterpret_cast<const Vector3i *>(_data._mem);
					valid = true;
					return (*v)[idx];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Vector3i *v = reinterpret_cast<const Vector3i *>(_data._mem);
				if (*str == "x") {
					valid = true;
					return v->x;
				} else if (*str == "y") {
					valid = true;
					return v->y;
				} else if (*str == "z") {
					valid = true;
					return v->z;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Vector3i *v = reinterpret_cast<const Vector3i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->x;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->y;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					return v->z;
				}
			}

		} break;
		case VECTOR4: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 4;
				}
				if (idx >= 0 && idx < 4) {
					const Vector4 *v = reinterpret_cast<const Vector4 *>(_data._mem);
					valid = true;
					return (*v)[idx];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Vector4 *v = reinterpret_cast<const Vector4 *>(_data._mem);
				if (*str == "x") {
					valid = true;
					return v->x;
				} else if (*str == "y") {
					valid = true;
					return v->y;
				} else if (*str == "z") {
					valid = true;
					return v->z;
				} else if (*str == "w") {
					valid = true;
					return v->w;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Vector4 *v = reinterpret_cast<const Vector4 *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->x;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->y;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					return v->z;
				} else if (p_index == CoreStringNames::singleton->w) {
					valid = true;
					return v->w;
				}
			}

		} break;
		case VECTOR4I: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				//scalar index
				int idx = p_index;
				if (idx < 0) {
					idx += 4;
				}
				if (idx >= 0 && idx < 4) {
					const Vector4i *v = reinterpret_cast<const Vector4i *>(_data._mem);
					valid = true;
					return (*v)[idx];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Vector4i *v = reinterpret_cast<const Vector4i *>(_data._mem);
				if (*str == "x") {
					valid = true;
					return v->x;
				} else if (*str == "y") {
					valid = true;
					return v->y;
				} else if (*str == "z") {
					valid = true;
					return v->z;
				} else if (*str == "w") {
					valid = true;
					return v->w;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name
				const Vector4i *v = reinterpret_cast<const Vector4i *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->x;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->y;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					return v->z;
				} else if (p_index == CoreStringNames::singleton->w) {
					valid = true;
					return v->w;
				}
			}

		} break;
		case PLANE: {
			if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Plane *v = reinterpret_cast<const Plane *>(_data._mem);
				if (*str == "x") {
					valid = true;
					return v->normal.x;
				} else if (*str == "y") {
					valid = true;
					return v->normal.y;
				} else if (*str == "z") {
					valid = true;
					return v->normal.z;
				} else if (*str == "normal") {
					valid = true;
					return v->normal;
				} else if (*str == "d") {
					valid = true;
					return v->d;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Plane *v = reinterpret_cast<const Plane *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->normal.x;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->normal.y;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					return v->normal.z;
				} else if (p_index == CoreStringNames::singleton->normal) {
					valid = true;
					return v->normal;
				} else if (p_index == CoreStringNames::singleton->d) {
					valid = true;
					return v->d;
				}
			}

		} break;
		case QUATERNION: {
			if (p_index.get_type() == Variant::STRING) {
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Quaternion *v = reinterpret_cast<const Quaternion *>(_data._mem);
				if (*str == "x") {
					valid = true;
					return v->x;
				} else if (*str == "y") {
					valid = true;
					return v->y;
				} else if (*str == "z") {
					valid = true;
					return v->z;
				} else if (*str == "w") {
					valid = true;
					return v->w;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				const Quaternion *v = reinterpret_cast<const Quaternion *>(_data._mem);
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->x;
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->y;
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					return v->z;
				} else if (p_index == CoreStringNames::singleton->w) {
					valid = true;
					return v->w;
				}
			}

		} break; // 10
		case AABB: {
			if (p_index.get_type() == Variant::STRING) {
				//scalar name

				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const ::AABB *v = _data._aabb;
				if (*str == "position") {
					valid = true;
					return v->position;
				} else if (*str == "size") {
					valid = true;
					return v->size;
				} else if (*str == "end") {
					valid = true;
					return v->size + v->position;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const ::AABB *v = _data._aabb;
				if (p_index == CoreStringNames::singleton->position) {
					valid = true;
					return v->position;
				} else if (p_index == CoreStringNames::singleton->size) {
					valid = true;
					return v->size;
				} else if (p_index == CoreStringNames::singleton->end) {
					valid = true;
					return v->size + v->position;
				}
			}
		} break;
		case BASIS: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				int index = p_index;
				if (index < 0) {
					index += 3;
				}
				if (index >= 0 && index < 3) {
					const Basis *v = _data._basis;

					valid = true;
					return v->get_axis(index);
				}
			} else if (p_index.get_type() == Variant::STRING) {
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Basis *v = _data._basis;

				if (*str == "x") {
					valid = true;
					return v->get_axis(0);
				} else if (*str == "y") {
					valid = true;
					return v->get_axis(1);
				} else if (*str == "z") {
					valid = true;
					return v->get_axis(2);
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				const Basis *v = _data._basis;

				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->get_axis(0);
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->get_axis(1);
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					return v->get_axis(2);
				}
			}

		} break;
		case TRANSFORM: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				int index = p_index;
				if (index < 0) {
					index += 4;
				}
				if (index >= 0 && index < 4) {
					const Transform *v = _data._transform;
					valid = true;
					return index == 3 ? v->origin : v->basis.get_axis(index);
				}
			} else if (p_index.get_type() == Variant::STRING) {
				const Transform *v = _data._transform;
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);

				if (*str == "basis") {
					valid = true;
					return v->basis;
				}
				if (*str == "origin") {
					valid = true;
					return v->origin;
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				const Transform *v = _data._transform;

				if (p_index == CoreStringNames::singleton->basis) {
					valid = true;
					return v->basis;
				}
				if (p_index == CoreStringNames::singleton->origin) {
					valid = true;
					return v->origin;
				}
			}

		} break;
		case TRANSFORM2D: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				int index = p_index;

				if (index < 0) {
					index += 3;
				}
				if (index >= 0 && index < 3) {
					const Transform2D *v = _data._transform2d;

					valid = true;
					return v->columns[index];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				//scalar name
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Transform2D *v = _data._transform2d;
				if (*str == "x") {
					valid = true;
					return v->columns[0];
				} else if (*str == "y") {
					valid = true;
					return v->columns[1];
				} else if (*str == "origin") {
					valid = true;
					return v->columns[2];
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				//scalar name

				const Transform2D *v = _data._transform2d;
				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->columns[0];
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->columns[1];
				} else if (p_index == CoreStringNames::singleton->origin) {
					valid = true;
					return v->columns[2];
				}
			}

		} break;
		case PROJECTION: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				int index = p_index;
				if (index < 0) {
					index += 4;
				}
				if (index >= 0 && index < 4) {
					const Projection *v = _data._projection;
					valid = true;
					return v->matrix[index];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				const Projection *v = _data._projection;
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);

				if (*str == "x") {
					valid = true;
					return v->matrix[0];
				} else if (*str == "y") {
					valid = true;
					return v->matrix[1];
				} else if (*str == "z") {
					valid = true;
					return v->matrix[2];
				} else if (*str == "w") {
					valid = true;
					return v->matrix[3];
				}
			} else if (p_index.get_type() == Variant::STRING_NAME) {
				const Projection *v = _data._projection;

				if (p_index == CoreStringNames::singleton->x) {
					valid = true;
					return v->matrix[0];
				} else if (p_index == CoreStringNames::singleton->y) {
					valid = true;
					return v->matrix[1];
				} else if (p_index == CoreStringNames::singleton->z) {
					valid = true;
					return v->matrix[2];
				} else if (p_index == CoreStringNames::singleton->w) {
					valid = true;
					return v->matrix[3];
				}
			}

		} break;
		case COLOR: {
			if (p_index.get_type() == Variant::STRING) {
				const String *str = reinterpret_cast<const String *>(p_index._data._mem);
				const Color *v = reinterpret_cast<const Color *>(_data._mem);
				if (*str == "r") {
					valid = true;
					return v->r;
				} else if (*str == "g") {
					valid = true;
					return v->g;
				} else if (*str == "b") {
					valid = true;
					return v->b;
				} else if (*str == "a") {
					valid = true;
					return v->a;
				} else if (*str == "h") {
					valid = true;
					return v->get_h();
				} else if (*str == "s") {
					valid = true;
					return v->get_s();
				} else if (*str == "v") {
					valid = true;
					return v->get_v();
				} else if (*str == "r8") {
					valid = true;
					return (int)Math::round(v->r * 255.0);
				} else if (*str == "g8") {
					valid = true;
					return (int)Math::round(v->g * 255.0);
				} else if (*str == "b8") {
					valid = true;
					return (int)Math::round(v->b * 255.0);
				} else if (*str == "a8") {
					valid = true;
					return (int)Math::round(v->a * 255.0);
				}
			} else if (p_index.get_type() == Variant::INT) {
				int idx = p_index;
				if (idx < 0) {
					idx += 4;
				}
				if (idx >= 0 && idx < 4) {
					const Color *v = reinterpret_cast<const Color *>(_data._mem);
					valid = true;
					return (*v)[idx];
				}
			} else if (p_index.get_type() == Variant::STRING) {
				const Color *v = reinterpret_cast<const Color *>(_data._mem);
				if (p_index == CoreStringNames::singleton->r) {
					valid = true;
					return v->r;
				} else if (p_index == CoreStringNames::singleton->g) {
					valid = true;
					return v->g;
				} else if (p_index == CoreStringNames::singleton->b) {
					valid = true;
					return v->b;
				} else if (p_index == CoreStringNames::singleton->a) {
					valid = true;
					return v->a;
				} else if (p_index == CoreStringNames::singleton->h) {
					valid = true;
					return v->get_h();
				} else if (p_index == CoreStringNames::singleton->s) {
					valid = true;
					return v->get_s();
				} else if (p_index == CoreStringNames::singleton->v) {
					valid = true;
					return v->get_v();
				} else if (p_index == CoreStringNames::singleton->r8) {
					valid = true;
					return (int)Math::round(v->r * 255.0);
				} else if (p_index == CoreStringNames::singleton->g8) {
					valid = true;
					return (int)Math::round(v->g * 255.0);
				} else if (p_index == CoreStringNames::singleton->b8) {
					valid = true;
					return (int)Math::round(v->b * 255.0);
				} else if (p_index == CoreStringNames::singleton->a8) {
					valid = true;
					return (int)Math::round(v->a * 255.0);
				}
			}

		} break;
		case OBJECT: {
			Object *obj = _OBJ_PTR(*this);
			if (unlikely(!obj)) {
				valid = false;
#ifdef DEBUG_ENABLED
				if (_get_obj().rc) {
					ERR_PRINT("Attempted get on a deleted object.");
				}
#endif
				return Variant();
			}

			return obj->get(p_index, r_valid);

		} break;
		case STRING_NAME: {
		} break;
		case DICTIONARY: {
			const Dictionary *dic = reinterpret_cast<const Dictionary *>(_data._mem);
			const Variant *res = dic->getptr(p_index);
			if (res) {
				valid = true;
				return *res;
			}
		} break;
			DEFAULT_OP_ARRAY_CMD(ARRAY, const Array, ;, return (*arr)[index]) // 20
			DEFAULT_OP_DVECTOR_GET(POOL_BYTE_ARRAY, uint8_t)
			DEFAULT_OP_DVECTOR_GET(POOL_INT_ARRAY, int)
			DEFAULT_OP_DVECTOR_GET(POOL_REAL_ARRAY, real_t)
			DEFAULT_OP_DVECTOR_GET(POOL_STRING_ARRAY, String)
			DEFAULT_OP_DVECTOR_GET(POOL_VECTOR2_ARRAY, Vector2)
			DEFAULT_OP_DVECTOR_GET(POOL_VECTOR2I_ARRAY, Vector2i)
			DEFAULT_OP_DVECTOR_GET(POOL_VECTOR3_ARRAY, Vector3)
			DEFAULT_OP_DVECTOR_GET(POOL_VECTOR3I_ARRAY, Vector3i)
			DEFAULT_OP_DVECTOR_GET(POOL_VECTOR4_ARRAY, Vector4)
			DEFAULT_OP_DVECTOR_GET(POOL_VECTOR4I_ARRAY, Vector4i)
			DEFAULT_OP_DVECTOR_GET(POOL_COLOR_ARRAY, Color)
		default:
			return Variant();
	}

	return Variant();
}

bool Variant::in(const Variant &p_index, bool *r_valid) const {
	if (r_valid) {
		*r_valid = true;
	}

	switch (type) {
		case STRING: {
			if (p_index.get_type() == Variant::STRING) {
				//string index
				String idx = p_index;
				const String *str = reinterpret_cast<const String *>(_data._mem);

				return str->find(idx) != -1;
			}

		} break;
		case OBJECT: {
			Object *obj = _OBJ_PTR(*this);
			if (unlikely(!obj)) {
				if (r_valid) {
					*r_valid = false;
				}
#ifdef DEBUG_ENABLED
				if (_get_obj().rc) {
					ERR_PRINT("Attempted 'in' on a deleted object.");
				}
#endif
				return false;
			}

			bool result;
			obj->get(p_index, &result);
			return result;
		} break;
		case DICTIONARY: {
			const Dictionary *dic = reinterpret_cast<const Dictionary *>(_data._mem);
			return dic->has(p_index);

		} break; // 20
		case ARRAY: {
			const Array *arr = reinterpret_cast<const Array *>(_data._mem);
			int l = arr->size();
			if (l) {
				for (int i = 0; i < l; i++) {
					if (evaluate(OP_EQUAL, (*arr)[i], p_index)) {
						return true;
					}
				}
			}

			return false;

		} break;
		case POOL_BYTE_ARRAY: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				int index = p_index;
				const PoolVector<uint8_t> *arr = reinterpret_cast<const PoolVector<uint8_t> *>(_data._mem);
				int l = arr->size();
				if (l) {
					PoolVector<uint8_t>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break;
		case POOL_INT_ARRAY: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				int index = p_index;
				const PoolVector<int> *arr = reinterpret_cast<const PoolVector<int> *>(_data._mem);
				int l = arr->size();
				if (l) {
					PoolVector<int>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}
		} break;
		case POOL_REAL_ARRAY: {
			if (p_index.get_type() == Variant::INT || p_index.get_type() == Variant::REAL) {
				real_t index = p_index;
				const PoolVector<real_t> *arr = reinterpret_cast<const PoolVector<real_t> *>(_data._mem);
				int l = arr->size();
				if (l) {
					PoolVector<real_t>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break;
		case POOL_STRING_ARRAY: {
			if (p_index.get_type() == Variant::STRING) {
				String index = p_index;
				const PoolVector<String> *arr = reinterpret_cast<const PoolVector<String> *>(_data._mem);

				int l = arr->size();
				if (l) {
					PoolVector<String>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break; //25
		case POOL_VECTOR2_ARRAY: {
			if (p_index.get_type() == Variant::VECTOR2) {
				Vector2 index = p_index;
				const PoolVector<Vector2> *arr = reinterpret_cast<const PoolVector<Vector2> *>(_data._mem);

				int l = arr->size();
				if (l) {
					PoolVector<Vector2>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break;
		case POOL_VECTOR2I_ARRAY: {
			if (p_index.get_type() == Variant::VECTOR2I) {
				Vector2i index = p_index;
				const PoolVector<Vector2i> *arr = reinterpret_cast<const PoolVector<Vector2i> *>(_data._mem);

				int l = arr->size();
				if (l) {
					PoolVector<Vector2i>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break;
		case POOL_VECTOR3_ARRAY: {
			if (p_index.get_type() == Variant::VECTOR3) {
				Vector3 index = p_index;
				const PoolVector<Vector3> *arr = reinterpret_cast<const PoolVector<Vector3> *>(_data._mem);

				int l = arr->size();
				if (l) {
					PoolVector<Vector3>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break;
		case POOL_VECTOR3I_ARRAY: {
			if (p_index.get_type() == Variant::VECTOR3I) {
				Vector3i index = p_index;
				const PoolVector<Vector3i> *arr = reinterpret_cast<const PoolVector<Vector3i> *>(_data._mem);

				int l = arr->size();
				if (l) {
					PoolVector<Vector3i>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break;
		case POOL_VECTOR4_ARRAY: {
			if (p_index.get_type() == Variant::VECTOR4) {
				Vector4 index = p_index;
				const PoolVector<Vector4> *arr = reinterpret_cast<const PoolVector<Vector4> *>(_data._mem);

				int l = arr->size();
				if (l) {
					PoolVector<Vector4>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break;
		case POOL_VECTOR4I_ARRAY: {
			if (p_index.get_type() == Variant::VECTOR4I) {
				Vector4i index = p_index;
				const PoolVector<Vector4i> *arr = reinterpret_cast<const PoolVector<Vector4i> *>(_data._mem);

				int l = arr->size();
				if (l) {
					PoolVector<Vector4i>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}

		} break;
		case POOL_COLOR_ARRAY: {
			if (p_index.get_type() == Variant::COLOR) {
				Color index = p_index;
				const PoolVector<Color> *arr = reinterpret_cast<const PoolVector<Color> *>(_data._mem);

				int l = arr->size();
				if (l) {
					PoolVector<Color>::Read r = arr->read();
					for (int i = 0; i < l; i++) {
						if (r[i] == index) {
							return true;
						}
					}
				}

				return false;
			}
		} break;
		default: {
		}
	}

	if (r_valid) {
		*r_valid = false;
	}
	return false;
}

bool Variant::iter_init(Variant &r_iter, bool &valid) const {
	valid = true;
	switch (type) {
		case INT: {
			r_iter = 0;
			return _data._int > 0;
		} break;
		case REAL: {
			r_iter = 0;
			return _data._real > 0.0;
		} break;
		case VECTOR2: {
			int64_t from = reinterpret_cast<const Vector2 *>(_data._mem)->x;
			int64_t to = reinterpret_cast<const Vector2 *>(_data._mem)->y;

			r_iter = from;

			return from < to;
		} break;
		case VECTOR2I: {
			int64_t from = reinterpret_cast<const Vector2i *>(_data._mem)->x;
			int64_t to = reinterpret_cast<const Vector2i *>(_data._mem)->y;

			r_iter = from;

			return from < to;
		} break;
		case VECTOR3: {
			int64_t from = reinterpret_cast<const Vector3 *>(_data._mem)->x;
			int64_t to = reinterpret_cast<const Vector3 *>(_data._mem)->y;
			int64_t step = reinterpret_cast<const Vector3 *>(_data._mem)->z;

			r_iter = from;

			if (from == to) {
				return false;
			} else if (from < to) {
				return step > 0;
			} else {
				return step < 0;
			}
			//return true;
		} break;
		case VECTOR3I: {
			int64_t from = reinterpret_cast<const Vector3i *>(_data._mem)->x;
			int64_t to = reinterpret_cast<const Vector3i *>(_data._mem)->y;
			int64_t step = reinterpret_cast<const Vector3i *>(_data._mem)->z;

			r_iter = from;

			if (from == to) {
				return false;
			} else if (from < to) {
				return step > 0;
			} else {
				return step < 0;
			}
			//return true;
		} break;
		case STRING: {
			const String *str = reinterpret_cast<const String *>(_data._mem);
			if (str->empty()) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case DICTIONARY: {
			const Dictionary *dic = reinterpret_cast<const Dictionary *>(_data._mem);
			if (dic->empty()) {
				return false;
			}

			const Variant *next = dic->next(nullptr);
			r_iter = *next;
			return true;

		} break;
		case ARRAY: {
			const Array *arr = reinterpret_cast<const Array *>(_data._mem);
			if (arr->empty()) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case POOL_BYTE_ARRAY: {
			const PoolVector<uint8_t> *arr = reinterpret_cast<const PoolVector<uint8_t> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;

		} break;
		case POOL_INT_ARRAY: {
			const PoolVector<int> *arr = reinterpret_cast<const PoolVector<int> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;

		} break;
		case POOL_REAL_ARRAY: {
			const PoolVector<real_t> *arr = reinterpret_cast<const PoolVector<real_t> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;

		} break;
		case POOL_STRING_ARRAY: {
			const PoolVector<String> *arr = reinterpret_cast<const PoolVector<String> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case POOL_VECTOR2_ARRAY: {
			const PoolVector<Vector2> *arr = reinterpret_cast<const PoolVector<Vector2> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case POOL_VECTOR2I_ARRAY: {
			const PoolVector<Vector2i> *arr = reinterpret_cast<const PoolVector<Vector2i> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case POOL_VECTOR3_ARRAY: {
			const PoolVector<Vector3> *arr = reinterpret_cast<const PoolVector<Vector3> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case POOL_VECTOR3I_ARRAY: {
			const PoolVector<Vector3i> *arr = reinterpret_cast<const PoolVector<Vector3i> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case POOL_VECTOR4_ARRAY: {
			const PoolVector<Vector4> *arr = reinterpret_cast<const PoolVector<Vector4> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case POOL_VECTOR4I_ARRAY: {
			const PoolVector<Vector4i> *arr = reinterpret_cast<const PoolVector<Vector4i> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;
		} break;
		case POOL_COLOR_ARRAY: {
			const PoolVector<Color> *arr = reinterpret_cast<const PoolVector<Color> *>(_data._mem);
			if (arr->size() == 0) {
				return false;
			}
			r_iter = 0;
			return true;

		} break;
		default: {
		}
	}

	valid = false;
	return false;
}
bool Variant::iter_next(Variant &r_iter, bool &valid) const {
	valid = true;
	switch (type) {
		case INT: {
			int64_t idx = r_iter;
			idx++;
			if (idx >= _data._int) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case REAL: {
			int64_t idx = r_iter;
			idx++;
			if (idx >= _data._real) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case VECTOR2: {
			int64_t to = reinterpret_cast<const Vector2 *>(_data._mem)->y;

			int64_t idx = r_iter;
			idx++;

			if (idx >= to) {
				return false;
			}

			r_iter = idx;
			return true;
		} break;
		case VECTOR2I: {
			int64_t to = reinterpret_cast<const Vector2i *>(_data._mem)->y;

			int64_t idx = r_iter;
			idx++;

			if (idx >= to) {
				return false;
			}

			r_iter = idx;
			return true;
		} break;
		case VECTOR3: {
			int64_t to = reinterpret_cast<const Vector3 *>(_data._mem)->y;
			int64_t step = reinterpret_cast<const Vector3 *>(_data._mem)->z;

			int64_t idx = r_iter;
			idx += step;

			if (step < 0 && idx <= to) {
				return false;
			}

			if (step > 0 && idx >= to) {
				return false;
			}

			r_iter = idx;
			return true;
		} break;
		case VECTOR3I: {
			int64_t to = reinterpret_cast<const Vector3i *>(_data._mem)->y;
			int64_t step = reinterpret_cast<const Vector3i *>(_data._mem)->z;

			int64_t idx = r_iter;
			idx += step;

			if (step < 0 && idx <= to) {
				return false;
			}

			if (step > 0 && idx >= to) {
				return false;
			}

			r_iter = idx;
			return true;
		} break;
		case STRING: {
			const String *str = reinterpret_cast<const String *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= str->length()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case DICTIONARY: {
			const Dictionary *dic = reinterpret_cast<const Dictionary *>(_data._mem);
			const Variant *next = dic->next(&r_iter);
			if (!next) {
				return false;
			}

			r_iter = *next;
			return true;

		} break;
		case ARRAY: {
			const Array *arr = reinterpret_cast<const Array *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case POOL_BYTE_ARRAY: {
			const PoolVector<uint8_t> *arr = reinterpret_cast<const PoolVector<uint8_t> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;

		} break;
		case POOL_INT_ARRAY: {
			const PoolVector<int> *arr = reinterpret_cast<const PoolVector<int> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;

		} break;
		case POOL_REAL_ARRAY: {
			const PoolVector<real_t> *arr = reinterpret_cast<const PoolVector<real_t> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;

		} break;
		case POOL_STRING_ARRAY: {
			const PoolVector<String> *arr = reinterpret_cast<const PoolVector<String> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case POOL_VECTOR2_ARRAY: {
			const PoolVector<Vector2> *arr = reinterpret_cast<const PoolVector<Vector2> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case POOL_VECTOR2I_ARRAY: {
			const PoolVector<Vector2i> *arr = reinterpret_cast<const PoolVector<Vector2i> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case POOL_VECTOR3_ARRAY: {
			const PoolVector<Vector3> *arr = reinterpret_cast<const PoolVector<Vector3> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case POOL_VECTOR3I_ARRAY: {
			const PoolVector<Vector3i> *arr = reinterpret_cast<const PoolVector<Vector3i> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case POOL_VECTOR4_ARRAY: {
			const PoolVector<Vector4> *arr = reinterpret_cast<const PoolVector<Vector4> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case POOL_VECTOR4I_ARRAY: {
			const PoolVector<Vector4i> *arr = reinterpret_cast<const PoolVector<Vector4i> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		case POOL_COLOR_ARRAY: {
			const PoolVector<Color> *arr = reinterpret_cast<const PoolVector<Color> *>(_data._mem);
			int idx = r_iter;
			idx++;
			if (idx >= arr->size()) {
				return false;
			}
			r_iter = idx;
			return true;
		} break;
		default: {
		}
	}

	valid = false;
	return false;
}

Variant Variant::iter_get(const Variant &r_iter, bool &r_valid) const {
	r_valid = true;
	switch (type) {
		case INT: {
			return r_iter;
		} break;
		case REAL: {
			return r_iter;
		} break;
		case VECTOR2: {
			return r_iter;
		} break;
		case VECTOR2I: {
			return r_iter;
		} break;
		case VECTOR3: {
			return r_iter;
		} break;
		case VECTOR3I: {
			return r_iter;
		} break;
		case STRING: {
			const String *str = reinterpret_cast<const String *>(_data._mem);
			return str->substr(r_iter, 1);
		} break;
		case DICTIONARY: {
			return r_iter; //iterator is the same as the key

		} break;
		case ARRAY: {
			const Array *arr = reinterpret_cast<const Array *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_BYTE_ARRAY: {
			const PoolVector<uint8_t> *arr = reinterpret_cast<const PoolVector<uint8_t> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_INT_ARRAY: {
			const PoolVector<int> *arr = reinterpret_cast<const PoolVector<int> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_REAL_ARRAY: {
			const PoolVector<real_t> *arr = reinterpret_cast<const PoolVector<real_t> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_STRING_ARRAY: {
			const PoolVector<String> *arr = reinterpret_cast<const PoolVector<String> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_VECTOR2_ARRAY: {
			const PoolVector<Vector2> *arr = reinterpret_cast<const PoolVector<Vector2> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_VECTOR2I_ARRAY: {
			const PoolVector<Vector2i> *arr = reinterpret_cast<const PoolVector<Vector2i> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_VECTOR3_ARRAY: {
			const PoolVector<Vector3> *arr = reinterpret_cast<const PoolVector<Vector3> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_VECTOR3I_ARRAY: {
			const PoolVector<Vector3i> *arr = reinterpret_cast<const PoolVector<Vector3i> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_VECTOR4_ARRAY: {
			const PoolVector<Vector4> *arr = reinterpret_cast<const PoolVector<Vector4> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_VECTOR4I_ARRAY: {
			const PoolVector<Vector4i> *arr = reinterpret_cast<const PoolVector<Vector4i> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		case POOL_COLOR_ARRAY: {
			const PoolVector<Color> *arr = reinterpret_cast<const PoolVector<Color> *>(_data._mem);
			int idx = r_iter;
#ifdef DEBUG_ENABLED
			if (idx < 0 || idx >= arr->size()) {
				r_valid = false;
				return Variant();
			}
#endif
			return arr->get(idx);
		} break;
		default: {
		}
	}

	r_valid = false;
	return Variant();
}

Variant Variant::duplicate(bool deep) const {
	switch (type) {
		case OBJECT: {
			/*  breaks stuff :(
			if (deep && !_get_obj().ref.is_null()) {
				Ref<Resource> resource = _get_obj().ref;
				if (resource.is_valid()) {
					return resource->duplicate(true);
				}
			}
			*/
			return *this;
		} break;
		case DICTIONARY:
			return operator Dictionary().duplicate(deep);
		case ARRAY:
			return operator Array().duplicate(deep);
		default:
			return *this;
	}
}

void Variant::sub(const Variant &a, const Variant &b, Variant &r_dst) {
	if (a.type != b.type) {
		return;
	}

	switch (a.type) {
		case NIL: {
			r_dst = Variant();
		}
			return;
		case INT: {
			int64_t va = a._data._int;
			int64_t vb = b._data._int;
			r_dst = int(va - vb);
		}
			return;
		case REAL: {
			real_t ra = a._data._real;
			real_t rb = b._data._real;
			r_dst = ra - rb;
		}
			return;
		case RECT2: {
			const Rect2 *ra = reinterpret_cast<const Rect2 *>(a._data._mem);
			const Rect2 *rb = reinterpret_cast<const Rect2 *>(b._data._mem);
			r_dst = Rect2(ra->position - rb->position, ra->size - rb->size);
		}
			return;
		case RECT2I: {
			const Rect2i *ra = reinterpret_cast<const Rect2i *>(a._data._mem);
			const Rect2i *rb = reinterpret_cast<const Rect2i *>(b._data._mem);

			int32_t vax = ra->position.x;
			int32_t vay = ra->position.y;
			int32_t vbx = ra->size.x;
			int32_t vby = ra->size.y;
			int32_t vcx = rb->position.x;
			int32_t vcy = rb->position.y;
			int32_t vdx = rb->size.x;
			int32_t vdy = rb->size.y;

			r_dst = Rect2i(int32_t(vax - vbx), int32_t(vay - vby), int32_t(vcx - vdx), int32_t(vcy - vdy));
		}
			return;
		case VECTOR2: {
			r_dst = *reinterpret_cast<const Vector2 *>(a._data._mem) - *reinterpret_cast<const Vector2 *>(b._data._mem);
		}
			return;
		case VECTOR2I: {
			int32_t vax = reinterpret_cast<const Vector2i *>(a._data._mem)->x;
			int32_t vbx = reinterpret_cast<const Vector2i *>(b._data._mem)->x;
			int32_t vay = reinterpret_cast<const Vector2i *>(a._data._mem)->y;
			int32_t vby = reinterpret_cast<const Vector2i *>(b._data._mem)->y;
			r_dst = Vector2i(int32_t(vax - vbx), int32_t(vay - vby));
		}
			return;
		case VECTOR3: {
			r_dst = *reinterpret_cast<const Vector3 *>(a._data._mem) - *reinterpret_cast<const Vector3 *>(b._data._mem);
		}
			return;
		case VECTOR3I: {
			int32_t vax = reinterpret_cast<const Vector3i *>(a._data._mem)->x;
			int32_t vbx = reinterpret_cast<const Vector3i *>(b._data._mem)->x;
			int32_t vay = reinterpret_cast<const Vector3i *>(a._data._mem)->y;
			int32_t vby = reinterpret_cast<const Vector3i *>(b._data._mem)->y;
			int32_t vaz = reinterpret_cast<const Vector3i *>(a._data._mem)->z;
			int32_t vbz = reinterpret_cast<const Vector3i *>(b._data._mem)->z;
			r_dst = Vector3i(int32_t(vax - vbx), int32_t(vay - vby), int32_t(vaz - vbz));
		}
			return;
		case VECTOR4: {
			r_dst = *reinterpret_cast<const Vector4 *>(a._data._mem) - *reinterpret_cast<const Vector4 *>(b._data._mem);
		}
			return;
		case VECTOR4I: {
			int32_t vax = reinterpret_cast<const Vector4i *>(a._data._mem)->x;
			int32_t vbx = reinterpret_cast<const Vector4i *>(b._data._mem)->x;
			int32_t vay = reinterpret_cast<const Vector4i *>(a._data._mem)->y;
			int32_t vaw = reinterpret_cast<const Vector4i *>(a._data._mem)->w;
			int32_t vby = reinterpret_cast<const Vector4i *>(b._data._mem)->y;
			int32_t vaz = reinterpret_cast<const Vector4i *>(a._data._mem)->z;
			int32_t vbz = reinterpret_cast<const Vector4i *>(b._data._mem)->z;
			int32_t vbw = reinterpret_cast<const Vector4i *>(b._data._mem)->w;
			r_dst = Vector4i(int32_t(vax - vbx), int32_t(vay - vby), int32_t(vaz - vbz), int32_t(vaw - vbw));
		}
			return;
		case AABB: {
			const ::AABB *ra = reinterpret_cast<const ::AABB *>(a._data._mem);
			const ::AABB *rb = reinterpret_cast<const ::AABB *>(b._data._mem);
			r_dst = ::AABB(ra->position - rb->position, ra->size - rb->size);
		}
			return;
		case QUATERNION: {
			Quaternion empty_rot;
			const Quaternion *qa = reinterpret_cast<const Quaternion *>(a._data._mem);
			const Quaternion *qb = reinterpret_cast<const Quaternion *>(b._data._mem);
			r_dst = (*qb).inverse() * *qa;
		}
			return;
		case COLOR: {
			const Color *ca = reinterpret_cast<const Color *>(a._data._mem);
			const Color *cb = reinterpret_cast<const Color *>(b._data._mem);
			float new_r = ca->r - cb->r;
			float new_g = ca->g - cb->g;
			float new_b = ca->b - cb->b;
			float new_a = ca->a - cb->a;
			new_r = new_r > 1.0 ? 1.0 : new_r;
			new_g = new_g > 1.0 ? 1.0 : new_g;
			new_b = new_b > 1.0 ? 1.0 : new_b;
			new_a = new_a > 1.0 ? 1.0 : new_a;
			r_dst = Color(new_r, new_g, new_b, new_a);
		}
			return;
		default: {
			r_dst = a;
		}
			return;
	}
}

void Variant::blend(const Variant &a, const Variant &b, float c, Variant &r_dst) {
	if (a.type != b.type) {
		if (a.is_num() && b.is_num()) {
			real_t va = a;
			real_t vb = b;
			r_dst = va + vb * c;
		} else {
			r_dst = a;
		}
		return;
	}

	switch (a.type) {
		case NIL: {
			r_dst = Variant();
		}
			return;
		case INT: {
			int64_t va = a._data._int;
			int64_t vb = b._data._int;
			r_dst = int(va + vb * c + 0.5);
		}
			return;
		case REAL: {
			double ra = a._data._real;
			double rb = b._data._real;
			r_dst = ra + rb * c;
		}
			return;
		case RECT2: {
			const Rect2 *ra = reinterpret_cast<const Rect2 *>(a._data._mem);
			const Rect2 *rb = reinterpret_cast<const Rect2 *>(b._data._mem);
			r_dst = Rect2(ra->position + rb->position * c, ra->size + rb->size * c);
		}
			return;
		case RECT2I: {
			const Rect2i *ra = reinterpret_cast<const Rect2i *>(a._data._mem);
			const Rect2i *rb = reinterpret_cast<const Rect2i *>(b._data._mem);
			r_dst = Rect2i(ra->position + rb->position * c, ra->size + rb->size * c);
		}
			return;
		case VECTOR2: {
			r_dst = *reinterpret_cast<const Vector2 *>(a._data._mem) + *reinterpret_cast<const Vector2 *>(b._data._mem) * c;
		}
			return;
		case VECTOR2I: {
			r_dst = *reinterpret_cast<const Vector2i *>(a._data._mem) + *reinterpret_cast<const Vector2i *>(b._data._mem) * c;
		}
			return;
		case VECTOR3: {
			r_dst = *reinterpret_cast<const Vector3 *>(a._data._mem) + *reinterpret_cast<const Vector3 *>(b._data._mem) * c;
		}
			return;
		case VECTOR3I: {
			r_dst = *reinterpret_cast<const Vector3i *>(a._data._mem) + *reinterpret_cast<const Vector3i *>(b._data._mem) * c;
		}
			return;
		case VECTOR4: {
			r_dst = *reinterpret_cast<const Vector4 *>(a._data._mem) + *reinterpret_cast<const Vector4 *>(b._data._mem) * c;
		}
			return;
		case VECTOR4I: {
			r_dst = *reinterpret_cast<const Vector4i *>(a._data._mem) + *reinterpret_cast<const Vector4i *>(b._data._mem) * c;
		}
			return;
		case AABB: {
			const ::AABB *ra = reinterpret_cast<const ::AABB *>(a._data._mem);
			const ::AABB *rb = reinterpret_cast<const ::AABB *>(b._data._mem);
			r_dst = ::AABB(ra->position + rb->position * c, ra->size + rb->size * c);
		}
			return;
		case QUATERNION: {
			Quaternion empty_rot;
			const Quaternion *qa = reinterpret_cast<const Quaternion *>(a._data._mem);
			const Quaternion *qb = reinterpret_cast<const Quaternion *>(b._data._mem);
			r_dst = *qa * empty_rot.slerp(*qb, c);
		}
			return;
		case COLOR: {
			const Color *ca = reinterpret_cast<const Color *>(a._data._mem);
			const Color *cb = reinterpret_cast<const Color *>(b._data._mem);
			float new_r = ca->r + cb->r * c;
			float new_g = ca->g + cb->g * c;
			float new_b = ca->b + cb->b * c;
			float new_a = ca->a + cb->a * c;
			new_r = new_r > 1.0 ? 1.0 : new_r;
			new_g = new_g > 1.0 ? 1.0 : new_g;
			new_b = new_b > 1.0 ? 1.0 : new_b;
			new_a = new_a > 1.0 ? 1.0 : new_a;
			r_dst = Color(new_r, new_g, new_b, new_a);
		}
			return;
		default: {
			r_dst = c < 0.5 ? a : b;
		}
			return;
	}
}

void Variant::interpolate(const Variant &a, const Variant &b, float c, Variant &r_dst) {
	if (a.type != b.type) {
		if (a.is_num() && b.is_num()) {
			//not as efficient but..
			real_t va = a;
			real_t vb = b;
			r_dst = va + (vb - va) * c;

		} else {
			r_dst = a;
		}
		return;
	}

	switch (a.type) {
		case NIL: {
			r_dst = Variant();
		}
			return;
		case BOOL: {
			r_dst = a;
		}
			return;
		case INT: {
			int64_t va = a._data._int;
			int64_t vb = b._data._int;
			r_dst = int(va + (vb - va) * c);
		}
			return;
		case REAL: {
			real_t va = a._data._real;
			real_t vb = b._data._real;
			r_dst = va + (vb - va) * c;
		}
			return;
		case STRING: {
			//this is pretty funny and bizarre, but artists like to use it for typewritter effects
			String sa = *reinterpret_cast<const String *>(a._data._mem);
			String sb = *reinterpret_cast<const String *>(b._data._mem);
			String dst;
			int sa_len = sa.length();
			int sb_len = sb.length();
			int csize = sa_len + (sb_len - sa_len) * c;
			if (csize == 0) {
				r_dst = "";
				return;
			}
			dst.resize(csize + 1);
			dst[csize] = 0;
			int split = csize / 2;

			for (int i = 0; i < csize; i++) {
				CharType chr = ' ';

				if (i < split) {
					if (i < sa.length()) {
						chr = sa[i];
					} else if (i < sb.length()) {
						chr = sb[i];
					}

				} else {
					if (i < sb.length()) {
						chr = sb[i];
					} else if (i < sa.length()) {
						chr = sa[i];
					}
				}

				dst[i] = chr;
			}

			r_dst = dst;
		}
			return;
		case RECT2: {
			r_dst = Rect2(reinterpret_cast<const Rect2 *>(a._data._mem)->position.linear_interpolate(reinterpret_cast<const Rect2 *>(b._data._mem)->position, c), reinterpret_cast<const Rect2 *>(a._data._mem)->size.linear_interpolate(reinterpret_cast<const Rect2 *>(b._data._mem)->size, c));
		}
			return;
		case RECT2I: {
			r_dst = Rect2(reinterpret_cast<const Rect2i *>(a._data._mem)->position.linear_interpolate(reinterpret_cast<const Rect2i *>(b._data._mem)->position, c), reinterpret_cast<const Rect2 *>(a._data._mem)->size.linear_interpolate(reinterpret_cast<const Rect2 *>(b._data._mem)->size, c));
		}
			return;
		case VECTOR2: {
			r_dst = reinterpret_cast<const Vector2 *>(a._data._mem)->linear_interpolate(*reinterpret_cast<const Vector2 *>(b._data._mem), c);
		}
			return;
		case VECTOR2I: {
			r_dst = reinterpret_cast<const Vector2i *>(a._data._mem)->linear_interpolate(*reinterpret_cast<const Vector2i *>(b._data._mem), c);
		}
			return;
		case VECTOR3: {
			r_dst = reinterpret_cast<const Vector3 *>(a._data._mem)->linear_interpolate(*reinterpret_cast<const Vector3 *>(b._data._mem), c);
		}
			return;
		case VECTOR3I: {
			r_dst = reinterpret_cast<const Vector3i *>(a._data._mem)->linear_interpolate(*reinterpret_cast<const Vector3i *>(b._data._mem), c);
		}
			return;
		case VECTOR4: {
			r_dst = reinterpret_cast<const Vector4 *>(a._data._mem)->linear_interpolate(*reinterpret_cast<const Vector4 *>(b._data._mem), c);
		}
			return;
		case VECTOR4I: {
			r_dst = reinterpret_cast<const Vector4i *>(a._data._mem)->linear_interpolate(*reinterpret_cast<const Vector4i *>(b._data._mem), c);
		}
			return;
		case PLANE: {
			r_dst = a;
		}
			return;
		case QUATERNION: {
			r_dst = reinterpret_cast<const Quaternion *>(a._data._mem)->slerp(*reinterpret_cast<const Quaternion *>(b._data._mem), c);
		}
			return;
		case AABB: {
			r_dst = ::AABB(a._data._aabb->position.linear_interpolate(b._data._aabb->position, c), a._data._aabb->size.linear_interpolate(b._data._aabb->size, c));
		}
			return;
		case BASIS: {
			r_dst = Transform(*a._data._basis).interpolate_with(Transform(*b._data._basis), c).basis;
		}
			return;
		case TRANSFORM: {
			r_dst = a._data._transform->interpolate_with(*b._data._transform, c);
		}
			return;
		case TRANSFORM2D: {
			r_dst = a._data._transform2d->interpolate_with(*b._data._transform2d, c);
		}
			return;
		case COLOR: {
			r_dst = reinterpret_cast<const Color *>(a._data._mem)->linear_interpolate(*reinterpret_cast<const Color *>(b._data._mem), c);
		}
			return;
		case OBJECT: {
			r_dst = a;
		}
			return;
		case STRING_NAME: {
			r_dst = a;
		}
			return;
		case DICTIONARY: {
		}
			return;
		case ARRAY: {
			r_dst = a;
		}
			return;
		case POOL_BYTE_ARRAY: {
			r_dst = a;
		}
			return;
		case POOL_INT_ARRAY: {
			const PoolVector<int> *arr_a = reinterpret_cast<const PoolVector<int> *>(a._data._mem);
			const PoolVector<int> *arr_b = reinterpret_cast<const PoolVector<int> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<int> v;
				v.resize(sz);
				{
					PoolVector<int>::Write vw = v.write();
					PoolVector<int>::Read ar = arr_a->read();
					PoolVector<int>::Read br = arr_b->read();

					Variant va;
					for (int i = 0; i < sz; i++) {
						Variant::interpolate(ar[i], br[i], c, va);
						vw[i] = va;
					}
				}
				r_dst = v;
			}
		}
			return;
		case POOL_REAL_ARRAY: {
			const PoolVector<real_t> *arr_a = reinterpret_cast<const PoolVector<real_t> *>(a._data._mem);
			const PoolVector<real_t> *arr_b = reinterpret_cast<const PoolVector<real_t> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<real_t> v;
				v.resize(sz);
				{
					PoolVector<real_t>::Write vw = v.write();
					PoolVector<real_t>::Read ar = arr_a->read();
					PoolVector<real_t>::Read br = arr_b->read();

					Variant va;
					for (int i = 0; i < sz; i++) {
						Variant::interpolate(ar[i], br[i], c, va);
						vw[i] = va;
					}
				}
				r_dst = v;
			}
		}
			return;
		case POOL_STRING_ARRAY: {
			r_dst = a;
		}
			return;
		case POOL_VECTOR2_ARRAY: {
			const PoolVector<Vector2> *arr_a = reinterpret_cast<const PoolVector<Vector2> *>(a._data._mem);
			const PoolVector<Vector2> *arr_b = reinterpret_cast<const PoolVector<Vector2> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<Vector2> v;
				v.resize(sz);
				{
					PoolVector<Vector2>::Write vw = v.write();
					PoolVector<Vector2>::Read ar = arr_a->read();
					PoolVector<Vector2>::Read br = arr_b->read();

					for (int i = 0; i < sz; i++) {
						vw[i] = ar[i].linear_interpolate(br[i], c);
					}
				}
				r_dst = v;
			}
		}
			return;
		case POOL_VECTOR2I_ARRAY: {
			const PoolVector<Vector2i> *arr_a = reinterpret_cast<const PoolVector<Vector2i> *>(a._data._mem);
			const PoolVector<Vector2i> *arr_b = reinterpret_cast<const PoolVector<Vector2i> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<Vector2i> v;
				v.resize(sz);
				{
					PoolVector<Vector2i>::Write vw = v.write();
					PoolVector<Vector2i>::Read ar = arr_a->read();
					PoolVector<Vector2i>::Read br = arr_b->read();

					for (int i = 0; i < sz; i++) {
						vw[i] = ar[i].linear_interpolate(br[i], c);
					}
				}
				r_dst = v;
			}
		}
			return;
		case POOL_VECTOR3_ARRAY: {
			const PoolVector<Vector3> *arr_a = reinterpret_cast<const PoolVector<Vector3> *>(a._data._mem);
			const PoolVector<Vector3> *arr_b = reinterpret_cast<const PoolVector<Vector3> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<Vector3> v;
				v.resize(sz);
				{
					PoolVector<Vector3>::Write vw = v.write();
					PoolVector<Vector3>::Read ar = arr_a->read();
					PoolVector<Vector3>::Read br = arr_b->read();

					for (int i = 0; i < sz; i++) {
						vw[i] = ar[i].linear_interpolate(br[i], c);
					}
				}
				r_dst = v;
			}
		}
			return;
		case POOL_VECTOR3I_ARRAY: {
			const PoolVector<Vector3i> *arr_a = reinterpret_cast<const PoolVector<Vector3i> *>(a._data._mem);
			const PoolVector<Vector3i> *arr_b = reinterpret_cast<const PoolVector<Vector3i> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<Vector3i> v;
				v.resize(sz);
				{
					PoolVector<Vector3i>::Write vw = v.write();
					PoolVector<Vector3i>::Read ar = arr_a->read();
					PoolVector<Vector3i>::Read br = arr_b->read();

					for (int i = 0; i < sz; i++) {
						vw[i] = ar[i].linear_interpolate(br[i], c);
					}
				}
				r_dst = v;
			}
		}
			return;
		case POOL_VECTOR4_ARRAY: {
			const PoolVector<Vector4> *arr_a = reinterpret_cast<const PoolVector<Vector4> *>(a._data._mem);
			const PoolVector<Vector4> *arr_b = reinterpret_cast<const PoolVector<Vector4> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<Vector4> v;
				v.resize(sz);
				{
					PoolVector<Vector4>::Write vw = v.write();
					PoolVector<Vector4>::Read ar = arr_a->read();
					PoolVector<Vector4>::Read br = arr_b->read();

					for (int i = 0; i < sz; i++) {
						vw[i] = ar[i].linear_interpolate(br[i], c);
					}
				}
				r_dst = v;
			}
		}
			return;
		case POOL_VECTOR4I_ARRAY: {
			const PoolVector<Vector4i> *arr_a = reinterpret_cast<const PoolVector<Vector4i> *>(a._data._mem);
			const PoolVector<Vector4i> *arr_b = reinterpret_cast<const PoolVector<Vector4i> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<Vector4i> v;
				v.resize(sz);
				{
					PoolVector<Vector4i>::Write vw = v.write();
					PoolVector<Vector4i>::Read ar = arr_a->read();
					PoolVector<Vector4i>::Read br = arr_b->read();

					for (int i = 0; i < sz; i++) {
						vw[i] = ar[i].linear_interpolate(br[i], c);
					}
				}
				r_dst = v;
			}

			r_dst = a;
		}
			return;
		case POOL_COLOR_ARRAY: {
			const PoolVector<Color> *arr_a = reinterpret_cast<const PoolVector<Color> *>(a._data._mem);
			const PoolVector<Color> *arr_b = reinterpret_cast<const PoolVector<Color> *>(b._data._mem);
			int sz = arr_a->size();
			if (sz == 0 || arr_b->size() != sz) {
				r_dst = a;
			} else {
				PoolVector<Color> v;
				v.resize(sz);
				{
					PoolVector<Color>::Write vw = v.write();
					PoolVector<Color>::Read ar = arr_a->read();
					PoolVector<Color>::Read br = arr_b->read();

					for (int i = 0; i < sz; i++) {
						vw[i] = ar[i].linear_interpolate(br[i], c);
					}
				}
				r_dst = v;
			}
		}
			return;
		default: {
			r_dst = a;
		}
	}
}

static const char *_op_names[Variant::OP_MAX] = {
	"==",
	"!=",
	"<",
	"<=",
	">",
	">=",
	"+",
	"-",
	"*",
	"/",
	"- (negation)",
	"+ (positive)",
	"%",
	"+ (concatenation)",
	"<<",
	">>",
	"&",
	"|",
	"^",
	"~",
	"and",
	"or",
	"xor",
	"not",
	"in"

};

String Variant::get_operator_name(Operator p_op) {
	ERR_FAIL_INDEX_V(p_op, OP_MAX, "");
	return _op_names[p_op];
}

#undef CASE_TYPE_ALL
#undef CASE_TYPE_ALL_BUT_INT
#undef TYPE
#undef TYPES
#undef CASES
#undef SWITCH
#undef SWITCH_OP
#undef CASE_TYPE
#undef CASES
#undef SWITCH
#undef SWITCH_OP
#undef CASE_TYPE
#undef _RETURN
#undef _RETURN_FAIL
#undef DEFAULT_OP_NUM
#undef DEFAULT_OP_NUM_NULL
#undef DEFAULT_OP_NUM_DIV
#undef DEFAULT_OP_NUM_DIV
#undef DEFAULT_OP_NUM_NEG
#undef DEFAULT_OP_NUM_POS
#undef DEFAULT_OP_NUM_VEC
#undef DEFAULT_OP_STR_REV
#undef DEFAULT_OP_STR
#undef DEFAULT_OP_STR_NULL
#undef DEFAULT_OP_STR_NULL_NP
#undef DEFAULT_OP_STR_NULL_SN
#undef DEFAULT_OP_LOCALMEM_REV
#undef DEFAULT_OP_LOCALMEM
#undef DEFAULT_OP_LOCALMEM_NULL
#undef DEFAULT_OP_LOCALMEM_NEG
#undef DEFAULT_OP_LOCALMEM_POS
#undef DEFAULT_OP_LOCALMEM_NUM
#undef DEFAULT_OP_PTR
#undef DEFAULT_OP_PTRREF
#undef DEFAULT_OP_PTRREF_NULL
#undef DEFAULT_OP_ARRAY_EQ
#undef DEFAULT_OP_ARRAY_NEQ
#undef DEFAULT_OP_ARRAY_LT
#undef DEFAULT_OP_ARRAY_GT
#undef DEFAULT_OP_ARRAY_OP
#undef DEFAULT_OP_ARRAY_OP_BODY
#undef DEFAULT_OP_ARRAY_ADD
#undef DEFAULT_OP_ARRAY_CMD
#undef DEFAULT_OP_DVECTOR_SET
#undef DEFAULT_OP_DVECTOR_GET
#line 0

//===================  RENDER CORE SECTION  ===================

#line 1 "sfw/render_core/font_data_bm_mini.inc.h"

// bm-mini.zip (public domain font)
// http://bitmapmania.m78.com
// cooz@m78.com

static const unsigned char bm_mini_ttf[] = {
	/*000000*/ 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x30, 0x00, 0x03, 0x00, 0xb0, 0x4f, 0x53, 0x2f, 0x32,
	/*000010*/ 0x80, 0x00, 0x6d, 0x88, 0x00, 0x00, 0x4e, 0x04, 0x00, 0x00, 0x00, 0x4e, 0x63, 0x6d, 0x61, 0x70,
	/*000020*/ 0xf1, 0x89, 0xe8, 0x81, 0x00, 0x00, 0x45, 0x54, 0x00, 0x00, 0x02, 0x28, 0x63, 0x76, 0x74, 0x20,
	/*000030*/ 0x5a, 0x9b, 0xfa, 0x82, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x32, 0x66, 0x70, 0x67, 0x6d,
	/*000040*/ 0x83, 0x33, 0xc2, 0x4f, 0x00, 0x00, 0x03, 0xd4, 0x00, 0x00, 0x00, 0x14, 0x67, 0x6c, 0x79, 0x66,
	/*000050*/ 0x05, 0xa3, 0xba, 0x6b, 0x00, 0x00, 0x04, 0x64, 0x00, 0x00, 0x3c, 0xec, 0x68, 0x64, 0x6d, 0x78,
	/*000060*/ 0x0d, 0xad, 0x0b, 0x14, 0x00, 0x00, 0x47, 0x7c, 0x00, 0x00, 0x06, 0x88, 0x68, 0x65, 0x61, 0x64,
	/*000070*/ 0xce, 0xfe, 0xc6, 0xae, 0x00, 0x00, 0x4e, 0x54, 0x00, 0x00, 0x00, 0x36, 0x68, 0x68, 0x65, 0x61,
	/*000080*/ 0x05, 0x15, 0x02, 0xee, 0x00, 0x00, 0x4e, 0x8c, 0x00, 0x00, 0x00, 0x24, 0x68, 0x6d, 0x74, 0x78,
	/*000090*/ 0xae, 0x38, 0x00, 0xf4, 0x00, 0x00, 0x42, 0xe0, 0x00, 0x00, 0x01, 0x8c, 0x6c, 0x6f, 0x63, 0x61,
	/*0000a0*/ 0x00, 0x0b, 0xe4, 0xba, 0x00, 0x00, 0x41, 0x50, 0x00, 0x00, 0x01, 0x90, 0x6d, 0x61, 0x78, 0x70,
	/*0000b0*/ 0x00, 0xfe, 0x01, 0x4d, 0x00, 0x00, 0x4e, 0xb0, 0x00, 0x00, 0x00, 0x20, 0x6e, 0x61, 0x6d, 0x65,
	/*0000c0*/ 0xd6, 0xe2, 0x1a, 0x1f, 0x00, 0x00, 0x00, 0xec, 0x00, 0x00, 0x02, 0xe5, 0x70, 0x6f, 0x73, 0x74,
	/*0000d0*/ 0x09, 0x85, 0x09, 0xff, 0x00, 0x00, 0x44, 0x6c, 0x00, 0x00, 0x00, 0xe8, 0x70, 0x72, 0x65, 0x70,
	/*0000e0*/ 0xc9, 0x0f, 0xd2, 0x13, 0x00, 0x00, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x15,
	/*0000f0*/ 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x3b, 0x00, 0x00,
	/*000100*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0e, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*000110*/ 0x00, 0x02, 0x00, 0x04, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x4e,
	/*000120*/ 0x01, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x14, 0x00, 0xd6, 0x00, 0x00,
	/*000130*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x48, 0x01, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*000140*/ 0x00, 0x06, 0x00, 0x10, 0x01, 0xd3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b,
	/*000150*/ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0xb1, 0x00, 0x01,
	/*000160*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0xc6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	/*000170*/ 0x00, 0x03, 0x00, 0x27, 0x00, 0xea, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0a,
	/*000180*/ 0x00, 0xcc, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x24, 0x01, 0x5f, 0x00, 0x01,
	/*000190*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x01, 0xcb, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09,
	/*0001a0*/ 0x00, 0x00, 0x00, 0x76, 0x00, 0x3b, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x01, 0x00, 0x0e,
	/*0001b0*/ 0x00, 0xb8, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x02, 0x00, 0x04, 0x00, 0xc8, 0x00, 0x03,
	/*0001c0*/ 0x00, 0x01, 0x04, 0x09, 0x00, 0x03, 0x00, 0x4e, 0x01, 0x11, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09,
	/*0001d0*/ 0x00, 0x04, 0x00, 0x14, 0x00, 0xd6, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x05, 0x00, 0x48,
	/*0001e0*/ 0x01, 0x83, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x06, 0x00, 0x10, 0x01, 0xd3, 0x43, 0x6f,
	/*0001f0*/ 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x43, 0x29, 0x20, 0x32, 0x30, 0x30, 0x31,
	/*000200*/ 0x20, 0x42, 0x69, 0x74, 0x6d, 0x61, 0x70, 0x4d, 0x61, 0x6e, 0x69, 0x61, 0x20, 0x2f, 0x20, 0x43,
	/*000210*/ 0x4f, 0x4f, 0x5a, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x73, 0x20,
	/*000220*/ 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2e, 0x00, 0x43, 0x00, 0x6f, 0x00, 0x70, 0x00,
	/*000230*/ 0x79, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x20, 0x00, 0x28, 0x00,
	/*000240*/ 0x43, 0x00, 0x29, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x31, 0x00, 0x20, 0x00,
	/*000250*/ 0x42, 0x00, 0x69, 0x00, 0x74, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x70, 0x00, 0x4d, 0x00, 0x61, 0x00,
	/*000260*/ 0x6e, 0x00, 0x69, 0x00, 0x61, 0x00, 0x20, 0x00, 0x2f, 0x00, 0x20, 0x00, 0x43, 0x00, 0x4f, 0x00,
	/*000270*/ 0x4f, 0x00, 0x5a, 0x00, 0x2e, 0x00, 0x20, 0x00, 0x41, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x20, 0x00,
	/*000280*/ 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x73, 0x00, 0x20, 0x00, 0x72, 0x00,
	/*000290*/ 0x65, 0x00, 0x73, 0x00, 0x65, 0x00, 0x72, 0x00, 0x76, 0x00, 0x65, 0x00, 0x64, 0x00, 0x2e, 0x42,
	/*0002a0*/ 0x4d, 0x20, 0x6d, 0x69, 0x6e, 0x69, 0x00, 0x42, 0x00, 0x4d, 0x00, 0x20, 0x00, 0x6d, 0x00, 0x69,
	/*0002b0*/ 0x00, 0x6e, 0x00, 0x69, 0x41, 0x38, 0x00, 0x41, 0x00, 0x38, 0x42, 0x4d, 0x20, 0x6d, 0x69, 0x6e,
	/*0002c0*/ 0x69, 0x20, 0x41, 0x38, 0x00, 0x42, 0x00, 0x4d, 0x00, 0x20, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x6e,
	/*0002d0*/ 0x00, 0x69, 0x00, 0x20, 0x00, 0x41, 0x00, 0x38, 0x4d, 0x61, 0x63, 0x72, 0x6f, 0x6d, 0x65, 0x64,
	/*0002e0*/ 0x69, 0x61, 0x20, 0x46, 0x6f, 0x6e, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x70, 0x68, 0x65, 0x72, 0x20,
	/*0002f0*/ 0x34, 0x2e, 0x31, 0x4a, 0x20, 0x42, 0x4d, 0x20, 0x6d, 0x69, 0x6e, 0x69, 0x20, 0x41, 0x38, 0x00,
	/*000300*/ 0x4d, 0x00, 0x61, 0x00, 0x63, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x64, 0x00,
	/*000310*/ 0x69, 0x00, 0x61, 0x00, 0x20, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x6f, 0x00,
	/*000320*/ 0x67, 0x00, 0x72, 0x00, 0x61, 0x00, 0x70, 0x00, 0x68, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00,
	/*000330*/ 0x34, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x4a, 0x00, 0x20, 0x00, 0x42, 0x00, 0x4d, 0x00, 0x20, 0x00,
	/*000340*/ 0x6d, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x20, 0x00, 0x41, 0x00, 0x38, 0x4d, 0x61, 0x63,
	/*000350*/ 0x72, 0x6f, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x20, 0x46, 0x6f, 0x6e, 0x74, 0x6f, 0x67, 0x72, 0x61,
	/*000360*/ 0x70, 0x68, 0x65, 0x72, 0x20, 0x34, 0x2e, 0x31, 0x4a, 0x20, 0x30, 0x31, 0x2e, 0x31, 0x2e, 0x32,
	/*000370*/ 0x37, 0x00, 0x4d, 0x00, 0x61, 0x00, 0x63, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x6d, 0x00, 0x65, 0x00,
	/*000380*/ 0x64, 0x00, 0x69, 0x00, 0x61, 0x00, 0x20, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x74, 0x00,
	/*000390*/ 0x6f, 0x00, 0x67, 0x00, 0x72, 0x00, 0x61, 0x00, 0x70, 0x00, 0x68, 0x00, 0x65, 0x00, 0x72, 0x00,
	/*0003a0*/ 0x20, 0x00, 0x34, 0x00, 0x2e, 0x00, 0x31, 0x00, 0x4a, 0x00, 0x20, 0x00, 0x30, 0x00, 0x31, 0x00,
	/*0003b0*/ 0x2e, 0x00, 0x31, 0x00, 0x2e, 0x00, 0x32, 0x00, 0x37, 0x42, 0x4d, 0x6d, 0x69, 0x6e, 0x69, 0x41,
	/*0003c0*/ 0x38, 0x00, 0x42, 0x00, 0x4d, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x41, 0x00,
	/*0003d0*/ 0x38, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x2c, 0x76, 0x45, 0x20, 0xb0, 0x03, 0x25, 0x45, 0x23,
	/*0003e0*/ 0x61, 0x68, 0x18, 0x23, 0x68, 0x60, 0x44, 0x2d, 0xff, 0x39, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57,
	/*0003f0*/ 0x00, 0x62, 0x00, 0xc5, 0x00, 0x62, 0x00, 0xc5, 0x01, 0x29, 0x01, 0x8d, 0x01, 0x8e, 0x01, 0x2a,
	/*000400*/ 0x5a, 0x67, 0x12, 0x06, 0xd2, 0xb8, 0x6a, 0x18, 0xf8, 0x2a, 0x61, 0xa3, 0x0e, 0x40, 0xee, 0xd2,
	/*000410*/ 0x80, 0x3a, 0x27, 0x55, 0xa2, 0x87, 0x00, 0x01, 0x00, 0x0d, 0x00, 0x00, 0x40, 0x11, 0x0b, 0x0b,
	/*000420*/ 0x0a, 0x0a, 0x09, 0x09, 0x08, 0x08, 0x03, 0x03, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x01, 0x8d,
	/*000430*/ 0xb8, 0x01, 0xff, 0x85, 0x45, 0x68, 0x44, 0x45, 0x68, 0x44, 0x45, 0x68, 0x44, 0x45, 0x68, 0x44,
	/*000440*/ 0x45, 0x68, 0x44, 0x45, 0x68, 0x44, 0x45, 0x68, 0x44, 0x45, 0x68, 0x44, 0xb3, 0x05, 0x04, 0x46,
	/*000450*/ 0x00, 0x2b, 0xb3, 0x07, 0x06, 0x46, 0x00, 0x2b, 0xb1, 0x04, 0x04, 0x45, 0x68, 0x44, 0xb1, 0x06,
	/*000460*/ 0x06, 0x45, 0x68, 0x44, 0x00, 0x02, 0x00, 0x32, 0x00, 0x00, 0x01, 0x5e, 0x02, 0x58, 0x00, 0x03,
	/*000470*/ 0x00, 0x07, 0x00, 0x55, 0x40, 0x1f, 0x01, 0x08, 0x08, 0x40, 0x09, 0x02, 0x07, 0x04, 0x04, 0x01,
	/*000480*/ 0x00, 0x06, 0x05, 0x04, 0x03, 0x02, 0x05, 0x04, 0x06, 0x00, 0x07, 0x06, 0x06, 0x01, 0x02, 0x01,
	/*000490*/ 0x03, 0x00, 0x01, 0x00, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x2f, 0x3c, 0x2f, 0x3c, 0x10, 0xfd,
	/*0004a0*/ 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x00, 0x31, 0x30,
	/*0004b0*/ 0x01, 0x49, 0x68, 0xb9, 0x00, 0x00, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38,
	/*0004c0*/ 0x11, 0x37, 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x33, 0x11, 0x21, 0x11, 0x27, 0x33, 0x11,
	/*0004d0*/ 0x23, 0x32, 0x01, 0x2c, 0xfa, 0xc8, 0xc8, 0x02, 0x58, 0xfd, 0xa8, 0x32, 0x01, 0xf4, 0x00, 0x02,
	/*0004e0*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x63, 0x02, 0x57, 0x00, 0x03, 0x00, 0x07, 0x00, 0x53, 0x40, 0x20,
	/*0004f0*/ 0x01, 0x08, 0x08, 0x40, 0x09, 0x00, 0x01, 0x00, 0x06, 0x05, 0x02, 0x03, 0x01, 0x04, 0x07, 0x04,
	/*000500*/ 0x03, 0x03, 0x00, 0x07, 0x06, 0x06, 0x04, 0x05, 0x04, 0x01, 0x03, 0x02, 0x03, 0x01, 0x01, 0x46,
	/*000510*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c,
	/*000520*/ 0xfd, 0x17, 0x3c, 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x08,
	/*000530*/ 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38,
	/*000540*/ 0x59, 0x37, 0x23, 0x11, 0x33, 0x11, 0x23, 0x35, 0x33, 0x63, 0x62, 0x62, 0x62, 0x62, 0xc9, 0x01,
	/*000550*/ 0x8e, 0xfd, 0xaa, 0x62, 0x00, 0x02, 0x00, 0x01, 0x01, 0x91, 0x01, 0x2b, 0x02, 0x57, 0x00, 0x03,
	/*000560*/ 0x00, 0x07, 0x00, 0x50, 0x40, 0x1e, 0x01, 0x08, 0x08, 0x40, 0x09, 0x00, 0x02, 0x01, 0x04, 0x03,
	/*000570*/ 0x00, 0x07, 0x04, 0x04, 0x06, 0x05, 0x05, 0x04, 0x01, 0x03, 0x00, 0x07, 0x06, 0x03, 0x03, 0x02,
	/*000580*/ 0x03, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0x01,
	/*000590*/ 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00,
	/*0005a0*/ 0x05, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x08,
	/*0005b0*/ 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x35, 0x33, 0x07, 0x23, 0x35, 0x33, 0x01, 0x2b, 0x62, 0x62,
	/*0005c0*/ 0xc8, 0x62, 0x62, 0x01, 0x91, 0xc6, 0xc6, 0xc6, 0x00, 0x02, 0x00, 0x01, 0x00, 0x65, 0x01, 0xf3,
	/*0005d0*/ 0x02, 0x57, 0x00, 0x1b, 0x00, 0x1f, 0x00, 0xb3, 0x40, 0x5e, 0x01, 0x20, 0x20, 0x40, 0x21, 0x00,
	/*0005e0*/ 0x1b, 0x18, 0x17, 0x14, 0x13, 0x0e, 0x0d, 0x0a, 0x09, 0x00, 0x06, 0x05, 0x04, 0x07, 0x1f, 0x12,
	/*0005f0*/ 0x11, 0x03, 0x1e, 0x04, 0x10, 0x0f, 0x0c, 0x0b, 0x08, 0x05, 0x07, 0x1d, 0x04, 0x03, 0x03, 0x1c,
	/*000600*/ 0x04, 0x1a, 0x19, 0x16, 0x02, 0x01, 0x05, 0x15, 0x1b, 0x1a, 0x06, 0x00, 0x1f, 0x0b, 0x0a, 0x03,
	/*000610*/ 0x1c, 0x06, 0x09, 0x08, 0x05, 0x04, 0x01, 0x05, 0x00, 0x0d, 0x0c, 0x06, 0x0e, 0x1e, 0x19, 0x18,
	/*000620*/ 0x03, 0x1d, 0x06, 0x17, 0x16, 0x13, 0x12, 0x0f, 0x05, 0x0e, 0x07, 0x06, 0x03, 0x03, 0x02, 0x15,
	/*000630*/ 0x14, 0x11, 0x03, 0x10, 0x03, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c,
	/*000640*/ 0x2f, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd,
	/*000650*/ 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd,
	/*000660*/ 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x00,
	/*000670*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x20, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*000680*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x20, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35,
	/*000690*/ 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x35,
	/*0006a0*/ 0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x27, 0x35, 0x23, 0x15, 0x01, 0xf3, 0x65, 0x61, 0x67,
	/*0006b0*/ 0x61, 0x64, 0x64, 0x64, 0x64, 0x62, 0x67, 0x61, 0x64, 0x64, 0x64, 0xc8, 0x62, 0xc9, 0x64, 0x64,
	/*0006c0*/ 0x64, 0x65, 0x61, 0x67, 0x61, 0x64, 0x64, 0x64, 0x65, 0x61, 0x67, 0x03, 0x62, 0x62, 0x00, 0x01,
	/*0006d0*/ 0x00, 0x01, 0x00, 0x01, 0x01, 0xf3, 0x01, 0xf3, 0x00, 0x13, 0x00, 0x88, 0x40, 0x42, 0x01, 0x14,
	/*0006e0*/ 0x14, 0x40, 0x15, 0x00, 0x13, 0x0a, 0x09, 0x00, 0x04, 0x03, 0x04, 0x05, 0x0e, 0x06, 0x05, 0x03,
	/*0006f0*/ 0x0d, 0x04, 0x0c, 0x0b, 0x08, 0x03, 0x07, 0x10, 0x0f, 0x04, 0x12, 0x02, 0x01, 0x03, 0x11, 0x07,
	/*000700*/ 0x06, 0x03, 0x03, 0x02, 0x0b, 0x00, 0x09, 0x08, 0x01, 0x03, 0x00, 0x07, 0x12, 0x11, 0x10, 0x0d,
	/*000710*/ 0x03, 0x0c, 0x13, 0x12, 0x0f, 0x0e, 0x0b, 0x05, 0x0a, 0x02, 0x05, 0x04, 0x01, 0x01, 0x09, 0x46,
	/*000720*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0x10, 0xfd, 0x17,
	/*000730*/ 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17,
	/*000740*/ 0x3c, 0x10, 0xfd, 0x3c, 0x2e, 0x2e, 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00,
	/*000750*/ 0x09, 0x00, 0x14, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14,
	/*000760*/ 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33,
	/*000770*/ 0x35, 0x33, 0x15, 0x33, 0x35, 0x33, 0x15, 0x33, 0x01, 0xf3, 0x65, 0x64, 0x61, 0x64, 0x64, 0x64,
	/*000780*/ 0x62, 0x67, 0x61, 0x64, 0xc9, 0x64, 0x64, 0x65, 0x64, 0xc5, 0x64, 0x64, 0x64, 0x65, 0x00, 0x03,
	/*000790*/ 0x00, 0x01, 0x00, 0x01, 0x02, 0xbb, 0x02, 0x57, 0x00, 0x23, 0x00, 0x27, 0x00, 0x2b, 0x00, 0xde,
	/*0007a0*/ 0x40, 0x80, 0x01, 0x2c, 0x2c, 0x40, 0x2d, 0x00, 0x20, 0x1f, 0x08, 0x07, 0x04, 0x0a, 0x09, 0x1e,
	/*0007b0*/ 0x1d, 0x04, 0x18, 0x17, 0x0c, 0x03, 0x0b, 0x29, 0x28, 0x16, 0x15, 0x0e, 0x05, 0x0d, 0x04, 0x0f,
	/*0007c0*/ 0x2b, 0x2a, 0x14, 0x13, 0x10, 0x05, 0x0f, 0x04, 0x12, 0x11, 0x1a, 0x06, 0x05, 0x03, 0x19, 0x04,
	/*0007d0*/ 0x27, 0x26, 0x1c, 0x04, 0x03, 0x05, 0x1b, 0x25, 0x24, 0x22, 0x02, 0x01, 0x05, 0x21, 0x04, 0x23,
	/*0007e0*/ 0x00, 0x27, 0x24, 0x05, 0x04, 0x01, 0x05, 0x00, 0x06, 0x02, 0x1d, 0x1c, 0x11, 0x10, 0x0d, 0x05,
	/*0007f0*/ 0x0c, 0x06, 0x0e, 0x21, 0x0f, 0x0e, 0x03, 0x20, 0x06, 0x26, 0x25, 0x23, 0x22, 0x1f, 0x1e, 0x0b,
	/*000800*/ 0x07, 0x06, 0x09, 0x0a, 0x2a, 0x29, 0x17, 0x16, 0x13, 0x05, 0x12, 0x06, 0x14, 0x2b, 0x28, 0x19,
	/*000810*/ 0x03, 0x18, 0x02, 0x1b, 0x1a, 0x15, 0x03, 0x14, 0x03, 0x09, 0x08, 0x03, 0x03, 0x02, 0x01, 0x01,
	/*000820*/ 0x11, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x17, 0x3c, 0x3f, 0x17, 0x3c,
	/*000830*/ 0x10, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*000840*/ 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c,
	/*000850*/ 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c,
	/*000860*/ 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x11, 0x00, 0x2c, 0x49, 0x68, 0x61,
	/*000870*/ 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x2c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23,
	/*000880*/ 0x15, 0x23, 0x35, 0x23, 0x35, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x23, 0x15, 0x23, 0x35, 0x23,
	/*000890*/ 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x15, 0x33, 0x35, 0x33, 0x15, 0x23, 0x15, 0x33, 0x35, 0x33,
	/*0008a0*/ 0x15, 0x33, 0x07, 0x35, 0x23, 0x15, 0x01, 0x35, 0x23, 0x15, 0x02, 0xbb, 0x65, 0x61, 0x64, 0x67,
	/*0008b0*/ 0x61, 0x64, 0x67, 0x61, 0x64, 0x64, 0x62, 0x64, 0x67, 0x61, 0x64, 0x67, 0x61, 0x64, 0x64, 0x62,
	/*0008c0*/ 0xfe, 0xd2, 0x62, 0x65, 0x64, 0x65, 0x63, 0xc8, 0xc6, 0xca, 0x64, 0x65, 0x61, 0x64, 0x65, 0x63,
	/*0008d0*/ 0xc8, 0xc6, 0xca, 0x64, 0x65, 0x61, 0x62, 0x62, 0x01, 0x2c, 0x62, 0x62, 0x00, 0x03, 0x00, 0x01,
	/*0008e0*/ 0x00, 0x01, 0x01, 0xf3, 0x02, 0x57, 0x00, 0x1b, 0x00, 0x1f, 0x00, 0x25, 0x00, 0xce, 0x40, 0x76,
	/*0008f0*/ 0x01, 0x26, 0x26, 0x40, 0x27, 0x00, 0x1a, 0x19, 0x1b, 0x04, 0x03, 0x03, 0x00, 0x04, 0x05, 0x10,
	/*000900*/ 0x0f, 0x0c, 0x03, 0x0b, 0x04, 0x09, 0x25, 0x24, 0x1f, 0x1e, 0x12, 0x11, 0x0e, 0x0d, 0x0a, 0x09,
	/*000910*/ 0x09, 0x04, 0x13, 0x23, 0x22, 0x1d, 0x1c, 0x18, 0x17, 0x14, 0x07, 0x13, 0x04, 0x15, 0x21, 0x20,
	/*000920*/ 0x16, 0x08, 0x07, 0x05, 0x15, 0x04, 0x06, 0x05, 0x02, 0x03, 0x01, 0x03, 0x02, 0x06, 0x04, 0x25,
	/*000930*/ 0x20, 0x0b, 0x0a, 0x07, 0x05, 0x06, 0x06, 0x04, 0x1e, 0x1d, 0x15, 0x14, 0x11, 0x05, 0x10, 0x06,
	/*000940*/ 0x12, 0x22, 0x21, 0x06, 0x0c, 0x24, 0x23, 0x19, 0x18, 0x0d, 0x01, 0x00, 0x07, 0x0c, 0x06, 0x17,
	/*000950*/ 0x0f, 0x0e, 0x03, 0x16, 0x1f, 0x1c, 0x1b, 0x03, 0x1a, 0x02, 0x13, 0x12, 0x03, 0x09, 0x08, 0x05,
	/*000960*/ 0x03, 0x04, 0x01, 0x01, 0x0b, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x3c,
	/*000970*/ 0x3f, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c,
	/*000980*/ 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*000990*/ 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2e, 0x2e,
	/*0009a0*/ 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x0b, 0x00, 0x26, 0x49, 0x68, 0x61, 0xb0, 0x40,
	/*0009b0*/ 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x26, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x33,
	/*0009c0*/ 0x15, 0x23, 0x35, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x33,
	/*0009d0*/ 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x35, 0x33, 0x25, 0x35, 0x23, 0x15, 0x13, 0x35, 0x23, 0x35,
	/*0009e0*/ 0x23, 0x15, 0x01, 0xf3, 0x64, 0x64, 0x62, 0x67, 0xc5, 0x64, 0x64, 0x64, 0x64, 0x62, 0x64, 0x64,
	/*0009f0*/ 0xcb, 0x61, 0xfe, 0xd4, 0x62, 0xc6, 0x64, 0x62, 0x01, 0x2d, 0xcb, 0x61, 0x64, 0x64, 0x65, 0xc5,
	/*000a00*/ 0x67, 0x61, 0x64, 0x65, 0x61, 0x66, 0x64, 0x02, 0x62, 0x62, 0xfe, 0xd4, 0x61, 0x65, 0xc6, 0x00,
	/*000a10*/ 0x00, 0x01, 0x00, 0x01, 0x01, 0x91, 0x00, 0x63, 0x02, 0x57, 0x00, 0x03, 0x00, 0x3f, 0x40, 0x13,
	/*000a20*/ 0x01, 0x04, 0x04, 0x40, 0x05, 0x00, 0x02, 0x01, 0x04, 0x03, 0x00, 0x01, 0x00, 0x03, 0x02, 0x03,
	/*000a30*/ 0x01, 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f, 0x3c, 0x01, 0x2f, 0x3c, 0xfd,
	/*000a40*/ 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x04, 0x49, 0x68, 0x61, 0xb0,
	/*000a50*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x04, 0xff, 0xc0, 0x38, 0x59, 0x13, 0x23, 0x35,
	/*000a60*/ 0x33, 0x63, 0x62, 0x62, 0x01, 0x91, 0xc6, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0xc7,
	/*000a70*/ 0x02, 0x57, 0x00, 0x0b, 0x00, 0x67, 0x40, 0x2d, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x07, 0x06,
	/*000a80*/ 0x0b, 0x04, 0x03, 0x03, 0x00, 0x04, 0x05, 0x0a, 0x09, 0x06, 0x05, 0x02, 0x05, 0x01, 0x04, 0x08,
	/*000a90*/ 0x07, 0x09, 0x08, 0x01, 0x03, 0x00, 0x06, 0x0a, 0x03, 0x02, 0x06, 0x04, 0x0b, 0x0a, 0x03, 0x05,
	/*000aa0*/ 0x04, 0x01, 0x01, 0x07, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd,
	/*000ab0*/ 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x00,
	/*000ac0*/ 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x07, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0,
	/*000ad0*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x13, 0x23, 0x11,
	/*000ae0*/ 0x33, 0x15, 0x23, 0x35, 0x23, 0x11, 0x33, 0x35, 0x33, 0xc7, 0x64, 0x64, 0x62, 0x64, 0x64, 0x62,
	/*000af0*/ 0x01, 0xf5, 0xfe, 0x6d, 0x61, 0x65, 0x01, 0x8d, 0x64, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*000b00*/ 0x00, 0xc7, 0x02, 0x57, 0x00, 0x0b, 0x00, 0x67, 0x40, 0x2c, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00,
	/*000b10*/ 0x0b, 0x0a, 0x02, 0x01, 0x04, 0x08, 0x07, 0x04, 0x03, 0x03, 0x0a, 0x09, 0x06, 0x03, 0x05, 0x04,
	/*000b20*/ 0x0b, 0x00, 0x05, 0x01, 0x00, 0x03, 0x04, 0x06, 0x02, 0x07, 0x06, 0x06, 0x08, 0x09, 0x08, 0x03,
	/*000b30*/ 0x03, 0x02, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10,
	/*000b40*/ 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd,
	/*000b50*/ 0x3c, 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x0c, 0x49, 0x68,
	/*000b60*/ 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x37,
	/*000b70*/ 0x23, 0x15, 0x23, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x15, 0x33, 0xc7, 0x65, 0x61, 0x64, 0x64,
	/*000b80*/ 0x62, 0x64, 0x65, 0x64, 0x62, 0x01, 0x92, 0x62, 0x65, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x2d,
	/*000b90*/ 0x01, 0x2b, 0x02, 0x57, 0x00, 0x13, 0x00, 0x83, 0x40, 0x40, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00,
	/*000ba0*/ 0x12, 0x11, 0x13, 0x04, 0x03, 0x03, 0x00, 0x04, 0x05, 0x08, 0x07, 0x04, 0x0e, 0x0d, 0x0a, 0x03,
	/*000bb0*/ 0x09, 0x10, 0x0f, 0x0c, 0x03, 0x0b, 0x04, 0x06, 0x05, 0x02, 0x03, 0x01, 0x07, 0x06, 0x06, 0x11,
	/*000bc0*/ 0x0d, 0x0c, 0x01, 0x00, 0x05, 0x10, 0x09, 0x08, 0x05, 0x03, 0x04, 0x13, 0x12, 0x0f, 0x03, 0x0e,
	/*000bd0*/ 0x03, 0x0b, 0x03, 0x02, 0x03, 0x0a, 0x02, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f,
	/*000be0*/ 0x17, 0x3c, 0x3f, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x01, 0x2f, 0x17,
	/*000bf0*/ 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x00,
	/*000c00*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x14, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*000c10*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x33, 0x15,
	/*000c20*/ 0x23, 0x35, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x15, 0x33, 0x35, 0x33, 0x01,
	/*000c30*/ 0x2b, 0x64, 0x64, 0x62, 0x67, 0x61, 0x64, 0x64, 0x62, 0x67, 0x61, 0x01, 0xf5, 0x67, 0x61, 0x64,
	/*000c40*/ 0x64, 0x62, 0x66, 0x62, 0x64, 0x64, 0x00, 0x01, 0x00, 0x01, 0x00, 0x65, 0x01, 0x2b, 0x01, 0x8f,
	/*000c50*/ 0x00, 0x0b, 0x00, 0x66, 0x40, 0x2c, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x0b, 0x00, 0x08, 0x01,
	/*000c60*/ 0x06, 0x05, 0x08, 0x03, 0x0a, 0x09, 0x02, 0x03, 0x01, 0x04, 0x08, 0x07, 0x04, 0x03, 0x03, 0x0b,
	/*000c70*/ 0x07, 0x06, 0x03, 0x0a, 0x06, 0x05, 0x04, 0x01, 0x03, 0x00, 0x03, 0x02, 0x09, 0x08, 0x02, 0x01,
	/*000c80*/ 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17,
	/*000c90*/ 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31,
	/*000ca0*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*000cb0*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35, 0x23,
	/*000cc0*/ 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x01, 0x2b, 0x65, 0x61, 0x64, 0x64, 0x62, 0x64, 0xc9, 0x64,
	/*000cd0*/ 0x65, 0x61, 0x64, 0x65, 0x00, 0x01, 0x00, 0x01, 0xff, 0x9d, 0x00, 0xc7, 0x00, 0x63, 0x00, 0x07,
	/*000ce0*/ 0x00, 0x53, 0x40, 0x1e, 0x01, 0x08, 0x08, 0x40, 0x09, 0x00, 0x02, 0x01, 0x04, 0x04, 0x03, 0x06,
	/*000cf0*/ 0x05, 0x04, 0x07, 0x00, 0x05, 0x04, 0x06, 0x02, 0x07, 0x06, 0x03, 0x02, 0x01, 0x00, 0x01, 0x01,
	/*000d00*/ 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f, 0x3c, 0x2f, 0x3c, 0x10, 0xfd, 0x3c,
	/*000d10*/ 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9,
	/*000d20*/ 0x00, 0x03, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00,
	/*000d30*/ 0x08, 0xff, 0xc0, 0x38, 0x59, 0x37, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x33, 0xc7, 0x65, 0x61,
	/*000d40*/ 0x64, 0x62, 0x01, 0x64, 0x62, 0x64, 0x00, 0x01, 0x00, 0x01, 0x00, 0xc9, 0x01, 0x2b, 0x01, 0x2b,
	/*000d50*/ 0x00, 0x03, 0x00, 0x3d, 0x40, 0x11, 0x01, 0x04, 0x04, 0x40, 0x05, 0x00, 0x03, 0x02, 0x01, 0x00,
	/*000d60*/ 0x03, 0x02, 0x01, 0x00, 0x01, 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x2f, 0x3c, 0x2f, 0x3c,
	/*000d70*/ 0x01, 0x2e, 0x2e, 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x04,
	/*000d80*/ 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x04, 0xff, 0xc0, 0x38,
	/*000d90*/ 0x59, 0x25, 0x21, 0x35, 0x21, 0x01, 0x2b, 0xfe, 0xd6, 0x01, 0x2a, 0xc9, 0x62, 0x00, 0x00, 0x01,
	/*000da0*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x63, 0x00, 0x63, 0x00, 0x03, 0x00, 0x3f, 0x40, 0x13, 0x01, 0x04,
	/*000db0*/ 0x04, 0x40, 0x05, 0x00, 0x03, 0x00, 0x04, 0x02, 0x01, 0x03, 0x02, 0x01, 0x00, 0x01, 0x01, 0x01,
	/*000dc0*/ 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x00,
	/*000dd0*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x04, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*000de0*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x04, 0xff, 0xc0, 0x38, 0x59, 0x37, 0x23, 0x35, 0x33, 0x63,
	/*000df0*/ 0x62, 0x62, 0x01, 0x62, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x2b, 0x02, 0x57, 0x00, 0x0b,
	/*000e00*/ 0x00, 0x69, 0x40, 0x2c, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x04, 0x03, 0x04, 0x06, 0x05, 0x08,
	/*000e10*/ 0x07, 0x04, 0x02, 0x01, 0x0a, 0x09, 0x04, 0x0b, 0x00, 0x01, 0x00, 0x07, 0x0a, 0x07, 0x03, 0x02,
	/*000e20*/ 0x03, 0x06, 0x07, 0x04, 0x0b, 0x0a, 0x03, 0x09, 0x08, 0x02, 0x05, 0x04, 0x01, 0x01, 0x05, 0x46,
	/*000e30*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10,
	/*000e40*/ 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x00,
	/*000e50*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*000e60*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x23, 0x15,
	/*000e70*/ 0x23, 0x35, 0x33, 0x35, 0x33, 0x35, 0x33, 0x01, 0x2b, 0x65, 0x64, 0x61, 0x65, 0x63, 0x62, 0x01,
	/*000e80*/ 0x91, 0xc8, 0xc8, 0xc6, 0xc8, 0xc8, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57,
	/*000e90*/ 0x00, 0x0b, 0x00, 0x11, 0x00, 0x17, 0x00, 0x95, 0x40, 0x4d, 0x01, 0x18, 0x18, 0x40, 0x19, 0x00,
	/*000ea0*/ 0x15, 0x14, 0x05, 0x05, 0x11, 0x10, 0x05, 0x00, 0x17, 0x16, 0x0f, 0x0e, 0x08, 0x07, 0x04, 0x07,
	/*000eb0*/ 0x03, 0x04, 0x06, 0x05, 0x13, 0x12, 0x0d, 0x0c, 0x0a, 0x02, 0x01, 0x07, 0x09, 0x04, 0x0b, 0x00,
	/*000ec0*/ 0x17, 0x12, 0x05, 0x04, 0x01, 0x05, 0x00, 0x06, 0x02, 0x0e, 0x0d, 0x0b, 0x0a, 0x07, 0x05, 0x06,
	/*000ed0*/ 0x06, 0x08, 0x11, 0x0c, 0x06, 0x13, 0x14, 0x13, 0x10, 0x03, 0x0f, 0x06, 0x16, 0x15, 0x09, 0x08,
	/*000ee0*/ 0x03, 0x03, 0x02, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c,
	/*000ef0*/ 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c,
	/*000f00*/ 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd,
	/*000f10*/ 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x18, 0x49, 0x68, 0x61, 0xb0,
	/*000f20*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x18, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15,
	/*000f30*/ 0x23, 0x35, 0x23, 0x11, 0x33, 0x35, 0x33, 0x15, 0x33, 0x07, 0x35, 0x23, 0x15, 0x33, 0x35, 0x13,
	/*000f40*/ 0x35, 0x23, 0x15, 0x23, 0x15, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x64, 0xc6, 0x64, 0x64, 0xc6, 0x61,
	/*000f50*/ 0x65, 0x62, 0x64, 0x65, 0x64, 0x65, 0x01, 0x8d, 0x64, 0x65, 0x61, 0x62, 0xc6, 0x64, 0xfe, 0xd4,
	/*000f60*/ 0xc6, 0x64, 0x62, 0x00, 0x00, 0x01, 0x00, 0x65, 0x00, 0x01, 0x01, 0x2b, 0x02, 0x57, 0x00, 0x07,
	/*000f70*/ 0x00, 0x54, 0x40, 0x20, 0x01, 0x08, 0x08, 0x40, 0x09, 0x00, 0x04, 0x03, 0x05, 0x00, 0x06, 0x05,
	/*000f80*/ 0x02, 0x03, 0x01, 0x04, 0x07, 0x00, 0x03, 0x02, 0x06, 0x05, 0x04, 0x07, 0x06, 0x03, 0x01, 0x00,
	/*000f90*/ 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x2f, 0x3c, 0xfd,
	/*000fa0*/ 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68,
	/*000fb0*/ 0xb9, 0x00, 0x03, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9,
	/*000fc0*/ 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x11, 0x23, 0x35, 0x33, 0x35, 0x33, 0x01, 0x2b,
	/*000fd0*/ 0x62, 0x64, 0x64, 0x62, 0x01, 0x01, 0x91, 0x61, 0x64, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*000fe0*/ 0x01, 0x8f, 0x02, 0x57, 0x00, 0x19, 0x00, 0xa4, 0x40, 0x53, 0x01, 0x1a, 0x1a, 0x40, 0x1b, 0x00,
	/*000ff0*/ 0x12, 0x11, 0x06, 0x03, 0x05, 0x04, 0x14, 0x13, 0x0a, 0x03, 0x09, 0x04, 0x03, 0x04, 0x16, 0x15,
	/*001000*/ 0x0c, 0x03, 0x0b, 0x0e, 0x0d, 0x04, 0x02, 0x01, 0x18, 0x17, 0x10, 0x03, 0x0f, 0x04, 0x19, 0x08,
	/*001010*/ 0x07, 0x03, 0x00, 0x13, 0x12, 0x01, 0x03, 0x00, 0x06, 0x19, 0x18, 0x0d, 0x03, 0x02, 0x03, 0x0c,
	/*001020*/ 0x06, 0x0b, 0x0a, 0x05, 0x03, 0x04, 0x07, 0x06, 0x06, 0x08, 0x15, 0x14, 0x11, 0x03, 0x10, 0x06,
	/*001030*/ 0x16, 0x17, 0x16, 0x03, 0x0f, 0x0e, 0x02, 0x09, 0x08, 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37,
	/*001040*/ 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x2f,
	/*001050*/ 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17,
	/*001060*/ 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c,
	/*001070*/ 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x1a, 0x49, 0x68, 0x61, 0xb0, 0x40,
	/*001080*/ 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x1a, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x23,
	/*001090*/ 0x15, 0x23, 0x15, 0x21, 0x15, 0x21, 0x35, 0x33, 0x35, 0x33, 0x35, 0x33, 0x35, 0x23, 0x15, 0x23,
	/*0010a0*/ 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x01, 0x8f, 0x65, 0x64, 0x63, 0x01, 0x2c, 0xfe, 0x72, 0x65,
	/*0010b0*/ 0x64, 0x63, 0xcb, 0x61, 0x64, 0xc6, 0x64, 0x01, 0x91, 0x64, 0x64, 0x67, 0x61, 0xc6, 0x64, 0x64,
	/*0010c0*/ 0x66, 0x64, 0x62, 0x64, 0x65, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57,
	/*0010d0*/ 0x00, 0x1b, 0x00, 0xa4, 0x40, 0x57, 0x01, 0x1c, 0x1c, 0x40, 0x1d, 0x00, 0x14, 0x13, 0x10, 0x0f,
	/*0010e0*/ 0x08, 0x04, 0x03, 0x07, 0x07, 0x04, 0x12, 0x11, 0x06, 0x03, 0x05, 0x1b, 0x18, 0x17, 0x03, 0x00,
	/*0010f0*/ 0x04, 0x09, 0x0c, 0x0b, 0x04, 0x1a, 0x19, 0x16, 0x0e, 0x0d, 0x0a, 0x09, 0x02, 0x01, 0x09, 0x15,
	/*001100*/ 0x1b, 0x1a, 0x07, 0x00, 0x09, 0x08, 0x06, 0x02, 0x07, 0x06, 0x06, 0x05, 0x01, 0x00, 0x03, 0x04,
	/*001110*/ 0x0b, 0x0a, 0x06, 0x0c, 0x19, 0x18, 0x11, 0x03, 0x10, 0x06, 0x17, 0x16, 0x13, 0x0f, 0x0e, 0x05,
	/*001120*/ 0x12, 0x15, 0x14, 0x03, 0x0d, 0x0c, 0x02, 0x03, 0x02, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37,
	/*001130*/ 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*001140*/ 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c,
	/*001150*/ 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01,
	/*001160*/ 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x1c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11,
	/*001170*/ 0x37, 0xb9, 0x00, 0x1c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33,
	/*001180*/ 0x15, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 0x33,
	/*001190*/ 0x15, 0x23, 0x15, 0x33, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x62, 0xca, 0x64, 0x64, 0xcb, 0x61, 0x64,
	/*0011a0*/ 0xc6, 0x64, 0x64, 0x64, 0x65, 0x64, 0x65, 0x61, 0x64, 0xcb, 0x61, 0x66, 0x64, 0x62, 0x64, 0x65,
	/*0011b0*/ 0x61, 0x67, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0d, 0x00, 0x6a,
	/*0011c0*/ 0x40, 0x2f, 0x01, 0x0e, 0x0e, 0x40, 0x0f, 0x00, 0x0d, 0x00, 0x0a, 0x09, 0x04, 0x03, 0x03, 0x04,
	/*0011d0*/ 0x0c, 0x0b, 0x02, 0x03, 0x01, 0x08, 0x07, 0x04, 0x06, 0x05, 0x0d, 0x09, 0x08, 0x03, 0x0c, 0x06,
	/*0011e0*/ 0x05, 0x04, 0x01, 0x03, 0x00, 0x0b, 0x0a, 0x07, 0x03, 0x06, 0x03, 0x03, 0x02, 0x01, 0x01, 0x05,
	/*0011f0*/ 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17,
	/*001200*/ 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x00, 0x31,
	/*001210*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*001220*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35, 0x23,
	/*001230*/ 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x01, 0x8f, 0x65, 0x61, 0xc8, 0x62, 0x67, 0x61,
	/*001240*/ 0x64, 0xc9, 0xc8, 0xc8, 0x01, 0x8e, 0xfe, 0xd4, 0x01, 0x2c, 0xfe, 0xd3, 0x00, 0x01, 0x00, 0x01,
	/*001250*/ 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f, 0x00, 0x7b, 0x40, 0x38, 0x01, 0x10, 0x10, 0x40,
	/*001260*/ 0x11, 0x00, 0x02, 0x01, 0x0e, 0x0d, 0x06, 0x03, 0x05, 0x04, 0x0f, 0x0a, 0x09, 0x03, 0x00, 0x0c,
	/*001270*/ 0x0b, 0x04, 0x08, 0x07, 0x04, 0x03, 0x03, 0x0f, 0x0e, 0x07, 0x00, 0x05, 0x01, 0x00, 0x03, 0x04,
	/*001280*/ 0x06, 0x02, 0x07, 0x06, 0x06, 0x0d, 0x0c, 0x0b, 0x0a, 0x06, 0x08, 0x09, 0x08, 0x03, 0x03, 0x02,
	/*001290*/ 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c,
	/*0012a0*/ 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd,
	/*0012b0*/ 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9,
	/*0012c0*/ 0x00, 0x03, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00,
	/*0012d0*/ 0x10, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x21, 0x35, 0x21, 0x35, 0x21, 0x11, 0x21, 0x15,
	/*0012e0*/ 0x21, 0x15, 0x33, 0x15, 0x33, 0x01, 0x8f, 0x65, 0xfe, 0xd7, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x8e,
	/*0012f0*/ 0xfe, 0xd4, 0xc8, 0x64, 0x65, 0x64, 0x62, 0xca, 0x01, 0x2a, 0x62, 0x67, 0x64, 0x00, 0x00, 0x03,
	/*001300*/ 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f, 0x00, 0x13, 0x00, 0x17, 0x00, 0x8a,
	/*001310*/ 0x40, 0x49, 0x01, 0x18, 0x18, 0x40, 0x19, 0x00, 0x17, 0x16, 0x13, 0x12, 0x08, 0x07, 0x04, 0x07,
	/*001320*/ 0x03, 0x04, 0x06, 0x05, 0x15, 0x14, 0x11, 0x10, 0x0e, 0x0d, 0x0a, 0x02, 0x01, 0x09, 0x09, 0x04,
	/*001330*/ 0x0f, 0x0c, 0x0b, 0x03, 0x00, 0x17, 0x14, 0x05, 0x04, 0x01, 0x05, 0x00, 0x06, 0x02, 0x12, 0x11,
	/*001340*/ 0x0b, 0x0a, 0x07, 0x05, 0x06, 0x06, 0x08, 0x16, 0x0f, 0x0e, 0x03, 0x15, 0x06, 0x13, 0x10, 0x0d,
	/*001350*/ 0x03, 0x0c, 0x09, 0x08, 0x03, 0x03, 0x02, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00,
	/*001360*/ 0x3f, 0x3c, 0x3f, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*001370*/ 0x17, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31,
	/*001380*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x18, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*001390*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x18, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35, 0x23,
	/*0013a0*/ 0x11, 0x33, 0x35, 0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x27, 0x35, 0x23, 0x15, 0x13, 0x35,
	/*0013b0*/ 0x23, 0x15, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x64, 0xc6, 0x64, 0x64, 0x64, 0x64, 0xc6, 0xc6, 0xc6,
	/*0013c0*/ 0x65, 0x64, 0x65, 0x01, 0x8d, 0x64, 0x65, 0x61, 0x67, 0x67, 0x62, 0x62, 0xfe, 0xd4, 0xc6, 0xc6,
	/*0013d0*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f, 0x00, 0x7d, 0x40, 0x38,
	/*0013e0*/ 0x01, 0x10, 0x10, 0x40, 0x11, 0x00, 0x04, 0x03, 0x04, 0x06, 0x05, 0x08, 0x07, 0x04, 0x02, 0x01,
	/*0013f0*/ 0x0a, 0x09, 0x04, 0x0f, 0x00, 0x0c, 0x0b, 0x04, 0x0e, 0x0d, 0x0d, 0x0c, 0x01, 0x03, 0x00, 0x07,
	/*001400*/ 0x0e, 0x07, 0x03, 0x02, 0x03, 0x06, 0x07, 0x04, 0x0b, 0x0a, 0x06, 0x0e, 0x0f, 0x0e, 0x03, 0x09,
	/*001410*/ 0x08, 0x02, 0x05, 0x04, 0x01, 0x01, 0x0d, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f,
	/*001420*/ 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f,
	/*001430*/ 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x00,
	/*001440*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x0d, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*001450*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x23, 0x15,
	/*001460*/ 0x23, 0x35, 0x33, 0x35, 0x33, 0x35, 0x23, 0x15, 0x23, 0x35, 0x21, 0x01, 0x8f, 0x65, 0x64, 0x61,
	/*001470*/ 0x65, 0x63, 0xcb, 0x61, 0x01, 0x8e, 0x01, 0x91, 0xc8, 0xc8, 0xc6, 0xc8, 0x66, 0x64, 0xc6, 0x00,
	/*001480*/ 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x13, 0x00, 0x17, 0x00, 0x1b,
	/*001490*/ 0x00, 0x94, 0x40, 0x52, 0x01, 0x1c, 0x1c, 0x40, 0x1d, 0x00, 0x1b, 0x1a, 0x17, 0x16, 0x0c, 0x0b,
	/*0014a0*/ 0x08, 0x07, 0x04, 0x09, 0x03, 0x04, 0x0a, 0x09, 0x06, 0x03, 0x05, 0x19, 0x18, 0x15, 0x14, 0x12,
	/*0014b0*/ 0x11, 0x0e, 0x02, 0x01, 0x09, 0x0d, 0x04, 0x13, 0x10, 0x0f, 0x03, 0x00, 0x1b, 0x18, 0x05, 0x04,
	/*0014c0*/ 0x01, 0x05, 0x00, 0x06, 0x02, 0x16, 0x15, 0x0f, 0x0e, 0x0b, 0x05, 0x0a, 0x06, 0x0c, 0x1a, 0x19,
	/*0014d0*/ 0x13, 0x12, 0x07, 0x05, 0x06, 0x06, 0x17, 0x14, 0x11, 0x09, 0x08, 0x05, 0x10, 0x0d, 0x0c, 0x03,
	/*0014e0*/ 0x03, 0x02, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x2f,
	/*0014f0*/ 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x17,
	/*001500*/ 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68,
	/*001510*/ 0xb9, 0x00, 0x05, 0x00, 0x1c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9,
	/*001520*/ 0x00, 0x1c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23,
	/*001530*/ 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x27, 0x35, 0x23, 0x15, 0x13, 0x35,
	/*001540*/ 0x23, 0x15, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x64, 0x64, 0x64, 0xc6, 0x64, 0x64, 0x64, 0x64, 0xc6,
	/*001550*/ 0xc6, 0xc6, 0x65, 0x64, 0x65, 0xc5, 0x67, 0x61, 0x64, 0x65, 0x61, 0x67, 0x67, 0x62, 0x62, 0xfe,
	/*001560*/ 0xd4, 0xc6, 0xc6, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f,
	/*001570*/ 0x00, 0x13, 0x00, 0x17, 0x00, 0x8a, 0x40, 0x49, 0x01, 0x18, 0x18, 0x40, 0x19, 0x00, 0x17, 0x16,
	/*001580*/ 0x13, 0x12, 0x0c, 0x0b, 0x08, 0x07, 0x04, 0x09, 0x03, 0x04, 0x0a, 0x09, 0x06, 0x03, 0x05, 0x15,
	/*001590*/ 0x14, 0x11, 0x10, 0x0e, 0x02, 0x01, 0x07, 0x0d, 0x04, 0x0f, 0x00, 0x17, 0x14, 0x05, 0x01, 0x00,
	/*0015a0*/ 0x05, 0x04, 0x06, 0x06, 0x12, 0x11, 0x0f, 0x0e, 0x0b, 0x05, 0x0a, 0x06, 0x0c, 0x13, 0x09, 0x08,
	/*0015b0*/ 0x03, 0x10, 0x06, 0x16, 0x15, 0x07, 0x03, 0x06, 0x0d, 0x0c, 0x03, 0x03, 0x02, 0x01, 0x01, 0x05,
	/*0015c0*/ 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c,
	/*0015d0*/ 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17,
	/*0015e0*/ 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x18, 0x49,
	/*0015f0*/ 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x18, 0xff, 0xc0, 0x38, 0x59,
	/*001600*/ 0x25, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 0x33,
	/*001610*/ 0x07, 0x35, 0x23, 0x15, 0x17, 0x35, 0x23, 0x15, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x64, 0x64, 0x64,
	/*001620*/ 0xc6, 0x64, 0x64, 0xc6, 0xc6, 0xc6, 0x65, 0x64, 0x65, 0x61, 0x67, 0xc5, 0x64, 0x65, 0xc5, 0xc6,
	/*001630*/ 0xc6, 0xc8, 0x62, 0x62, 0x00, 0x02, 0x00, 0x01, 0x00, 0x65, 0x00, 0x63, 0x01, 0xf3, 0x00, 0x03,
	/*001640*/ 0x00, 0x07, 0x00, 0x54, 0x40, 0x20, 0x01, 0x08, 0x08, 0x40, 0x09, 0x00, 0x07, 0x04, 0x03, 0x03,
	/*001650*/ 0x00, 0x04, 0x06, 0x05, 0x02, 0x03, 0x01, 0x01, 0x00, 0x06, 0x02, 0x07, 0x06, 0x06, 0x04, 0x03,
	/*001660*/ 0x02, 0x05, 0x04, 0x01, 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x2f, 0x3c, 0x2f, 0x3c, 0x10,
	/*001670*/ 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01,
	/*001680*/ 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11,
	/*001690*/ 0x37, 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x13, 0x23, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33,
	/*0016a0*/ 0x63, 0x62, 0x62, 0x62, 0x62, 0x01, 0x91, 0x62, 0xfe, 0x72, 0x62, 0x00, 0x00, 0x02, 0x00, 0x01,
	/*0016b0*/ 0x00, 0x01, 0x00, 0x63, 0x01, 0xf3, 0x00, 0x03, 0x00, 0x07, 0x00, 0x55, 0x40, 0x21, 0x01, 0x08,
	/*0016c0*/ 0x08, 0x40, 0x09, 0x00, 0x07, 0x04, 0x03, 0x03, 0x00, 0x04, 0x06, 0x05, 0x02, 0x03, 0x01, 0x07,
	/*0016d0*/ 0x06, 0x07, 0x04, 0x01, 0x00, 0x06, 0x02, 0x03, 0x02, 0x05, 0x04, 0x01, 0x01, 0x01, 0x46, 0x76,
	/*0016e0*/ 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f,
	/*0016f0*/ 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x08,
	/*001700*/ 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38,
	/*001710*/ 0x59, 0x13, 0x23, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x63, 0x62, 0x62, 0x62, 0x62, 0x01, 0x91,
	/*001720*/ 0x62, 0xfe, 0x0e, 0xc6, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x2b, 0x01, 0xf3, 0x00, 0x13,
	/*001730*/ 0x00, 0x8a, 0x40, 0x42, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00, 0x10, 0x0f, 0x13, 0x08, 0x07, 0x03,
	/*001740*/ 0x00, 0x04, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x06, 0x02, 0x01, 0x07, 0x05, 0x04, 0x0b, 0x0c, 0x0b,
	/*001750*/ 0x04, 0x03, 0x03, 0x04, 0x0e, 0x0d, 0x01, 0x00, 0x06, 0x12, 0x07, 0x06, 0x06, 0x08, 0x05, 0x04,
	/*001760*/ 0x06, 0x0b, 0x0a, 0x0d, 0x0c, 0x06, 0x0f, 0x03, 0x02, 0x03, 0x0e, 0x13, 0x12, 0x11, 0x10, 0x02,
	/*001770*/ 0x09, 0x08, 0x01, 0x01, 0x0d, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x2f,
	/*001780*/ 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c,
	/*001790*/ 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2e, 0x2e,
	/*0017a0*/ 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x0d, 0x00, 0x14, 0x49, 0x68, 0x61, 0xb0, 0x40,
	/*0017b0*/ 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x23,
	/*0017c0*/ 0x15, 0x33, 0x15, 0x33, 0x15, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x33, 0x35, 0x33,
	/*0017d0*/ 0x01, 0x2b, 0x65, 0x63, 0x64, 0x64, 0x62, 0x64, 0x64, 0x65, 0x63, 0x62, 0x01, 0x91, 0x64, 0x67,
	/*0017e0*/ 0x64, 0x61, 0x65, 0x64, 0x61, 0x64, 0x64, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x65, 0x01, 0x2b,
	/*0017f0*/ 0x01, 0x8f, 0x00, 0x03, 0x00, 0x07, 0x00, 0x54, 0x40, 0x1e, 0x01, 0x08, 0x08, 0x40, 0x09, 0x00,
	/*001800*/ 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x01, 0x00, 0x06, 0x02, 0x07, 0x06, 0x06, 0x04,
	/*001810*/ 0x05, 0x04, 0x03, 0x02, 0x02, 0x01, 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f,
	/*001820*/ 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
	/*001830*/ 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40,
	/*001840*/ 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x21, 0x35, 0x21,
	/*001850*/ 0x11, 0x21, 0x35, 0x21, 0x01, 0x2b, 0xfe, 0xd6, 0x01, 0x2a, 0xfe, 0xd6, 0x01, 0x2a, 0x01, 0x2d,
	/*001860*/ 0x62, 0xfe, 0xd6, 0x62, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x2b, 0x01, 0xf3, 0x00, 0x13,
	/*001870*/ 0x00, 0x8e, 0x40, 0x44, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00, 0x10, 0x0f, 0x04, 0x03, 0x03, 0x04,
	/*001880*/ 0x0e, 0x0d, 0x06, 0x03, 0x05, 0x0c, 0x0b, 0x08, 0x03, 0x07, 0x04, 0x02, 0x01, 0x12, 0x11, 0x0a,
	/*001890*/ 0x03, 0x09, 0x04, 0x13, 0x00, 0x13, 0x12, 0x06, 0x00, 0x09, 0x01, 0x00, 0x03, 0x08, 0x06, 0x02,
	/*0018a0*/ 0x07, 0x03, 0x02, 0x03, 0x06, 0x06, 0x04, 0x0b, 0x0a, 0x06, 0x11, 0x10, 0x0d, 0x0c, 0x06, 0x0e,
	/*0018b0*/ 0x0f, 0x0e, 0x05, 0x04, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f,
	/*0018c0*/ 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c,
	/*0018d0*/ 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17,
	/*0018e0*/ 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x14, 0x49,
	/*0018f0*/ 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59,
	/*001900*/ 0x25, 0x23, 0x15, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x33, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33,
	/*001910*/ 0x15, 0x33, 0x15, 0x33, 0x01, 0x2b, 0x65, 0x64, 0x61, 0x65, 0x63, 0x64, 0x64, 0x62, 0x64, 0x64,
	/*001920*/ 0xc9, 0x64, 0x64, 0x62, 0x64, 0x67, 0x63, 0x62, 0x65, 0x64, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01,
	/*001930*/ 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f, 0x00, 0x13, 0x00, 0x86, 0x40, 0x40, 0x01, 0x14, 0x14, 0x40,
	/*001940*/ 0x15, 0x00, 0x02, 0x01, 0x05, 0x03, 0x0e, 0x0d, 0x06, 0x03, 0x05, 0x04, 0x0f, 0x00, 0x08, 0x07,
	/*001950*/ 0x04, 0x0a, 0x09, 0x13, 0x10, 0x04, 0x12, 0x11, 0x0c, 0x0b, 0x04, 0x05, 0x03, 0x05, 0x01, 0x00,
	/*001960*/ 0x03, 0x04, 0x06, 0x03, 0x02, 0x09, 0x08, 0x06, 0x0f, 0x0e, 0x0b, 0x07, 0x06, 0x05, 0x0a, 0x13,
	/*001970*/ 0x12, 0x06, 0x10, 0x11, 0x10, 0x01, 0x0d, 0x0c, 0x03, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18,
	/*001980*/ 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd,
	/*001990*/ 0x17, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17,
	/*0019a0*/ 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x14, 0x49,
	/*0019b0*/ 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59,
	/*0019c0*/ 0x01, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 0x33,
	/*0019d0*/ 0x03, 0x23, 0x35, 0x33, 0x01, 0x8f, 0x65, 0xc5, 0xc8, 0xcb, 0x61, 0x64, 0xc6, 0x64, 0xc8, 0x62,
	/*0019e0*/ 0x62, 0x01, 0x2d, 0x64, 0x62, 0xca, 0x64, 0x62, 0x64, 0x65, 0xfe, 0x0f, 0x62, 0x00, 0x00, 0x03,
	/*0019f0*/ 0x00, 0x01, 0xff, 0x9d, 0x01, 0xf3, 0x01, 0xf3, 0x00, 0x0b, 0x00, 0x0f, 0x00, 0x15, 0x00, 0x8a,
	/*001a00*/ 0x40, 0x42, 0x01, 0x16, 0x16, 0x40, 0x17, 0x00, 0x14, 0x13, 0x12, 0x11, 0x13, 0x12, 0x08, 0x07,
	/*001a10*/ 0x04, 0x05, 0x03, 0x04, 0x06, 0x05, 0x11, 0x10, 0x0d, 0x0c, 0x0a, 0x05, 0x09, 0x04, 0x0b, 0x00,
	/*001a20*/ 0x0f, 0x0e, 0x04, 0x15, 0x02, 0x01, 0x03, 0x14, 0x0f, 0x0c, 0x06, 0x00, 0x0e, 0x0d, 0x06, 0x15,
	/*001a30*/ 0x10, 0x09, 0x08, 0x03, 0x02, 0x0b, 0x0a, 0x07, 0x03, 0x06, 0x02, 0x05, 0x04, 0x01, 0x03, 0x00,
	/*001a40*/ 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x17, 0x3c, 0x2f,
	/*001a50*/ 0x3c, 0x2f, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x3c,
	/*001a60*/ 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x2e, 0x2e, 0x2e, 0x2e, 0x31,
	/*001a70*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x16, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*001a80*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x16, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x15, 0x23, 0x35, 0x23,
	/*001a90*/ 0x11, 0x33, 0x35, 0x21, 0x15, 0x33, 0x03, 0x35, 0x23, 0x15, 0x37, 0x35, 0x21, 0x11, 0x33, 0x11,
	/*001aa0*/ 0x01, 0xf3, 0xfe, 0xd3, 0x61, 0x64, 0x64, 0x01, 0x2a, 0x64, 0x64, 0x62, 0x62, 0xfe, 0xd6, 0x62,
	/*001ab0*/ 0x01, 0x64, 0x65, 0x01, 0x8d, 0x64, 0x65, 0xfe, 0xd7, 0x62, 0x62, 0xc8, 0x62, 0xfe, 0x72, 0x01,
	/*001ac0*/ 0x2c, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x09, 0x00, 0x0d,
	/*001ad0*/ 0x00, 0x6b, 0x40, 0x30, 0x01, 0x0e, 0x0e, 0x40, 0x0f, 0x00, 0x0d, 0x0c, 0x08, 0x04, 0x03, 0x05,
	/*001ae0*/ 0x07, 0x04, 0x06, 0x05, 0x0b, 0x02, 0x01, 0x03, 0x0a, 0x04, 0x09, 0x00, 0x0d, 0x0a, 0x06, 0x03,
	/*001af0*/ 0x02, 0x0c, 0x0b, 0x07, 0x03, 0x06, 0x06, 0x08, 0x09, 0x08, 0x03, 0x05, 0x04, 0x01, 0x03, 0x00,
	/*001b00*/ 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x3c, 0x10, 0xfd,
	/*001b10*/ 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17,
	/*001b20*/ 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0,
	/*001b30*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x35,
	/*001b40*/ 0x23, 0x15, 0x23, 0x11, 0x33, 0x35, 0x21, 0x03, 0x35, 0x23, 0x15, 0x01, 0x8f, 0x62, 0xca, 0x62,
	/*001b50*/ 0x64, 0x01, 0x2a, 0x64, 0xc6, 0x01, 0xc8, 0xc8, 0x01, 0xf2, 0x64, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
	/*001b60*/ 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0b, 0x00, 0x0f, 0x00, 0x13,
	/*001b70*/ 0x00, 0x82, 0x40, 0x41, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00, 0x13, 0x12, 0x0f, 0x03, 0x0e, 0x04,
	/*001b80*/ 0x04, 0x03, 0x11, 0x10, 0x0d, 0x0c, 0x0a, 0x09, 0x06, 0x02, 0x01, 0x09, 0x05, 0x04, 0x0b, 0x08,
	/*001b90*/ 0x07, 0x03, 0x00, 0x13, 0x10, 0x01, 0x03, 0x00, 0x06, 0x02, 0x0e, 0x07, 0x06, 0x03, 0x0d, 0x06,
	/*001ba0*/ 0x04, 0x12, 0x0b, 0x0a, 0x03, 0x11, 0x06, 0x0f, 0x0c, 0x09, 0x03, 0x08, 0x05, 0x04, 0x03, 0x03,
	/*001bb0*/ 0x02, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x2f, 0x17,
	/*001bc0*/ 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x17, 0x3c,
	/*001bd0*/ 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00,
	/*001be0*/ 0x03, 0x00, 0x14, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14,
	/*001bf0*/ 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x21, 0x11, 0x21, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33,
	/*001c00*/ 0x27, 0x35, 0x23, 0x15, 0x13, 0x35, 0x23, 0x15, 0x01, 0x8f, 0x65, 0xfe, 0xd7, 0x01, 0x2a, 0x64,
	/*001c10*/ 0x64, 0x64, 0x64, 0xc6, 0xc6, 0xc6, 0x65, 0x64, 0x02, 0x56, 0x65, 0x61, 0x67, 0x67, 0x62, 0x62,
	/*001c20*/ 0xfe, 0xd4, 0xc6, 0xc6, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0b,
	/*001c30*/ 0x00, 0x64, 0x40, 0x2a, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x07, 0x06, 0x0b, 0x04, 0x03, 0x00,
	/*001c40*/ 0x0a, 0x09, 0x06, 0x05, 0x02, 0x05, 0x01, 0x04, 0x08, 0x07, 0x09, 0x08, 0x01, 0x03, 0x00, 0x06,
	/*001c50*/ 0x0a, 0x03, 0x02, 0x06, 0x04, 0x0b, 0x0a, 0x03, 0x05, 0x04, 0x01, 0x01, 0x07, 0x46, 0x76, 0x2f,
	/*001c60*/ 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f,
	/*001c70*/ 0x3c, 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x2e, 0x2e, 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68,
	/*001c80*/ 0xb9, 0x00, 0x07, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9,
	/*001c90*/ 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x21, 0x11, 0x21, 0x15, 0x21, 0x35, 0x23, 0x11, 0x33,
	/*001ca0*/ 0x35, 0x21, 0x01, 0x8f, 0xfe, 0xd4, 0x01, 0x2c, 0xfe, 0xd6, 0x64, 0x64, 0x01, 0x2a, 0x01, 0xf5,
	/*001cb0*/ 0xfe, 0x6e, 0x62, 0x65, 0x01, 0x8d, 0x64, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f,
	/*001cc0*/ 0x02, 0x57, 0x00, 0x07, 0x00, 0x0b, 0x00, 0x65, 0x40, 0x2c, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00,
	/*001cd0*/ 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x09, 0x08, 0x06, 0x02, 0x01, 0x05, 0x05, 0x04, 0x07, 0x00, 0x0b,
	/*001ce0*/ 0x08, 0x01, 0x03, 0x00, 0x06, 0x02, 0x0a, 0x07, 0x06, 0x03, 0x09, 0x06, 0x04, 0x05, 0x04, 0x03,
	/*001cf0*/ 0x03, 0x02, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10,
	/*001d00*/ 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd,
	/*001d10*/ 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0,
	/*001d20*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15,
	/*001d30*/ 0x21, 0x11, 0x21, 0x15, 0x33, 0x03, 0x11, 0x23, 0x11, 0x01, 0x8f, 0x65, 0xfe, 0xd7, 0x01, 0x2a,
	/*001d40*/ 0x64, 0x64, 0xc6, 0x65, 0x64, 0x02, 0x56, 0x65, 0xfe, 0x73, 0x01, 0x8e, 0xfe, 0x72, 0x00, 0x01,
	/*001d50*/ 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0d, 0x00, 0x6d, 0x40, 0x2f, 0x01, 0x0e,
	/*001d60*/ 0x0e, 0x40, 0x0f, 0x00, 0x0d, 0x08, 0x07, 0x04, 0x03, 0x00, 0x0c, 0x0b, 0x06, 0x05, 0x02, 0x05,
	/*001d70*/ 0x01, 0x04, 0x0a, 0x09, 0x0b, 0x0a, 0x01, 0x03, 0x00, 0x06, 0x0c, 0x05, 0x04, 0x06, 0x03, 0x02,
	/*001d80*/ 0x07, 0x06, 0x06, 0x08, 0x0d, 0x0c, 0x03, 0x09, 0x08, 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37,
	/*001d90*/ 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17,
	/*001da0*/ 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x00, 0x31, 0x30,
	/*001db0*/ 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38,
	/*001dc0*/ 0x11, 0x37, 0xb9, 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x21, 0x15, 0x33, 0x15, 0x23, 0x15,
	/*001dd0*/ 0x21, 0x15, 0x21, 0x11, 0x33, 0x35, 0x21, 0x01, 0x8f, 0xfe, 0xd4, 0xc8, 0xc8, 0x01, 0x2c, 0xfe,
	/*001de0*/ 0x72, 0x64, 0x01, 0x2a, 0x01, 0xf5, 0x67, 0x61, 0xca, 0x62, 0x01, 0xf2, 0x64, 0x00, 0x00, 0x01,
	/*001df0*/ 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0b, 0x00, 0x62, 0x40, 0x29, 0x01, 0x0c,
	/*001e00*/ 0x0c, 0x40, 0x0d, 0x00, 0x0b, 0x04, 0x03, 0x00, 0x0a, 0x09, 0x06, 0x05, 0x02, 0x05, 0x01, 0x04,
	/*001e10*/ 0x08, 0x07, 0x09, 0x08, 0x01, 0x03, 0x00, 0x06, 0x0a, 0x05, 0x04, 0x06, 0x03, 0x02, 0x0b, 0x0a,
	/*001e20*/ 0x03, 0x07, 0x06, 0x01, 0x01, 0x07, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c,
	/*001e30*/ 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2e, 0x2e,
	/*001e40*/ 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x07, 0x00, 0x0c, 0x49, 0x68, 0x61,
	/*001e50*/ 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x21,
	/*001e60*/ 0x15, 0x33, 0x15, 0x23, 0x11, 0x23, 0x11, 0x33, 0x35, 0x21, 0x01, 0x8f, 0xfe, 0xd4, 0xc8, 0xc8,
	/*001e70*/ 0x62, 0x64, 0x01, 0x2a, 0x01, 0xf5, 0x67, 0x61, 0xfe, 0xd4, 0x01, 0xf2, 0x64, 0x00, 0x00, 0x01,
	/*001e80*/ 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f, 0x00, 0x7c, 0x40, 0x39, 0x01, 0x10,
	/*001e90*/ 0x10, 0x40, 0x11, 0x00, 0x03, 0x02, 0x0e, 0x0d, 0x05, 0x00, 0x0a, 0x06, 0x05, 0x02, 0x01, 0x05,
	/*001ea0*/ 0x09, 0x04, 0x04, 0x03, 0x0c, 0x0b, 0x04, 0x0f, 0x08, 0x07, 0x03, 0x00, 0x0b, 0x0a, 0x06, 0x00,
	/*001eb0*/ 0x09, 0x05, 0x04, 0x03, 0x08, 0x06, 0x06, 0x0d, 0x0c, 0x06, 0x0e, 0x0f, 0x0e, 0x02, 0x07, 0x06,
	/*001ec0*/ 0x03, 0x01, 0x00, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c,
	/*001ed0*/ 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c,
	/*001ee0*/ 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01,
	/*001ef0*/ 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11,
	/*001f00*/ 0x37, 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x23, 0x11, 0x33, 0x35, 0x21,
	/*001f10*/ 0x15, 0x21, 0x11, 0x33, 0x35, 0x23, 0x35, 0x33, 0x01, 0x8f, 0xfe, 0xd6, 0x64, 0x64, 0x01, 0x2a,
	/*001f20*/ 0xfe, 0xd4, 0xca, 0x64, 0xc6, 0x01, 0x65, 0x01, 0x8d, 0x64, 0x62, 0xfe, 0x6e, 0xcb, 0x61, 0x00,
	/*001f30*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0b, 0x00, 0x65, 0x40, 0x2c,
	/*001f40*/ 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x0a, 0x09, 0x02, 0x03, 0x01, 0x04, 0x0b, 0x00, 0x08, 0x07,
	/*001f50*/ 0x04, 0x03, 0x03, 0x04, 0x06, 0x05, 0x03, 0x02, 0x06, 0x08, 0x09, 0x08, 0x02, 0x0b, 0x0a, 0x07,
	/*001f60*/ 0x03, 0x06, 0x03, 0x05, 0x04, 0x01, 0x03, 0x00, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18,
	/*001f70*/ 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x17, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd,
	/*001f80*/ 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05,
	/*001f90*/ 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff,
	/*001fa0*/ 0xc0, 0x38, 0x59, 0x25, 0x23, 0x11, 0x23, 0x11, 0x23, 0x11, 0x33, 0x15, 0x33, 0x35, 0x33, 0x01,
	/*001fb0*/ 0x8f, 0x62, 0xca, 0x62, 0x62, 0xca, 0x62, 0x01, 0x01, 0x2c, 0xfe, 0xd4, 0x02, 0x56, 0xc8, 0xc8,
	/*001fc0*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x2b, 0x02, 0x57, 0x00, 0x0b, 0x00, 0x6c, 0x40, 0x30,
	/*001fd0*/ 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x0b, 0x08, 0x07, 0x03, 0x00, 0x08, 0x09, 0x06, 0x05, 0x02,
	/*001fe0*/ 0x03, 0x01, 0x08, 0x03, 0x04, 0x03, 0x04, 0x0a, 0x09, 0x0b, 0x0a, 0x03, 0x03, 0x02, 0x06, 0x00,
	/*001ff0*/ 0x09, 0x08, 0x05, 0x03, 0x04, 0x06, 0x06, 0x07, 0x06, 0x03, 0x01, 0x00, 0x01, 0x01, 0x01, 0x46,
	/*002000*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17,
	/*002010*/ 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x00, 0x31,
	/*002020*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*002030*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x33, 0x11, 0x23,
	/*002040*/ 0x35, 0x21, 0x15, 0x23, 0x11, 0x33, 0x01, 0x2b, 0xfe, 0xd6, 0x64, 0x64, 0x01, 0x2a, 0x64, 0x64,
	/*002050*/ 0x01, 0x62, 0x01, 0x92, 0x62, 0x62, 0xfe, 0x6d, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f,
	/*002060*/ 0x02, 0x57, 0x00, 0x09, 0x00, 0x61, 0x40, 0x27, 0x01, 0x0a, 0x0a, 0x40, 0x0b, 0x00, 0x04, 0x03,
	/*002070*/ 0x02, 0x01, 0x08, 0x07, 0x05, 0x00, 0x06, 0x05, 0x04, 0x09, 0x00, 0x05, 0x01, 0x00, 0x03, 0x04,
	/*002080*/ 0x06, 0x02, 0x07, 0x06, 0x06, 0x08, 0x09, 0x08, 0x03, 0x03, 0x02, 0x01, 0x01, 0x03, 0x46, 0x76,
	/*002090*/ 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01,
	/*0020a0*/ 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x2e, 0x2e, 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49,
	/*0020b0*/ 0x68, 0xb9, 0x00, 0x03, 0x00, 0x0a, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37,
	/*0020c0*/ 0xb9, 0x00, 0x0a, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x21, 0x35, 0x21, 0x11, 0x23, 0x35,
	/*0020d0*/ 0x33, 0x01, 0x8f, 0x65, 0xfe, 0xd7, 0x01, 0x2c, 0x64, 0xc6, 0x65, 0x64, 0x62, 0x01, 0x92, 0x62,
	/*0020e0*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f, 0x00, 0x76, 0x40, 0x37,
	/*0020f0*/ 0x01, 0x10, 0x10, 0x40, 0x11, 0x00, 0x0f, 0x0e, 0x0e, 0x0d, 0x0a, 0x09, 0x02, 0x05, 0x01, 0x04,
	/*002100*/ 0x0f, 0x0c, 0x0b, 0x03, 0x00, 0x08, 0x07, 0x04, 0x03, 0x03, 0x04, 0x06, 0x05, 0x0d, 0x0c, 0x07,
	/*002110*/ 0x06, 0x03, 0x02, 0x06, 0x08, 0x09, 0x08, 0x02, 0x0b, 0x0a, 0x07, 0x03, 0x06, 0x03, 0x05, 0x04,
	/*002120*/ 0x01, 0x03, 0x00, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f,
	/*002130*/ 0x17, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c,
	/*002140*/ 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00,
	/*002150*/ 0x05, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x10,
	/*002160*/ 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x11, 0x23, 0x11, 0x23, 0x11, 0x33, 0x15, 0x33, 0x35, 0x33,
	/*002170*/ 0x15, 0x23, 0x15, 0x33, 0x01, 0x8f, 0x62, 0xca, 0x62, 0x62, 0xca, 0x62, 0x64, 0x64, 0x01, 0x01,
	/*002180*/ 0x2c, 0xfe, 0xd4, 0x02, 0x56, 0xc8, 0xc8, 0xc6, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*002190*/ 0x01, 0x8f, 0x02, 0x57, 0x00, 0x07, 0x00, 0x53, 0x40, 0x1f, 0x01, 0x08, 0x08, 0x40, 0x09, 0x00,
	/*0021a0*/ 0x03, 0x02, 0x07, 0x00, 0x06, 0x02, 0x01, 0x03, 0x05, 0x04, 0x04, 0x03, 0x07, 0x06, 0x06, 0x00,
	/*0021b0*/ 0x05, 0x04, 0x03, 0x01, 0x00, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c,
	/*0021c0*/ 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x00, 0x2e, 0x2e,
	/*0021d0*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*0021e0*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x23, 0x11,
	/*0021f0*/ 0x33, 0x11, 0x21, 0x01, 0x8f, 0xfe, 0xd6, 0x64, 0x62, 0x01, 0x2c, 0x01, 0x65, 0x01, 0xf1, 0xfe,
	/*002200*/ 0x0c, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0xf3, 0x02, 0x57, 0x00, 0x13, 0x00, 0x8a,
	/*002210*/ 0x40, 0x43, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00, 0x10, 0x0f, 0x05, 0x00, 0x12, 0x11, 0x02, 0x03,
	/*002220*/ 0x01, 0x04, 0x13, 0x00, 0x04, 0x03, 0x04, 0x0e, 0x0d, 0x06, 0x03, 0x05, 0x0c, 0x0b, 0x08, 0x03,
	/*002230*/ 0x07, 0x04, 0x0a, 0x09, 0x07, 0x06, 0x03, 0x03, 0x02, 0x06, 0x11, 0x0d, 0x0c, 0x03, 0x10, 0x05,
	/*002240*/ 0x04, 0x06, 0x0e, 0x0f, 0x0e, 0x02, 0x13, 0x12, 0x0b, 0x03, 0x0a, 0x03, 0x09, 0x08, 0x01, 0x03,
	/*002250*/ 0x00, 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x17, 0x3c,
	/*002260*/ 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17,
	/*002270*/ 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31,
	/*002280*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x14, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*002290*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x11, 0x23, 0x15, 0x23,
	/*0022a0*/ 0x35, 0x23, 0x11, 0x23, 0x11, 0x33, 0x15, 0x33, 0x15, 0x33, 0x35, 0x33, 0x35, 0x33, 0x01, 0xf3,
	/*0022b0*/ 0x62, 0x67, 0x61, 0x67, 0x61, 0x62, 0x64, 0x67, 0x64, 0x61, 0x01, 0x01, 0x90, 0x64, 0x64, 0xfe,
	/*0022c0*/ 0x70, 0x02, 0x56, 0x65, 0x63, 0x64, 0x64, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f,
	/*0022d0*/ 0x02, 0x57, 0x00, 0x0f, 0x00, 0x79, 0x40, 0x38, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00, 0x0c, 0x04,
	/*0022e0*/ 0x03, 0x03, 0x0b, 0x05, 0x07, 0x0e, 0x0d, 0x02, 0x03, 0x01, 0x04, 0x0f, 0x00, 0x0a, 0x09, 0x06,
	/*0022f0*/ 0x03, 0x05, 0x04, 0x08, 0x07, 0x03, 0x02, 0x06, 0x0c, 0x05, 0x04, 0x06, 0x0b, 0x0a, 0x0d, 0x0c,
	/*002300*/ 0x02, 0x0f, 0x0e, 0x09, 0x03, 0x08, 0x03, 0x07, 0x06, 0x01, 0x03, 0x00, 0x01, 0x01, 0x07, 0x46,
	/*002310*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x17, 0x3c, 0x3f, 0x3c, 0x2f, 0x3c, 0xfd,
	/*002320*/ 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10,
	/*002330*/ 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x07, 0x00, 0x10, 0x49, 0x68,
	/*002340*/ 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x25,
	/*002350*/ 0x23, 0x11, 0x23, 0x35, 0x23, 0x11, 0x23, 0x11, 0x33, 0x15, 0x33, 0x15, 0x33, 0x35, 0x33, 0x01,
	/*002360*/ 0x8f, 0x62, 0x64, 0x67, 0x61, 0x62, 0x64, 0x67, 0x61, 0x01, 0x01, 0x2d, 0x63, 0xfe, 0x70, 0x02,
	/*002370*/ 0x56, 0x65, 0x63, 0xc8, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0b,
	/*002380*/ 0x00, 0x0f, 0x00, 0x6f, 0x40, 0x35, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00, 0x0f, 0x0e, 0x08, 0x07,
	/*002390*/ 0x04, 0x05, 0x03, 0x04, 0x06, 0x05, 0x0d, 0x0c, 0x0a, 0x02, 0x01, 0x05, 0x09, 0x04, 0x0b, 0x00,
	/*0023a0*/ 0x0f, 0x0c, 0x05, 0x04, 0x01, 0x05, 0x00, 0x06, 0x02, 0x0e, 0x0d, 0x0b, 0x0a, 0x07, 0x05, 0x06,
	/*0023b0*/ 0x06, 0x08, 0x09, 0x08, 0x03, 0x03, 0x02, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00,
	/*0023c0*/ 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd,
	/*0023d0*/ 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05,
	/*0023e0*/ 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x10, 0xff,
	/*0023f0*/ 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35, 0x23, 0x11, 0x33, 0x35, 0x33, 0x15, 0x33, 0x03,
	/*002400*/ 0x11, 0x23, 0x11, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x64, 0xc6, 0x64, 0x64, 0xc6, 0x65, 0x64, 0x65,
	/*002410*/ 0x01, 0x8d, 0x64, 0x65, 0xfe, 0x73, 0x01, 0x8e, 0xfe, 0x72, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01,
	/*002420*/ 0x01, 0x8f, 0x02, 0x57, 0x00, 0x09, 0x00, 0x0d, 0x00, 0x6b, 0x40, 0x30, 0x01, 0x0e, 0x0e, 0x40,
	/*002430*/ 0x0f, 0x00, 0x0d, 0x04, 0x03, 0x03, 0x0c, 0x04, 0x06, 0x05, 0x0b, 0x0a, 0x08, 0x02, 0x01, 0x05,
	/*002440*/ 0x07, 0x04, 0x09, 0x00, 0x0d, 0x0a, 0x01, 0x03, 0x00, 0x06, 0x03, 0x02, 0x0c, 0x09, 0x08, 0x03,
	/*002450*/ 0x0b, 0x06, 0x06, 0x07, 0x06, 0x03, 0x05, 0x04, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18,
	/*002460*/ 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x01, 0x2f,
	/*002470*/ 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9,
	/*002480*/ 0x00, 0x05, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00,
	/*002490*/ 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x23, 0x15, 0x23, 0x11, 0x21, 0x15, 0x33, 0x07,
	/*0024a0*/ 0x35, 0x23, 0x15, 0x01, 0x8f, 0x65, 0xc7, 0x62, 0x01, 0x2a, 0x64, 0x64, 0xc6, 0x01, 0x2d, 0x64,
	/*0024b0*/ 0xc8, 0x02, 0x56, 0x65, 0xc5, 0xc6, 0xc6, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f,
	/*0024c0*/ 0x02, 0x57, 0x00, 0x09, 0x00, 0x0f, 0x00, 0x13, 0x00, 0x85, 0x40, 0x42, 0x01, 0x14, 0x14, 0x40,
	/*0024d0*/ 0x15, 0x00, 0x11, 0x0f, 0x0e, 0x03, 0x10, 0x05, 0x00, 0x13, 0x12, 0x0d, 0x0c, 0x06, 0x05, 0x02,
	/*0024e0*/ 0x07, 0x01, 0x04, 0x04, 0x03, 0x0b, 0x0a, 0x08, 0x03, 0x07, 0x04, 0x09, 0x00, 0x13, 0x03, 0x02,
	/*0024f0*/ 0x03, 0x10, 0x06, 0x00, 0x0c, 0x0b, 0x09, 0x08, 0x05, 0x05, 0x04, 0x06, 0x06, 0x0e, 0x0d, 0x06,
	/*002500*/ 0x12, 0x0f, 0x0a, 0x03, 0x11, 0x07, 0x06, 0x03, 0x01, 0x00, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f,
	/*002510*/ 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c,
	/*002520*/ 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10,
	/*002530*/ 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x14, 0x49, 0x68,
	/*002540*/ 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59, 0x25,
	/*002550*/ 0x21, 0x35, 0x23, 0x11, 0x33, 0x35, 0x33, 0x15, 0x33, 0x03, 0x11, 0x23, 0x15, 0x33, 0x15, 0x07,
	/*002560*/ 0x35, 0x23, 0x15, 0x01, 0x8f, 0xfe, 0xd6, 0x64, 0x64, 0xc6, 0x64, 0x64, 0xc6, 0x64, 0x02, 0x62,
	/*002570*/ 0x01, 0x65, 0x01, 0x8d, 0x64, 0x65, 0xfe, 0xd7, 0x01, 0x2a, 0xc5, 0x65, 0x64, 0x62, 0x62, 0x00,
	/*002580*/ 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0d, 0x00, 0x11, 0x00, 0x7c,
	/*002590*/ 0x40, 0x3c, 0x01, 0x12, 0x12, 0x40, 0x13, 0x00, 0x11, 0x04, 0x03, 0x03, 0x10, 0x04, 0x06, 0x05,
	/*0025a0*/ 0x0f, 0x0e, 0x0c, 0x0b, 0x08, 0x02, 0x01, 0x07, 0x07, 0x04, 0x0d, 0x0a, 0x09, 0x03, 0x00, 0x0d,
	/*0025b0*/ 0x0c, 0x07, 0x00, 0x11, 0x0e, 0x0b, 0x03, 0x0a, 0x06, 0x03, 0x02, 0x10, 0x09, 0x08, 0x03, 0x0f,
	/*0025c0*/ 0x06, 0x06, 0x07, 0x06, 0x03, 0x05, 0x04, 0x01, 0x03, 0x00, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f,
	/*0025d0*/ 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17,
	/*0025e0*/ 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c,
	/*0025f0*/ 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x12, 0x49, 0x68, 0x61, 0xb0, 0x40,
	/*002600*/ 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x12, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x35, 0x23,
	/*002610*/ 0x15, 0x23, 0x11, 0x21, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x27, 0x35, 0x23, 0x15, 0x01, 0x8f,
	/*002620*/ 0x62, 0xca, 0x62, 0x01, 0x2a, 0x64, 0x64, 0x64, 0x64, 0xc6, 0x01, 0xc8, 0xc8, 0x02, 0x56, 0x65,
	/*002630*/ 0xc5, 0x67, 0x67, 0xc6, 0xc6, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57,
	/*002640*/ 0x00, 0x17, 0x00, 0xa3, 0x40, 0x53, 0x01, 0x18, 0x18, 0x40, 0x19, 0x00, 0x17, 0x10, 0x0f, 0x03,
	/*002650*/ 0x00, 0x04, 0x05, 0x16, 0x06, 0x05, 0x02, 0x01, 0x05, 0x15, 0x04, 0x07, 0x14, 0x08, 0x07, 0x03,
	/*002660*/ 0x13, 0x04, 0x09, 0x12, 0x0e, 0x0d, 0x0a, 0x09, 0x05, 0x11, 0x04, 0x0c, 0x0b, 0x04, 0x03, 0x03,
	/*002670*/ 0x17, 0x16, 0x06, 0x00, 0x05, 0x01, 0x00, 0x03, 0x04, 0x06, 0x02, 0x15, 0x14, 0x06, 0x07, 0x06,
	/*002680*/ 0x09, 0x08, 0x06, 0x13, 0x12, 0x0b, 0x0a, 0x06, 0x0c, 0x11, 0x0d, 0x0c, 0x03, 0x10, 0x06, 0x0e,
	/*002690*/ 0x0f, 0x0e, 0x03, 0x03, 0x02, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c,
	/*0026a0*/ 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd,
	/*0026b0*/ 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10,
	/*0026c0*/ 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49,
	/*0026d0*/ 0x68, 0xb9, 0x00, 0x03, 0x00, 0x18, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37,
	/*0026e0*/ 0xb9, 0x00, 0x18, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x21, 0x35, 0x21, 0x35, 0x23, 0x35,
	/*0026f0*/ 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x21, 0x15, 0x21, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x01,
	/*002700*/ 0x8f, 0x65, 0xfe, 0xd7, 0x01, 0x2c, 0x64, 0x64, 0x64, 0x64, 0x01, 0x2a, 0xfe, 0xd4, 0x64, 0x64,
	/*002710*/ 0x64, 0x65, 0x64, 0x62, 0x67, 0x64, 0x64, 0x61, 0x64, 0x62, 0x67, 0x64, 0x64, 0x00, 0x00, 0x01,
	/*002720*/ 0x00, 0x01, 0x00, 0x01, 0x01, 0xf3, 0x02, 0x57, 0x00, 0x07, 0x00, 0x53, 0x40, 0x1f, 0x01, 0x08,
	/*002730*/ 0x08, 0x40, 0x09, 0x00, 0x07, 0x06, 0x05, 0x00, 0x02, 0x01, 0x04, 0x04, 0x03, 0x05, 0x04, 0x01,
	/*002740*/ 0x03, 0x00, 0x06, 0x06, 0x07, 0x06, 0x03, 0x03, 0x02, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37,
	/*002750*/ 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2e,
	/*002760*/ 0x2e, 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x08, 0x49, 0x68,
	/*002770*/ 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x01,
	/*002780*/ 0x23, 0x11, 0x23, 0x11, 0x23, 0x35, 0x21, 0x01, 0xf3, 0xc8, 0x62, 0xc8, 0x01, 0xf2, 0x01, 0xf5,
	/*002790*/ 0xfe, 0x0c, 0x01, 0xf4, 0x62, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57,
	/*0027a0*/ 0x00, 0x0b, 0x00, 0x67, 0x40, 0x2c, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x05, 0x04, 0x02, 0x01,
	/*0027b0*/ 0x05, 0x03, 0x08, 0x04, 0x03, 0x03, 0x07, 0x04, 0x06, 0x05, 0x0a, 0x09, 0x04, 0x0b, 0x00, 0x09,
	/*0027c0*/ 0x01, 0x00, 0x03, 0x08, 0x06, 0x02, 0x0b, 0x0a, 0x07, 0x03, 0x06, 0x03, 0x03, 0x02, 0x01, 0x01,
	/*0027d0*/ 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c,
	/*0027e0*/ 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x2e, 0x2e,
	/*0027f0*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*002800*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35,
	/*002810*/ 0x23, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x62, 0xca, 0x62, 0x65,
	/*002820*/ 0x64, 0x65, 0x01, 0xf1, 0xfe, 0x0c, 0x01, 0xf4, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f,
	/*002830*/ 0x02, 0x57, 0x00, 0x0f, 0x00, 0x79, 0x40, 0x37, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00, 0x04, 0x03,
	/*002840*/ 0x05, 0x07, 0x0a, 0x09, 0x06, 0x03, 0x05, 0x04, 0x08, 0x07, 0x0c, 0x0b, 0x04, 0x02, 0x01, 0x0e,
	/*002850*/ 0x0d, 0x04, 0x0f, 0x00, 0x0d, 0x01, 0x00, 0x03, 0x0c, 0x06, 0x02, 0x0b, 0x03, 0x02, 0x03, 0x0a,
	/*002860*/ 0x06, 0x05, 0x04, 0x0f, 0x0e, 0x09, 0x03, 0x08, 0x03, 0x07, 0x06, 0x01, 0x01, 0x07, 0x46, 0x76,
	/*002870*/ 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*002880*/ 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c,
	/*002890*/ 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x07, 0x00, 0x10, 0x49, 0x68,
	/*0028a0*/ 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x01,
	/*0028b0*/ 0x23, 0x15, 0x23, 0x15, 0x23, 0x15, 0x23, 0x11, 0x33, 0x11, 0x33, 0x35, 0x33, 0x11, 0x33, 0x01,
	/*0028c0*/ 0x8f, 0x65, 0x64, 0x64, 0x61, 0x62, 0x67, 0x64, 0x61, 0x01, 0x2d, 0x64, 0x64, 0x64, 0x02, 0x56,
	/*0028d0*/ 0xfe, 0x70, 0x64, 0x01, 0x2c, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0xf3, 0x02, 0x57,
	/*0028e0*/ 0x00, 0x13, 0x00, 0x87, 0x40, 0x41, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00, 0x0f, 0x0e, 0x09, 0x08,
	/*0028f0*/ 0x02, 0x01, 0x04, 0x03, 0x06, 0x05, 0x04, 0x07, 0x0c, 0x08, 0x07, 0x03, 0x0b, 0x04, 0x0a, 0x09,
	/*002900*/ 0x0e, 0x0d, 0x04, 0x10, 0x04, 0x03, 0x03, 0x0f, 0x12, 0x11, 0x04, 0x13, 0x00, 0x11, 0x10, 0x0d,
	/*002910*/ 0x05, 0x04, 0x01, 0x00, 0x07, 0x0c, 0x06, 0x02, 0x13, 0x12, 0x0b, 0x03, 0x0a, 0x03, 0x07, 0x06,
	/*002920*/ 0x03, 0x03, 0x02, 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f,
	/*002930*/ 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c,
	/*002940*/ 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x2e, 0x2e, 0x2e, 0x2e,
	/*002950*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x14, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*002960*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35,
	/*002970*/ 0x23, 0x15, 0x23, 0x35, 0x23, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x01,
	/*002980*/ 0xf3, 0x65, 0x61, 0x67, 0x61, 0x64, 0x62, 0x67, 0x61, 0x66, 0x62, 0x65, 0x64, 0x64, 0x64, 0x65,
	/*002990*/ 0x01, 0xf1, 0xfe, 0x0c, 0x01, 0x90, 0xfe, 0x70, 0x01, 0xf4, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*0029a0*/ 0x01, 0x8f, 0x02, 0x57, 0x00, 0x13, 0x00, 0x87, 0x40, 0x44, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00,
	/*0029b0*/ 0x12, 0x11, 0x06, 0x02, 0x01, 0x05, 0x05, 0x04, 0x13, 0x04, 0x03, 0x03, 0x00, 0x10, 0x0f, 0x0c,
	/*0029c0*/ 0x0b, 0x08, 0x05, 0x07, 0x04, 0x0e, 0x0d, 0x0a, 0x03, 0x09, 0x0d, 0x0c, 0x01, 0x03, 0x00, 0x07,
	/*0029d0*/ 0x0e, 0x03, 0x02, 0x07, 0x04, 0x0b, 0x0a, 0x07, 0x03, 0x06, 0x07, 0x10, 0x11, 0x10, 0x02, 0x13,
	/*0029e0*/ 0x12, 0x0f, 0x03, 0x0e, 0x03, 0x09, 0x08, 0x05, 0x03, 0x04, 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f,
	/*0029f0*/ 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x17, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10,
	/*002a00*/ 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c,
	/*002a10*/ 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x14, 0x49, 0x68,
	/*002a20*/ 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59, 0x01,
	/*002a30*/ 0x23, 0x15, 0x33, 0x15, 0x23, 0x35, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x15,
	/*002a40*/ 0x33, 0x35, 0x33, 0x01, 0x8f, 0x64, 0x64, 0x62, 0xca, 0x62, 0x64, 0x64, 0x62, 0xca, 0x62, 0x01,
	/*002a50*/ 0x91, 0xcb, 0xc5, 0xc8, 0xc8, 0xc6, 0xca, 0xc6, 0xc8, 0xc8, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*002a60*/ 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f, 0x00, 0x76, 0x40, 0x36, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00,
	/*002a70*/ 0x09, 0x08, 0x02, 0x01, 0x05, 0x03, 0x0e, 0x0d, 0x06, 0x03, 0x05, 0x04, 0x0f, 0x00, 0x0c, 0x08,
	/*002a80*/ 0x07, 0x04, 0x03, 0x05, 0x0b, 0x04, 0x0a, 0x09, 0x05, 0x01, 0x00, 0x03, 0x04, 0x06, 0x02, 0x0d,
	/*002a90*/ 0x0c, 0x06, 0x07, 0x06, 0x0f, 0x0e, 0x0b, 0x03, 0x0a, 0x03, 0x03, 0x02, 0x01, 0x01, 0x09, 0x46,
	/*002aa0*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd,
	/*002ab0*/ 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c,
	/*002ac0*/ 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x10, 0x49, 0x68, 0x61,
	/*002ad0*/ 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23,
	/*002ae0*/ 0x15, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x23, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x01, 0x8f,
	/*002af0*/ 0x65, 0xc5, 0xc8, 0xc8, 0x64, 0x62, 0xca, 0x62, 0x65, 0x64, 0x62, 0x67, 0x64, 0x01, 0x29, 0xfe,
	/*002b00*/ 0xd4, 0x01, 0x2c, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x13,
	/*002b10*/ 0x00, 0x8e, 0x40, 0x43, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00, 0x06, 0x05, 0x04, 0x12, 0x11, 0x0a,
	/*002b20*/ 0x03, 0x09, 0x04, 0x03, 0x04, 0x0c, 0x0b, 0x0e, 0x0d, 0x04, 0x02, 0x01, 0x10, 0x0f, 0x04, 0x13,
	/*002b30*/ 0x08, 0x07, 0x03, 0x00, 0x01, 0x00, 0x07, 0x12, 0x0d, 0x03, 0x02, 0x03, 0x0c, 0x06, 0x0b, 0x0a,
	/*002b40*/ 0x05, 0x03, 0x04, 0x07, 0x06, 0x06, 0x08, 0x11, 0x10, 0x06, 0x12, 0x13, 0x12, 0x03, 0x0f, 0x0e,
	/*002b50*/ 0x02, 0x09, 0x08, 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c,
	/*002b60*/ 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*002b70*/ 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f,
	/*002b80*/ 0x17, 0x3c, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x14, 0x49,
	/*002b90*/ 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59,
	/*002ba0*/ 0x01, 0x23, 0x15, 0x23, 0x15, 0x23, 0x15, 0x21, 0x15, 0x21, 0x35, 0x33, 0x35, 0x33, 0x35, 0x33,
	/*002bb0*/ 0x35, 0x21, 0x35, 0x21, 0x01, 0x8f, 0x65, 0x64, 0x63, 0x01, 0x2c, 0xfe, 0x72, 0x65, 0x64, 0x63,
	/*002bc0*/ 0xfe, 0xd4, 0x01, 0x8e, 0x01, 0x91, 0x64, 0x64, 0x67, 0x61, 0xc6, 0x64, 0x64, 0x66, 0x62, 0x00,
	/*002bd0*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0xc7, 0x02, 0x57, 0x00, 0x07, 0x00, 0x59, 0x40, 0x23,
	/*002be0*/ 0x01, 0x08, 0x08, 0x40, 0x09, 0x00, 0x07, 0x04, 0x03, 0x03, 0x00, 0x05, 0x01, 0x06, 0x05, 0x04,
	/*002bf0*/ 0x02, 0x01, 0x07, 0x06, 0x06, 0x00, 0x05, 0x04, 0x06, 0x02, 0x03, 0x02, 0x03, 0x01, 0x00, 0x01,
	/*002c00*/ 0x01, 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x10,
	/*002c10*/ 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49,
	/*002c20*/ 0x68, 0xb9, 0x00, 0x01, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37,
	/*002c30*/ 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x37, 0x23, 0x11, 0x33, 0x15, 0x23, 0x11, 0x33, 0xc7,
	/*002c40*/ 0xc6, 0xc6, 0x64, 0x64, 0x01, 0x02, 0x56, 0x62, 0xfe, 0x6d, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*002c50*/ 0x01, 0x2b, 0x02, 0x57, 0x00, 0x0b, 0x00, 0x6d, 0x40, 0x2f, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00,
	/*002c60*/ 0x0b, 0x00, 0x04, 0x01, 0x0a, 0x02, 0x01, 0x03, 0x09, 0x04, 0x03, 0x08, 0x04, 0x03, 0x03, 0x07,
	/*002c70*/ 0x04, 0x06, 0x05, 0x0b, 0x0a, 0x07, 0x00, 0x03, 0x02, 0x07, 0x09, 0x08, 0x05, 0x04, 0x07, 0x06,
	/*002c80*/ 0x07, 0x06, 0x03, 0x01, 0x00, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c,
	/*002c90*/ 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd,
	/*002ca0*/ 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9,
	/*002cb0*/ 0x00, 0x05, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00,
	/*002cc0*/ 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33, 0x15, 0x33, 0x15,
	/*002cd0*/ 0x33, 0x01, 0x2b, 0x62, 0x64, 0x64, 0x62, 0x64, 0x64, 0x01, 0xc9, 0xc7, 0xc6, 0xc9, 0xc8, 0x00,
	/*002ce0*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0xc7, 0x02, 0x57, 0x00, 0x07, 0x00, 0x59, 0x40, 0x23,
	/*002cf0*/ 0x01, 0x08, 0x08, 0x40, 0x09, 0x00, 0x06, 0x05, 0x02, 0x03, 0x01, 0x05, 0x00, 0x04, 0x03, 0x04,
	/*002d00*/ 0x07, 0x00, 0x03, 0x02, 0x06, 0x00, 0x05, 0x04, 0x06, 0x06, 0x07, 0x06, 0x03, 0x01, 0x00, 0x01,
	/*002d10*/ 0x01, 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x10,
	/*002d20*/ 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49,
	/*002d30*/ 0x68, 0xb9, 0x00, 0x01, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37,
	/*002d40*/ 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x37, 0x23, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0xc7,
	/*002d50*/ 0xc6, 0x64, 0x64, 0xc6, 0x01, 0x62, 0x01, 0x92, 0x62, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x91,
	/*002d60*/ 0x01, 0x2b, 0x02, 0x57, 0x00, 0x0b, 0x00, 0x69, 0x40, 0x2d, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00,
	/*002d70*/ 0x0b, 0x00, 0x04, 0x01, 0x04, 0x03, 0x04, 0x06, 0x05, 0x08, 0x07, 0x04, 0x0a, 0x02, 0x01, 0x03,
	/*002d80*/ 0x09, 0x0b, 0x0a, 0x06, 0x00, 0x07, 0x06, 0x03, 0x03, 0x02, 0x06, 0x08, 0x05, 0x04, 0x01, 0x03,
	/*002d90*/ 0x00, 0x09, 0x08, 0x03, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f, 0x17,
	/*002da0*/ 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c,
	/*002db0*/ 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0c,
	/*002dc0*/ 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38,
	/*002dd0*/ 0x59, 0x01, 0x23, 0x35, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x01, 0x2b, 0x62,
	/*002de0*/ 0x67, 0x61, 0x64, 0x62, 0x64, 0x01, 0x91, 0x64, 0x64, 0x62, 0x64, 0x65, 0x00, 0x01, 0x00, 0x01,
	/*002df0*/ 0x00, 0x01, 0x01, 0x8f, 0x00, 0x63, 0x00, 0x03, 0x00, 0x3e, 0x40, 0x12, 0x01, 0x04, 0x04, 0x40,
	/*002e00*/ 0x05, 0x00, 0x03, 0x02, 0x01, 0x00, 0x03, 0x02, 0x01, 0x00, 0x01, 0x01, 0x01, 0x46, 0x76, 0x2f,
	/*002e10*/ 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x2f, 0x3c, 0x01, 0x2e, 0x2e, 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01,
	/*002e20*/ 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x04, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11,
	/*002e30*/ 0x37, 0xb9, 0x00, 0x04, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x21, 0x01, 0x8f, 0xfe, 0x72,
	/*002e40*/ 0x01, 0x8e, 0x01, 0x62, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x07,
	/*002e50*/ 0x00, 0x0b, 0x00, 0x65, 0x40, 0x2c, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x0b, 0x0a, 0x06, 0x05,
	/*002e60*/ 0x02, 0x05, 0x01, 0x04, 0x04, 0x03, 0x09, 0x08, 0x04, 0x07, 0x00, 0x0b, 0x03, 0x02, 0x03, 0x08,
	/*002e70*/ 0x06, 0x00, 0x0a, 0x09, 0x05, 0x03, 0x04, 0x06, 0x06, 0x07, 0x06, 0x02, 0x01, 0x00, 0x01, 0x01,
	/*002e80*/ 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10,
	/*002e90*/ 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30,
	/*002ea0*/ 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38,
	/*002eb0*/ 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x23, 0x35, 0x33, 0x35,
	/*002ec0*/ 0x21, 0x03, 0x35, 0x23, 0x15, 0x01, 0x8f, 0xfe, 0xd6, 0x64, 0x64, 0x01, 0x2a, 0x64, 0xc6, 0x01,
	/*002ed0*/ 0x65, 0xc5, 0x64, 0xfe, 0xd6, 0xc6, 0xc6, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f,
	/*002ee0*/ 0x02, 0x57, 0x00, 0x09, 0x00, 0x0d, 0x00, 0x6e, 0x40, 0x32, 0x01, 0x0e, 0x0e, 0x40, 0x0f, 0x00,
	/*002ef0*/ 0x0d, 0x06, 0x05, 0x03, 0x0c, 0x04, 0x04, 0x03, 0x0b, 0x0a, 0x08, 0x02, 0x01, 0x05, 0x07, 0x04,
	/*002f00*/ 0x09, 0x00, 0x0d, 0x0a, 0x01, 0x03, 0x00, 0x06, 0x02, 0x0c, 0x09, 0x08, 0x03, 0x0b, 0x06, 0x06,
	/*002f10*/ 0x07, 0x06, 0x02, 0x05, 0x04, 0x03, 0x03, 0x02, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18,
	/*002f20*/ 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01,
	/*002f30*/ 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68,
	/*002f40*/ 0xb9, 0x00, 0x03, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9,
	/*002f50*/ 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x21, 0x11, 0x33, 0x15, 0x33, 0x15, 0x33,
	/*002f60*/ 0x07, 0x35, 0x23, 0x15, 0x01, 0x8f, 0x65, 0xfe, 0xd7, 0x62, 0xc8, 0x64, 0x64, 0xc6, 0x65, 0x64,
	/*002f70*/ 0x02, 0x56, 0xc8, 0x65, 0xc5, 0xc6, 0xc6, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f,
	/*002f80*/ 0x01, 0x8f, 0x00, 0x0b, 0x00, 0x67, 0x40, 0x2c, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x0b, 0x04,
	/*002f90*/ 0x03, 0x00, 0x0a, 0x09, 0x06, 0x05, 0x02, 0x05, 0x01, 0x04, 0x08, 0x07, 0x07, 0x06, 0x07, 0x08,
	/*002fa0*/ 0x09, 0x08, 0x01, 0x03, 0x00, 0x06, 0x0a, 0x03, 0x02, 0x06, 0x04, 0x0b, 0x0a, 0x02, 0x05, 0x04,
	/*002fb0*/ 0x01, 0x01, 0x07, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c,
	/*002fc0*/ 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x2e,
	/*002fd0*/ 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x07, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0,
	/*002fe0*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x21, 0x15,
	/*002ff0*/ 0x21, 0x15, 0x21, 0x35, 0x23, 0x35, 0x33, 0x35, 0x21, 0x01, 0x8f, 0xfe, 0xd4, 0x01, 0x2c, 0xfe,
	/*003000*/ 0xd6, 0x64, 0x64, 0x01, 0x2a, 0x01, 0x2d, 0xca, 0x62, 0x65, 0xc5, 0x64, 0x00, 0x02, 0x00, 0x01,
	/*003010*/ 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x09, 0x00, 0x0d, 0x00, 0x6e, 0x40, 0x32, 0x01, 0x0e,
	/*003020*/ 0x0e, 0x40, 0x0f, 0x00, 0x0d, 0x0c, 0x06, 0x05, 0x02, 0x05, 0x01, 0x04, 0x04, 0x03, 0x0b, 0x08,
	/*003030*/ 0x07, 0x03, 0x0a, 0x04, 0x09, 0x00, 0x0d, 0x03, 0x02, 0x03, 0x0a, 0x06, 0x00, 0x0c, 0x0b, 0x05,
	/*003040*/ 0x03, 0x04, 0x06, 0x06, 0x09, 0x08, 0x03, 0x07, 0x06, 0x02, 0x01, 0x00, 0x01, 0x01, 0x03, 0x46,
	/*003050*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10,
	/*003060*/ 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31,
	/*003070*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*003080*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x23, 0x35, 0x33,
	/*003090*/ 0x35, 0x33, 0x35, 0x33, 0x03, 0x35, 0x23, 0x15, 0x01, 0x8f, 0xfe, 0xd6, 0x64, 0x65, 0xc7, 0x62,
	/*0030a0*/ 0x64, 0xc6, 0x01, 0x65, 0xc5, 0x64, 0xc8, 0xfe, 0x0e, 0xc6, 0xc6, 0x00, 0x00, 0x02, 0x00, 0x01,
	/*0030b0*/ 0x00, 0x01, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x0d, 0x00, 0x11, 0x00, 0x89, 0x40, 0x43, 0x01, 0x12,
	/*0030c0*/ 0x12, 0x40, 0x13, 0x00, 0x0c, 0x0b, 0x05, 0x05, 0x0d, 0x04, 0x03, 0x03, 0x00, 0x05, 0x01, 0x0f,
	/*0030d0*/ 0x0e, 0x02, 0x03, 0x01, 0x04, 0x05, 0x11, 0x10, 0x0a, 0x09, 0x06, 0x05, 0x05, 0x04, 0x08, 0x07,
	/*0030e0*/ 0x07, 0x06, 0x07, 0x08, 0x11, 0x0e, 0x01, 0x03, 0x00, 0x06, 0x0c, 0x03, 0x02, 0x06, 0x04, 0x10,
	/*0030f0*/ 0x0f, 0x0d, 0x0c, 0x09, 0x05, 0x08, 0x06, 0x0a, 0x0b, 0x0a, 0x02, 0x05, 0x04, 0x01, 0x01, 0x07,
	/*003100*/ 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*003110*/ 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*003120*/ 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9,
	/*003130*/ 0x00, 0x07, 0x00, 0x12, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00,
	/*003140*/ 0x12, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x33, 0x15, 0x21, 0x35, 0x23, 0x35, 0x33, 0x35,
	/*003150*/ 0x33, 0x15, 0x33, 0x07, 0x35, 0x23, 0x15, 0x01, 0x8f, 0xc8, 0xc8, 0xfe, 0xd6, 0x64, 0x64, 0xc6,
	/*003160*/ 0x64, 0xc8, 0x62, 0xc9, 0x67, 0x61, 0x65, 0xc5, 0x64, 0x65, 0x61, 0x62, 0x62, 0x00, 0x00, 0x01,
	/*003170*/ 0x00, 0x01, 0x00, 0x01, 0x01, 0x2b, 0x02, 0x57, 0x00, 0x0b, 0x00, 0x68, 0x40, 0x2d, 0x01, 0x0c,
	/*003180*/ 0x0c, 0x40, 0x0d, 0x00, 0x04, 0x03, 0x05, 0x07, 0x0b, 0x00, 0x05, 0x09, 0x0a, 0x09, 0x06, 0x05,
	/*003190*/ 0x02, 0x05, 0x01, 0x04, 0x08, 0x07, 0x09, 0x08, 0x01, 0x03, 0x00, 0x06, 0x0a, 0x05, 0x04, 0x06,
	/*0031a0*/ 0x03, 0x02, 0x0b, 0x0a, 0x03, 0x07, 0x06, 0x01, 0x01, 0x07, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00,
	/*0031b0*/ 0x3f, 0x3c, 0x3f, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd,
	/*0031c0*/ 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00,
	/*0031d0*/ 0x07, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c,
	/*0031e0*/ 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x33, 0x15, 0x23, 0x11, 0x23, 0x11, 0x33, 0x35, 0x33,
	/*0031f0*/ 0x01, 0x2b, 0xc8, 0x64, 0x65, 0x61, 0x64, 0xc6, 0x01, 0xf5, 0x67, 0x61, 0xfe, 0xd4, 0x01, 0xf2,
	/*003200*/ 0x64, 0x00, 0x00, 0x02, 0x00, 0x01, 0xff, 0x39, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x0d, 0x00, 0x11,
	/*003210*/ 0x00, 0x7a, 0x40, 0x3b, 0x01, 0x12, 0x12, 0x40, 0x13, 0x00, 0x11, 0x10, 0x0c, 0x0b, 0x08, 0x07,
	/*003220*/ 0x04, 0x07, 0x03, 0x04, 0x0a, 0x09, 0x0f, 0x06, 0x05, 0x02, 0x01, 0x05, 0x0e, 0x04, 0x0d, 0x00,
	/*003230*/ 0x05, 0x01, 0x00, 0x03, 0x04, 0x06, 0x02, 0x11, 0x09, 0x08, 0x03, 0x0e, 0x06, 0x07, 0x06, 0x10,
	/*003240*/ 0x0f, 0x0b, 0x03, 0x0a, 0x06, 0x0c, 0x0d, 0x0c, 0x02, 0x03, 0x02, 0x00, 0x01, 0x09, 0x46, 0x76,
	/*003250*/ 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17,
	/*003260*/ 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c,
	/*003270*/ 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x12, 0x49, 0x68, 0x61, 0xb0, 0x40,
	/*003280*/ 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x12, 0xff, 0xc0, 0x38, 0x59, 0x05, 0x23, 0x15, 0x23,
	/*003290*/ 0x35, 0x33, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x21, 0x03, 0x35, 0x23, 0x15, 0x01, 0x8f,
	/*0032a0*/ 0x65, 0xc5, 0xc8, 0xc8, 0x64, 0x64, 0x01, 0x2a, 0x64, 0xc6, 0x63, 0x64, 0x62, 0x67, 0x64, 0xc5,
	/*0032b0*/ 0x64, 0xfe, 0xd6, 0xc6, 0xc6, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57,
	/*0032c0*/ 0x00, 0x0b, 0x00, 0x65, 0x40, 0x2b, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x0b, 0x0a, 0x0a, 0x09,
	/*0032d0*/ 0x02, 0x03, 0x01, 0x04, 0x0b, 0x00, 0x08, 0x07, 0x04, 0x03, 0x03, 0x04, 0x06, 0x05, 0x03, 0x02,
	/*0032e0*/ 0x06, 0x08, 0x09, 0x08, 0x02, 0x07, 0x06, 0x03, 0x05, 0x04, 0x01, 0x03, 0x00, 0x01, 0x01, 0x05,
	/*0032f0*/ 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c,
	/*003300*/ 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x2e, 0x2e, 0x31, 0x30,
	/*003310*/ 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38,
	/*003320*/ 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x11, 0x23, 0x11, 0x23, 0x11,
	/*003330*/ 0x33, 0x15, 0x33, 0x15, 0x33, 0x01, 0x8f, 0x62, 0xca, 0x62, 0x62, 0xc8, 0x64, 0x01, 0x01, 0x2c,
	/*003340*/ 0xfe, 0xd4, 0x02, 0x56, 0xc8, 0x65, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x63, 0x02, 0x57,
	/*003350*/ 0x00, 0x03, 0x00, 0x07, 0x00, 0x54, 0x40, 0x21, 0x01, 0x08, 0x08, 0x40, 0x09, 0x00, 0x07, 0x04,
	/*003360*/ 0x03, 0x03, 0x00, 0x04, 0x06, 0x05, 0x02, 0x03, 0x01, 0x01, 0x00, 0x06, 0x02, 0x07, 0x06, 0x02,
	/*003370*/ 0x05, 0x04, 0x01, 0x03, 0x02, 0x03, 0x01, 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c,
	/*003380*/ 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31,
	/*003390*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x08, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*0033a0*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x08, 0xff, 0xc0, 0x38, 0x59, 0x13, 0x23, 0x35, 0x33, 0x11, 0x23,
	/*0033b0*/ 0x11, 0x33, 0x63, 0x62, 0x62, 0x62, 0x62, 0x01, 0xf5, 0x62, 0xfd, 0xaa, 0x01, 0x8e, 0x00, 0x02,
	/*0033c0*/ 0x00, 0x01, 0xff, 0x39, 0x00, 0xc7, 0x02, 0x57, 0x00, 0x03, 0x00, 0x0b, 0x00, 0x68, 0x40, 0x2d,
	/*0033d0*/ 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x0a, 0x09, 0x02, 0x03, 0x01, 0x04, 0x0b, 0x04, 0x03, 0x03,
	/*0033e0*/ 0x00, 0x06, 0x05, 0x04, 0x08, 0x07, 0x01, 0x00, 0x06, 0x02, 0x09, 0x05, 0x04, 0x03, 0x08, 0x06,
	/*0033f0*/ 0x06, 0x0b, 0x0a, 0x02, 0x07, 0x06, 0x00, 0x03, 0x02, 0x03, 0x01, 0x07, 0x46, 0x76, 0x2f, 0x37,
	/*003400*/ 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01,
	/*003410*/ 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68,
	/*003420*/ 0xb9, 0x00, 0x07, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9,
	/*003430*/ 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x13, 0x23, 0x35, 0x33, 0x11, 0x23, 0x15, 0x23, 0x35, 0x33,
	/*003440*/ 0x11, 0x33, 0xc7, 0x62, 0x62, 0x65, 0x61, 0x64, 0x62, 0x01, 0xf5, 0x62, 0xfd, 0x46, 0x64, 0x62,
	/*003450*/ 0x01, 0xf4, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x02, 0x57, 0x00, 0x0f, 0x00, 0x79,
	/*003460*/ 0x40, 0x39, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00, 0x0e, 0x0d, 0x0a, 0x09, 0x02, 0x05, 0x01, 0x04,
	/*003470*/ 0x0f, 0x0c, 0x0b, 0x03, 0x00, 0x08, 0x07, 0x04, 0x03, 0x03, 0x04, 0x06, 0x05, 0x0f, 0x0e, 0x07,
	/*003480*/ 0x00, 0x03, 0x02, 0x06, 0x08, 0x0d, 0x09, 0x08, 0x03, 0x0c, 0x06, 0x0a, 0x0b, 0x0a, 0x02, 0x07,
	/*003490*/ 0x06, 0x03, 0x05, 0x04, 0x01, 0x03, 0x00, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00,
	/*0034a0*/ 0x3f, 0x17, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd,
	/*0034b0*/ 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30,
	/*0034c0*/ 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38,
	/*0034d0*/ 0x11, 0x37, 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x35, 0x23, 0x15, 0x23, 0x11,
	/*0034e0*/ 0x33, 0x11, 0x33, 0x35, 0x33, 0x15, 0x23, 0x15, 0x33, 0x01, 0x8f, 0x62, 0xca, 0x62, 0x62, 0xcb,
	/*0034f0*/ 0x61, 0x64, 0x64, 0x01, 0xc8, 0xc8, 0x02, 0x56, 0xfe, 0xd4, 0x64, 0x62, 0x67, 0x00, 0x00, 0x01,
	/*003500*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x63, 0x02, 0x57, 0x00, 0x03, 0x00, 0x40, 0x40, 0x14, 0x01, 0x04,
	/*003510*/ 0x04, 0x40, 0x05, 0x00, 0x02, 0x01, 0x04, 0x03, 0x00, 0x03, 0x02, 0x03, 0x01, 0x00, 0x01, 0x01,
	/*003520*/ 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c,
	/*003530*/ 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x04, 0x49, 0x68, 0x61, 0xb0, 0x40,
	/*003540*/ 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x04, 0xff, 0xc0, 0x38, 0x59, 0x37, 0x23, 0x11, 0x33,
	/*003550*/ 0x63, 0x62, 0x62, 0x01, 0x02, 0x56, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0xf3, 0x01, 0x8f,
	/*003560*/ 0x00, 0x0d, 0x00, 0x6b, 0x40, 0x2f, 0x01, 0x0e, 0x0e, 0x40, 0x0f, 0x00, 0x0d, 0x0c, 0x0c, 0x0b,
	/*003570*/ 0x02, 0x03, 0x01, 0x04, 0x0d, 0x00, 0x04, 0x03, 0x04, 0x06, 0x05, 0x08, 0x07, 0x04, 0x0a, 0x09,
	/*003580*/ 0x07, 0x06, 0x03, 0x03, 0x02, 0x06, 0x0a, 0x0b, 0x0a, 0x02, 0x09, 0x08, 0x05, 0x04, 0x01, 0x05,
	/*003590*/ 0x00, 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x3c, 0x10,
	/*0035a0*/ 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17,
	/*0035b0*/ 0x3c, 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x0e, 0x49, 0x68,
	/*0035c0*/ 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x25,
	/*0035d0*/ 0x23, 0x11, 0x23, 0x11, 0x23, 0x11, 0x23, 0x11, 0x23, 0x11, 0x21, 0x15, 0x33, 0x01, 0xf3, 0x62,
	/*0035e0*/ 0x67, 0x61, 0x67, 0x61, 0x01, 0x8e, 0x64, 0x01, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x2c, 0xfe, 0xd4,
	/*0035f0*/ 0x01, 0x8e, 0x65, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x09,
	/*003600*/ 0x00, 0x5c, 0x40, 0x25, 0x01, 0x0a, 0x0a, 0x40, 0x0b, 0x00, 0x09, 0x08, 0x08, 0x07, 0x02, 0x03,
	/*003610*/ 0x01, 0x04, 0x09, 0x00, 0x04, 0x03, 0x04, 0x06, 0x05, 0x03, 0x02, 0x06, 0x06, 0x07, 0x06, 0x02,
	/*003620*/ 0x05, 0x04, 0x01, 0x03, 0x00, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17,
	/*003630*/ 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c,
	/*003640*/ 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0a, 0x49, 0x68, 0x61,
	/*003650*/ 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0a, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23,
	/*003660*/ 0x11, 0x23, 0x11, 0x23, 0x11, 0x21, 0x15, 0x33, 0x01, 0x8f, 0x62, 0xca, 0x62, 0x01, 0x2a, 0x64,
	/*003670*/ 0x01, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x8e, 0x65, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f,
	/*003680*/ 0x01, 0x8f, 0x00, 0x0b, 0x00, 0x0f, 0x00, 0x6f, 0x40, 0x35, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00,
	/*003690*/ 0x0f, 0x0e, 0x08, 0x07, 0x04, 0x05, 0x03, 0x04, 0x06, 0x05, 0x0d, 0x0c, 0x0a, 0x02, 0x01, 0x05,
	/*0036a0*/ 0x09, 0x04, 0x0b, 0x00, 0x0f, 0x0c, 0x05, 0x04, 0x01, 0x05, 0x00, 0x06, 0x02, 0x0e, 0x0d, 0x0b,
	/*0036b0*/ 0x0a, 0x07, 0x05, 0x06, 0x06, 0x08, 0x09, 0x08, 0x02, 0x03, 0x02, 0x01, 0x01, 0x05, 0x46, 0x76,
	/*0036c0*/ 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c,
	/*0036d0*/ 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49,
	/*0036e0*/ 0x68, 0xb9, 0x00, 0x05, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37,
	/*0036f0*/ 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35,
	/*003700*/ 0x33, 0x15, 0x33, 0x07, 0x35, 0x23, 0x15, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x64, 0xc6, 0x64, 0x64,
	/*003710*/ 0xc6, 0x65, 0x64, 0x65, 0xc5, 0x64, 0x65, 0xc5, 0xc6, 0xc6, 0x00, 0x02, 0x00, 0x01, 0xff, 0x39,
	/*003720*/ 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x09, 0x00, 0x0d, 0x00, 0x6e, 0x40, 0x32, 0x01, 0x0e, 0x0e, 0x40,
	/*003730*/ 0x0f, 0x00, 0x0d, 0x04, 0x03, 0x03, 0x0c, 0x04, 0x06, 0x05, 0x0b, 0x0a, 0x08, 0x02, 0x01, 0x05,
	/*003740*/ 0x07, 0x04, 0x09, 0x00, 0x0d, 0x0a, 0x01, 0x03, 0x00, 0x06, 0x02, 0x0c, 0x09, 0x08, 0x03, 0x0b,
	/*003750*/ 0x06, 0x06, 0x07, 0x06, 0x02, 0x05, 0x04, 0x00, 0x03, 0x02, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f,
	/*003760*/ 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17,
	/*003770*/ 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01,
	/*003780*/ 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11,
	/*003790*/ 0x37, 0xb9, 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x15, 0x23, 0x11, 0x21,
	/*0037a0*/ 0x15, 0x33, 0x07, 0x35, 0x23, 0x15, 0x01, 0x8f, 0x65, 0xc7, 0x62, 0x01, 0x2a, 0x64, 0x64, 0xc6,
	/*0037b0*/ 0x65, 0x64, 0xc8, 0x02, 0x56, 0x65, 0xc5, 0xc6, 0xc6, 0x00, 0x00, 0x02, 0x00, 0x01, 0xff, 0x39,
	/*0037c0*/ 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x09, 0x00, 0x0d, 0x00, 0x6e, 0x40, 0x32, 0x01, 0x0e, 0x0e, 0x40,
	/*0037d0*/ 0x0f, 0x00, 0x0d, 0x0c, 0x08, 0x07, 0x04, 0x05, 0x03, 0x04, 0x06, 0x05, 0x0b, 0x02, 0x01, 0x03,
	/*0037e0*/ 0x0a, 0x04, 0x09, 0x00, 0x0d, 0x05, 0x04, 0x03, 0x0a, 0x06, 0x02, 0x0c, 0x0b, 0x07, 0x03, 0x06,
	/*0037f0*/ 0x06, 0x08, 0x09, 0x08, 0x02, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0x01, 0x05, 0x46, 0x76, 0x2f,
	/*003800*/ 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17,
	/*003810*/ 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x31, 0x30, 0x01,
	/*003820*/ 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11,
	/*003830*/ 0x37, 0xb9, 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x05, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33,
	/*003840*/ 0x35, 0x21, 0x03, 0x35, 0x23, 0x15, 0x01, 0x8f, 0x62, 0xc8, 0x64, 0x64, 0x01, 0x2a, 0x64, 0xc6,
	/*003850*/ 0xc7, 0xc8, 0x65, 0xc5, 0x64, 0xfe, 0xd6, 0xc6, 0xc6, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*003860*/ 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x0b, 0x00, 0x65, 0x40, 0x2b, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00,
	/*003870*/ 0x02, 0x01, 0x05, 0x05, 0x0a, 0x09, 0x05, 0x0b, 0x00, 0x08, 0x07, 0x04, 0x03, 0x03, 0x04, 0x06,
	/*003880*/ 0x05, 0x03, 0x02, 0x06, 0x09, 0x01, 0x00, 0x03, 0x08, 0x0b, 0x0a, 0x07, 0x03, 0x06, 0x02, 0x05,
	/*003890*/ 0x04, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x2f,
	/*0038a0*/ 0x17, 0x3c, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd,
	/*0038b0*/ 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0,
	/*0038c0*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15,
	/*0038d0*/ 0x23, 0x15, 0x23, 0x11, 0x33, 0x15, 0x33, 0x35, 0x33, 0x01, 0x8f, 0xc9, 0x64, 0x61, 0x62, 0x67,
	/*0038e0*/ 0xc5, 0x01, 0x2d, 0x64, 0xc8, 0x01, 0x8e, 0x64, 0x64, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*0038f0*/ 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x0f, 0x00, 0x85, 0x40, 0x3f, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00,
	/*003900*/ 0x0a, 0x09, 0x08, 0x05, 0x0f, 0x0c, 0x0b, 0x03, 0x00, 0x05, 0x05, 0x08, 0x07, 0x04, 0x03, 0x03,
	/*003910*/ 0x05, 0x0d, 0x0e, 0x0d, 0x06, 0x03, 0x05, 0x04, 0x02, 0x01, 0x0f, 0x0e, 0x06, 0x00, 0x05, 0x01,
	/*003920*/ 0x00, 0x03, 0x04, 0x06, 0x02, 0x07, 0x06, 0x06, 0x08, 0x0d, 0x09, 0x08, 0x03, 0x0c, 0x06, 0x0a,
	/*003930*/ 0x0b, 0x0a, 0x02, 0x03, 0x02, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c,
	/*003940*/ 0x3f, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c,
	/*003950*/ 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd,
	/*003960*/ 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0,
	/*003970*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15,
	/*003980*/ 0x21, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x21, 0x15, 0x23, 0x15, 0x33, 0x01, 0x8f, 0x65,
	/*003990*/ 0xfe, 0xd7, 0xc8, 0xc8, 0x64, 0x01, 0x2a, 0xc8, 0xc8, 0x65, 0x64, 0x62, 0x67, 0x61, 0x64, 0x62,
	/*0039a0*/ 0x67, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x2b, 0x01, 0xf3, 0x00, 0x0b, 0x00, 0x64,
	/*0039b0*/ 0x40, 0x2a, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x03, 0x02, 0x0b, 0x08, 0x07, 0x03, 0x00, 0x05,
	/*0039c0*/ 0x01, 0x0a, 0x09, 0x06, 0x02, 0x01, 0x05, 0x05, 0x04, 0x04, 0x03, 0x0b, 0x0a, 0x06, 0x00, 0x09,
	/*0039d0*/ 0x08, 0x06, 0x07, 0x06, 0x05, 0x04, 0x01, 0x00, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18,
	/*0039e0*/ 0x00, 0x3f, 0x3c, 0x2f, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd,
	/*0039f0*/ 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00,
	/*003a00*/ 0x03, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0c,
	/*003a10*/ 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x35, 0x23, 0x11, 0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33,
	/*003a20*/ 0x01, 0x2b, 0xc6, 0x64, 0x62, 0xc8, 0xc8, 0xc8, 0x01, 0x65, 0x01, 0x8d, 0x65, 0x61, 0xca, 0x00,
	/*003a30*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x09, 0x00, 0x5c, 0x40, 0x25,
	/*003a40*/ 0x01, 0x0a, 0x0a, 0x40, 0x0b, 0x00, 0x03, 0x02, 0x06, 0x02, 0x01, 0x03, 0x05, 0x04, 0x04, 0x03,
	/*003a50*/ 0x08, 0x07, 0x04, 0x09, 0x00, 0x07, 0x06, 0x06, 0x00, 0x09, 0x08, 0x05, 0x03, 0x04, 0x02, 0x01,
	/*003a60*/ 0x00, 0x01, 0x01, 0x03, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x10,
	/*003a70*/ 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x2e, 0x2e, 0x31,
	/*003a80*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x0a, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*003a90*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0a, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x23, 0x11, 0x33,
	/*003aa0*/ 0x11, 0x33, 0x11, 0x33, 0x01, 0x8f, 0xfe, 0xd6, 0x64, 0x62, 0xca, 0x62, 0x01, 0x65, 0x01, 0x29,
	/*003ab0*/ 0xfe, 0xd4, 0x01, 0x2c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x0b,
	/*003ac0*/ 0x00, 0x65, 0x40, 0x2c, 0x01, 0x0c, 0x0c, 0x40, 0x0d, 0x00, 0x02, 0x01, 0x05, 0x03, 0x08, 0x04,
	/*003ad0*/ 0x03, 0x03, 0x07, 0x04, 0x06, 0x05, 0x0a, 0x09, 0x04, 0x0b, 0x00, 0x09, 0x05, 0x04, 0x01, 0x00,
	/*003ae0*/ 0x05, 0x08, 0x07, 0x02, 0x0b, 0x0a, 0x07, 0x03, 0x06, 0x02, 0x03, 0x02, 0x01, 0x01, 0x05, 0x46,
	/*003af0*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f,
	/*003b00*/ 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49,
	/*003b10*/ 0x68, 0xb9, 0x00, 0x05, 0x00, 0x0c, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37,
	/*003b20*/ 0xb9, 0x00, 0x0c, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x15,
	/*003b30*/ 0x33, 0x35, 0x33, 0x01, 0x8f, 0x65, 0xc5, 0x64, 0x62, 0xca, 0x62, 0xc9, 0xc8, 0xc8, 0xc6, 0xc8,
	/*003b40*/ 0xc8, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0xf3, 0x01, 0x8f, 0x00, 0x0d, 0x00, 0x6b,
	/*003b50*/ 0x40, 0x2f, 0x01, 0x0e, 0x0e, 0x40, 0x0f, 0x00, 0x03, 0x02, 0x06, 0x02, 0x01, 0x03, 0x05, 0x04,
	/*003b60*/ 0x04, 0x03, 0x08, 0x07, 0x04, 0x0a, 0x09, 0x0c, 0x0b, 0x04, 0x0d, 0x00, 0x0b, 0x0a, 0x07, 0x03,
	/*003b70*/ 0x06, 0x06, 0x00, 0x0d, 0x0c, 0x09, 0x08, 0x05, 0x05, 0x04, 0x02, 0x01, 0x00, 0x01, 0x01, 0x03,
	/*003b80*/ 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01,
	/*003b90*/ 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x00, 0x2e, 0x2e,
	/*003ba0*/ 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x03, 0x00, 0x0e, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52,
	/*003bb0*/ 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x0e, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x23, 0x11,
	/*003bc0*/ 0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x01, 0xf3, 0xfe, 0x72, 0x64, 0x62, 0x67,
	/*003bd0*/ 0x61, 0x67, 0x61, 0x01, 0x65, 0x01, 0x29, 0xfe, 0xd4, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x2c, 0x00,
	/*003be0*/ 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x13, 0x00, 0x89, 0x40, 0x45,
	/*003bf0*/ 0x01, 0x14, 0x14, 0x40, 0x15, 0x00, 0x0c, 0x0b, 0x05, 0x01, 0x12, 0x11, 0x06, 0x02, 0x01, 0x05,
	/*003c00*/ 0x05, 0x04, 0x13, 0x04, 0x03, 0x03, 0x00, 0x10, 0x0f, 0x08, 0x03, 0x07, 0x04, 0x0e, 0x0d, 0x0a,
	/*003c10*/ 0x03, 0x09, 0x07, 0x06, 0x07, 0x10, 0x11, 0x10, 0x0d, 0x0c, 0x01, 0x05, 0x00, 0x06, 0x0e, 0x0b,
	/*003c20*/ 0x0a, 0x03, 0x03, 0x02, 0x06, 0x04, 0x13, 0x12, 0x0f, 0x03, 0x0e, 0x02, 0x09, 0x08, 0x05, 0x03,
	/*003c30*/ 0x04, 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x17, 0x3c, 0x3f, 0x17, 0x3c,
	/*003c40*/ 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x01, 0x2f, 0x17, 0x3c, 0xfd,
	/*003c50*/ 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49,
	/*003c60*/ 0x68, 0xb9, 0x00, 0x09, 0x00, 0x14, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37,
	/*003c70*/ 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x33, 0x15, 0x23, 0x35, 0x23, 0x15,
	/*003c80*/ 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x15, 0x33, 0x35, 0x33, 0x01, 0x8f, 0x64, 0x64, 0x62,
	/*003c90*/ 0xcb, 0x61, 0x64, 0x64, 0x62, 0xcb, 0x61, 0x01, 0x2d, 0xcb, 0x61, 0x64, 0x64, 0x62, 0xca, 0x62,
	/*003ca0*/ 0x64, 0x64, 0x00, 0x01, 0x00, 0x01, 0xff, 0x39, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x0f, 0x00, 0x76,
	/*003cb0*/ 0x40, 0x36, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00, 0x09, 0x08, 0x02, 0x01, 0x05, 0x03, 0x0e, 0x0d,
	/*003cc0*/ 0x06, 0x03, 0x05, 0x04, 0x0f, 0x00, 0x0c, 0x08, 0x07, 0x04, 0x03, 0x05, 0x0b, 0x04, 0x0a, 0x09,
	/*003cd0*/ 0x05, 0x01, 0x00, 0x03, 0x04, 0x06, 0x02, 0x0d, 0x0c, 0x06, 0x07, 0x06, 0x0f, 0x0e, 0x0b, 0x03,
	/*003ce0*/ 0x0a, 0x02, 0x03, 0x02, 0x00, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f,
	/*003cf0*/ 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c,
	/*003d00*/ 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x2e, 0x2e, 0x31, 0x30, 0x01, 0x49, 0x68,
	/*003d10*/ 0xb9, 0x00, 0x09, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9,
	/*003d20*/ 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x05, 0x23, 0x15, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x23,
	/*003d30*/ 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x01, 0x8f, 0x65, 0xc5, 0xc8, 0xc8, 0x64, 0x62, 0xca, 0x62,
	/*003d40*/ 0x63, 0x64, 0x62, 0x67, 0x64, 0x01, 0x29, 0xfe, 0xd4, 0x01, 0x2c, 0x00, 0x00, 0x01, 0x00, 0x01,
	/*003d50*/ 0x00, 0x01, 0x01, 0x8f, 0x01, 0x8f, 0x00, 0x0f, 0x00, 0x7c, 0x40, 0x38, 0x01, 0x10, 0x10, 0x40,
	/*003d60*/ 0x11, 0x00, 0x0f, 0x0a, 0x09, 0x08, 0x07, 0x02, 0x01, 0x00, 0x04, 0x03, 0x04, 0x0d, 0x0e, 0x0d,
	/*003d70*/ 0x06, 0x03, 0x05, 0x04, 0x0c, 0x0b, 0x0d, 0x05, 0x04, 0x03, 0x0c, 0x07, 0x08, 0x0f, 0x0e, 0x03,
	/*003d80*/ 0x03, 0x02, 0x06, 0x00, 0x0b, 0x0a, 0x07, 0x03, 0x06, 0x06, 0x08, 0x09, 0x08, 0x02, 0x01, 0x00,
	/*003d90*/ 0x01, 0x01, 0x01, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x10, 0xfd, 0x17,
	/*003da0*/ 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10,
	/*003db0*/ 0xfd, 0x3c, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68,
	/*003dc0*/ 0xb9, 0x00, 0x01, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9,
	/*003dd0*/ 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x21, 0x35, 0x33, 0x35, 0x33, 0x35, 0x23, 0x35, 0x21,
	/*003de0*/ 0x15, 0x23, 0x15, 0x23, 0x15, 0x33, 0x01, 0x8f, 0xfe, 0x72, 0x65, 0x63, 0xc8, 0x01, 0x8e, 0x65,
	/*003df0*/ 0x63, 0xc8, 0x01, 0x62, 0x64, 0x66, 0x62, 0x62, 0x64, 0x67, 0x00, 0x01, 0x00, 0x01, 0xff, 0x9d,
	/*003e00*/ 0x01, 0x2b, 0x02, 0x57, 0x00, 0x13, 0x00, 0x89, 0x40, 0x42, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00,
	/*003e10*/ 0x10, 0x0f, 0x13, 0x08, 0x07, 0x03, 0x00, 0x04, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x06, 0x02, 0x01,
	/*003e20*/ 0x07, 0x05, 0x04, 0x0b, 0x0c, 0x0b, 0x04, 0x03, 0x03, 0x04, 0x0e, 0x0d, 0x05, 0x04, 0x07, 0x0b,
	/*003e30*/ 0x0a, 0x11, 0x10, 0x01, 0x03, 0x00, 0x06, 0x12, 0x07, 0x06, 0x06, 0x08, 0x0d, 0x0c, 0x06, 0x0f,
	/*003e40*/ 0x03, 0x02, 0x03, 0x0e, 0x09, 0x08, 0x13, 0x12, 0x03, 0x01, 0x0d, 0x46, 0x76, 0x2f, 0x37, 0x18,
	/*003e50*/ 0x00, 0x3f, 0x3c, 0x2f, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x17,
	/*003e60*/ 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x10,
	/*003e70*/ 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x0d, 0x00, 0x14,
	/*003e80*/ 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38,
	/*003e90*/ 0x59, 0x01, 0x23, 0x15, 0x23, 0x15, 0x33, 0x15, 0x33, 0x15, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35,
	/*003ea0*/ 0x33, 0x35, 0x33, 0x35, 0x33, 0x01, 0x2b, 0x65, 0x63, 0x64, 0x64, 0x62, 0x64, 0x64, 0x65, 0x63,
	/*003eb0*/ 0x62, 0x01, 0xf5, 0xc8, 0x67, 0xc8, 0x61, 0x65, 0xc8, 0x61, 0xc8, 0x64, 0x00, 0x01, 0x00, 0x01,
	/*003ec0*/ 0x00, 0x01, 0x00, 0x63, 0x02, 0x57, 0x00, 0x03, 0x00, 0x40, 0x40, 0x14, 0x01, 0x04, 0x04, 0x40,
	/*003ed0*/ 0x05, 0x00, 0x02, 0x01, 0x04, 0x03, 0x00, 0x03, 0x02, 0x03, 0x01, 0x00, 0x01, 0x01, 0x01, 0x46,
	/*003ee0*/ 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x00, 0x31,
	/*003ef0*/ 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x01, 0x00, 0x04, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58,
	/*003f00*/ 0x38, 0x11, 0x37, 0xb9, 0x00, 0x04, 0xff, 0xc0, 0x38, 0x59, 0x37, 0x23, 0x11, 0x33, 0x63, 0x62,
	/*003f10*/ 0x62, 0x01, 0x02, 0x56, 0x00, 0x01, 0x00, 0x01, 0xff, 0x9d, 0x01, 0x2b, 0x02, 0x57, 0x00, 0x13,
	/*003f20*/ 0x00, 0x8a, 0x40, 0x41, 0x01, 0x14, 0x14, 0x40, 0x15, 0x00, 0x10, 0x0f, 0x04, 0x03, 0x03, 0x04,
	/*003f30*/ 0x0e, 0x0d, 0x06, 0x03, 0x05, 0x0c, 0x0b, 0x08, 0x03, 0x07, 0x04, 0x02, 0x01, 0x12, 0x11, 0x0a,
	/*003f40*/ 0x03, 0x09, 0x04, 0x13, 0x00, 0x0b, 0x0a, 0x07, 0x11, 0x10, 0x13, 0x12, 0x06, 0x09, 0x08, 0x01,
	/*003f50*/ 0x03, 0x00, 0x07, 0x06, 0x06, 0x04, 0x0d, 0x0c, 0x06, 0x0e, 0x05, 0x04, 0x0f, 0x0e, 0x03, 0x03,
	/*003f60*/ 0x02, 0x01, 0x01, 0x05, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x3c, 0x2f, 0x3c,
	/*003f70*/ 0x10, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x01,
	/*003f80*/ 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c,
	/*003f90*/ 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x05, 0x00, 0x14, 0x49, 0x68, 0x61, 0xb0, 0x40,
	/*003fa0*/ 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x14, 0xff, 0xc0, 0x38, 0x59, 0x25, 0x23, 0x15, 0x23,
	/*003fb0*/ 0x15, 0x23, 0x35, 0x33, 0x35, 0x33, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33, 0x15, 0x33, 0x15, 0x33,
	/*003fc0*/ 0x01, 0x2b, 0x65, 0x64, 0x61, 0x65, 0x63, 0x64, 0x64, 0x62, 0x64, 0x64, 0xc9, 0xc8, 0x64, 0x62,
	/*003fd0*/ 0xc8, 0x67, 0xc7, 0x62, 0x65, 0xc8, 0x00, 0x01, 0x00, 0x01, 0x01, 0x91, 0x01, 0x8f, 0x02, 0x57,
	/*003fe0*/ 0x00, 0x0f, 0x00, 0x73, 0x40, 0x35, 0x01, 0x10, 0x10, 0x40, 0x11, 0x00, 0x02, 0x01, 0x04, 0x03,
	/*003ff0*/ 0x06, 0x05, 0x04, 0x08, 0x07, 0x0c, 0x04, 0x03, 0x03, 0x0b, 0x04, 0x0a, 0x09, 0x0e, 0x0d, 0x04,
	/*004000*/ 0x0f, 0x00, 0x0d, 0x0c, 0x09, 0x05, 0x04, 0x01, 0x00, 0x07, 0x08, 0x06, 0x02, 0x07, 0x06, 0x03,
	/*004010*/ 0x03, 0x02, 0x0f, 0x0e, 0x0b, 0x03, 0x0a, 0x03, 0x01, 0x07, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00,
	/*004020*/ 0x3f, 0x17, 0x3c, 0x2f, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c, 0x2f,
	/*004030*/ 0x3c, 0xfd, 0x17, 0x3c, 0x2f, 0x3c, 0xfd, 0x3c, 0x10, 0xfd, 0x3c, 0x00, 0x31, 0x30, 0x01, 0x49,
	/*004040*/ 0x68, 0xb9, 0x00, 0x07, 0x00, 0x10, 0x49, 0x68, 0x61, 0xb0, 0x40, 0x52, 0x58, 0x38, 0x11, 0x37,
	/*004050*/ 0xb9, 0x00, 0x10, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15, 0x23, 0x35, 0x23, 0x15, 0x23, 0x35,
	/*004060*/ 0x33, 0x35, 0x33, 0x15, 0x33, 0x35, 0x33, 0x01, 0x8f, 0x65, 0x61, 0x67, 0x61, 0x64, 0x62, 0x67,
	/*004070*/ 0x61, 0x01, 0xf5, 0x64, 0x64, 0x64, 0x62, 0x64, 0x64, 0x64, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
	/*004080*/ 0x01, 0xf3, 0x02, 0x57, 0x00, 0x17, 0x00, 0x95, 0x40, 0x4a, 0x01, 0x18, 0x18, 0x40, 0x19, 0x00,
	/*004090*/ 0x17, 0x0e, 0x0d, 0x0a, 0x09, 0x04, 0x03, 0x00, 0x06, 0x02, 0x01, 0x03, 0x05, 0x04, 0x07, 0x12,
	/*0040a0*/ 0x0c, 0x0b, 0x08, 0x07, 0x05, 0x11, 0x04, 0x10, 0x0f, 0x14, 0x13, 0x04, 0x16, 0x15, 0x0d, 0x0c,
	/*0040b0*/ 0x01, 0x03, 0x00, 0x06, 0x16, 0x0b, 0x0a, 0x03, 0x03, 0x02, 0x06, 0x09, 0x08, 0x05, 0x03, 0x04,
	/*0040c0*/ 0x15, 0x14, 0x11, 0x03, 0x10, 0x03, 0x17, 0x16, 0x13, 0x12, 0x0f, 0x05, 0x0e, 0x02, 0x07, 0x06,
	/*0040d0*/ 0x01, 0x01, 0x09, 0x46, 0x76, 0x2f, 0x37, 0x18, 0x00, 0x3f, 0x3c, 0x3f, 0x17, 0x3c, 0x3f, 0x17,
	/*0040e0*/ 0x3c, 0x2f, 0x17, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x01, 0x2f, 0x3c, 0xfd, 0x3c,
	/*0040f0*/ 0x2f, 0x3c, 0xfd, 0x17, 0x3c, 0x10, 0xfd, 0x17, 0x3c, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
	/*004100*/ 0x2e, 0x00, 0x31, 0x30, 0x01, 0x49, 0x68, 0xb9, 0x00, 0x09, 0x00, 0x18, 0x49, 0x68, 0x61, 0xb0,
	/*004110*/ 0x40, 0x52, 0x58, 0x38, 0x11, 0x37, 0xb9, 0x00, 0x18, 0xff, 0xc0, 0x38, 0x59, 0x01, 0x23, 0x15,
	/*004120*/ 0x33, 0x15, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15,
	/*004130*/ 0x33, 0x35, 0x33, 0x15, 0x33, 0x01, 0xf3, 0xc8, 0xc8, 0xc9, 0x61, 0xc8, 0xc8, 0xc8, 0x64, 0x62,
	/*004140*/ 0x67, 0x61, 0x64, 0x01, 0x2d, 0x67, 0x61, 0x64, 0x65, 0x61, 0x67, 0x61, 0xc8, 0xc8, 0xc8, 0xc9,
	/*004150*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x7a,
	/*004160*/ 0x00, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x01, 0x64, 0x00, 0x00, 0x02, 0x6a,
	/*004170*/ 0x00, 0x00, 0x03, 0x2a, 0x00, 0x00, 0x04, 0x78, 0x00, 0x00, 0x05, 0xac, 0x00, 0x00, 0x06, 0x04,
	/*004180*/ 0x00, 0x00, 0x06, 0x96, 0x00, 0x00, 0x07, 0x26, 0x00, 0x00, 0x07, 0xe2, 0x00, 0x00, 0x08, 0x70,
	/*004190*/ 0x00, 0x00, 0x08, 0xe2, 0x00, 0x00, 0x09, 0x3a, 0x00, 0x00, 0x09, 0x90, 0x00, 0x00, 0x0a, 0x22,
	/*0041a0*/ 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x76, 0x00, 0x00, 0x0c, 0x62, 0x00, 0x00, 0x0d, 0x4e,
	/*0041b0*/ 0x00, 0x00, 0x0d, 0xe8, 0x00, 0x00, 0x0e, 0x9a, 0x00, 0x00, 0x0f, 0x6c, 0x00, 0x00, 0x10, 0x1c,
	/*0041c0*/ 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0xd0, 0x00, 0x00, 0x12, 0x48, 0x00, 0x00, 0x12, 0xc0,
	/*0041d0*/ 0x00, 0x00, 0x13, 0x84, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0xc6, 0x00, 0x00, 0x15, 0x8a,
	/*0041e0*/ 0x00, 0x00, 0x16, 0x5e, 0x00, 0x00, 0x16, 0xfc, 0x00, 0x00, 0x17, 0xc0, 0x00, 0x00, 0x18, 0x54,
	/*0041f0*/ 0x00, 0x00, 0x18, 0xea, 0x00, 0x00, 0x19, 0x8a, 0x00, 0x00, 0x1a, 0x1a, 0x00, 0x00, 0x1a, 0xcc,
	/*004200*/ 0x00, 0x00, 0x1b, 0x5c, 0x00, 0x00, 0x1b, 0xf4, 0x00, 0x00, 0x1c, 0x7c, 0x00, 0x00, 0x1d, 0x26,
	/*004210*/ 0x00, 0x00, 0x1d, 0x9e, 0x00, 0x00, 0x1e, 0x64, 0x00, 0x00, 0x1f, 0x10, 0x00, 0x00, 0x1f, 0xb6,
	/*004220*/ 0x00, 0x00, 0x20, 0x54, 0x00, 0x00, 0x21, 0x1c, 0x00, 0x00, 0x21, 0xd2, 0x00, 0x00, 0x22, 0xba,
	/*004230*/ 0x00, 0x00, 0x23, 0x32, 0x00, 0x00, 0x23, 0xc4, 0x00, 0x00, 0x24, 0x72, 0x00, 0x00, 0x25, 0x36,
	/*004240*/ 0x00, 0x00, 0x25, 0xf6, 0x00, 0x00, 0x26, 0xa0, 0x00, 0x00, 0x27, 0x6c, 0x00, 0x00, 0x27, 0xe6,
	/*004250*/ 0x00, 0x00, 0x28, 0x7c, 0x00, 0x00, 0x28, 0xf6, 0x00, 0x00, 0x29, 0x88, 0x00, 0x00, 0x29, 0xe0,
	/*004260*/ 0x00, 0x00, 0x2a, 0x74, 0x00, 0x00, 0x2b, 0x14, 0x00, 0x00, 0x2b, 0xa8, 0x00, 0x00, 0x2c, 0x48,
	/*004270*/ 0x00, 0x00, 0x2d, 0x0a, 0x00, 0x00, 0x2d, 0x9e, 0x00, 0x00, 0x2e, 0x52, 0x00, 0x00, 0x2e, 0xe2,
	/*004280*/ 0x00, 0x00, 0x2f, 0x5a, 0x00, 0x00, 0x2f, 0xee, 0x00, 0x00, 0x30, 0x9a, 0x00, 0x00, 0x30, 0xf2,
	/*004290*/ 0x00, 0x00, 0x31, 0x90, 0x00, 0x00, 0x32, 0x14, 0x00, 0x00, 0x32, 0xb6, 0x00, 0x00, 0x33, 0x56,
	/*0042a0*/ 0x00, 0x00, 0x33, 0xf6, 0x00, 0x00, 0x34, 0x86, 0x00, 0x00, 0x35, 0x3e, 0x00, 0x00, 0x35, 0xcc,
	/*0042b0*/ 0x00, 0x00, 0x36, 0x50, 0x00, 0x00, 0x36, 0xde, 0x00, 0x00, 0x37, 0x7c, 0x00, 0x00, 0x38, 0x3e,
	/*0042c0*/ 0x00, 0x00, 0x38, 0xe8, 0x00, 0x00, 0x39, 0x96, 0x00, 0x00, 0x3a, 0x58, 0x00, 0x00, 0x3a, 0xb0,
	/*0042d0*/ 0x00, 0x00, 0x3b, 0x72, 0x00, 0x00, 0x3c, 0x16, 0x00, 0x00, 0x3c, 0xec, 0x00, 0x00, 0x3c, 0xec,
	/*0042e0*/ 0x01, 0x90, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x00,
	/*0042f0*/ 0x00, 0xc8, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01,
	/*004300*/ 0x03, 0x20, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01, 0x00, 0xc8, 0x00, 0x01, 0x01, 0x2c, 0x00, 0x01,
	/*004310*/ 0x01, 0x2c, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01, 0x01, 0x2c, 0x00, 0x01,
	/*004320*/ 0x01, 0x90, 0x00, 0x01, 0x00, 0xc8, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004330*/ 0x01, 0xf4, 0x00, 0x65, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004340*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004350*/ 0x01, 0xf4, 0x00, 0x01, 0x00, 0xc8, 0x00, 0x01, 0x00, 0xc8, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01,
	/*004360*/ 0x01, 0x90, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01,
	/*004370*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004380*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004390*/ 0x01, 0x90, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*0043a0*/ 0x02, 0x58, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*0043b0*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01,
	/*0043c0*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*0043d0*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0x2c, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01,
	/*0043e0*/ 0x01, 0x2c, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*0043f0*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004400*/ 0x01, 0x90, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x00, 0xc8, 0x00, 0x01,
	/*004410*/ 0x01, 0x2c, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x00, 0xc8, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01,
	/*004420*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004430*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004440*/ 0x01, 0xf4, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01, 0x01, 0xf4, 0x00, 0x01,
	/*004450*/ 0x01, 0xf4, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01, 0x00, 0xc8, 0x00, 0x01, 0x01, 0x90, 0x00, 0x01,
	/*004460*/ 0x01, 0xf4, 0x00, 0x01, 0x02, 0x58, 0x00, 0x01, 0x01, 0x90, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	/*004470*/ 0x00, 0x00, 0x00, 0x00, 0xff, 0x7b, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004480*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00,
	/*004490*/ 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08,
	/*0044a0*/ 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0f, 0x00, 0x10,
	/*0044b0*/ 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00, 0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17, 0x00, 0x18,
	/*0044c0*/ 0x00, 0x19, 0x00, 0x1a, 0x00, 0x1b, 0x00, 0x1c, 0x00, 0x1d, 0x00, 0x1e, 0x00, 0x1f, 0x00, 0x20,
	/*0044d0*/ 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27, 0x00, 0x28,
	/*0044e0*/ 0x00, 0x29, 0x00, 0x2a, 0x00, 0x2b, 0x00, 0x2c, 0x00, 0x2d, 0x00, 0x2e, 0x00, 0x2f, 0x00, 0x30,
	/*0044f0*/ 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00, 0x38,
	/*004500*/ 0x00, 0x39, 0x00, 0x3a, 0x00, 0x3b, 0x00, 0x3c, 0x00, 0x3d, 0x00, 0x3e, 0x00, 0x3f, 0x00, 0x40,
	/*004510*/ 0x00, 0x41, 0x00, 0x42, 0x00, 0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00, 0x48, 0x00, 0x49,
	/*004520*/ 0x00, 0x4a, 0x00, 0x4b, 0x00, 0x4c, 0x00, 0x4d, 0x00, 0x4e, 0x00, 0x4f, 0x00, 0x50, 0x00, 0x51,
	/*004530*/ 0x00, 0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00, 0x58, 0x00, 0x59,
	/*004540*/ 0x00, 0x5a, 0x00, 0x5b, 0x00, 0x5c, 0x00, 0x5d, 0x00, 0x5e, 0x00, 0x5f, 0x00, 0x60, 0x00, 0x61,
	/*004550*/ 0x00, 0x96, 0x00, 0xac, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x24,
	/*004560*/ 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x01, 0x24,
	/*004570*/ 0x00, 0x00, 0x01, 0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
	/*004580*/ 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004590*/ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c,
	/*0045a0*/ 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
	/*0045b0*/ 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c,
	/*0045c0*/ 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c,
	/*0045d0*/ 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x00, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
	/*0045e0*/ 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,
	/*0045f0*/ 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004610*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00,
	/*004620*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004630*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	/*004650*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004660*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004670*/ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x04, 0x00, 0x00, 0x00, 0x0c,
	/*004680*/ 0x00, 0x08, 0x00, 0x02, 0x00, 0x04, 0x00, 0x5f, 0x00, 0x7e, 0x00, 0xa0, 0x00, 0xa5, 0x20, 0x10,
	/*004690*/ 0xff, 0xff, 0x00, 0x00, 0x00, 0x20, 0x00, 0x61, 0x00, 0xa0, 0x00, 0xa5, 0x20, 0x10, 0xff, 0xff,
	/*0046a0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0c, 0x00, 0x8a,
	/*0046b0*/ 0x00, 0xc4, 0x00, 0xc4, 0x00, 0xc4, 0xff, 0xff, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06,
	/*0046c0*/ 0x00, 0x07, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x0e,
	/*0046d0*/ 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00, 0x14, 0x00, 0x15, 0x00, 0x16,
	/*0046e0*/ 0x00, 0x17, 0x00, 0x18, 0x00, 0x19, 0x00, 0x1a, 0x00, 0x1b, 0x00, 0x1c, 0x00, 0x1d, 0x00, 0x1e,
	/*0046f0*/ 0x00, 0x1f, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x26,
	/*004700*/ 0x00, 0x27, 0x00, 0x28, 0x00, 0x29, 0x00, 0x2a, 0x00, 0x2b, 0x00, 0x2c, 0x00, 0x2d, 0x00, 0x2e,
	/*004710*/ 0x00, 0x2f, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36,
	/*004720*/ 0x00, 0x37, 0x00, 0x38, 0x00, 0x39, 0x00, 0x3a, 0x00, 0x3b, 0x00, 0x3c, 0x00, 0x3d, 0x00, 0x3e,
	/*004730*/ 0x00, 0x3f, 0x00, 0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00, 0x44, 0x00, 0x45, 0x00, 0x46,
	/*004740*/ 0x00, 0x47, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4a, 0x00, 0x4b, 0x00, 0x4c, 0x00, 0x4d, 0x00, 0x4e,
	/*004750*/ 0x00, 0x4f, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55, 0x00, 0x56,
	/*004760*/ 0x00, 0x57, 0x00, 0x58, 0x00, 0x59, 0x00, 0x5a, 0x00, 0x5b, 0x00, 0x5c, 0x00, 0x5d, 0x00, 0x5e,
	/*004770*/ 0x00, 0x5f, 0x00, 0x60, 0x00, 0x62, 0x00, 0x61, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	/*004780*/ 0x00, 0x00, 0x00, 0x68, 0x09, 0x09, 0x05, 0x00, 0x03, 0x03, 0x02, 0x05, 0x07, 0x07, 0x09, 0x07,
	/*004790*/ 0x02, 0x03, 0x03, 0x05, 0x05, 0x03, 0x05, 0x02, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	/*0047a0*/ 0x06, 0x06, 0x06, 0x02, 0x02, 0x05, 0x05, 0x05, 0x06, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	/*0047b0*/ 0x06, 0x06, 0x05, 0x06, 0x06, 0x06, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x06, 0x06,
	/*0047c0*/ 0x07, 0x06, 0x06, 0x06, 0x03, 0x05, 0x03, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x06,
	/*0047d0*/ 0x06, 0x02, 0x03, 0x06, 0x02, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x07,
	/*0047e0*/ 0x06, 0x06, 0x06, 0x05, 0x02, 0x05, 0x06, 0x07, 0x05, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x05, 0x00,
	/*0047f0*/ 0x04, 0x04, 0x03, 0x05, 0x08, 0x08, 0x0a, 0x08, 0x03, 0x04, 0x04, 0x05, 0x05, 0x04, 0x05, 0x03,
	/*004800*/ 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x03, 0x03, 0x05, 0x05, 0x05,
	/*004810*/ 0x06, 0x08, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x06, 0x08, 0x06,
	/*004820*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x08, 0x06, 0x06, 0x08, 0x06, 0x06, 0x06, 0x04, 0x05, 0x04, 0x05,
	/*004830*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x03, 0x04, 0x06, 0x03, 0x08, 0x06, 0x06,
	/*004840*/ 0x06, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x08, 0x06, 0x06, 0x06, 0x05, 0x03, 0x05, 0x06, 0x08,
	/*004850*/ 0x05, 0x00, 0x00, 0x00, 0x0b, 0x0b, 0x06, 0x00, 0x04, 0x04, 0x03, 0x06, 0x08, 0x08, 0x0b, 0x08,
	/*004860*/ 0x03, 0x04, 0x04, 0x06, 0x06, 0x04, 0x06, 0x03, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	/*004870*/ 0x07, 0x07, 0x07, 0x03, 0x03, 0x06, 0x06, 0x06, 0x07, 0x08, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	/*004880*/ 0x07, 0x07, 0x06, 0x07, 0x07, 0x07, 0x08, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x07, 0x07,
	/*004890*/ 0x08, 0x07, 0x07, 0x07, 0x04, 0x06, 0x04, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x07,
	/*0048a0*/ 0x07, 0x03, 0x04, 0x07, 0x03, 0x08, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x07, 0x07, 0x08,
	/*0048b0*/ 0x07, 0x07, 0x07, 0x06, 0x03, 0x06, 0x07, 0x08, 0x06, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x06, 0x00,
	/*0048c0*/ 0x05, 0x05, 0x03, 0x06, 0x09, 0x09, 0x0c, 0x09, 0x03, 0x05, 0x05, 0x06, 0x06, 0x05, 0x06, 0x03,
	/*0048d0*/ 0x06, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x03, 0x03, 0x06, 0x06, 0x06,
	/*0048e0*/ 0x08, 0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x06, 0x08, 0x08, 0x08, 0x09, 0x08,
	/*0048f0*/ 0x08, 0x08, 0x08, 0x08, 0x08, 0x09, 0x08, 0x08, 0x09, 0x08, 0x08, 0x08, 0x05, 0x06, 0x05, 0x06,
	/*004900*/ 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x06, 0x08, 0x08, 0x03, 0x05, 0x08, 0x03, 0x09, 0x08, 0x08,
	/*004910*/ 0x08, 0x08, 0x08, 0x08, 0x06, 0x08, 0x08, 0x09, 0x08, 0x08, 0x08, 0x06, 0x03, 0x06, 0x08, 0x09,
	/*004920*/ 0x06, 0x00, 0x00, 0x00, 0x0d, 0x0d, 0x07, 0x00, 0x05, 0x05, 0x03, 0x07, 0x0a, 0x0a, 0x0d, 0x0a,
	/*004930*/ 0x03, 0x05, 0x05, 0x07, 0x07, 0x05, 0x07, 0x03, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/*004940*/ 0x08, 0x08, 0x08, 0x03, 0x03, 0x07, 0x07, 0x07, 0x08, 0x0a, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/*004950*/ 0x08, 0x08, 0x07, 0x08, 0x08, 0x08, 0x0a, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0a, 0x08, 0x08,
	/*004960*/ 0x0a, 0x08, 0x08, 0x08, 0x05, 0x07, 0x05, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07, 0x08,
	/*004970*/ 0x08, 0x03, 0x05, 0x08, 0x03, 0x0a, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07, 0x08, 0x08, 0x0a,
	/*004980*/ 0x08, 0x08, 0x08, 0x07, 0x03, 0x07, 0x08, 0x0a, 0x07, 0x00, 0x00, 0x00, 0x0e, 0x0e, 0x07, 0x00,
	/*004990*/ 0x05, 0x05, 0x04, 0x07, 0x0b, 0x0b, 0x0e, 0x0b, 0x04, 0x05, 0x05, 0x07, 0x07, 0x05, 0x07, 0x04,
	/*0049a0*/ 0x07, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x07, 0x07, 0x07,
	/*0049b0*/ 0x09, 0x0b, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x07, 0x09, 0x09, 0x09, 0x0b, 0x09,
	/*0049c0*/ 0x09, 0x09, 0x09, 0x09, 0x09, 0x0b, 0x09, 0x09, 0x0b, 0x09, 0x09, 0x09, 0x05, 0x07, 0x05, 0x07,
	/*0049d0*/ 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x07, 0x09, 0x09, 0x04, 0x05, 0x09, 0x04, 0x0b, 0x09, 0x09,
	/*0049e0*/ 0x09, 0x09, 0x09, 0x09, 0x07, 0x09, 0x09, 0x0b, 0x09, 0x09, 0x09, 0x07, 0x04, 0x07, 0x09, 0x0b,
	/*0049f0*/ 0x07, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x08, 0x00, 0x06, 0x06, 0x04, 0x08, 0x0b, 0x0b, 0x0f, 0x0b,
	/*004a00*/ 0x04, 0x06, 0x06, 0x08, 0x08, 0x06, 0x08, 0x04, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
	/*004a10*/ 0x09, 0x09, 0x09, 0x04, 0x04, 0x08, 0x08, 0x08, 0x09, 0x0b, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
	/*004a20*/ 0x09, 0x09, 0x08, 0x09, 0x09, 0x09, 0x0b, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0b, 0x09, 0x09,
	/*004a30*/ 0x0b, 0x09, 0x09, 0x09, 0x06, 0x08, 0x06, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09,
	/*004a40*/ 0x09, 0x04, 0x06, 0x09, 0x04, 0x0b, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 0x0b,
	/*004a50*/ 0x09, 0x09, 0x09, 0x08, 0x04, 0x08, 0x09, 0x0b, 0x08, 0x00, 0x00, 0x00, 0x10, 0x10, 0x08, 0x00,
	/*004a60*/ 0x06, 0x06, 0x04, 0x08, 0x0c, 0x0c, 0x10, 0x0c, 0x04, 0x06, 0x06, 0x08, 0x08, 0x06, 0x08, 0x04,
	/*004a70*/ 0x08, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x04, 0x04, 0x08, 0x08, 0x08,
	/*004a80*/ 0x0a, 0x0c, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x08, 0x0a, 0x0a, 0x0a, 0x0c, 0x0a,
	/*004a90*/ 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0c, 0x0a, 0x0a, 0x0c, 0x0a, 0x0a, 0x0a, 0x06, 0x08, 0x06, 0x08,
	/*004aa0*/ 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x08, 0x0a, 0x0a, 0x04, 0x06, 0x0a, 0x04, 0x0c, 0x0a, 0x0a,
	/*004ab0*/ 0x0a, 0x0a, 0x0a, 0x0a, 0x08, 0x0a, 0x0a, 0x0c, 0x0a, 0x0a, 0x0a, 0x08, 0x04, 0x08, 0x0a, 0x0c,
	/*004ac0*/ 0x08, 0x00, 0x00, 0x00, 0x11, 0x11, 0x09, 0x00, 0x06, 0x06, 0x04, 0x09, 0x0d, 0x0d, 0x11, 0x0d,
	/*004ad0*/ 0x04, 0x06, 0x06, 0x09, 0x09, 0x06, 0x09, 0x04, 0x09, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
	/*004ae0*/ 0x0b, 0x0b, 0x0b, 0x04, 0x04, 0x09, 0x09, 0x09, 0x0b, 0x0d, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
	/*004af0*/ 0x0b, 0x0b, 0x09, 0x0b, 0x0b, 0x0b, 0x0d, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0d, 0x0b, 0x0b,
	/*004b00*/ 0x0d, 0x0b, 0x0b, 0x0b, 0x06, 0x09, 0x06, 0x09, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x09, 0x0b,
	/*004b10*/ 0x0b, 0x04, 0x06, 0x0b, 0x04, 0x0d, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x09, 0x0b, 0x0b, 0x0d,
	/*004b20*/ 0x0b, 0x0b, 0x0b, 0x09, 0x04, 0x09, 0x0b, 0x0d, 0x09, 0x00, 0x00, 0x00, 0x12, 0x12, 0x09, 0x00,
	/*004b30*/ 0x07, 0x07, 0x05, 0x09, 0x0e, 0x0e, 0x12, 0x0e, 0x05, 0x07, 0x07, 0x09, 0x09, 0x07, 0x09, 0x05,
	/*004b40*/ 0x09, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x05, 0x05, 0x09, 0x09, 0x09,
	/*004b50*/ 0x0b, 0x0e, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x09, 0x0b, 0x0b, 0x0b, 0x0e, 0x0b,
	/*004b60*/ 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0e, 0x0b, 0x0b, 0x0e, 0x0b, 0x0b, 0x0b, 0x07, 0x09, 0x07, 0x09,
	/*004b70*/ 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x09, 0x0b, 0x0b, 0x05, 0x07, 0x0b, 0x05, 0x0e, 0x0b, 0x0b,
	/*004b80*/ 0x0b, 0x0b, 0x0b, 0x0b, 0x09, 0x0b, 0x0b, 0x0e, 0x0b, 0x0b, 0x0b, 0x09, 0x05, 0x09, 0x0b, 0x0e,
	/*004b90*/ 0x09, 0x00, 0x00, 0x00, 0x13, 0x13, 0x0a, 0x00, 0x07, 0x07, 0x05, 0x0a, 0x0e, 0x0e, 0x13, 0x0e,
	/*004ba0*/ 0x05, 0x07, 0x07, 0x0a, 0x0a, 0x07, 0x0a, 0x05, 0x0a, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	/*004bb0*/ 0x0c, 0x0c, 0x0c, 0x05, 0x05, 0x0a, 0x0a, 0x0a, 0x0c, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	/*004bc0*/ 0x0c, 0x0c, 0x0a, 0x0c, 0x0c, 0x0c, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0e, 0x0c, 0x0c,
	/*004bd0*/ 0x0e, 0x0c, 0x0c, 0x0c, 0x07, 0x0a, 0x07, 0x0a, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0a, 0x0c,
	/*004be0*/ 0x0c, 0x05, 0x07, 0x0c, 0x05, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0a, 0x0c, 0x0c, 0x0e,
	/*004bf0*/ 0x0c, 0x0c, 0x0c, 0x0a, 0x05, 0x0a, 0x0c, 0x0e, 0x0a, 0x00, 0x00, 0x00, 0x14, 0x14, 0x0a, 0x00,
	/*004c00*/ 0x08, 0x08, 0x05, 0x0a, 0x0f, 0x0f, 0x14, 0x0f, 0x05, 0x08, 0x08, 0x0a, 0x0a, 0x08, 0x0a, 0x05,
	/*004c10*/ 0x0a, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x05, 0x05, 0x0a, 0x0a, 0x0a,
	/*004c20*/ 0x0d, 0x0f, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0a, 0x0d, 0x0d, 0x0d, 0x0f, 0x0d,
	/*004c30*/ 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0f, 0x0d, 0x0d, 0x0f, 0x0d, 0x0d, 0x0d, 0x08, 0x0a, 0x08, 0x0a,
	/*004c40*/ 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0a, 0x0d, 0x0d, 0x05, 0x08, 0x0d, 0x05, 0x0f, 0x0d, 0x0d,
	/*004c50*/ 0x0d, 0x0d, 0x0d, 0x0d, 0x0a, 0x0d, 0x0d, 0x0f, 0x0d, 0x0d, 0x0d, 0x0a, 0x05, 0x0a, 0x0d, 0x0f,
	/*004c60*/ 0x0a, 0x00, 0x00, 0x00, 0x15, 0x15, 0x0b, 0x00, 0x08, 0x08, 0x05, 0x0b, 0x10, 0x10, 0x15, 0x10,
	/*004c70*/ 0x05, 0x08, 0x08, 0x0b, 0x0b, 0x08, 0x0b, 0x05, 0x0b, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
	/*004c80*/ 0x0d, 0x0d, 0x0d, 0x05, 0x05, 0x0b, 0x0b, 0x0b, 0x0d, 0x10, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
	/*004c90*/ 0x0d, 0x0d, 0x0b, 0x0d, 0x0d, 0x0d, 0x10, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x10, 0x0d, 0x0d,
	/*004ca0*/ 0x10, 0x0d, 0x0d, 0x0d, 0x08, 0x0b, 0x08, 0x0b, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0b, 0x0d,
	/*004cb0*/ 0x0d, 0x05, 0x08, 0x0d, 0x05, 0x10, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0b, 0x0d, 0x0d, 0x10,
	/*004cc0*/ 0x0d, 0x0d, 0x0d, 0x0b, 0x05, 0x0b, 0x0d, 0x10, 0x0b, 0x00, 0x00, 0x00, 0x16, 0x16, 0x0b, 0x00,
	/*004cd0*/ 0x08, 0x08, 0x06, 0x0b, 0x11, 0x11, 0x16, 0x11, 0x06, 0x08, 0x08, 0x0b, 0x0b, 0x08, 0x0b, 0x06,
	/*004ce0*/ 0x0b, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x06, 0x06, 0x0b, 0x0b, 0x0b,
	/*004cf0*/ 0x0e, 0x11, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0b, 0x0e, 0x0e, 0x0e, 0x11, 0x0e,
	/*004d00*/ 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x11, 0x0e, 0x0e, 0x11, 0x0e, 0x0e, 0x0e, 0x08, 0x0b, 0x08, 0x0b,
	/*004d10*/ 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0b, 0x0e, 0x0e, 0x06, 0x08, 0x0e, 0x06, 0x11, 0x0e, 0x0e,
	/*004d20*/ 0x0e, 0x0e, 0x0e, 0x0e, 0x0b, 0x0e, 0x0e, 0x11, 0x0e, 0x0e, 0x0e, 0x0b, 0x06, 0x0b, 0x0e, 0x11,
	/*004d30*/ 0x0b, 0x00, 0x00, 0x00, 0x17, 0x17, 0x0c, 0x00, 0x09, 0x09, 0x06, 0x0c, 0x11, 0x11, 0x17, 0x11,
	/*004d40*/ 0x06, 0x09, 0x09, 0x0c, 0x0c, 0x09, 0x0c, 0x06, 0x0c, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
	/*004d50*/ 0x0e, 0x0e, 0x0e, 0x06, 0x06, 0x0c, 0x0c, 0x0c, 0x0e, 0x11, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
	/*004d60*/ 0x0e, 0x0e, 0x0c, 0x0e, 0x0e, 0x0e, 0x11, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x11, 0x0e, 0x0e,
	/*004d70*/ 0x11, 0x0e, 0x0e, 0x0e, 0x09, 0x0c, 0x09, 0x0c, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0c, 0x0e,
	/*004d80*/ 0x0e, 0x06, 0x09, 0x0e, 0x06, 0x11, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0c, 0x0e, 0x0e, 0x11,
	/*004d90*/ 0x0e, 0x0e, 0x0e, 0x0c, 0x06, 0x0c, 0x0e, 0x11, 0x0c, 0x00, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x00,
	/*004da0*/ 0x09, 0x09, 0x06, 0x0c, 0x12, 0x12, 0x18, 0x12, 0x06, 0x09, 0x09, 0x0c, 0x0c, 0x09, 0x0c, 0x06,
	/*004db0*/ 0x0c, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x06, 0x06, 0x0c, 0x0c, 0x0c,
	/*004dc0*/ 0x0f, 0x12, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0c, 0x0f, 0x0f, 0x0f, 0x12, 0x0f,
	/*004dd0*/ 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x12, 0x0f, 0x0f, 0x12, 0x0f, 0x0f, 0x0f, 0x09, 0x0c, 0x09, 0x0c,
	/*004de0*/ 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0c, 0x0f, 0x0f, 0x06, 0x09, 0x0f, 0x06, 0x12, 0x0f, 0x0f,
	/*004df0*/ 0x0f, 0x0f, 0x0f, 0x0f, 0x0c, 0x0f, 0x0f, 0x12, 0x0f, 0x0f, 0x0f, 0x0c, 0x06, 0x0c, 0x0f, 0x12,
	/*004e00*/ 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xaf, 0x01, 0x90, 0x00, 0x05, 0x00, 0x01, 0x02, 0x30,
	/*004e10*/ 0x02, 0x08, 0x00, 0x00, 0x00, 0x72, 0x02, 0x30, 0x02, 0x08, 0x00, 0x00, 0x01, 0x6b, 0x00, 0x28,
	/*004e20*/ 0x00, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/*004e30*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x6c,
	/*004e40*/ 0x74, 0x73, 0x00, 0x40, 0x00, 0x20, 0x20, 0x10, 0x02, 0x58, 0xff, 0x38, 0x00, 0x00, 0x02, 0x58,
	/*004e50*/ 0x00, 0xc7, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xe3, 0xe5, 0x12, 0x31,
	/*004e60*/ 0x5f, 0x0f, 0x3c, 0xf5, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0xb6, 0x97, 0xc2, 0x82,
	/*004e70*/ 0x00, 0x00, 0x00, 0x00, 0xb6, 0x97, 0xc2, 0x82, 0x00, 0x00, 0xff, 0x39, 0x02, 0xbb, 0x02, 0x58,
	/*004e80*/ 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	/*004e90*/ 0x02, 0x58, 0xff, 0x38, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0x00, 0x32, 0x02, 0xbb, 0x00, 0x01,
	/*004ea0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63,
	/*004eb0*/ 0x00, 0x01, 0x00, 0x00, 0x00, 0x63, 0x00, 0x2c, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	/*004ec0*/ 0x00, 0x08, 0x00, 0x40, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x84, 0x00, 0xde, 0x00, 0x01, 0x00, 0x01
};
#line 0
#line 1 "sfw/render_core/font_data_tables.inc.h"

// font framework from FWK. original code by Vassvik (UNLICENSED)
// - rlyeh, public domain.

// The following data tables are coming from Dear Imgui.
// Re-licensed under permission as MIT-0.
//
// @todo: 0x3100, 0x312F, FONT_TW, // Bopomofo

static const unsigned table_common[] = {
	0x0020,
	0x00FF, // Basic Latin + Latin Supplement
	0xFFFD,
	0xFFFD, // Invalid
	0,
};

static const unsigned table_cyrillic[] = {
	0x0400,
	0x052F, // Cyrillic + Cyrillic Supplement
	0x2DE0,
	0x2DFF, // Cyrillic Extended-A
	0xA640,
	0xA69F, // Cyrillic Extended-B
	0,
};

static const unsigned table_vietnamese[] = {
	0x0102,
	0x0103,
	0x0110,
	0x0111,
	0x0128,
	0x0129,
	0x0168,
	0x0169,
	0x01A0,
	0x01A1,
	0x01AF,
	0x01B0,
	0x1EA0,
	0x1EF9,
	0,
};

static const unsigned table_thai[] = {
	0x0E00,
	0x0E7F, // Thai
	0x2010,
	0x205E, // General Punctuation (smaller set than full CJK 2000-206F)
	0,
};

static const unsigned table_korean[] = {
	0x1100,
	0x11FF, // Hangul Jamo
	0x3131,
	0x3163, // Korean alphabets (no 3130-318F?)
	0xAC00,
	0xD7A3, // Korean characters (no AC00-D7AF?)
	0,
};

static const unsigned table_chinese_punctuation[] = {
	0x2000,
	0x206F, // General CJK Punctuation (Thai uses 2010-205E)
	0,
};

static const unsigned table_chinese_japanese_common[] = {
	0x3000,
	0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
	0x31F0,
	0x31FF, // Katakana Phonetic Extensions
	0xFF00,
	0xFFEF, // Half-width characters (Romaji)
	0,
};

static const unsigned table_chinese_full[] = {
	0x4e00,
	0x9FAF, // CJK Ideograms
	0,
};

static const unsigned table_eastern_europe[] = {
	0x0100, 0x017F, // Latin_Extended-A
	0x0180, 0x024F, // Latin_Extended-B
	0x0250, 0x02AF, // International Phonetic Alphabet (IPA)
	0x02B0, 0x02FF, // Spacing modifier letters (and quotes)
	0x0300, 0x036F, // Fix IPA missing glyphs (?)
	0x16A0, 0x16F0, // Old Norse / Runic
	0x1E00, 0x1EFF, // Latin_Extended_Additional
	0x2000, 0x206F, // General punctuaction
	//  0x2C60, 0x2C7F, // Latin Extended-C (Uighur New Script, the Uralic Phonetic Alphabet, Shona, and Claudian Latin)
	0xFB00, 0xFB4F, // Ligatures for the Latin, Armenian, and Hebrew scripts
	0
};

static const unsigned table_western_europe[] = {
	0x0370, 0x03FF, // Greek and Coptic
	0x10A0, 0x10FF, // Modern Georgian, Svan, and Mingrelian
	0x1F00, 0x1FFF, // fix ancient greek glyphs (?)
	0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
	0x2DE0, 0x2DFF, // Cyrillic Extended-A
	0xA640, 0xA69F, // Cyrillic Extended-B
	0xFB00, 0xFB4F, // Ligatures for the Latin, Armenian, and Hebrew scripts
	0
};

static const unsigned table_middle_east[] = {
	0x0590, 0x05FF, // Hebrew, Yiddish, Ladino, and other Jewish diaspora languages.
	0x0600, 0x06FF, // Arabic script and Arabic-Indic digits
	0xFB00, 0xFB4F, // Ligatures for the Latin, Armenian, and Hebrew scripts
	0
};

static const unsigned table_emoji[] = {
	//  0xE000, 0xEB4C, // Private use (emojis)
	0xE000, 0xF68B, // Private use (emojis+webfonts). U+F68C excluded
	0xF68D, 0xF8FF, // Private use (emojis+webfonts)
	0xF0001, 0xF1CC7, // Private use (icon mdi)
	0
};

// Store 2500 regularly used characters for Simplified Chinese. Table below covers 97.97% of all characters used during the month in July, 1987.
// [ref] https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
static const unsigned short packed_table_chinese[] = { // starts with 0x4E00
	0, 1, 2, 4, 1, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 1, 1, 1, 1, 1, 5, 2, 1, 2, 3, 3, 3, 2, 2, 4, 1, 1, 1, 2, 1, 5, 2, 3, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 4, 1, 1, 1, 1, 5, 10, 1, 2, 19, 2, 1, 2, 1, 2, 1, 2, 1, 2,
	1, 5, 1, 6, 3, 2, 1, 2, 2, 1, 1, 1, 4, 8, 5, 1, 1, 4, 1, 1, 3, 1, 2, 1, 5, 1, 2, 1, 1, 1, 10, 1, 1, 5, 2, 4, 6, 1, 4, 2, 2, 2, 12, 2, 1, 1, 6, 1, 1, 1, 4, 1, 1, 4, 6, 5, 1, 4, 2, 2, 4, 10, 7, 1, 1, 4, 2, 4,
	2, 1, 4, 3, 6, 10, 12, 5, 7, 2, 14, 2, 9, 1, 1, 6, 7, 10, 4, 7, 13, 1, 5, 4, 8, 4, 1, 1, 2, 28, 5, 6, 1, 1, 5, 2, 5, 20, 2, 2, 9, 8, 11, 2, 9, 17, 1, 8, 6, 8, 27, 4, 6, 9, 20, 11, 27, 6, 68, 2, 2, 1, 1,
	1, 2, 1, 2, 2, 7, 6, 11, 3, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 8, 3, 4, 1, 5, 7, 2, 1, 4, 4, 8, 4, 2, 1, 2, 1, 1, 4, 5, 6, 3, 6, 2, 12, 3, 1, 3, 9, 2, 4, 3, 4, 1, 5, 3, 3, 1, 3, 7, 1, 5, 1, 1, 1, 1, 2,
	3, 4, 5, 2, 3, 2, 6, 1, 1, 2, 1, 7, 1, 7, 3, 4, 5, 15, 2, 2, 1, 5, 3, 22, 19, 2, 1, 1, 1, 1, 2, 5, 1, 1, 1, 6, 1, 1, 12, 8, 2, 9, 18, 22, 4, 1, 1, 5, 1, 16, 1, 2, 7, 10, 15, 1, 1, 6, 2, 4, 1, 2, 4, 1, 6,
	1, 1, 3, 2, 4, 1, 6, 4, 5, 1, 2, 1, 1, 2, 1, 10, 3, 1, 3, 2, 1, 9, 3, 2, 5, 7, 2, 19, 4, 3, 6, 1, 1, 1, 1, 1, 4, 3, 2, 1, 1, 1, 2, 5, 3, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 3, 1, 1, 1, 3, 7, 1, 4, 1, 1, 2, 1,
	1, 2, 1, 2, 4, 4, 3, 8, 1, 1, 1, 2, 1, 3, 5, 1, 3, 1, 3, 4, 6, 2, 2, 14, 4, 6, 6, 11, 9, 1, 15, 3, 1, 28, 5, 2, 5, 5, 3, 1, 3, 4, 5, 4, 6, 14, 3, 2, 3, 5, 21, 2, 7, 20, 10, 1, 2, 19, 2, 4, 28, 28, 2, 3,
	2, 1, 14, 4, 1, 26, 28, 42, 12, 40, 3, 52, 79, 5, 14, 17, 3, 2, 2, 11, 3, 4, 6, 3, 1, 8, 2, 23, 4, 5, 8, 10, 4, 2, 7, 3, 5, 1, 1, 6, 3, 1, 2, 2, 2, 5, 28, 1, 1, 7, 7, 20, 5, 3, 29, 3, 17, 26, 1, 8, 4,
	27, 3, 6, 11, 23, 5, 3, 4, 6, 13, 24, 16, 6, 5, 10, 25, 35, 7, 3, 2, 3, 3, 14, 3, 6, 2, 6, 1, 4, 2, 3, 8, 2, 1, 1, 3, 3, 3, 4, 1, 1, 13, 2, 2, 4, 5, 2, 1, 14, 14, 1, 2, 2, 1, 4, 5, 2, 3, 1, 14, 3, 12,
	3, 17, 2, 16, 5, 1, 2, 1, 8, 9, 3, 19, 4, 2, 2, 4, 17, 25, 21, 20, 28, 75, 1, 10, 29, 103, 4, 1, 2, 1, 1, 4, 2, 4, 1, 2, 3, 24, 2, 2, 2, 1, 1, 2, 1, 3, 8, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 6, 1, 5, 3, 1, 1,
	1, 3, 4, 1, 1, 5, 2, 1, 5, 6, 13, 9, 16, 1, 1, 1, 1, 3, 2, 3, 2, 4, 5, 2, 5, 2, 2, 3, 7, 13, 7, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 1, 6, 4, 9, 2, 1, 14, 2, 14, 2, 1, 18, 3, 4, 14, 4, 11, 41, 15, 23, 15, 23,
	176, 1, 3, 4, 1, 1, 1, 1, 5, 3, 1, 2, 3, 7, 3, 1, 1, 2, 1, 2, 4, 4, 6, 2, 4, 1, 9, 7, 1, 10, 5, 8, 16, 29, 1, 1, 2, 2, 3, 1, 3, 5, 2, 4, 5, 4, 1, 1, 2, 2, 3, 3, 7, 1, 6, 10, 1, 17, 1, 44, 4, 6, 2, 1, 1, 6,
	5, 4, 2, 10, 1, 6, 9, 2, 8, 1, 24, 1, 2, 13, 7, 8, 8, 2, 1, 4, 1, 3, 1, 3, 3, 5, 2, 5, 10, 9, 4, 9, 12, 2, 1, 6, 1, 10, 1, 1, 7, 7, 4, 10, 8, 3, 1, 13, 4, 3, 1, 6, 1, 3, 5, 2, 1, 2, 17, 16, 5, 2, 16, 6,
	1, 4, 2, 1, 3, 3, 6, 8, 5, 11, 11, 1, 3, 3, 2, 4, 6, 10, 9, 5, 7, 4, 7, 4, 7, 1, 1, 4, 2, 1, 3, 6, 8, 7, 1, 6, 11, 5, 5, 3, 24, 9, 4, 2, 7, 13, 5, 1, 8, 82, 16, 61, 1, 1, 1, 4, 2, 2, 16, 10, 3, 8, 1, 1,
	6, 4, 2, 1, 3, 1, 1, 1, 4, 3, 8, 4, 2, 2, 1, 1, 1, 1, 1, 6, 3, 5, 1, 1, 4, 6, 9, 2, 1, 1, 1, 2, 1, 7, 2, 1, 6, 1, 5, 4, 4, 3, 1, 8, 1, 3, 3, 1, 3, 2, 2, 2, 2, 3, 1, 6, 1, 2, 1, 2, 1, 3, 7, 1, 8, 2, 1, 2, 1, 5,
	2, 5, 3, 5, 10, 1, 2, 1, 1, 3, 2, 5, 11, 3, 9, 3, 5, 1, 1, 5, 9, 1, 2, 1, 5, 7, 9, 9, 8, 1, 3, 3, 3, 6, 8, 2, 3, 2, 1, 1, 32, 6, 1, 2, 15, 9, 3, 7, 13, 1, 3, 10, 13, 2, 14, 1, 13, 10, 2, 1, 3, 10, 4, 15,
	2, 15, 15, 10, 1, 3, 9, 6, 9, 32, 25, 26, 47, 7, 3, 2, 3, 1, 6, 3, 4, 3, 2, 8, 5, 4, 1, 9, 4, 2, 2, 19, 10, 6, 2, 3, 8, 1, 2, 2, 4, 2, 1, 9, 4, 4, 4, 6, 4, 8, 9, 2, 3, 1, 1, 1, 1, 3, 5, 5, 1, 3, 8, 4, 6,
	2, 1, 4, 12, 1, 5, 3, 7, 13, 2, 5, 8, 1, 6, 1, 2, 5, 14, 6, 1, 5, 2, 4, 8, 15, 5, 1, 23, 6, 62, 2, 10, 1, 1, 8, 1, 2, 2, 10, 4, 2, 2, 9, 2, 1, 1, 3, 2, 3, 1, 5, 3, 3, 2, 1, 3, 8, 1, 1, 1, 11, 3, 1, 1, 4,
	3, 7, 1, 14, 1, 2, 3, 12, 5, 2, 5, 1, 6, 7, 5, 7, 14, 11, 1, 3, 1, 8, 9, 12, 2, 1, 11, 8, 4, 4, 2, 6, 10, 9, 13, 1, 1, 3, 1, 5, 1, 3, 2, 4, 4, 1, 18, 2, 3, 14, 11, 4, 29, 4, 2, 7, 1, 3, 13, 9, 2, 2, 5,
	3, 5, 20, 7, 16, 8, 5, 72, 34, 6, 4, 22, 12, 12, 28, 45, 36, 9, 7, 39, 9, 191, 1, 1, 1, 4, 11, 8, 4, 9, 2, 3, 22, 1, 1, 1, 1, 4, 17, 1, 7, 7, 1, 11, 31, 10, 2, 4, 8, 2, 3, 2, 1, 4, 2, 16, 4, 32, 2,
	3, 19, 13, 4, 9, 1, 5, 2, 14, 8, 1, 1, 3, 6, 19, 6, 5, 1, 16, 6, 2, 10, 8, 5, 1, 2, 3, 1, 5, 5, 1, 11, 6, 6, 1, 3, 3, 2, 6, 3, 8, 1, 1, 4, 10, 7, 5, 7, 7, 5, 8, 9, 2, 1, 3, 4, 1, 1, 3, 1, 3, 3, 2, 6, 16,
	1, 4, 6, 3, 1, 10, 6, 1, 3, 15, 2, 9, 2, 10, 25, 13, 9, 16, 6, 2, 2, 10, 11, 4, 3, 9, 1, 2, 6, 6, 5, 4, 30, 40, 1, 10, 7, 12, 14, 33, 6, 3, 6, 7, 3, 1, 3, 1, 11, 14, 4, 9, 5, 12, 11, 49, 18, 51, 31,
	140, 31, 2, 2, 1, 5, 1, 8, 1, 10, 1, 4, 4, 3, 24, 1, 10, 1, 3, 6, 6, 16, 3, 4, 5, 2, 1, 4, 2, 57, 10, 6, 22, 2, 22, 3, 7, 22, 6, 10, 11, 36, 18, 16, 33, 36, 2, 5, 5, 1, 1, 1, 4, 10, 1, 4, 13, 2, 7,
	5, 2, 9, 3, 4, 1, 7, 43, 3, 7, 3, 9, 14, 7, 9, 1, 11, 1, 1, 3, 7, 4, 18, 13, 1, 14, 1, 3, 6, 10, 73, 2, 2, 30, 6, 1, 11, 18, 19, 13, 22, 3, 46, 42, 37, 89, 7, 3, 16, 34, 2, 2, 3, 9, 1, 7, 1, 1, 1, 2,
	2, 4, 10, 7, 3, 10, 3, 9, 5, 28, 9, 2, 6, 13, 7, 3, 1, 3, 10, 2, 7, 2, 11, 3, 6, 21, 54, 85, 2, 1, 4, 2, 2, 1, 39, 3, 21, 2, 2, 5, 1, 1, 1, 4, 1, 1, 3, 4, 15, 1, 3, 2, 4, 4, 2, 3, 8, 2, 20, 1, 8, 7, 13,
	4, 1, 26, 6, 2, 9, 34, 4, 21, 52, 10, 4, 4, 1, 5, 12, 2, 11, 1, 7, 2, 30, 12, 44, 2, 30, 1, 1, 3, 6, 16, 9, 17, 39, 82, 2, 2, 24, 7, 1, 7, 3, 16, 9, 14, 44, 2, 1, 2, 1, 2, 3, 5, 2, 4, 1, 6, 7, 5, 3,
	2, 6, 1, 11, 5, 11, 2, 1, 18, 19, 8, 1, 3, 24, 29, 2, 1, 3, 5, 2, 2, 1, 13, 6, 5, 1, 46, 11, 3, 5, 1, 1, 5, 8, 2, 10, 6, 12, 6, 3, 7, 11, 2, 4, 16, 13, 2, 5, 1, 1, 2, 2, 5, 2, 28, 5, 2, 23, 10, 8, 4,
	4, 22, 39, 95, 38, 8, 14, 9, 5, 1, 13, 5, 4, 3, 13, 12, 11, 1, 9, 1, 27, 37, 2, 5, 4, 4, 63, 211, 95, 2, 2, 2, 1, 3, 5, 2, 1, 1, 2, 2, 1, 1, 1, 3, 2, 4, 1, 2, 1, 1, 5, 2, 2, 1, 1, 2, 3, 1, 3, 1, 1, 1,
	3, 1, 4, 2, 1, 3, 6, 1, 1, 3, 7, 15, 5, 3, 2, 5, 3, 9, 11, 4, 2, 22, 1, 6, 3, 8, 7, 1, 4, 28, 4, 16, 3, 3, 25, 4, 4, 27, 27, 1, 4, 1, 2, 2, 7, 1, 3, 5, 2, 28, 8, 2, 14, 1, 8, 6, 16, 25, 3, 3, 3, 14, 3,
	3, 1, 1, 2, 1, 4, 6, 3, 8, 4, 1, 1, 1, 2, 3, 6, 10, 6, 2, 3, 18, 3, 2, 5, 5, 4, 3, 1, 5, 2, 5, 4, 23, 7, 6, 12, 6, 4, 17, 11, 9, 5, 1, 1, 10, 5, 12, 1, 1, 11, 26, 33, 7, 3, 6, 1, 17, 7, 1, 5, 12, 1, 11,
	2, 4, 1, 8, 14, 17, 23, 1, 2, 1, 7, 8, 16, 11, 9, 6, 5, 2, 6, 4, 16, 2, 8, 14, 1, 11, 8, 9, 1, 1, 1, 9, 25, 4, 11, 19, 7, 2, 15, 2, 12, 8, 52, 7, 5, 19, 2, 16, 4, 36, 8, 1, 16, 8, 24, 26, 4, 6, 2, 9,
	5, 4, 36, 3, 28, 12, 25, 15, 37, 27, 17, 12, 59, 38, 5, 32, 127, 1, 2, 9, 17, 14, 4, 1, 2, 1, 1, 8, 11, 50, 4, 14, 2, 19, 16, 4, 17, 5, 4, 5, 26, 12, 45, 2, 23, 45, 104, 30, 12, 8, 3, 10, 2, 2,
	3, 3, 1, 4, 20, 7, 2, 9, 6, 15, 2, 20, 1, 3, 16, 4, 11, 15, 6, 134, 2, 5, 59, 1, 2, 2, 2, 1, 9, 17, 3, 26, 137, 10, 211, 59, 1, 2, 4, 1, 4, 1, 1, 1, 2, 6, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 4, 4, 2, 3, 3,
	1, 4, 3, 1, 7, 2, 2, 3, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 1, 3, 14, 6, 1, 3, 2, 9, 6, 15, 27, 9, 34, 145, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 3, 1, 2, 1, 1, 1, 2, 3, 5, 8, 3, 5, 2, 4, 1, 3, 2, 2, 2, 12,
	4, 1, 1, 1, 10, 4, 5, 1, 20, 4, 16, 1, 15, 9, 5, 12, 2, 9, 2, 5, 4, 2, 26, 19, 7, 1, 26, 4, 30, 12, 15, 42, 1, 6, 8, 172, 1, 1, 4, 2, 1, 1, 11, 2, 2, 4, 2, 1, 2, 1, 10, 8, 1, 2, 1, 4, 5, 1, 2, 5, 1, 8,
	4, 1, 3, 4, 2, 1, 6, 2, 1, 3, 4, 1, 2, 1, 1, 1, 1, 12, 5, 7, 2, 4, 3, 1, 1, 1, 3, 3, 6, 1, 2, 2, 3, 3, 3, 2, 1, 2, 12, 14, 11, 6, 6, 4, 12, 2, 8, 1, 7, 10, 1, 35, 7, 4, 13, 15, 4, 3, 23, 21, 28, 52, 5,
	26, 5, 6, 1, 7, 10, 2, 7, 53, 3, 2, 1, 1, 1, 2, 163, 532, 1, 10, 11, 1, 3, 3, 4, 8, 2, 8, 6, 2, 2, 23, 22, 4, 2, 2, 4, 2, 1, 3, 1, 3, 3, 5, 9, 8, 2, 1, 2, 8, 1, 10, 2, 12, 21, 20, 15, 105, 2, 3, 1, 1,
	3, 2, 3, 1, 1, 2, 5, 1, 4, 15, 11, 19, 1, 1, 1, 1, 5, 4, 5, 1, 1, 2, 5, 3, 5, 12, 1, 2, 5, 1, 11, 1, 1, 15, 9, 1, 4, 5, 3, 26, 8, 2, 1, 3, 1, 1, 15, 19, 2, 12, 1, 2, 5, 2, 7, 2, 19, 2, 20, 6, 26, 7, 5,
	2, 2, 7, 34, 21, 13, 70, 2, 128, 1, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 2, 15, 1, 4, 1, 3, 4, 42, 10, 6, 1, 49, 85, 8, 1, 2, 1, 1, 4, 4, 2, 3, 6, 1, 5, 7, 4, 3, 211, 4, 1, 2, 1, 2, 5, 1, 2, 4, 2, 2, 6, 5, 6,
	10, 3, 4, 48, 100, 6, 2, 16, 296, 5, 27, 387, 2, 2, 3, 7, 16, 8, 5, 38, 15, 39, 21, 9, 10, 3, 7, 59, 13, 27, 21, 47, 5, 21, 6
};

// 2999 japanese ideograms = 2136 Joyo (for common use) + 863 Jinmeiyo (for personal name) Kanji code points.
// [ref] https://github.com/ocornut/imgui/pull/3627 - Missing 1 Joyo Kanji: U+20B9F (Kun'yomi: Shikaru, On'yomi: Shitsu,shichi).
static const unsigned short packed_table_japanese[] = {
	// starts with 0x4E00
	0,
	1,
	2,
	4,
	1,
	1,
	1,
	1,
	2,
	1,
	3,
	3,
	2,
	2,
	1,
	5,
	3,
	5,
	7,
	5,
	6,
	1,
	2,
	1,
	7,
	2,
	6,
	3,
	1,
	8,
	1,
	1,
	4,
	1,
	1,
	18,
	2,
	11,
	2,
	6,
	2,
	1,
	2,
	1,
	5,
	1,
	2,
	1,
	3,
	1,
	2,
	1,
	2,
	3,
	3,
	1,
	1,
	2,
	3,
	1,
	1,
	1,
	12,
	7,
	9,
	1,
	4,
	5,
	1,
	1,
	2,
	1,
	10,
	1,
	1,
	9,
	2,
	2,
	4,
	5,
	6,
	9,
	3,
	1,
	1,
	1,
	1,
	9,
	3,
	18,
	5,
	2,
	2,
	2,
	2,
	1,
	6,
	3,
	7,
	1,
	1,
	1,
	1,
	2,
	2,
	4,
	2,
	1,
	23,
	2,
	10,
	4,
	3,
	5,
	2,
	4,
	10,
	2,
	4,
	13,
	1,
	6,
	1,
	9,
	3,
	1,
	1,
	6,
	6,
	7,
	6,
	3,
	1,
	2,
	11,
	3,
	2,
	2,
	3,
	2,
	15,
	2,
	2,
	5,
	4,
	3,
	6,
	4,
	1,
	2,
	5,
	2,
	12,
	16,
	6,
	13,
	9,
	13,
	2,
	1,
	1,
	7,
	16,
	4,
	7,
	1,
	19,
	1,
	5,
	1,
	2,
	2,
	7,
	7,
	8,
	2,
	6,
	5,
	4,
	9,
	18,
	7,
	4,
	5,
	9,
	13,
	11,
	8,
	15,
	2,
	1,
	1,
	1,
	2,
	1,
	2,
	2,
	1,
	2,
	2,
	8,
	2,
	9,
	3,
	3,
	1,
	1,
	4,
	4,
	1,
	1,
	1,
	4,
	9,
	1,
	4,
	3,
	5,
	5,
	2,
	7,
	5,
	3,
	4,
	8,
	2,
	1,
	13,
	2,
	3,
	3,
	1,
	14,
	1,
	1,
	4,
	5,
	1,
	3,
	6,
	1,
	5,
	2,
	1,
	1,
	3,
	3,
	3,
	3,
	1,
	1,
	2,
	7,
	6,
	6,
	7,
	1,
	4,
	7,
	6,
	1,
	1,
	1,
	1,
	1,
	12,
	3,
	3,
	9,
	5,
	2,
	6,
	1,
	5,
	6,
	1,
	2,
	3,
	18,
	2,
	4,
	14,
	4,
	1,
	3,
	6,
	1,
	1,
	6,
	3,
	5,
	5,
	3,
	2,
	2,
	2,
	2,
	12,
	3,
	1,
	4,
	2,
	3,
	2,
	3,
	11,
	1,
	7,
	4,
	1,
	2,
	1,
	3,
	17,
	1,
	9,
	1,
	24,
	1,
	1,
	4,
	2,
	2,
	4,
	1,
	2,
	7,
	1,
	1,
	1,
	3,
	1,
	2,
	2,
	4,
	15,
	1,
	1,
	2,
	1,
	1,
	2,
	1,
	5,
	2,
	5,
	20,
	2,
	5,
	9,
	1,
	10,
	8,
	7,
	6,
	1,
	1,
	1,
	1,
	1,
	1,
	6,
	2,
	1,
	2,
	8,
	1,
	1,
	1,
	1,
	5,
	1,
	1,
	3,
	1,
	1,
	1,
	1,
	3,
	1,
	1,
	12,
	4,
	1,
	3,
	1,
	1,
	1,
	1,
	1,
	10,
	3,
	1,
	7,
	5,
	13,
	1,
	2,
	3,
	4,
	6,
	1,
	1,
	30,
	2,
	9,
	9,
	1,
	15,
	38,
	11,
	3,
	1,
	8,
	24,
	7,
	1,
	9,
	8,
	10,
	2,
	1,
	9,
	31,
	2,
	13,
	6,
	2,
	9,
	4,
	49,
	5,
	2,
	15,
	2,
	1,
	10,
	2,
	1,
	1,
	1,
	2,
	2,
	6,
	15,
	30,
	35,
	3,
	14,
	18,
	8,
	1,
	16,
	10,
	28,
	12,
	19,
	45,
	38,
	1,
	3,
	2,
	3,
	13,
	2,
	1,
	7,
	3,
	6,
	5,
	3,
	4,
	3,
	1,
	5,
	7,
	8,
	1,
	5,
	3,
	18,
	5,
	3,
	6,
	1,
	21,
	4,
	24,
	9,
	24,
	40,
	3,
	14,
	3,
	21,
	3,
	2,
	1,
	2,
	4,
	2,
	3,
	1,
	15,
	15,
	6,
	5,
	1,
	1,
	3,
	1,
	5,
	6,
	1,
	9,
	7,
	3,
	3,
	2,
	1,
	4,
	3,
	8,
	21,
	5,
	16,
	4,
	5,
	2,
	10,
	11,
	11,
	3,
	6,
	3,
	2,
	9,
	3,
	6,
	13,
	1,
	2,
	1,
	1,
	1,
	1,
	11,
	12,
	6,
	6,
	1,
	4,
	2,
	6,
	5,
	2,
	1,
	1,
	3,
	3,
	6,
	13,
	3,
	1,
	1,
	5,
	1,
	2,
	3,
	3,
	14,
	2,
	1,
	2,
	2,
	2,
	5,
	1,
	9,
	5,
	1,
	1,
	6,
	12,
	3,
	12,
	3,
	4,
	13,
	2,
	14,
	2,
	8,
	1,
	17,
	5,
	1,
	16,
	4,
	2,
	2,
	21,
	8,
	9,
	6,
	23,
	20,
	12,
	25,
	19,
	9,
	38,
	8,
	3,
	21,
	40,
	25,
	33,
	13,
	4,
	3,
	1,
	4,
	1,
	2,
	4,
	1,
	2,
	5,
	26,
	2,
	1,
	1,
	2,
	1,
	3,
	6,
	2,
	1,
	1,
	1,
	1,
	1,
	1,
	2,
	3,
	1,
	1,
	1,
	9,
	2,
	3,
	1,
	1,
	1,
	3,
	6,
	3,
	2,
	1,
	1,
	6,
	6,
	1,
	8,
	2,
	2,
	2,
	1,
	4,
	1,
	2,
	3,
	2,
	7,
	3,
	2,
	4,
	1,
	2,
	1,
	2,
	2,
	1,
	1,
	1,
	1,
	1,
	3,
	1,
	2,
	5,
	4,
	10,
	9,
	4,
	9,
	1,
	1,
	1,
	1,
	1,
	1,
	5,
	3,
	2,
	1,
	6,
	4,
	9,
	6,
	1,
	10,
	2,
	31,
	17,
	8,
	3,
	7,
	5,
	40,
	1,
	7,
	7,
	1,
	6,
	5,
	2,
	10,
	7,
	8,
	4,
	15,
	39,
	25,
	6,
	28,
	47,
	18,
	10,
	7,
	1,
	3,
	1,
	1,
	2,
	1,
	1,
	1,
	3,
	3,
	3,
	1,
	1,
	1,
	3,
	4,
	2,
	1,
	4,
	1,
	3,
	6,
	10,
	7,
	8,
	6,
	2,
	2,
	1,
	3,
	3,
	2,
	5,
	8,
	7,
	9,
	12,
	2,
	15,
	1,
	1,
	4,
	1,
	2,
	1,
	1,
	1,
	3,
	2,
	1,
	3,
	3,
	5,
	6,
	2,
	3,
	2,
	10,
	1,
	4,
	2,
	8,
	1,
	1,
	1,
	11,
	6,
	1,
	21,
	4,
	16,
	3,
	1,
	3,
	1,
	4,
	2,
	3,
	6,
	5,
	1,
	3,
	1,
	1,
	3,
	3,
	4,
	6,
	1,
	1,
	10,
	4,
	2,
	7,
	10,
	4,
	7,
	4,
	2,
	9,
	4,
	3,
	1,
	1,
	1,
	4,
	1,
	8,
	3,
	4,
	1,
	3,
	1,
	6,
	1,
	4,
	2,
	1,
	4,
	7,
	2,
	1,
	8,
	1,
	4,
	5,
	1,
	1,
	2,
	2,
	4,
	6,
	2,
	7,
	1,
	10,
	1,
	1,
	3,
	4,
	11,
	10,
	8,
	21,
	4,
	6,
	1,
	3,
	5,
	2,
	1,
	2,
	28,
	5,
	5,
	2,
	3,
	13,
	1,
	2,
	3,
	1,
	4,
	2,
	1,
	5,
	20,
	3,
	8,
	11,
	1,
	3,
	3,
	3,
	1,
	8,
	10,
	9,
	2,
	10,
	9,
	2,
	3,
	1,
	1,
	2,
	4,
	1,
	8,
	3,
	6,
	1,
	7,
	8,
	6,
	11,
	1,
	4,
	29,
	8,
	4,
	3,
	1,
	2,
	7,
	13,
	1,
	4,
	1,
	6,
	2,
	6,
	12,
	12,
	2,
	20,
	3,
	2,
	3,
	6,
	4,
	8,
	9,
	2,
	7,
	34,
	5,
	1,
	18,
	6,
	1,
	1,
	4,
	4,
	5,
	7,
	9,
	1,
	2,
	2,
	4,
	3,
	4,
	1,
	7,
	2,
	2,
	2,
	6,
	2,
	3,
	25,
	5,
	3,
	6,
	1,
	4,
	6,
	7,
	4,
	2,
	1,
	4,
	2,
	13,
	6,
	4,
	4,
	3,
	1,
	5,
	3,
	4,
	4,
	3,
	2,
	1,
	1,
	4,
	1,
	2,
	1,
	1,
	3,
	1,
	11,
	1,
	6,
	3,
	1,
	7,
	3,
	6,
	2,
	8,
	8,
	6,
	9,
	3,
	4,
	11,
	3,
	2,
	10,
	12,
	2,
	5,
	11,
	1,
	6,
	4,
	5,
	3,
	1,
	8,
	5,
	4,
	6,
	6,
	3,
	5,
	1,
	1,
	3,
	2,
	1,
	2,
	2,
	6,
	17,
	12,
	1,
	10,
	1,
	6,
	12,
	1,
	6,
	6,
	19,
	9,
	6,
	16,
	1,
	13,
	4,
	4,
	15,
	7,
	17,
	6,
	11,
	9,
	15,
	12,
	6,
	7,
	2,
	1,
	2,
	2,
	15,
	9,
	3,
	21,
	4,
	6,
	49,
	18,
	7,
	3,
	2,
	3,
	1,
	6,
	8,
	2,
	2,
	6,
	2,
	9,
	1,
	3,
	6,
	4,
	4,
	1,
	2,
	16,
	2,
	5,
	2,
	1,
	6,
	2,
	3,
	5,
	3,
	1,
	2,
	5,
	1,
	2,
	1,
	9,
	3,
	1,
	8,
	6,
	4,
	8,
	11,
	3,
	1,
	1,
	1,
	1,
	3,
	1,
	13,
	8,
	4,
	1,
	3,
	2,
	2,
	1,
	4,
	1,
	11,
	1,
	5,
	2,
	1,
	5,
	2,
	5,
	8,
	6,
	1,
	1,
	7,
	4,
	3,
	8,
	3,
	2,
	7,
	2,
	1,
	5,
	1,
	5,
	2,
	4,
	7,
	6,
	2,
	8,
	5,
	1,
	11,
	4,
	5,
	3,
	6,
	18,
	1,
	2,
	13,
	3,
	3,
	1,
	21,
	1,
	1,
	4,
	1,
	4,
	1,
	1,
	1,
	8,
	1,
	2,
	2,
	7,
	1,
	2,
	4,
	2,
	2,
	9,
	2,
	1,
	1,
	1,
	4,
	3,
	6,
	3,
	12,
	5,
	1,
	1,
	1,
	5,
	6,
	3,
	2,
	4,
	8,
	2,
	2,
	4,
	2,
	7,
	1,
	8,
	9,
	5,
	2,
	3,
	2,
	1,
	3,
	2,
	13,
	7,
	14,
	6,
	5,
	1,
	1,
	2,
	1,
	4,
	2,
	23,
	2,
	1,
	1,
	6,
	3,
	1,
	4,
	1,
	15,
	3,
	1,
	7,
	3,
	9,
	14,
	1,
	3,
	1,
	4,
	1,
	1,
	5,
	8,
	1,
	3,
	8,
	3,
	8,
	15,
	11,
	4,
	14,
	4,
	4,
	2,
	5,
	5,
	1,
	7,
	1,
	6,
	14,
	7,
	7,
	8,
	5,
	15,
	4,
	8,
	6,
	5,
	6,
	2,
	1,
	13,
	1,
	20,
	15,
	11,
	9,
	2,
	5,
	6,
	2,
	11,
	2,
	6,
	2,
	5,
	1,
	5,
	8,
	4,
	13,
	19,
	25,
	4,
	1,
	1,
	11,
	1,
	34,
	2,
	5,
	9,
	14,
	6,
	2,
	2,
	6,
	1,
	1,
	14,
	1,
	3,
	14,
	13,
	1,
	6,
	12,
	21,
	14,
	14,
	6,
	32,
	17,
	8,
	32,
	9,
	28,
	1,
	2,
	4,
	11,
	8,
	3,
	1,
	14,
	2,
	5,
	15,
	1,
	1,
	1,
	1,
	3,
	6,
	4,
	1,
	3,
	4,
	11,
	3,
	1,
	1,
	11,
	30,
	1,
	5,
	1,
	4,
	1,
	5,
	8,
	1,
	1,
	3,
	2,
	4,
	3,
	17,
	35,
	2,
	6,
	12,
	17,
	3,
	1,
	6,
	2,
	1,
	1,
	12,
	2,
	7,
	3,
	3,
	2,
	1,
	16,
	2,
	8,
	3,
	6,
	5,
	4,
	7,
	3,
	3,
	8,
	1,
	9,
	8,
	5,
	1,
	2,
	1,
	3,
	2,
	8,
	1,
	2,
	9,
	12,
	1,
	1,
	2,
	3,
	8,
	3,
	24,
	12,
	4,
	3,
	7,
	5,
	8,
	3,
	3,
	3,
	3,
	3,
	3,
	1,
	23,
	10,
	3,
	1,
	2,
	2,
	6,
	3,
	1,
	16,
	1,
	16,
	22,
	3,
	10,
	4,
	11,
	6,
	9,
	7,
	7,
	3,
	6,
	2,
	2,
	2,
	4,
	10,
	2,
	1,
	1,
	2,
	8,
	7,
	1,
	6,
	4,
	1,
	3,
	3,
	3,
	5,
	10,
	12,
	12,
	2,
	3,
	12,
	8,
	15,
	1,
	1,
	16,
	6,
	6,
	1,
	5,
	9,
	11,
	4,
	11,
	4,
	2,
	6,
	12,
	1,
	17,
	5,
	13,
	1,
	4,
	9,
	5,
	1,
	11,
	2,
	1,
	8,
	1,
	5,
	7,
	28,
	8,
	3,
	5,
	10,
	2,
	17,
	3,
	38,
	22,
	1,
	2,
	18,
	12,
	10,
	4,
	38,
	18,
	1,
	4,
	44,
	19,
	4,
	1,
	8,
	4,
	1,
	12,
	1,
	4,
	31,
	12,
	1,
	14,
	7,
	75,
	7,
	5,
	10,
	6,
	6,
	13,
	3,
	2,
	11,
	11,
	3,
	2,
	5,
	28,
	15,
	6,
	18,
	18,
	5,
	6,
	4,
	3,
	16,
	1,
	7,
	18,
	7,
	36,
	3,
	5,
	3,
	1,
	7,
	1,
	9,
	1,
	10,
	7,
	2,
	4,
	2,
	6,
	2,
	9,
	7,
	4,
	3,
	32,
	12,
	3,
	7,
	10,
	2,
	23,
	16,
	3,
	1,
	12,
	3,
	31,
	4,
	11,
	1,
	3,
	8,
	9,
	5,
	1,
	30,
	15,
	6,
	12,
	3,
	2,
	2,
	11,
	19,
	9,
	14,
	2,
	6,
	2,
	3,
	19,
	13,
	17,
	5,
	3,
	3,
	25,
	3,
	14,
	1,
	1,
	1,
	36,
	1,
	3,
	2,
	19,
	3,
	13,
	36,
	9,
	13,
	31,
	6,
	4,
	16,
	34,
	2,
	5,
	4,
	2,
	3,
	3,
	5,
	1,
	1,
	1,
	4,
	3,
	1,
	17,
	3,
	2,
	3,
	5,
	3,
	1,
	3,
	2,
	3,
	5,
	6,
	3,
	12,
	11,
	1,
	3,
	1,
	2,
	26,
	7,
	12,
	7,
	2,
	14,
	3,
	3,
	7,
	7,
	11,
	25,
	25,
	28,
	16,
	4,
	36,
	1,
	2,
	1,
	6,
	2,
	1,
	9,
	3,
	27,
	17,
	4,
	3,
	4,
	13,
	4,
	1,
	3,
	2,
	2,
	1,
	10,
	4,
	2,
	4,
	6,
	3,
	8,
	2,
	1,
	18,
	1,
	1,
	24,
	2,
	2,
	4,
	33,
	2,
	3,
	63,
	7,
	1,
	6,
	40,
	7,
	3,
	4,
	4,
	2,
	4,
	15,
	18,
	1,
	16,
	1,
	1,
	11,
	2,
	41,
	14,
	1,
	3,
	18,
	13,
	3,
	2,
	4,
	16,
	2,
	17,
	7,
	15,
	24,
	7,
	18,
	13,
	44,
	2,
	2,
	3,
	6,
	1,
	1,
	7,
	5,
	1,
	7,
	1,
	4,
	3,
	3,
	5,
	10,
	8,
	2,
	3,
	1,
	8,
	1,
	1,
	27,
	4,
	2,
	1,
	12,
	1,
	2,
	1,
	10,
	6,
	1,
	6,
	7,
	5,
	2,
	3,
	7,
	11,
	5,
	11,
	3,
	6,
	6,
	2,
	3,
	15,
	4,
	9,
	1,
	1,
	2,
	1,
	2,
	11,
	2,
	8,
	12,
	8,
	5,
	4,
	2,
	3,
	1,
	5,
	2,
	2,
	1,
	14,
	1,
	12,
	11,
	4,
	1,
	11,
	17,
	17,
	4,
	3,
	2,
	5,
	5,
	7,
	3,
	1,
	5,
	9,
	9,
	8,
	2,
	5,
	6,
	6,
	13,
	13,
	2,
	1,
	2,
	6,
	1,
	2,
	2,
	49,
	4,
	9,
	1,
	2,
	10,
	16,
	7,
	8,
	4,
	3,
	2,
	23,
	4,
	58,
	3,
	29,
	1,
	14,
	19,
	19,
	11,
	11,
	2,
	7,
	5,
	1,
	3,
	4,
	6,
	2,
	18,
	5,
	12,
	12,
	17,
	17,
	3,
	3,
	2,
	4,
	1,
	6,
	2,
	3,
	4,
	3,
	1,
	1,
	1,
	1,
	5,
	1,
	1,
	9,
	1,
	3,
	1,
	3,
	6,
	1,
	8,
	1,
	1,
	2,
	6,
	4,
	14,
	3,
	1,
	4,
	11,
	4,
	1,
	3,
	32,
	1,
	2,
	4,
	13,
	4,
	1,
	2,
	4,
	2,
	1,
	3,
	1,
	11,
	1,
	4,
	2,
	1,
	4,
	4,
	6,
	3,
	5,
	1,
	6,
	5,
	7,
	6,
	3,
	23,
	3,
	5,
	3,
	5,
	3,
	3,
	13,
	3,
	9,
	10,
	1,
	12,
	10,
	2,
	3,
	18,
	13,
	7,
	160,
	52,
	4,
	2,
	2,
	3,
	2,
	14,
	5,
	4,
	12,
	4,
	6,
	4,
	1,
	20,
	4,
	11,
	6,
	2,
	12,
	27,
	1,
	4,
	1,
	2,
	2,
	7,
	4,
	5,
	2,
	28,
	3,
	7,
	25,
	8,
	3,
	19,
	3,
	6,
	10,
	2,
	2,
	1,
	10,
	2,
	5,
	4,
	1,
	3,
	4,
	1,
	5,
	3,
	2,
	6,
	9,
	3,
	6,
	2,
	16,
	3,
	3,
	16,
	4,
	5,
	5,
	3,
	2,
	1,
	2,
	16,
	15,
	8,
	2,
	6,
	21,
	2,
	4,
	1,
	22,
	5,
	8,
	1,
	1,
	21,
	11,
	2,
	1,
	11,
	11,
	19,
	13,
	12,
	4,
	2,
	3,
	2,
	3,
	6,
	1,
	8,
	11,
	1,
	4,
	2,
	9,
	5,
	2,
	1,
	11,
	2,
	9,
	1,
	1,
	2,
	14,
	31,
	9,
	3,
	4,
	21,
	14,
	4,
	8,
	1,
	7,
	2,
	2,
	2,
	5,
	1,
	4,
	20,
	3,
	3,
	4,
	10,
	1,
	11,
	9,
	8,
	2,
	1,
	4,
	5,
	14,
	12,
	14,
	2,
	17,
	9,
	6,
	31,
	4,
	14,
	1,
	20,
	13,
	26,
	5,
	2,
	7,
	3,
	6,
	13,
	2,
	4,
	2,
	19,
	6,
	2,
	2,
	18,
	9,
	3,
	5,
	12,
	12,
	14,
	4,
	6,
	2,
	3,
	6,
	9,
	5,
	22,
	4,
	5,
	25,
	6,
	4,
	8,
	5,
	2,
	6,
	27,
	2,
	35,
	2,
	16,
	3,
	7,
	8,
	8,
	6,
	6,
	5,
	9,
	17,
	2,
	20,
	6,
	19,
	2,
	13,
	3,
	1,
	1,
	1,
	4,
	17,
	12,
	2,
	14,
	7,
	1,
	4,
	18,
	12,
	38,
	33,
	2,
	10,
	1,
	1,
	2,
	13,
	14,
	17,
	11,
	50,
	6,
	33,
	20,
	26,
	74,
	16,
	23,
	45,
	50,
	13,
	38,
	33,
	6,
	6,
	7,
	4,
	4,
	2,
	1,
	3,
	2,
	5,
	8,
	7,
	8,
	9,
	3,
	11,
	21,
	9,
	13,
	1,
	3,
	10,
	6,
	7,
	1,
	2,
	2,
	18,
	5,
	5,
	1,
	9,
	9,
	2,
	68,
	9,
	19,
	13,
	2,
	5,
	1,
	4,
	4,
	7,
	4,
	13,
	3,
	9,
	10,
	21,
	17,
	3,
	26,
	2,
	1,
	5,
	2,
	4,
	5,
	4,
	1,
	7,
	4,
	7,
	3,
	4,
	2,
	1,
	6,
	1,
	1,
	20,
	4,
	1,
	9,
	2,
	2,
	1,
	3,
	3,
	2,
	3,
	2,
	1,
	1,
	1,
	20,
	2,
	3,
	1,
	6,
	2,
	3,
	6,
	2,
	4,
	8,
	1,
	3,
	2,
	10,
	3,
	5,
	3,
	4,
	4,
	3,
	4,
	16,
	1,
	6,
	1,
	10,
	2,
	4,
	2,
	1,
	1,
	2,
	10,
	11,
	2,
	2,
	3,
	1,
	24,
	31,
	4,
	10,
	10,
	2,
	5,
	12,
	16,
	164,
	15,
	4,
	16,
	7,
	9,
	15,
	19,
	17,
	1,
	2,
	1,
	1,
	5,
	1,
	1,
	1,
	1,
	1,
	3,
	1,
	4,
	3,
	1,
	3,
	1,
	3,
	1,
	2,
	1,
	1,
	3,
	3,
	7,
	2,
	8,
	1,
	2,
	2,
	2,
	1,
	3,
	4,
	3,
	7,
	8,
	12,
	92,
	2,
	10,
	3,
	1,
	3,
	14,
	5,
	25,
	16,
	42,
	4,
	7,
	7,
	4,
	2,
	21,
	5,
	27,
	26,
	27,
	21,
	25,
	30,
	31,
	2,
	1,
	5,
	13,
	3,
	22,
	5,
	6,
	6,
	11,
	9,
	12,
	1,
	5,
	9,
	7,
	5,
	5,
	22,
	60,
	3,
	5,
	13,
	1,
	1,
	8,
	1,
	1,
	3,
	3,
	2,
	1,
	9,
	3,
	3,
	18,
	4,
	1,
	2,
	3,
	7,
	6,
	3,
	1,
	2,
	3,
	9,
	1,
	3,
	1,
	3,
	2,
	1,
	3,
	1,
	1,
	1,
	2,
	1,
	11,
	3,
	1,
	6,
	9,
	1,
	3,
	2,
	3,
	1,
	2,
	1,
	5,
	1,
	1,
	4,
	3,
	4,
	1,
	2,
	2,
	4,
	4,
	1,
	7,
	2,
	1,
	2,
	2,
	3,
	5,
	13,
	18,
	3,
	4,
	14,
	9,
	9,
	4,
	16,
	3,
	7,
	5,
	8,
	2,
	6,
	48,
	28,
	3,
	1,
	1,
	4,
	2,
	14,
	8,
	2,
	9,
	2,
	1,
	15,
	2,
	4,
	3,
	2,
	10,
	16,
	12,
	8,
	7,
	1,
	1,
	3,
	1,
	1,
	1,
	2,
	7,
	4,
	1,
	6,
	4,
	38,
	39,
	16,
	23,
	7,
	15,
	15,
	3,
	2,
	12,
	7,
	21,
	37,
	27,
	6,
	5,
	4,
	8,
	2,
	10,
	8,
	8,
	6,
	5,
	1,
	2,
	1,
	3,
	24,
	1,
	16,
	17,
	9,
	23,
	10,
	17,
	6,
	1,
	51,
	55,
	44,
	13,
	294,
	9,
	3,
	6,
	2,
	4,
	2,
	2,
	15,
	1,
	1,
	1,
	13,
	21,
	17,
	68,
	14,
	8,
	9,
	4,
	1,
	4,
	9,
	3,
	11,
	7,
	1,
	1,
	1,
	5,
	6,
	3,
	2,
	1,
	1,
	1,
	2,
	3,
	8,
	1,
	2,
	2,
	4,
	1,
	5,
	5,
	2,
	1,
	4,
	3,
	7,
	13,
	4,
	1,
	4,
	1,
	3,
	1,
	1,
	1,
	5,
	5,
	10,
	1,
	6,
	1,
	5,
	2,
	1,
	5,
	2,
	4,
	1,
	4,
	5,
	7,
	3,
	18,
	2,
	9,
	11,
	32,
	4,
	3,
	3,
	2,
	4,
	7,
	11,
	16,
	9,
	11,
	8,
	13,
	38,
	32,
	8,
	4,
	2,
	1,
	1,
	2,
	1,
	2,
	4,
	4,
	1,
	1,
	1,
	4,
	1,
	21,
	3,
	11,
	1,
	16,
	1,
	1,
	6,
	1,
	3,
	2,
	4,
	9,
	8,
	57,
	7,
	44,
	1,
	3,
	3,
	13,
	3,
	10,
	1,
	1,
	7,
	5,
	2,
	7,
	21,
	47,
	63,
	3,
	15,
	4,
	7,
	1,
	16,
	1,
	1,
	2,
	8,
	2,
	3,
	42,
	15,
	4,
	1,
	29,
	7,
	22,
	10,
	3,
	78,
	16,
	12,
	20,
	18,
	4,
	67,
	11,
	5,
	1,
	3,
	15,
	6,
	21,
	31,
	32,
	27,
	18,
	13,
	71,
	35,
	5,
	142,
	4,
	10,
	1,
	2,
	50,
	19,
	33,
	16,
	35,
	37,
	16,
	19,
	27,
	7,
	1,
	133,
	19,
	1,
	4,
	8,
	7,
	20,
	1,
	4,
	4,
	1,
	10,
	3,
	1,
	6,
	1,
	2,
	51,
	5,
	40,
	15,
	24,
	43,
	22928,
	11,
	1,
	13,
	154,
	70,
	3,
	1,
	1,
	7,
	4,
	10,
	1,
	2,
	1,
	1,
	2,
	1,
	2,
	1,
	2,
	2,
	1,
	1,
	2,
	1,
	1,
	1,
	1,
	1,
	2,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	2,
	1,
	1,
	1,
	3,
	2,
	1,
	1,
	1,
	1,
	2,
	1,
	1,
};
#line 0

#line 1 "sfw/render_core/frame_buffer.cpp"

int FrameBuffer::get_texture_flags() const {
	return _texture_flags;
}

void FrameBuffer::set_texture_flags(const int p_flags) {
	_texture_flags = p_flags;
}

int FrameBuffer::create(const int p_width, const int p_height, const int p_msaa_count) {
	ERR_FAIL_COND_V(p_width <= 0, -1);
	ERR_FAIL_COND_V(p_height <= 0, -1);
	ERR_FAIL_COND_V(p_msaa_count < 0, -1);

	int max_msaa_levels = 0;
	glGetIntegerv(GL_MAX_SAMPLES, &max_msaa_levels);

	int msaa = MIN(max_msaa_levels, p_msaa_count);

	if (msaa % 2 == 0) {
		--msaa;
	}

	destroy();

	_fbo_width = p_width;
	_fbo_height = p_height;
	_fbo_msaa_count = msaa;

	glGenFramebuffers(1, &_fbo);
	glBindFramebuffer(GL_FRAMEBUFFER, _fbo);

	glGenTextures(1, &_texture);
	glBindTexture(GL_TEXTURE_2D, _texture);

	if ((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_MIP_MAPS)) {
		if ((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_FILTER)) {
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		} else {
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
		}
	} else {
		if ((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_FILTER)) {
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		} else {
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		}
	}

	if ((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_FILTER)) {
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Linear Filtering
	} else {
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); // raw Filtering
	}

	if ((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_REPEAT) || (_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_MIRRORED_REPEAT)) {
		if (_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_MIRRORED_REPEAT) {
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
		} else {
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		}
	} else {
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	}

	glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, ((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_MIP_MAPS) > 0) ? GL_TRUE : GL_FALSE);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, _fbo_width, _fbo_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _texture, 0);

	int status = get_status();

	if (status != GL_FRAMEBUFFER_COMPLETE) {
		glBindRenderbuffer(GL_RENDERBUFFER, 0);
		glBindTexture(GL_TEXTURE_2D, 0);
		glBindFramebuffer(GL_FRAMEBUFFER, 0);

		return status;
	}

	if (_fbo_msaa_count > 0) {
		glGenFramebuffers(1, &_msaa_fbo);
		glBindFramebuffer(GL_FRAMEBUFFER, _msaa_fbo);

		glGenRenderbuffers(1, &_msaa_rbo_color);
		glBindRenderbuffer(GL_RENDERBUFFER, _msaa_rbo_color);
		glRenderbufferStorageMultisample(GL_RENDERBUFFER, _fbo_msaa_count, GL_RGBA8, _fbo_width, _fbo_height);

		glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _msaa_rbo_color);

		glGenRenderbuffers(1, &_msaa_rbo_depth);
		glBindRenderbuffer(GL_RENDERBUFFER, _msaa_rbo_depth);
		glRenderbufferStorageMultisample(GL_RENDERBUFFER, _fbo_msaa_count, GL_DEPTH_COMPONENT, _fbo_width, _fbo_height);

		glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _msaa_rbo_depth);

		status = get_status();
	}

	glBindRenderbuffer(GL_RENDERBUFFER, 0);
	glBindTexture(GL_TEXTURE_2D, 0);
	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	return status;
}

void FrameBuffer::destroy() {
	if (!_fbo) {
		return;
	}

	if (_msaa_rbo_color) {
		glDeleteRenderbuffers(1, &_msaa_rbo_color);
		_msaa_rbo_color = 0;
	}

	if (_msaa_rbo_depth) {
		glDeleteRenderbuffers(1, &_msaa_rbo_depth);
		_msaa_rbo_depth = 0;
	}

	if (_msaa_fbo) {
		glDeleteFramebuffers(1, &_msaa_fbo);
		_msaa_fbo = 0;
	}

	if (_texture) {
		glDeleteTextures(1, &_texture);
		_texture = 0;
	}

	if (_rbo) {
		glDeleteRenderbuffers(1, &_rbo);
		_rbo = 0;
	}

	if (_fbo) {
		glDeleteFramebuffers(1, &_fbo);
		_fbo = 0;
	}
}

int FrameBuffer::get_status() {
	GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);

	return status;
}

uint32_t FrameBuffer::get_gl_fbo() {
	if (!_msaa_fbo) {
		return _fbo;
	}

	return _msaa_fbo;
}

uint32_t FrameBuffer::get_gl_texture() {
	return _texture;
}

void FrameBuffer::bind() {
	glBindFramebuffer(GL_FRAMEBUFFER, get_gl_fbo());
}
void FrameBuffer::unbind() {
	glBindFramebuffer(GL_FRAMEBUFFER, 0);
}
void FrameBuffer::update() {
	if (_fbo_msaa_count > 0) {
		glBindFramebuffer(GL_READ_FRAMEBUFFER, _msaa_fbo);
		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, _fbo);
		glBlitFramebuffer(0, 0, _fbo_width, _fbo_height, 0, 0, _fbo_width, _fbo_height, GL_COLOR_BUFFER_BIT, GL_LINEAR);
		glBlitFramebuffer(0, 0, _fbo_width, _fbo_height, 0, 0, _fbo_width, _fbo_height, GL_DEPTH_BUFFER_BIT, GL_NEAREST);
	}

	if (((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_MIP_MAPS) > 0)) {
		glBindTexture(GL_TEXTURE_2D, _texture);
		glGenerateMipmap(GL_TEXTURE_2D);
		glBindTexture(GL_TEXTURE_2D, 0);
	}
}

Ref<Image> FrameBuffer::get_image_color() {
	Ref<Image> img;
	img.instance();

	Vector<uint8_t> cb = get_color_buffer();

	img->create(_fbo_width, _fbo_height, false, Image::FORMAT_RGBA8, cb);

	if (((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_MIP_MAPS) > 0)) {
		img->generate_mipmaps();
	}

	return img;
}
Ref<Image> FrameBuffer::get_image_depth() {
	Ref<Image> img;
	img.instance();

	Vector<float> db = get_depth_buffer();

	img->create(_fbo_width, _fbo_height, false, Image::FORMAT_RF);

	ERR_FAIL_COND_V(db.size() * (int)sizeof(float) != img->get_data_size(), img);

	const float *db_ptr = db.ptr();
	float *ifptr = (float *)img->dataw();
	int db_size = db.size();
	for (int i = 0; i < db_size; ++i) {
		ifptr[i] = db_ptr[i];
	}

	if (((_texture_flags & FRAMEBUFFER_TEXTURE_FLAG_MIP_MAPS) > 0)) {
		img->generate_mipmaps();
	}

	return img;
}
Vector<uint8_t> FrameBuffer::get_color_buffer() {
	Vector<uint8_t> color_buffer;
	color_buffer.resize(_fbo_width * _fbo_height * 4);

	if (_fbo_msaa_count > 0) {
		blit_color_to(_fbo);
	}

	glBindFramebuffer(GL_READ_FRAMEBUFFER, _fbo);
	glReadPixels(0, 0, _fbo_width, _fbo_height, GL_RGBA, GL_UNSIGNED_BYTE, color_buffer.ptrw());

	return color_buffer;
}
Vector<float> FrameBuffer::get_depth_buffer() {
	Vector<float> depth_buffer;
	depth_buffer.resize(_fbo_width * _fbo_height);

	if (_fbo_msaa_count > 0) {
		blit_depth_to(_fbo);
	}

	glBindFramebuffer(GL_READ_FRAMEBUFFER, _fbo);
	glReadPixels(0, 0, _fbo_width, _fbo_height, GL_DEPTH_COMPONENT, GL_FLOAT, depth_buffer.ptrw());

	return depth_buffer;
}

Vector2i FrameBuffer::get_size() const {
	return Vector2i(_fbo_width, _fbo_height);
}

void FrameBuffer::blit_color_to(const uint32_t p_destination_framebuffer, const Rect2i &p_rect) {
	ERR_FAIL_COND(!p_destination_framebuffer);

	int width = p_rect.size.width == 0 ? _fbo_width : p_rect.size.width;
	int height = p_rect.size.height == 0 ? _fbo_height : p_rect.size.height;

	uint32_t fbo = get_gl_fbo();

	glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo);
	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, p_destination_framebuffer);
	glBlitFramebuffer(0, 0, _fbo_width, _fbo_height, p_rect.position.x, p_rect.position.y, width, height, GL_COLOR_BUFFER_BIT, GL_LINEAR);
}

void FrameBuffer::blit_depth_to(const uint32_t p_destination_framebuffer, const Rect2i &p_rect) {
	ERR_FAIL_COND(!p_destination_framebuffer);

	int width = p_rect.size.width == 0 ? _fbo_width : p_rect.size.width;
	int height = p_rect.size.height == 0 ? _fbo_height : p_rect.size.height;

	uint32_t fbo = get_gl_fbo();

	glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo);
	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, p_destination_framebuffer);
	glBlitFramebuffer(0, 0, _fbo_width, _fbo_height, p_rect.position.x, p_rect.position.y, width, height, GL_DEPTH_BUFFER_BIT, GL_NEAREST);
}

void FrameBuffer::set_as_viewport() {
	RenderState::current_framebuffer = Ref<FrameBuffer>(this);
	RenderState::render_rect = Rect2i(0, 0, _fbo_width, _fbo_height);
	RenderState::apply_render_rect();
}

void FrameBuffer::reset_as_viewport() {
	RenderState::current_framebuffer.unref();
	RenderState::render_rect = Rect2i(0, 0, AppWindow::get_singleton()->get_width(), AppWindow::get_singleton()->get_height());
	RenderState::apply_render_rect();
}

float FrameBuffer::get_aspect() const {
	return _fbo_width / (float)_fbo_height;
}

FrameBuffer::FrameBuffer() {
	_texture = 0;

	_msaa_fbo = 0;
	_msaa_rbo_color = 0;
	_msaa_rbo_depth = 0;

	_fbo_width = 0;
	_fbo_height = 0;
	_fbo_msaa_count = 0;

	_rbo = 0;
	_fbo = 0;
	_texture_flags = 0;
}

FrameBuffer::~FrameBuffer() {
	destroy();
}
#line 0

#line 1 "sfw/render_core/texture.cpp"

void Texture::create_from_image(const Ref<Image> &img) {
	if (_image == img) {
		return;
	}

	_image = img;

	_texture_width = 0;
	_texture_height = 0;

	if (!_image.is_valid()) {
		if (_texture) {
			glDeleteTextures(1, &_texture);
			_texture = 0;
		}

		return;
	}

	upload();
}

Ref<Image> Texture::get_data() {
	ERR_FAIL_COND_V(!_texture, Ref<Image>());
	ERR_FAIL_COND_V(_data_size == 0, Ref<Image>());

	//GLES

	uint32_t gl_format;
	uint32_t gl_internal_format;
	uint32_t gl_type;
	bool supported;
	_get_gl_format(_texture_format, gl_format, gl_internal_format, gl_type, supported);

	if (!supported) {
		return Ref<Image>();
	}

	Vector<uint8_t> data;

	int data_size = Image::get_image_data_size(_texture_width, _texture_height, _texture_format, _mipmaps > 1);

	data.resize(data_size * 2); //add some memory at the end, just in case for buggy drivers
	uint8_t *wb = data.ptrw();

	glActiveTexture(GL_TEXTURE0);

	glBindTexture(GL_TEXTURE_2D, _texture);
	glBindBuffer(GL_PIXEL_PACK_BUFFER, 0);

	for (int i = 0; i < _mipmaps; i++) {
		int ofs = Image::get_image_mipmap_offset(_texture_width, _texture_height, _texture_format, i);

		glPixelStorei(GL_PACK_ALIGNMENT, 1);
		glGetTexImage(GL_TEXTURE_2D, i, gl_format, gl_type, &wb[ofs]);
	}

	data.resize(data_size);

	Image *img = memnew(Image(_texture_width, _texture_height, _mipmaps > 1, _texture_format, data));

	return Ref<Image>(img);
}

Vector2i Texture::get_size() const {
	return Vector2i(_texture_width, _texture_height);
}

void Texture::upload() {
	if (!_image.is_valid()) {
		return;
	}

	uint32_t gl_format;
	uint32_t gl_internal_format;
	uint32_t gl_type;
	bool supported;
	Image::Format image_format = _image->get_format();
	_get_gl_format(image_format, gl_format, gl_internal_format, gl_type, supported);

	if (!supported) {
		return;
	}

	_data_size = _image->get_data().size();
	_texture_format = image_format;
	Vector<uint8_t> image_data = _image->get_data();

	if (image_data.size() == 0) {
		return;
	}

	const uint8_t *read = image_data.ptr();
	ERR_FAIL_COND(!read);

	if (!_texture) {
		glGenTextures(1, &_texture);
	}

	glActiveTexture(GL_TEXTURE0 + _texture_index);

	uint32_t texture_type = GL_TEXTURE_2D;

	glBindTexture(texture_type, _texture);

	int mipmaps = ((_flags & TEXTURE_FLAG_MIP_MAPS) && _image->has_mipmaps()) ? _image->get_mipmap_count() + 1 : 1;

	if (mipmaps > 1) {
		if ((_flags & TEXTURE_FLAG_FILTER)) {
			glTexParameteri(texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		} else {
			glTexParameteri(texture_type, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
		}
	} else {
		if ((_flags & TEXTURE_FLAG_FILTER)) {
			glTexParameteri(texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		} else {
			glTexParameteri(texture_type, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		}
	}

	if ((_flags & TEXTURE_FLAG_FILTER)) {
		glTexParameteri(texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Linear Filtering
	} else {
		glTexParameteri(texture_type, GL_TEXTURE_MAG_FILTER, GL_NEAREST); // raw Filtering
	}

	if ((_flags & TEXTURE_FLAG_REPEAT) || (_flags & TEXTURE_FLAG_MIRRORED_REPEAT)) {
		if (_flags & TEXTURE_FLAG_MIRRORED_REPEAT) {
			glTexParameterf(texture_type, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
			glTexParameterf(texture_type, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
		} else {
			glTexParameterf(texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT);
			glTexParameterf(texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT);
		}
	} else {
		glTexParameterf(texture_type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameterf(texture_type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	}

	_texture_width = _image->get_width();
	_texture_height = _image->get_height();

	int w = _texture_width;
	int h = _texture_height;

	int tsize = 0;

	for (int i = 0; i < mipmaps; i++) {
		int size;
		int ofs;
		_image->get_mipmap_offset_and_size(i, ofs, size);

		glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
		glTexImage2D(texture_type, i, gl_internal_format, w, h, 0, gl_format, gl_type, &read[ofs]);

		tsize += size;

		w = MAX(1, w >> 1);
		h = MAX(1, h >> 1);
	}

	if (mipmaps > 1) {
		//generate mipmaps if they were requested and the image does not contain them
		glGenerateMipmap(texture_type);
	}

	_mipmaps = mipmaps;

	glBindTexture(texture_type, 0);
}

void Texture::_get_gl_format(Image::Format p_format, uint32_t &r_gl_format, uint32_t &r_gl_internal_format, uint32_t &r_gl_type, bool &r_supported) const {
	r_gl_format = 0;
	r_supported = true;

	switch (p_format) {
		case Image::FORMAT_L8: {
			r_gl_internal_format = GL_LUMINANCE;
			r_gl_format = GL_LUMINANCE;
			r_gl_type = GL_UNSIGNED_BYTE;
		} break;
		case Image::FORMAT_LA8: {
			r_gl_internal_format = GL_LUMINANCE_ALPHA;
			r_gl_format = GL_LUMINANCE_ALPHA;
			r_gl_type = GL_UNSIGNED_BYTE;
		} break;
		case Image::FORMAT_R8: {
			r_gl_internal_format = GL_ALPHA;
			r_gl_format = GL_ALPHA;
			r_gl_type = GL_UNSIGNED_BYTE;

		} break;
		case Image::FORMAT_RG8: {
			ERR_PRINT("RG texture not supported! Convert it to to RGB8.");

			r_supported = false;
		} break;
		case Image::FORMAT_RGB8: {
			r_gl_internal_format = GL_RGB;
			r_gl_format = GL_RGB;
			r_gl_type = GL_UNSIGNED_BYTE;

		} break;
		case Image::FORMAT_RGBA8: {
			r_gl_format = GL_RGBA;
			r_gl_internal_format = GL_RGBA;
			r_gl_type = GL_UNSIGNED_BYTE;

		} break;
		case Image::FORMAT_RGBA4444: {
			r_gl_internal_format = GL_RGBA;
			r_gl_format = GL_RGBA;
			r_gl_type = GL_UNSIGNED_SHORT_4_4_4_4;

		} break;
		case Image::FORMAT_RGBA5551: {
			r_gl_internal_format = GL_RGB5_A1;
			r_gl_format = GL_RGBA;
			r_gl_type = GL_UNSIGNED_SHORT_5_5_5_1;

		} break;
		case Image::FORMAT_RF: {
			r_gl_internal_format = GL_ALPHA;
			r_gl_format = GL_ALPHA;
			r_gl_type = GL_FLOAT;
		} break;
		case Image::FORMAT_RGF: {
			ERR_PRINT("RG float texture not supported! Convert it to RGB8.");
			r_supported = false;
		} break;
		case Image::FORMAT_RGBF: {
			r_gl_internal_format = GL_RGB;
			r_gl_format = GL_RGB;
			r_gl_type = GL_FLOAT;
		} break;
		case Image::FORMAT_RGBAF: {
			r_gl_internal_format = GL_RGBA;
			r_gl_format = GL_RGBA;
			r_gl_type = GL_FLOAT;
		} break;
		default: {
			r_supported = false;
			ERR_FAIL_COND(true);
		}
	}
}

Texture::Texture() {
	_texture = 0;
	_texture_width = 0;
	_texture_height = 0;
	_mipmaps = 1;
	_data_size = 0;
	_texture_index = 0;
	_flags = 0;

	_texture_format = Image::FORMAT_RGBA8;
}

Texture::~Texture() {
	if (_texture) {
		glDeleteTextures(1, &_texture);
	}
}

//RenderTexture

bool RenderTexture::get_v_flip() const {
	return _v_flip;
}
void RenderTexture::set_v_flip(const bool p_v_flip) {
	_v_flip = p_v_flip;
}

RenderTexture::RenderTextureType RenderTexture::get_type() const {
	return _type;
}
void RenderTexture::set_type(const RenderTextureType p_type) {
	_type = p_type;
}

Ref<FrameBuffer> RenderTexture::get_frame_buffer() const {
	return _frame_buffer;
}
void RenderTexture::set_frame_buffer(const Ref<FrameBuffer> &p_frame_buffer) {
	_frame_buffer = p_frame_buffer;
}

void RenderTexture::update() {
	if (!_frame_buffer.is_valid()) {
		return;
	}

	_frame_buffer->update();

	Ref<Image> img;

	switch (_type) {
		case RENDER_TEXTURE_TYPE_COLOR:
			img = _frame_buffer->get_image_color();

			if (_v_flip) {
				img->flip_y();
			}

			create_from_image(img);

			break;
		case RENDER_TEXTURE_TYPE_DEPTH:
			img = _frame_buffer->get_image_depth();

			if (_v_flip) {
				img->flip_y();
			}

			create_from_image(img);

			break;
		default:
			break;
	}
}

RenderTexture::RenderTexture() {
	_type = RENDER_TEXTURE_TYPE_COLOR;
	_v_flip = true;
}

RenderTexture::~RenderTexture() {
	_frame_buffer.unref();
}
#line 0

#line 1 "sfw/render_core/application.cpp"

void Application::input_event(const Ref<InputEvent> &event) {
	ERR_FAIL_COND(scene.is_null());

	scene->input_event(event);
}

void Application::update(float delta) {
	ERR_FAIL_COND(scene.is_null());

	scene->update(delta);
}

void Application::render() {
	ERR_FAIL_COND(scene.is_null());

	scene->render();
}

void Application::start_main_loop() {
#ifdef __EMSCRIPTEN__
	emscripten_set_main_loop(&Application::main_loop_static, 0, 1);
#else
	while (running) {
		main_loop();
	}
#endif // __EMSCRIPTEN__
}

void Application::main_loop() {
	uint64_t start = SFWTime::time_us();

	AppWindow *w = AppWindow::get_singleton();

	if (!w->frame_begin()) { // calls Application::main_loop()
		running = false;
		return;
	}

	//handle input
	Input::get_singleton()->iteration(frame_delta);

	//update_world
	update(frame_delta);

	//render
	render();

	uint64_t end = SFWTime::time_us();

	uint64_t elapsed_us = end - start;

	double elapsed_seconds = USEC_TO_SEC(elapsed_us);

	double tfpss = 1.0 / static_cast<double>(target_fps);
	double remaining = tfpss - elapsed_seconds;

	if (remaining > 0) {
		SFWTime::sleep_us(SEC_TO_USEC(remaining));

		end = SFWTime::time_us();
		elapsed_us = end - start;
		elapsed_seconds = USEC_TO_SEC(elapsed_us);
	}

	frame_delta = elapsed_seconds;
	frame_delta *= _time_scale;
	++_idle_frames;

	w->frame_end();
	w->frame_swap();
}

void Application::_init_window() {
	AppWindow::get_singleton()->create(false, 1, 0);
}

Application::Application() {
	_instance = this;

	running = true;
	target_fps = 60;

	frame_delta = 0;

	_time_scale = 1;

	SFWCore::setup();

	// TODO Move these to a central place in core!

	CoreStringNames::create();

	// TODO add a helper static method
	memnew(AppWindow());
	memnew(InputMap());
	memnew(Input());
	Input::get_singleton()->set_main_loop(this);

	_init_window();
}
Application::~Application() {
	_instance = NULL;

	// TODO Move these to a central place in core!

	CoreStringNames::free();

	// TODO add a helper static method
	memdelete(AppWindow::get_singleton());
	memdelete(Input::get_singleton());
	memdelete(InputMap::get_singleton());

	SFWCore::cleanup();
}

Application *Application::get_singleton() {
	return _instance;
}

Application *Application::_instance = NULL;
#line 0

#line 1 "sfw/render_core/shader.cpp"

bool Shader::bind() {
	if (current_shader != this) {
		glUseProgram(program);

		current_shader = this;

		return true;
	}

	return false;
}

void Shader::unbind() {
	if (current_shader == this) {
		glUseProgram(0);

		current_shader = NULL;
	}
}

void Shader::compile() {
	ERR_FAIL_COND(_vertex_shader_source.empty());
	ERR_FAIL_COND(_fragment_shader_source.empty());

	if (!program) {
		program = glCreateProgram();
	}

	if (!vertex_shader) {
		vertex_shader = glCreateShader(GL_VERTEX_SHADER);
	}

	if (!fragment_shader) {
		fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
	}

	CharString vertex_shader_source = _vertex_shader_source.utf8();
	const char *vss = vertex_shader_source.get_data();

	glShaderSource(vertex_shader, 1, &vss, NULL);
	glCompileShader(vertex_shader);

	int32_t shader_compiled = GL_FALSE;
	glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &shader_compiled);
	if (shader_compiled != GL_TRUE) {
		print_shader_errors(vertex_shader, "compiling Vertex Shader");
		return;
	}

	glAttachShader(program, vertex_shader);

	CharString fragment_shader_source = _fragment_shader_source.utf8();
	const char *fss = fragment_shader_source.get_data();

	glShaderSource(fragment_shader, 1, &fss, NULL);
	glCompileShader(fragment_shader);

	shader_compiled = GL_FALSE;
	glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &shader_compiled);
	if (shader_compiled != GL_TRUE) {
		print_shader_errors(fragment_shader, "compiling Fragment Shader");
		return;
	}

	glAttachShader(program, fragment_shader);

	glBindAttribLocation(program, ATTRIBUTE_POSITION, "a_position");
	glBindAttribLocation(program, ATTRIBUTE_NORMAL, "a_normal");
	glBindAttribLocation(program, ATTRIBUTE_COLOR, "a_color");
	glBindAttribLocation(program, ATTRIBUTE_UV, "a_uv");

	glLinkProgram(program);

	int32_t program_compiled = GL_FALSE;
	glGetProgramiv(program, GL_LINK_STATUS, &program_compiled);
	if (program_compiled != GL_TRUE) {
		print_program_errors(program);
		return;
	}
}
void Shader::destroy() {
	glDeleteShader(vertex_shader);
	glDeleteShader(fragment_shader);
	glDeleteProgram(program);
}

String Shader::get_vertex_shader_source() {
	return _vertex_shader_source;
}
void Shader::set_vertex_shader_source(const String &source) {
	_vertex_shader_source = source;
}

String Shader::get_fragment_shader_source() {
	return _fragment_shader_source;
}
void Shader::set_fragment_shader_source(const String &source) {
	_fragment_shader_source = source;
}

void Shader::print_shader_errors(const uint32_t p_program, const String &name) {
	int max_length = 5000;
	char error_log[5000];

	glGetShaderInfoLog(p_program, max_length, &max_length, error_log);

	ERR_PRINT("Error " + name + "\n" + String::utf8(error_log, max_length));
}

void Shader::print_program_errors(const uint32_t p_program) {
	if (glIsProgram(program)) {
		int info_length = 0;
		int max_length = 5000;
		char info_log[5000];

		glGetProgramiv(p_program, GL_INFO_LOG_LENGTH, &info_length);

		glGetProgramInfoLog(p_program, max_length, &info_length, info_log);

		if (info_length > 0) {
			ERR_PRINT(String::utf8(info_log, info_length));
		}
	} else {
		ERR_PRINT("print_program_errors: Not a program!\n");
	}
}

Shader::Shader() {
	vertex_shader = 0;
	fragment_shader = 0;
	program = 0;
}
Shader::~Shader() {
	destroy();
}

Shader *Shader::current_shader = NULL;

//Meyers singleton
//thread safe
ShaderCache *ShaderCache::get_singleton() {
	static ShaderCache instance;

	return &instance;
}

Shader *ShaderCache::get_shader(const int id) {
	return shaders[id];
}
void ShaderCache::add_shader(const int id, Shader *shader) {
	shaders[id] = shader;
}

ShaderCache::ShaderCache() {
}
ShaderCache::~ShaderCache() {
	for (HashMap<int, Shader *>::Element *E = shaders.front(); E; E = E->next) {
		memdelete(E->get());
	}

	shaders.clear();
}
#line 0

#line 1 "sfw/render_core/input_event.cpp"
/*************************************************************************/
/*  input_event.cpp                                                      */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

const int InputEvent::DEVICE_ID_TOUCH_MOUSE = -1;
const int InputEvent::DEVICE_ID_INTERNAL = -2;

void InputEvent::set_device(int p_device) {
	device = p_device;
}

int InputEvent::get_device() const {
	return device;
}

bool InputEvent::is_action(const StringName &p_action, bool p_exact_match) const {
	return InputMap::get_singleton()->event_is_action(Ref<InputEvent>((InputEvent *)this), p_action, p_exact_match);
}

bool InputEvent::is_action_pressed(const StringName &p_action, bool p_allow_echo, bool p_exact_match) const {
	bool pressed = false;
	bool valid = InputMap::get_singleton()->event_get_action_status(Ref<InputEvent>((InputEvent *)this), p_action, p_exact_match, &pressed, nullptr, nullptr);
	return valid && pressed && (p_allow_echo || !is_echo());
}

bool InputEvent::is_action_released(const StringName &p_action, bool p_exact_match) const {
	bool pressed = false;
	bool valid = InputMap::get_singleton()->event_get_action_status(Ref<InputEvent>((InputEvent *)this), p_action, p_exact_match, &pressed, nullptr, nullptr);
	return valid && !pressed;
}

float InputEvent::get_action_strength(const StringName &p_action, bool p_exact_match) const {
	float strength = 0.0f;
	bool valid = InputMap::get_singleton()->event_get_action_status(Ref<InputEvent>((InputEvent *)this), p_action, p_exact_match, nullptr, &strength, nullptr);
	return valid ? strength : 0.0f;
}

float InputEvent::get_action_raw_strength(const StringName &p_action, bool p_exact_match) const {
	float raw_strength = 0.0f;
	bool valid = InputMap::get_singleton()->event_get_action_status(Ref<InputEvent>((InputEvent *)this), p_action, p_exact_match, nullptr, nullptr, &raw_strength);
	return valid ? raw_strength : 0.0f;
}

bool InputEvent::is_canceled() const {
	return canceled;
}

bool InputEvent::is_pressed() const {
	return pressed && !canceled;
}

bool InputEvent::is_released() const {
	return !pressed && !canceled;
}

bool InputEvent::is_echo() const {
	return false;
}

Ref<InputEvent> InputEvent::xformed_by(const Transform2D &p_xform, const Vector2 &p_local_ofs) const {
	return Ref<InputEvent>((InputEvent *)this);
}

String InputEvent::as_text() const {
	return String();
}

bool InputEvent::action_match(const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength, float p_deadzone) const {
	return false;
}

bool InputEvent::shortcut_match(const Ref<InputEvent> &p_event, bool p_exact_match) const {
	return false;
}

bool InputEvent::is_action_type() const {
	return false;
}

InputEvent::InputEvent() {
	device = 0;
	canceled = false;
	pressed = false;
}

//////////////////

void InputEventWithModifiers::set_shift(bool p_enabled) {
	shift = p_enabled;
}

bool InputEventWithModifiers::get_shift() const {
	return shift;
}

void InputEventWithModifiers::set_alt(bool p_enabled) {
	alt = p_enabled;
}
bool InputEventWithModifiers::get_alt() const {
	return alt;
}

void InputEventWithModifiers::set_control(bool p_enabled) {
	control = p_enabled;
}
bool InputEventWithModifiers::get_control() const {
	return control;
}

void InputEventWithModifiers::set_metakey(bool p_enabled) {
	meta = p_enabled;
}
bool InputEventWithModifiers::get_metakey() const {
	return meta;
}

void InputEventWithModifiers::set_command(bool p_enabled) {
	command = p_enabled;
}
bool InputEventWithModifiers::get_command() const {
	return command;
}

void InputEventWithModifiers::set_modifiers_from_event(const InputEventWithModifiers *event) {
	set_alt(event->get_alt());
	set_shift(event->get_shift());
	set_control(event->get_control());
	set_metakey(event->get_metakey());
}

uint32_t InputEventWithModifiers::get_modifiers_mask() const {
	uint32_t mask = 0;
	if (get_control()) {
		mask |= KEY_MASK_CTRL;
	}
	if (get_shift()) {
		mask |= KEY_MASK_SHIFT;
	}
	if (get_alt()) {
		mask |= KEY_MASK_ALT;
	}
	if (get_metakey()) {
		mask |= KEY_MASK_META;
	}
	return mask;
}

InputEventWithModifiers::InputEventWithModifiers() {
	alt = false;
	shift = false;
	control = false;
	meta = false;
}

//////////////////////////////////

void InputEventKey::set_pressed(bool p_pressed) {
	pressed = p_pressed;
}

void InputEventKey::set_scancode(uint32_t p_scancode) {
	scancode = p_scancode;
}
uint32_t InputEventKey::get_scancode() const {
	return scancode;
}

void InputEventKey::set_physical_scancode(uint32_t p_scancode) {
	physical_scancode = p_scancode;
}
uint32_t InputEventKey::get_physical_scancode() const {
	return physical_scancode;
}

void InputEventKey::set_unicode(uint32_t p_unicode) {
	unicode = p_unicode;
}
uint32_t InputEventKey::get_unicode() const {
	return unicode;
}

void InputEventKey::set_echo(bool p_enable) {
	echo = p_enable;
}
bool InputEventKey::is_echo() const {
	return echo;
}

void InputEventKey::set_action_match_force_exact(bool p_enable) {
	action_match_force_exact = p_enable;
}
bool InputEventKey::is_action_match_force_exact() const {
	return action_match_force_exact;
}

uint32_t InputEventKey::get_scancode_with_modifiers() const {
	return scancode | get_modifiers_mask();
}

uint32_t InputEventKey::get_physical_scancode_with_modifiers() const {
	return physical_scancode | get_modifiers_mask();
}

String InputEventKey::as_text() const {
	String kc;

	if (scancode == 0) {
		kc = keycode_get_string(physical_scancode) + " (" + RTR("Physical") + ")";
	} else {
		kc = keycode_get_string(scancode);
	}

	if (kc == String()) {
		return kc;
	}

	if (get_metakey()) {
		kc = find_keycode_name(KEY_META) + ("+" + kc);
	}
	if (get_alt()) {
		kc = find_keycode_name(KEY_ALT) + ("+" + kc);
	}
	if (get_shift()) {
		kc = find_keycode_name(KEY_SHIFT) + ("+" + kc);
	}
	if (get_control()) {
		kc = find_keycode_name(KEY_CONTROL) + ("+" + kc);
	}
	return kc;
}

Ref<InputEventKey> InputEventKey::create_reference(uint32_t p_keycode, bool p_physical) {
	Ref<InputEventKey> ie;

	ie.instance();

	if (p_physical) {
		ie->set_physical_scancode(p_keycode & KEY_CODE_MASK);
	} else {
		ie->set_scancode(p_keycode & KEY_CODE_MASK);
	}

	char32_t ch = char32_t(p_keycode & KEY_CODE_MASK);

	if (ch < 0xd800 || (ch > 0xdfff && ch <= 0x10ffff)) {
		ie->set_unicode(ch);
	}

	if ((p_keycode & KEY_MASK_SHIFT)) {
		ie->set_shift(true);
	}

	if ((p_keycode & KEY_MASK_ALT)) {
		ie->set_alt(true);
	}

	if ((p_keycode & KEY_MASK_CTRL)) {
		ie->set_control(true);
	}

	if ((p_keycode & KEY_MASK_META)) {
		ie->set_command(true);
	}

	return ie;
}

bool InputEventKey::action_match(const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength, float p_deadzone) const {
	Ref<InputEventKey> key = p_event;
	if (key.is_null()) {
		return false;
	}

	if (action_match_force_exact) {
		uint32_t code = get_scancode_with_modifiers();
		uint32_t event_code = key->get_scancode_with_modifiers();

		bool match = (code == event_code);
		if (match) {
			if (p_pressed != NULL) {
				*p_pressed = key->is_pressed();
			}
			if (p_strength != NULL) {
				*p_strength = (p_pressed != NULL && *p_pressed) ? 1.0f : 0.0f;
			}
		}
		return match;
	}

	bool match;
	if (scancode != 0) {
		match = scancode == key->scancode;
	} else {
		match = physical_scancode == key->physical_scancode;
	}
	uint32_t action_mask = get_modifiers_mask();
	uint32_t key_mask = key->get_modifiers_mask();
	if (key->is_pressed()) {
		match &= (action_mask & key_mask) == action_mask;
	}
	if (p_exact_match) {
		match &= action_mask == key_mask;
	}
	if (match) {
		bool pressed = key->is_pressed();
		if (p_pressed != nullptr) {
			*p_pressed = pressed;
		}
		float strength = pressed ? 1.0f : 0.0f;
		if (p_strength != nullptr) {
			*p_strength = strength;
		}
		if (p_raw_strength != nullptr) {
			*p_raw_strength = strength;
		}
	}
	return match;
}

bool InputEventKey::shortcut_match(const Ref<InputEvent> &p_event, bool p_exact_match) const {
	Ref<InputEventKey> key = p_event;
	if (key.is_null()) {
		return false;
	}

	if (scancode == 0) {
		return physical_scancode == key->physical_scancode &&
				(!p_exact_match || get_modifiers_mask() == key->get_modifiers_mask());
	} else {
		return scancode == key->scancode &&
				(!p_exact_match || get_modifiers_mask() == key->get_modifiers_mask());
	}
}

InputEventKey::InputEventKey() {
	scancode = 0;
	physical_scancode = 0;
	unicode = 0; ///unicode
	echo = false;
	action_match_force_exact = false;
}

////////////////////////////////////////

void InputEventMouse::set_button_mask(int p_mask) {
	button_mask = p_mask;
}
int InputEventMouse::get_button_mask() const {
	return button_mask;
}

void InputEventMouse::set_position(const Vector2 &p_pos) {
	pos = p_pos;
}
Vector2 InputEventMouse::get_position() const {
	return pos;
}

void InputEventMouse::set_global_position(const Vector2 &p_global_pos) {
	global_pos = p_global_pos;
}
Vector2 InputEventMouse::get_global_position() const {
	return global_pos;
}

InputEventMouse::InputEventMouse() {
	button_mask = 0;
}

///////////////////////////////////////

void InputEventMouseButton::set_factor(float p_factor) {
	factor = p_factor;
}

float InputEventMouseButton::get_factor() const {
	return factor;
}

void InputEventMouseButton::set_button_index(int p_index) {
	button_index = p_index;
}
int InputEventMouseButton::get_button_index() const {
	return button_index;
}

void InputEventMouseButton::set_pressed(bool p_pressed) {
	pressed = p_pressed;
}
void InputEventMouseButton::set_canceled(bool p_canceled) {
	canceled = p_canceled;
}

void InputEventMouseButton::set_doubleclick(bool p_doubleclick) {
	doubleclick = p_doubleclick;
}
bool InputEventMouseButton::is_doubleclick() const {
	return doubleclick;
}

Ref<InputEvent> InputEventMouseButton::xformed_by(const Transform2D &p_xform, const Vector2 &p_local_ofs) const {
	Vector2 g = get_global_position();
	Vector2 l = p_xform.xform(get_position() + p_local_ofs);

	Ref<InputEventMouseButton> mb;
	mb.instance();

	mb->set_device(get_device());

	mb->set_modifiers_from_event(this);

	mb->set_position(l);
	mb->set_global_position(g);

	mb->set_button_mask(get_button_mask());
	mb->set_pressed(pressed);
	mb->set_canceled(canceled);
	mb->set_doubleclick(doubleclick);
	mb->set_factor(factor);
	mb->set_button_index(button_index);

	return mb;
}

bool InputEventMouseButton::action_match(const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength, float p_deadzone) const {
	Ref<InputEventMouseButton> mb = p_event;
	if (mb.is_null()) {
		return false;
	}

	bool match = mb->button_index == button_index;
	uint32_t action_mask = get_modifiers_mask();
	uint32_t button_mask = mb->get_modifiers_mask();
	if (mb->is_pressed()) {
		match &= (action_mask & button_mask) == action_mask;
	}
	if (p_exact_match) {
		match &= action_mask == button_mask;
	}
	if (match) {
		bool pressed = mb->is_pressed();
		if (p_pressed != nullptr) {
			*p_pressed = pressed;
		}
		float strength = pressed ? 1.0f : 0.0f;
		if (p_strength != nullptr) {
			*p_strength = strength;
		}
		if (p_raw_strength != nullptr) {
			*p_raw_strength = strength;
		}
	}

	return match;
}

bool InputEventMouseButton::shortcut_match(const Ref<InputEvent> &p_event, bool p_exact_match) const {
	Ref<InputEventMouseButton> mb = p_event;
	if (mb.is_null()) {
		return false;
	}

	return button_index == mb->button_index &&
			(!p_exact_match || get_modifiers_mask() == mb->get_modifiers_mask());
}

String InputEventMouseButton::as_text() const {
	String button_index_string = "";
	switch (get_button_index()) {
		case BUTTON_LEFT:
			button_index_string = "BUTTON_LEFT";
			break;
		case BUTTON_RIGHT:
			button_index_string = "BUTTON_RIGHT";
			break;
		case BUTTON_MIDDLE:
			button_index_string = "BUTTON_MIDDLE";
			break;
		case BUTTON_WHEEL_UP:
			button_index_string = "BUTTON_WHEEL_UP";
			break;
		case BUTTON_WHEEL_DOWN:
			button_index_string = "BUTTON_WHEEL_DOWN";
			break;
		case BUTTON_WHEEL_LEFT:
			button_index_string = "BUTTON_WHEEL_LEFT";
			break;
		case BUTTON_WHEEL_RIGHT:
			button_index_string = "BUTTON_WHEEL_RIGHT";
			break;
		case BUTTON_XBUTTON1:
			button_index_string = "BUTTON_XBUTTON1";
			break;
		case BUTTON_XBUTTON2:
			button_index_string = "BUTTON_XBUTTON2";
			break;
		default:
			button_index_string = itos(get_button_index());
			break;
	}
	return "InputEventMouseButton : button_index=" + button_index_string + ", pressed=" + (pressed ? "true" : "false") + ", canceled=" + (canceled ? "true" : "false") + ", position=(" + String(get_position()) + "), button_mask=" + itos(get_button_mask()) + ", doubleclick=" + (doubleclick ? "true" : "false");
}

InputEventMouseButton::InputEventMouseButton() {
	factor = 1;
	button_index = 0;
	doubleclick = false;
}

////////////////////////////////////////////

void InputEventMouseMotion::set_tilt(const Vector2 &p_tilt) {
	tilt = p_tilt;
}

Vector2 InputEventMouseMotion::get_tilt() const {
	return tilt;
}

void InputEventMouseMotion::set_pressure(float p_pressure) {
	pressure = p_pressure;
}

float InputEventMouseMotion::get_pressure() const {
	return pressure;
}

void InputEventMouseMotion::set_pen_inverted(bool p_inverted) {
	pen_inverted = p_inverted;
}

bool InputEventMouseMotion::get_pen_inverted() const {
	return pen_inverted;
}

void InputEventMouseMotion::set_relative(const Vector2 &p_relative) {
	relative = p_relative;
}

Vector2 InputEventMouseMotion::get_relative() const {
	return relative;
}

void InputEventMouseMotion::set_speed(const Vector2 &p_speed) {
	speed = p_speed;
}

Vector2 InputEventMouseMotion::get_speed() const {
	return speed;
}

Ref<InputEvent> InputEventMouseMotion::xformed_by(const Transform2D &p_xform, const Vector2 &p_local_ofs) const {
	Vector2 g = get_global_position();
	Vector2 l = p_xform.xform(get_position() + p_local_ofs);
	Vector2 r = p_xform.basis_xform(get_relative());
	Vector2 s = p_xform.basis_xform(get_speed());

	Ref<InputEventMouseMotion> mm;
	mm.instance();

	mm->set_device(get_device());

	mm->set_modifiers_from_event(this);

	mm->set_position(l);
	mm->set_pressure(get_pressure());
	mm->set_pen_inverted(get_pen_inverted());
	mm->set_tilt(get_tilt());
	mm->set_global_position(g);

	mm->set_button_mask(get_button_mask());
	mm->set_relative(r);
	mm->set_speed(s);

	return mm;
}

String InputEventMouseMotion::as_text() const {
	String button_mask_string = "";
	switch (get_button_mask()) {
		case BUTTON_MASK_LEFT:
			button_mask_string = "BUTTON_MASK_LEFT";
			break;
		case BUTTON_MASK_MIDDLE:
			button_mask_string = "BUTTON_MASK_MIDDLE";
			break;
		case BUTTON_MASK_RIGHT:
			button_mask_string = "BUTTON_MASK_RIGHT";
			break;
		case BUTTON_MASK_XBUTTON1:
			button_mask_string = "BUTTON_MASK_XBUTTON1";
			break;
		case BUTTON_MASK_XBUTTON2:
			button_mask_string = "BUTTON_MASK_XBUTTON2";
			break;
		default:
			button_mask_string = itos(get_button_mask());
			break;
	}
	return "InputEventMouseMotion : button_mask=" + button_mask_string + ", position=(" + String(get_position()) + "), relative=(" + String(get_relative()) + "), speed=(" + String(get_speed()) + "), pressure=(" + rtos(get_pressure()) + "), tilt=(" + String(get_tilt()) + "), pen_inverted=(" + rtos(get_pen_inverted()) + ")";
}

bool InputEventMouseMotion::accumulate(const Ref<InputEvent> &p_event) {
	Ref<InputEventMouseMotion> motion = p_event;
	if (motion.is_null()) {
		return false;
	}

	if (is_canceled() != motion->is_canceled()) {
		return false;
	}

	if (is_pressed() != motion->is_pressed()) {
		return false;
	}

	if (get_button_mask() != motion->get_button_mask()) {
		return false;
	}

	if (get_shift() != motion->get_shift()) {
		return false;
	}

	if (get_control() != motion->get_control()) {
		return false;
	}

	if (get_alt() != motion->get_alt()) {
		return false;
	}

	if (get_metakey() != motion->get_metakey()) {
		return false;
	}

	set_position(motion->get_position());
	set_global_position(motion->get_global_position());
	set_speed(motion->get_speed());
	relative += motion->get_relative();

	return true;
}

InputEventMouseMotion::InputEventMouseMotion() {
	pressure = 0;
	pen_inverted = false;
}

/////////////////////////////

void InputEventAction::set_action(const StringName &p_action) {
	action = p_action;
}
StringName InputEventAction::get_action() const {
	return action;
}

void InputEventAction::set_pressed(bool p_pressed) {
	pressed = p_pressed;
}

void InputEventAction::set_strength(float p_strength) {
	strength = CLAMP(p_strength, 0.0f, 1.0f);
}

float InputEventAction::get_strength() const {
	return strength;
}

bool InputEventAction::shortcut_match(const Ref<InputEvent> &p_event, bool p_exact_match) const {
	if (p_event.is_null()) {
		return false;
	}

	return p_event->is_action(action, p_exact_match);
}

bool InputEventAction::is_action(const StringName &p_action) const {
	return action == p_action;
}

bool InputEventAction::action_match(const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength, float p_deadzone) const {
	Ref<InputEventAction> act = p_event;
	if (act.is_null()) {
		return false;
	}

	bool match = action == act->action;
	if (match) {
		bool pressed = act->is_pressed();
		if (p_pressed != nullptr) {
			*p_pressed = pressed;
		}
		float strength = pressed ? 1.0f : 0.0f;
		if (p_strength != nullptr) {
			*p_strength = strength;
		}
		if (p_raw_strength != nullptr) {
			*p_raw_strength = strength;
		}
	}
	return match;
}

String InputEventAction::as_text() const {
	return "InputEventAction : action=" + action + ", pressed=(" + (is_pressed() ? "true" : "false");
}

InputEventAction::InputEventAction() {
	strength = 1.0f;
}
/////////////////////////////

void InputEventShortCut::set_shortcut(Ref<ShortCut> p_shortcut) {
	shortcut = p_shortcut;
	emit_changed();
}

Ref<ShortCut> InputEventShortCut::get_shortcut() {
	return shortcut;
}

String InputEventShortCut::as_text() const {
	ERR_FAIL_COND_V(shortcut.is_null(), "None");

	return vformat(RTR("Input Event with ShortCut=%s"), shortcut->get_as_text());
}

String InputEventShortCut::to_string() {
	ERR_FAIL_COND_V(shortcut.is_null(), "None");

	return vformat("InputEventShortCut: shortcut=%s", shortcut->get_as_text());
}

InputEventShortCut::InputEventShortCut() {
}

InputEventShortCut::~InputEventShortCut() {
}
#line 0

#line 1 "sfw/render_core/mesh.cpp"

void Mesh::add_vertex2(float x, float y) {
	vertices.push_back(x);
	vertices.push_back(y);
}
void Mesh::add_vertex2(const Vector2 &v) {
	vertices.push_back(v.x);
	vertices.push_back(v.y);
}

void Mesh::add_vertex3(float x, float y, float z) {
	vertices.push_back(x);
	vertices.push_back(y);
	vertices.push_back(z);
}
void Mesh::add_vertex3(const Vector3 &v) {
	vertices.push_back(v.x);
	vertices.push_back(v.y);
	vertices.push_back(v.z);
}

void Mesh::add_normal(float x, float y, float z) {
	normals.push_back(x);
	normals.push_back(y);
	normals.push_back(z);
}

void Mesh::add_normal(const Vector3 &n) {
	normals.push_back(n.x);
	normals.push_back(n.y);
	normals.push_back(n.z);
}

void Mesh::add_color(float r, float g, float b, float a) {
	colors.push_back(r);
	colors.push_back(g);
	colors.push_back(b);
	colors.push_back(a);
}
void Mesh::add_color(const Color &p_color) {
	colors.push_back(p_color.r);
	colors.push_back(p_color.g);
	colors.push_back(p_color.b);
	colors.push_back(p_color.a);
}

void Mesh::add_uv(float u, float v) {
	uvs.push_back(u);
	uvs.push_back(v);
}
void Mesh::add_uv(const Vector2 &uv) {
	uvs.push_back(uv.x);
	uvs.push_back(uv.y);
}

void Mesh::add_index(uint32_t index) {
	indices.push_back(index);
}
void Mesh::add_triangle(uint32_t i1, uint32_t i2, uint32_t i3) {
	indices.push_back(i1);
	indices.push_back(i2);
	indices.push_back(i3);
}

void Mesh::flip_faces() {
	if (normals.size() > 0 && indices.size() > 0) {
		{
			int nc = normals.size();
			float *w = normals.ptrw();
			for (int i = 0; i < nc; i++) {
				w[i] = -w[i];
			}
		}

		{
			int ic = indices.size();
			uint32_t *w = indices.ptrw();
			for (int i = 0; i < ic; i += 3) {
				SWAP(w[i + 0], w[i + 1]);
			}
		}
	}
}

void Mesh::fill_colors(const Color &p_color) {
	while (colors.size() % 4 != 0) {
		colors.push_back(0);
	}

	int needed_color_count = get_vertex_count() * 4;

	if (colors.size() > needed_color_count) {
		colors.resize(needed_color_count);
		return;
	}

	while (colors.size() < needed_color_count) {
		colors.push_back(p_color.r);
		colors.push_back(p_color.g);
		colors.push_back(p_color.b);
		colors.push_back(p_color.a);
	}
}

void Mesh::fill_colors_random() {
	while (colors.size() % 4 != 0) {
		colors.push_back(0);
	}

	int needed_color_count = get_vertex_count() * 4;

	if (colors.size() > needed_color_count) {
		colors.resize(needed_color_count);
		return;
	}

	RandomPCG r;
	r.randomize();

	while (colors.size() < needed_color_count) {
		colors.push_back(r.randf());
		colors.push_back(r.randf());
		colors.push_back(r.randf());
		colors.push_back(1);
	}
}

void Mesh::fill_colors_interpolated(const Color &p_from, const Color &p_to) {
	while (colors.size() % 4 != 0) {
		colors.push_back(0);
	}

	int needed_color_count = get_vertex_count() * 4;

	if (colors.size() > needed_color_count) {
		colors.resize(needed_color_count);
		return;
	}

	RandomPCG r;
	r.randomize();

	while (colors.size() < needed_color_count) {
		Color c = p_from.linear_interpolate(p_to, colors.size() / (real_t)needed_color_count);

		colors.push_back(c.r);
		colors.push_back(c.g);
		colors.push_back(c.b);
		colors.push_back(c.a);
	}
}

void Mesh::update_aabb() {
	aabb = AABB();

	if (vertex_dimesions == 2) {
		int size = vertices.size();

		if (size < 2) {
			return;
		}

		const float *v = vertices.ptr();

		aabb.position.x = v[0];
		aabb.position.y = v[1];

		Vector3 vert;

		for (int i = 0; i < size; i += 2) {
			vert.x = v[i];
			vert.y = v[i + 1];

			aabb.expand_to(vert);
		}
	} else if (vertex_dimesions == 3) {
		int size = vertices.size();

		if (size < 3) {
			return;
		}

		const float *v = vertices.ptr();

		aabb.position.x = v[0];
		aabb.position.y = v[1];
		aabb.position.z = v[2];

		Vector3 vert;

		for (int i = 0; i < size; i += 2) {
			vert.x = v[i];
			vert.y = v[i + 1];
			vert.z = v[i + 2];

			aabb.expand_to(vert);
		}
	}
}

void Mesh::clear() {
	vertices.clear();
	normals.clear();
	colors.clear();
	uvs.clear();
	indices.clear();
}

void Mesh::upload() {
	if (vertices.size() == 0) {
		return;
	}

	if (!VBO) {
		glGenBuffers(1, &VBO);
	}

	vertices_vbo_size = sizeof(float) * vertices.size();
	normals_vbo_size = sizeof(float) * normals.size();
	colors_vbo_size = sizeof(float) * colors.size();
	uvs_vbo_size = sizeof(float) * uvs.size();
	indices_vbo_size = sizeof(uint32_t) * indices.size();

	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, vertices_vbo_size + normals_vbo_size + colors_vbo_size + uvs_vbo_size, NULL, GL_STATIC_DRAW);

	glBufferSubData(GL_ARRAY_BUFFER, 0, vertices_vbo_size, vertices.ptr());

	if (normals_vbo_size > 0) {
		glBufferSubData(GL_ARRAY_BUFFER, vertices_vbo_size, normals_vbo_size, normals.ptr());
	}

	if (colors_vbo_size > 0) {
		glBufferSubData(GL_ARRAY_BUFFER, vertices_vbo_size + normals_vbo_size, colors_vbo_size, colors.ptr());
	}

	if (uvs_vbo_size > 0) {
		glBufferSubData(GL_ARRAY_BUFFER, vertices_vbo_size + normals_vbo_size + colors_vbo_size, uvs_vbo_size, uvs.ptr());
	}

	if (indices_vbo_size > 0) {
		if (!IBO) {
			glGenBuffers(1, &IBO);
		}

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices_vbo_size, indices.ptr(), GL_STATIC_DRAW);

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
	}

	glBindBuffer(GL_ARRAY_BUFFER, 0);
}
void Mesh::destroy() {
	if (VBO) {
		glDeleteBuffers(1, &VBO);
		VBO = 0;
	}

	if (IBO) {
		glDeleteBuffers(1, &IBO);
		IBO = 0;
	}
}
void Mesh::render() {
	if (!vertices_vbo_size) {
		return;
	}

	if (!Shader::current_shader) {
		return;
	}

	glBindBuffer(GL_ARRAY_BUFFER, VBO);

	glVertexAttribPointer(Shader::ATTRIBUTE_POSITION, vertex_dimesions, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(Shader::ATTRIBUTE_POSITION);

	if (normals_vbo_size > 0) {
		glVertexAttribPointer(Shader::ATTRIBUTE_NORMAL, 3, GL_FLOAT, GL_FALSE, 0, (void *)(uintptr_t)(vertices_vbo_size));
		glEnableVertexAttribArray(Shader::ATTRIBUTE_NORMAL);
	}

	if (colors_vbo_size > 0) {
		glVertexAttribPointer(Shader::ATTRIBUTE_COLOR, 4, GL_FLOAT, GL_FALSE, 0, (void *)(uintptr_t)(vertices_vbo_size + normals_vbo_size));
		glEnableVertexAttribArray(Shader::ATTRIBUTE_COLOR);
	}

	if (uvs_vbo_size > 0) {
		glVertexAttribPointer(Shader::ATTRIBUTE_UV, 2, GL_FLOAT, GL_FALSE, 0, (void *)(uintptr_t)(vertices_vbo_size + normals_vbo_size + colors_vbo_size));
		glEnableVertexAttribArray(Shader::ATTRIBUTE_UV);
	}

	if (indices_vbo_size > 0) {
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);

		glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, (GLvoid *)0);
	} else {
		glDrawArrays(GL_TRIANGLES, 0, vertices.size());
	}

	glDisableVertexAttribArray(Shader::ATTRIBUTE_POSITION);

	if (normals_vbo_size > 0) {
		glDisableVertexAttribArray(Shader::ATTRIBUTE_NORMAL);
	}

	if (colors_vbo_size > 0) {
		glDisableVertexAttribArray(Shader::ATTRIBUTE_COLOR);
	}

	if (uvs_vbo_size > 0) {
		glDisableVertexAttribArray(Shader::ATTRIBUTE_UV);
	}

	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}

int Mesh::get_vertex_count() const {
	return vertices.size() / vertex_dimesions;
}

Mesh::Mesh() {
	VBO = 0;
	IBO = 0;

	vertex_dimesions = 3;

	vertices_vbo_size = 0;
	normals_vbo_size = 0;
	colors_vbo_size = 0;
	uvs_vbo_size = 0;
	indices_vbo_size = 0;
}
Mesh::Mesh(int vert_dim) {
	VBO = 0;
	IBO = 0;

	vertex_dimesions = vert_dim;

	vertices_vbo_size = 0;
	normals_vbo_size = 0;
	colors_vbo_size = 0;
	uvs_vbo_size = 0;
	indices_vbo_size = 0;
}
Mesh::~Mesh() {
	destroy();
	clear();
}
#line 0

#line 1 "sfw/render_core/font.cpp"
// font framework. original code by Vassvik (UNLICENSED)
// - rlyeh, public domain.
//
// [x] embedded default font (bm mini).
// [x] oversampling, texture dimensions.
// [x] utf8, unicode ranges.
// [x] markup opcodes.
// [x] faces (italic, bold, regular, cjk), colors and sizes.
// [x] unicode ranges from dear-imgui (@ocornut allowed to mit-0 relicense the data tables).
// [*] alignment. kinda hacky. revisit some day.
// [ ] underlining, soft/hard shadows, outlines.
// [ ] clip/wrap/overflow regions.
// [ ] text-shaping, text-layout.
// [ ] text-wrapping.
// [ ] optimizations.
//
// ## language families that could be merged on a single texture alias
// - EU+EL+RU
// - AR+HE+RU
// - TH+VI+TW
// - ZH
// - JP
// - KR

// -----------------------------------------------------------------------------

// bm-mini.zip (public domain font)
// http://bitmapmania.m78.com
// cooz@m78.com

void Font::load_default(const float size, const uint32_t flags) {
	font_face_from_mem(bm_mini_ttf, 20176, size, flags);
}

float Font::get_scale() const {
	return _scale;
}
void Font::set_scale(const float p_scale) {
	_scale = p_scale;
}

void Font::font_face_from_mem(const void *ttf_data, uint32_t ttf_len, float font_size, uint32_t flags) {
	if (font_size <= 0 || font_size > 72) {
		return;
	}

	if (!ttf_data || !ttf_len) {
		return;
	}

	unload();

	if (!(flags & FONT_ASCII)) {
		flags |= FONT_ASCII; // ensure this minimal range [0020-00FF] is almost always in
	}

	// load .ttf into a bitmap using stb_truetype.h
	int dim = flags & FONT_4096 ? 4096 : flags & FONT_2048 ? 2048
			: flags & FONT_1024							   ? 1024
														   : 512;
	_width = dim;
	_height = dim;

	// change size [h1(largest) to h3(regular) to h6(smallest)]
	_font_size = font_size;
	_scale = 1.0000f;

// figure out what ranges we're about to bake
#define MERGE_TABLE(table)                                     \
	do {                                                       \
		for (unsigned i = 0; table[i]; i += 2) {               \
			uint64_t begin = table[i + 0], end = table[i + 1]; \
			for (unsigned j = begin; j <= end; ++j) {          \
				sorted.push_back(j);                           \
			}                                                  \
		}                                                      \
	} while (0)

#define MERGE_PACKED_TABLE(codepoint_begin, table, table_size)                     \
	do {                                                                           \
		for (int i = 0, begin = codepoint_begin, end = table_size; i < end; i++) { \
			sorted.push_back((unsigned)(begin + table[i]));                        \
			begin += table[i];                                                     \
		}                                                                          \
	} while (0)

	Vector<uint64_t> sorted;
	if (flags & FONT_ASCII) {
		MERGE_TABLE(table_common);
	}
	if (flags & FONT_EM) {
		MERGE_TABLE(table_emoji);
	}
	if (flags & FONT_EU) {
		MERGE_TABLE(table_eastern_europe);
	}
	if (flags & FONT_RU) {
		MERGE_TABLE(table_western_europe);
	}
	if (flags & FONT_EL) {
		MERGE_TABLE(table_western_europe);
	}
	if (flags & FONT_AR) {
		MERGE_TABLE(table_middle_east);
	}
	if (flags & FONT_HE) {
		MERGE_TABLE(table_middle_east);
	}
	if (flags & FONT_TH) {
		MERGE_TABLE(table_thai);
	}
	if (flags & FONT_VI) {
		MERGE_TABLE(table_vietnamese);
	}
	if (flags & FONT_KR) {
		MERGE_TABLE(table_korean);
	}
	if (flags & FONT_JP) {
		MERGE_TABLE(table_chinese_japanese_common);
		MERGE_PACKED_TABLE(0x4E00, packed_table_japanese, 2999);
	}
	if (flags & FONT_ZH) {
		MERGE_TABLE(table_chinese_japanese_common);
		MERGE_PACKED_TABLE(0x4E00, packed_table_chinese, 2500);

	} // zh-simplified
	if (flags & FONT_ZH) {
		MERGE_TABLE(table_chinese_punctuation);
	} // both zh-simplified and zh-full
	//  if(flags & FONT_ZH)    { MERGE_TABLE(table_chinese_full); } // zh-full

	sorted.sort();

	for (int i = 0; i < sorted.size(); ++i) {
		uint64_t current_element = sorted[i];

		for (int j = i + 1; j < sorted.size(); ++j) {
			if (sorted[j] == current_element) {
				sorted.remove(j);
				--j;
			} else {
				break;
			}
		}
	}

	// pack and create bitmap
	Vector<uint8_t> bitmap_data;
	bitmap_data.resize(_height * _width);
	unsigned char *bitmap = (unsigned char *)bitmap_data.ptrw();

	int charCount = sorted[sorted.size() - 1] - sorted[0] + 1; // 0xEFFFF;
	stbtt_packedchar *cdata = memnew_arr(stbtt_packedchar, charCount);
	_iter2cp = memnew_arr(unsigned int, charCount);
	_cp2iter = memnew_arr(unsigned int, charCount);
	for (int i = 0; i < charCount; ++i) {
		_iter2cp[i] = _cp2iter[i] = 0xFFFD; // default invalid glyph
	}

	// find first ch./co
	{
		stbtt_fontinfo info = { 0 };
		stbtt_InitFont(&info, (const unsigned char *)ttf_data, stbtt_GetFontOffsetForIndex((const unsigned char *)ttf_data, 0));

		for (int i = 0, end = sorted.size() - 1; i < end; ++i) {
			unsigned glyph = sorted[i];
			if (!stbtt_FindGlyphIndex(&info, glyph)) {
				continue;
			}

			_begin = glyph;
			break;
		}
	}

	stbtt_pack_context pc;
	if (!stbtt_PackBegin(&pc, bitmap, _width, _height, 0, 1, NULL)) {
		ERR_FAIL_COND("Failed to initialize atlas font");
	}
	stbtt_PackSetOversampling(&pc, flags & FONT_OVERSAMPLE_X ? 2 : 1, flags & FONT_OVERSAMPLE_Y ? 2 : 1); /*useful on small fonts*/
	unsigned int count = 0;
	for (int i = 0, num = sorted.size() - 1; i < num; ++i) {
		uint64_t begin = sorted[i], end = sorted[i];
		while (i < (num - 1) && (sorted[i + 1] - sorted[i]) == 1) {
			end = sorted[++i];
		}

		if (begin < _begin) {
			continue;
		}

		if (stbtt_PackFontRange(&pc, (const unsigned char *)ttf_data, 0, _font_size, begin, end - begin + 1, cdata + begin - _begin)) {
			for (uint64_t cp = begin; cp <= end; ++cp) {
				// unicode->index runtime lookup
				_cp2iter[cp - _begin] = count;
				_iter2cp[count++] = cp;
			}
		} else {
			ERR_PRINT("!Failed to pack atlas font. Likely out of texture mem.");
		}
	}

	stbtt_PackEnd(&pc);
	_num_glyphs = count;

	// calculate vertical font metrics
	stbtt_fontinfo info = { 0 };
	stbtt_InitFont(&info, (const unsigned char *)ttf_data, stbtt_GetFontOffsetForIndex((const unsigned char *)ttf_data, 0));

	int a, d, l;
	if (!stbtt_GetFontVMetricsOS2(&info, &a, &d, &l)) {
		stbtt_GetFontVMetrics(&info, &a, &d, &l);
	}

	_ascent = a;
	_descent = d;
	_linegap = l;
	_linedist = (a - d + l);
	_factor = (_font_size / (_ascent - _descent));

	// save some gpu memory by truncating unused vertical space in atlas texture
	{
		int max_y1 = 0;
		for (unsigned int i = 0; i < _num_glyphs; i++) {
			int cp = _iter2cp[i];
			if (cp == 0xFFFD) {
				continue;
			}

			stbtt_packedchar *cd = &cdata[cp - _begin];
			if (cd->y1 > max_y1) {
				max_y1 = cd->y1;
			}
		}
		// cut away the unused part of the bitmap
		_height = max_y1 + 1;
	}

	// last chance to inspect the original font atlases
	//String pngname = "font_debug" + itos(index) + " .png";
	//stbi_write_png(pngname.utf8().get_data(), _width, _height, 1, bitmap, 0);

	bitmap_data.resize(_width * _height);

	_image->create(_width, _height, false, Image::FORMAT_L8, bitmap_data);

	_texture->create_from_image(_image);

	_texture_offsets.resize(_num_glyphs);

	// remap larger 0xFFFF unicodes into smaller NUM_GLYPHS glyphs
	for (unsigned i = 0; i < _num_glyphs; i++) {
		unsigned cp = _iter2cp[i];
		if (cp == 0xFFFD) {
			continue;
		}

		stbtt_packedchar *cd = &cdata[cp - _begin];

		TextureOffset offset;

		offset.x0 = cd->x0 / (double)_width;
		offset.y0 = cd->y0 / (double)_height;
		offset.x1 = cd->x1 / (double)_width;
		offset.y1 = cd->y1 / (double)_height;

		offset.x0_orig = cd->x0;
		offset.y0_orig = cd->y0;
		offset.x1_orig = cd->x1;
		offset.y1_orig = cd->y1;

		offset.xoff = cd->xoff;
		offset.yoff = cd->yoff;
		offset.xoff2 = cd->xoff2;
		offset.yoff2 = cd->yoff2;
		offset.xadvance = cd->xadvance;

		_texture_offsets.write[i] = offset;
	}

	memdelete_arr(cdata);

	_initialized = true;

#undef MERGE_TABLE
#undef MERGE_PACKED_TABLE
}

void Font::font_face(const char *filename_ttf, float font_size, unsigned flags) {
	/*
	font_init();

	int len;
	const char *buffer = vfs_load(filename_ttf, &len);
	if (!buffer)
		buffer = file_load(filename_ttf, &len);

	font_face_from_mem(tag, buffer, len, font_size, flags);
	*/
}

Vector2 Font::generate_mesh(const String &p_text, Ref<Mesh> &p_into, const Color &p_color) const {
	ERR_FAIL_COND_V(!_initialized, Vector2());
	ERR_FAIL_COND_V(!p_into.is_valid(), Vector2());

	float X = 0;
	float Y = _linedist * _factor * _scale;
	float W = 0;
	float L = _ascent * _factor * _scale;
	float LL = L; // LL=largest linedist

	int mesh_index_offset = p_into->indices.size();

	// parse string
	for (int i = 0, end = p_text.length(); i < end; ++i) {
		uint32_t ch = p_text[i];

		if (ch == '\n') {
			// change cursor, advance y, record largest x as width, increase height
			if (X > W) {
				W = X;
			}

			X = 0.0;
			Y += _linedist * _factor * _scale;

			continue;
		}

		int cp = ch - _begin;

		const TextureOffset &t = _texture_offsets[_cp2iter[cp]];

		p_into->add_uv(t.x0, t.y0);
		p_into->add_color(p_color);
		p_into->add_vertex2(X + t.xoff, Y + t.yoff);

		p_into->add_uv(t.x1, t.y1);
		p_into->add_color(p_color);
		p_into->add_vertex2(X + t.xoff2, Y + t.yoff2);

		p_into->add_uv(t.x0, t.y1);
		p_into->add_color(p_color);
		p_into->add_vertex2(X + t.xoff, Y + t.yoff2);

		p_into->add_uv(t.x1, t.y0);
		p_into->add_color(p_color);
		p_into->add_vertex2(X + t.xoff2, Y + t.yoff);

		p_into->add_triangle(mesh_index_offset + 1, mesh_index_offset + 0, mesh_index_offset + 2);
		p_into->add_triangle(mesh_index_offset + 0, mesh_index_offset + 1, mesh_index_offset + 3);

		mesh_index_offset += 4;

		X += t.xadvance * _scale;
	}

	Y += (-_descent + _linegap) * _factor * _scale;

	return Vector2(W * W > X * X ? W : X, Y * Y > LL * LL ? Y : LL).abs();
}

// Calculate the size of a string, in the pixel size specified. Count stray newlines too.
Vector2 Font::get_string_size(const String &p_text) const {
	ERR_FAIL_COND_V(!_initialized, Vector2());

	float X = 0;
	float Y = _linedist * _factor * _scale;
	float W = 0;
	float L = _ascent * _factor * _scale;
	float LL = L; // LL=largest linedist

	// parse string
	for (int i = 0, end = p_text.length(); i < end; ++i) {
		uint32_t ch = p_text[i];

		if (ch == '\n') {
			// change cursor, advance y, record largest x as width, increase height
			if (X > W) {
				W = X;
			}

			X = 0.0;
			Y += _linedist * _factor * _scale;

			continue;
		}

		int cp = ch - _begin;
		const TextureOffset &t = _texture_offsets[_cp2iter[cp]];
		X += t.xadvance * _scale;
	}

	Y += (-_descent + _linegap) * _factor * _scale;

	return Vector2(W * W > X * X ? W : X, Y * Y > LL * LL ? Y : LL).abs();
}

Font::FontMetrics Font::font_metrics() const {
	FontMetrics m;

	m.ascent = _ascent * _factor * _scale;
	m.descent = _descent * _factor * _scale;
	m.linegap = _linegap * _factor * _scale;
	m.linedist = _linedist * _factor * _scale;

	return m;
}

int Font::get_atlas_width() const {
	return _width;
}

int Font::get_atlas_height() const {
	return _height;
}

Ref<Image> Font::get_image() const {
	return _image;
}
Ref<Texture> Font::get_texture() const {
	return _texture;
}

void Font::unload() {
	if (!_initialized) {
		return;
	}

	_num_glyphs = 0;
	_cp2iter = NULL;
	_iter2cp = NULL;
	_begin = 0;

	_initialized = false;

	_height = 0;
	_width = 0;
	_font_size = 0;
	_factor = 0;
	_scale = 0;

	_ascent = 0;
	_descent = 0;
	_linegap = 0;
	_linedist = 0;

	_image.unref();
	_texture.unref();

	_texture_offsets.clear();
}

Font::Font() {
	_num_glyphs = 0;
	_cp2iter = NULL;
	_iter2cp = NULL;
	_begin = 0;

	_initialized = false;

	_height = 0;
	_width = 0;
	_font_size = 0;
	_factor = 0;
	_scale = 0;

	_ascent = 0;
	_descent = 0;
	_linegap = 0;
	_linedist = 0;

	_image.instance();
	_texture.instance();
}

Font::~Font() {
	unload();
}
#line 0

#line 1 "sfw/render_core/render_state.cpp"

Transform RenderState::camera_transform_3d;
Transform RenderState::model_view_matrix_3d;
Projection RenderState::projection_matrix_3d;

Transform2D RenderState::model_view_matrix_2d;
Transform RenderState::projection_matrix_2d;

Rect2i RenderState::render_rect;

Ref<FrameBuffer> RenderState::current_framebuffer;

void RenderState::apply_render_rect() {
	glViewport(render_rect.position.x, render_rect.position.y, render_rect.size.x, render_rect.size.y);
}

void RenderState::window_update_render_rect_size(const int p_width, const int p_height) {
	if (current_framebuffer.is_valid()) {
		return;
	}

	render_rect = Rect2i(0, 0, p_width, p_height);
}

RenderState::RenderState() {
}
RenderState::~RenderState() {
}
#line 0

#line 1 "sfw/render_core/mesh_utils.cpp"
/*************************************************************************/
/*  Most of these are originally from primitive_meshes.cpp               */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void MeshUtils::create_simple_test_cone(Ref<Mesh> mesh) {
	ERR_FAIL_COND(!mesh.is_valid());

	uint32_t vc = mesh->get_vertex_count();

	//eleje
	mesh->add_color(1, 0, 0);
	mesh->add_vertex3(0, 0.5, 0);

	mesh->add_color(1, 0, 0);
	mesh->add_vertex3(-0.5, -0.5, 0.5);

	mesh->add_color(1, 0, 0);
	mesh->add_vertex3(0.5, -0.5, 0.5);

	mesh->add_triangle(0 + vc, 1 + vc, 2 + vc);

	//bal
	mesh->add_color(0, 1, 0);
	mesh->add_vertex3(0, 0.5, 0);

	mesh->add_color(0, 1, 0);
	mesh->add_vertex3(-0.5, -0.5, -0.5);

	mesh->add_color(0, 1, 0);
	mesh->add_vertex3(-0.5, -0.5, 0.5);

	mesh->add_triangle(3 + vc, 4 + vc, 5 + vc);

	//jobb
	mesh->add_color(0, 0, 1);
	mesh->add_vertex3(0, 0.5, 0);

	mesh->add_color(0, 0, 1);
	mesh->add_vertex3(0.5, -0.5, 0.5);

	mesh->add_color(0, 0, 1);
	mesh->add_vertex3(0.5, -0.5, -0.5);

	mesh->add_triangle(6 + vc, 7 + vc, 8 + vc);

	//hátulja
	mesh->add_color(1, 1, 0);
	mesh->add_vertex3(0, 0.5, 0);

	mesh->add_color(1, 1, 0);
	mesh->add_vertex3(0.5, -0.5, -0.5);

	mesh->add_color(1, 1, 0);
	mesh->add_vertex3(-0.5, -0.5, -0.5);

	mesh->add_triangle(9 + vc, 10 + vc, 11 + vc);

	//alja

	mesh->add_color(1, 0, 1);
	mesh->add_vertex3(-0.5, -0.5, -0.5);

	mesh->add_color(1, 0, 1);
	mesh->add_vertex3(0.5, -0.5, 0.5);

	mesh->add_color(1, 0, 1);
	mesh->add_vertex3(-0.5, -0.5, 0.5);

	mesh->add_color(1, 0, 1);
	mesh->add_vertex3(0.5, -0.5, -0.5);

	mesh->add_triangle(12 + vc, 13 + vc, 14 + vc);
	mesh->add_triangle(13 + vc, 12 + vc, 15 + vc);
}

void MeshUtils::create_capsule(Ref<Mesh> mesh, const float radius, const float mid_height, const int p_radial_segments, const int p_rings) {
	ERR_FAIL_COND(!mesh.is_valid());

	int msi = mesh->get_vertex_count();

	int radial_segments = p_radial_segments > 4 ? p_radial_segments : 4;
	int rings = p_rings > 1 ? p_rings : 1;

	int i, j, prevrow, thisrow, point;
	float x, y, z, u, v, w;
	float onethird = 1.0 / 3.0;
	float twothirds = 2.0 / 3.0;

	// note, this has been aligned with our collision shape but I've left the descriptions as top/middle/bottom

	point = 0;

	// top hemisphere
	thisrow = 0;
	prevrow = 0;
	for (j = 0; j <= (rings + 1); j++) {
		v = j;

		v /= (rings + 1);
		w = sin(0.5 * Math_PI * v);
		z = radius * cos(0.5 * Math_PI * v);

		for (i = 0; i <= radial_segments; i++) {
			u = i;
			u /= radial_segments;

			x = sin(u * (Math_PI * 2.0));
			y = -cos(u * (Math_PI * 2.0));

			Vector3 p = Vector3(x * radius * w, y * radius * w, z);
			mesh->add_vertex3(p + Vector3(0.0, 0.0, 0.5 * mid_height));
			mesh->add_normal(p.normalized());
			mesh->add_uv(Vector2(u, v * onethird));

			point++;

			if (i > 0 && j > 0) {
				mesh->add_index(msi + prevrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i - 1);

				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i);
				mesh->add_index(msi + thisrow + i - 1);
			};
		};

		prevrow = thisrow;
		thisrow = point;
	};

	// cylinder
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= (rings + 1); j++) {
		v = j;
		v /= (rings + 1);

		z = mid_height * v;
		z = (mid_height * 0.5) - z;

		for (i = 0; i <= radial_segments; i++) {
			u = i;
			u /= radial_segments;

			x = sin(u * (Math_PI * 2.0));
			y = -cos(u * (Math_PI * 2.0));

			Vector3 p = Vector3(x * radius, y * radius, z);
			mesh->add_vertex3(p);
			mesh->add_normal(Vector3(x, y, 0.0));
			mesh->add_uv(Vector2(u, onethird + (v * onethird)));
			point++;

			if (i > 0 && j > 0) {
				mesh->add_index(msi + prevrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i - 1);

				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i);
				mesh->add_index(msi + thisrow + i - 1);
			};
		};

		prevrow = thisrow;
		thisrow = point;
	};

	// bottom hemisphere
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= (rings + 1); j++) {
		v = j;

		v /= (rings + 1);
		v += 1.0;
		w = sin(0.5 * Math_PI * v);
		z = radius * cos(0.5 * Math_PI * v);

		for (i = 0; i <= radial_segments; i++) {
			float u2 = i;
			u2 /= radial_segments;

			x = sin(u2 * (Math_PI * 2.0));
			y = -cos(u2 * (Math_PI * 2.0));

			Vector3 p = Vector3(x * radius * w, y * radius * w, z);
			mesh->add_vertex3(p + Vector3(0.0, 0.0, -0.5 * mid_height));
			mesh->add_normal(p.normalized());
			mesh->add_uv(Vector2(u2, twothirds + ((v - 1.0) * onethird)));
			point++;

			if (i > 0 && j > 0) {
				mesh->add_index(msi + prevrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i - 1);

				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i);
				mesh->add_index(msi + thisrow + i - 1);
			};
		};

		prevrow = thisrow;
		thisrow = point;
	};
}

void MeshUtils::create_cube(Ref<Mesh> mesh, const Vector3 size, const int p_subdivide_w, const int subdivide_h, const int p_subdivide_d) {
	ERR_FAIL_COND(!mesh.is_valid());

	int msi = mesh->get_vertex_count();

	int subdivide_w = p_subdivide_w > 0 ? p_subdivide_w : 0;
	int subdivide_d = p_subdivide_d > 0 ? p_subdivide_d : 0;

	int i, j, prevrow, thisrow, point;
	float x, y, z;
	float onethird = 1.0 / 3.0;
	float twothirds = 2.0 / 3.0;

	Vector3 start_pos = size * -0.5;

	// set our bounding box

	point = 0;

	// front + back
	y = start_pos.y;
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= subdivide_h + 1; j++) {
		x = start_pos.x;
		for (i = 0; i <= subdivide_w + 1; i++) {
			float u = i;
			float v = j;
			u /= (3.0 * (subdivide_w + 1.0));
			v /= (2.0 * (subdivide_h + 1.0));

			// front
			mesh->add_vertex3(Vector3(x, -y, -start_pos.z)); // double negative on the Z!
			mesh->add_normal(Vector3(0.0, 0.0, 1.0));
			mesh->add_uv(Vector2(u, v));
			point++;

			// back
			mesh->add_vertex3(Vector3(-x, -y, start_pos.z));
			mesh->add_normal(Vector3(0.0, 0.0, -1.0));
			mesh->add_uv(Vector2(twothirds + u, v));
			point++;

			if (i > 0 && j > 0) {
				int i2 = i * 2;

				// front
				mesh->add_index(msi + prevrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);

				// back
				mesh->add_index(msi + prevrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
			};

			x += size.x / (subdivide_w + 1.0);
		};

		y += size.y / (subdivide_h + 1.0);
		prevrow = thisrow;
		thisrow = point;
	};

	// left + right
	y = start_pos.y;
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= (subdivide_h + 1); j++) {
		z = start_pos.z;
		for (i = 0; i <= (subdivide_d + 1); i++) {
			float u = i;
			float v = j;
			u /= (3.0 * (subdivide_d + 1.0));
			v /= (2.0 * (subdivide_h + 1.0));

			// right
			mesh->add_vertex3(Vector3(-start_pos.x, -y, -z));
			mesh->add_normal(Vector3(1.0, 0.0, 0.0));
			mesh->add_uv(Vector2(onethird + u, v));
			point++;

			// left
			mesh->add_vertex3(Vector3(start_pos.x, -y, z));
			mesh->add_normal(Vector3(-1.0, 0.0, 0.0));
			mesh->add_uv(Vector2(u, 0.5 + v));
			point++;

			if (i > 0 && j > 0) {
				int i2 = i * 2;

				// right
				mesh->add_index(msi + prevrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);

				// left
				mesh->add_index(msi + prevrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
			};

			z += size.z / (subdivide_d + 1.0);
		};

		y += size.y / (subdivide_h + 1.0);
		prevrow = thisrow;
		thisrow = point;
	};

	// top + bottom
	z = start_pos.z;
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= (subdivide_d + 1); j++) {
		x = start_pos.x;
		for (i = 0; i <= (subdivide_w + 1); i++) {
			float u = i;
			float v = j;
			u /= (3.0 * (subdivide_w + 1.0));
			v /= (2.0 * (subdivide_d + 1.0));

			// top
			mesh->add_vertex3(Vector3(-x, -start_pos.y, -z));
			mesh->add_normal(Vector3(0.0, 1.0, 0.0));
			mesh->add_uv(Vector2(onethird + u, 0.5 + v));
			point++;

			// bottom
			mesh->add_vertex3(Vector3(x, start_pos.y, -z));
			mesh->add_normal(Vector3(0.0, -1.0, 0.0));
			mesh->add_uv(Vector2(twothirds + u, 0.5 + v));
			point++;

			if (i > 0 && j > 0) {
				int i2 = i * 2;

				// top
				mesh->add_index(msi + prevrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);

				// bottom
				mesh->add_index(msi + prevrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
			};

			x += size.x / (subdivide_w + 1.0);
		};

		z += size.z / (subdivide_d + 1.0);
		prevrow = thisrow;
		thisrow = point;
	};
}

void MeshUtils::create_cylinder(Ref<Mesh> mesh, float top_radius, float bottom_radius, float height, int p_radial_segments, int p_rings) {
	ERR_FAIL_COND(!mesh.is_valid());

	int msi = mesh->get_vertex_count();

	int radial_segments = p_radial_segments > 4 ? p_radial_segments : 4;
	int rings = p_rings > 0 ? p_rings : 0;

	int i, j, prevrow, thisrow, point;
	float x, y, z, u, v, radius;

	point = 0;

	thisrow = 0;
	prevrow = 0;
	const real_t side_normal_y = (bottom_radius - top_radius) / height;
	for (j = 0; j <= (rings + 1); j++) {
		v = j;
		v /= (rings + 1);

		radius = top_radius + ((bottom_radius - top_radius) * v);

		y = height * v;
		y = (height * 0.5) - y;

		for (i = 0; i <= radial_segments; i++) {
			u = i;
			u /= radial_segments;

			x = sin(u * (Math_PI * 2.0));
			z = cos(u * (Math_PI * 2.0));

			Vector3 p = Vector3(x * radius, y, z * radius);
			mesh->add_vertex3(p);
			mesh->add_normal(Vector3(x, side_normal_y, z).normalized());
			mesh->add_uv(Vector2(u, v * 0.5));
			point++;

			if (i > 0 && j > 0) {
				mesh->add_index(msi + prevrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i - 1);

				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i);
				mesh->add_index(msi + thisrow + i - 1);
			};
		};

		prevrow = thisrow;
		thisrow = point;
	};

	// add top
	if (top_radius > 0.0) {
		y = height * 0.5;

		thisrow = point;
		mesh->add_vertex3(Vector3(0.0, y, 0.0));
		mesh->add_normal(Vector3(0.0, 1.0, 0.0));
		mesh->add_uv(Vector2(0.25, 0.75));
		point++;

		for (i = 0; i <= radial_segments; i++) {
			float r = i;
			r /= radial_segments;

			x = sin(r * (Math_PI * 2.0));
			z = cos(r * (Math_PI * 2.0));

			u = ((x + 1.0) * 0.25);
			v = 0.5 + ((z + 1.0) * 0.25);

			Vector3 p = Vector3(x * top_radius, y, z * top_radius);
			mesh->add_vertex3(p);
			mesh->add_normal(Vector3(0.0, 1.0, 0.0));
			mesh->add_uv(Vector2(u, v));
			point++;

			if (i > 0) {
				mesh->add_index(msi + thisrow);
				mesh->add_index(msi + point - 1);
				mesh->add_index(msi + point - 2);
			};
		};
	};

	// add bottom
	if (bottom_radius > 0.0) {
		y = height * -0.5;

		thisrow = point;
		mesh->add_vertex3(Vector3(0.0, y, 0.0));
		mesh->add_normal(Vector3(0.0, -1.0, 0.0));
		mesh->add_uv(Vector2(0.75, 0.75));
		point++;

		for (i = 0; i <= radial_segments; i++) {
			float r = i;
			r /= radial_segments;

			x = sin(r * (Math_PI * 2.0));
			z = cos(r * (Math_PI * 2.0));

			u = 0.5 + ((x + 1.0) * 0.25);
			v = 1.0 - ((z + 1.0) * 0.25);

			Vector3 p = Vector3(x * bottom_radius, y, z * bottom_radius);
			mesh->add_vertex3(p);
			mesh->add_normal(Vector3(0.0, -1.0, 0.0));
			mesh->add_uv(Vector2(u, v));
			point++;

			if (i > 0) {
				mesh->add_index(msi + thisrow);
				mesh->add_index(msi + point - 2);
				mesh->add_index(msi + point - 1);
			};
		};
	};
}

void MeshUtils::create_plane(Ref<Mesh> mesh, Size2 size, int p_subdivide_w, int p_subdivide_d, Vector3 center_offset) {
	ERR_FAIL_COND(!mesh.is_valid());

	int msi = mesh->get_vertex_count();

	int subdivide_w = p_subdivide_w > 0 ? p_subdivide_w : 0;
	int subdivide_d = p_subdivide_d > 0 ? p_subdivide_d : 0;

	int i, j, prevrow, thisrow, point;
	float x, z;

	Size2 start_pos = size * -0.5;

	point = 0;

	// top + bottom
	z = start_pos.y;
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= (subdivide_d + 1); j++) {
		x = start_pos.x;
		for (i = 0; i <= (subdivide_w + 1); i++) {
			float u = i;
			float v = j;
			u /= (subdivide_w + 1.0);
			v /= (subdivide_d + 1.0);

			mesh->add_vertex3(Vector3(-x, 0.0, -z) + center_offset);
			mesh->add_normal(Vector3(0.0, 1.0, 0.0));
			mesh->add_uv(Vector2(1.0 - u, 1.0 - v)); // 1.0 - uv to match orientation with Quad
			point++;

			if (i > 0 && j > 0) {
				mesh->add_index(msi + prevrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i);
				mesh->add_index(msi + thisrow + i - 1);
			};

			x += size.x / (subdivide_w + 1.0);
		};

		z += size.y / (subdivide_d + 1.0);
		prevrow = thisrow;
		thisrow = point;
	};
}

void MeshUtils::create_prism(Ref<Mesh> mesh, float left_to_right, Vector3 size, int p_subdivide_w, int p_subdivide_h, int p_subdivide_d) {
	ERR_FAIL_COND(!mesh.is_valid());

	int msi = mesh->get_vertex_count();

	int subdivide_w = p_subdivide_w > 0 ? p_subdivide_w : 0;
	int subdivide_h = p_subdivide_h > 0 ? p_subdivide_h : 0;
	int subdivide_d = p_subdivide_d > 0 ? p_subdivide_d : 0;

	int i, j, prevrow, thisrow, point;
	float x, y, z;
	float onethird = 1.0 / 3.0;
	float twothirds = 2.0 / 3.0;

	Vector3 start_pos = size * -0.5;

	// set our bounding box

	point = 0;

	// front + back
	y = start_pos.y;
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= (subdivide_h + 1); j++) {
		float scale = (y - start_pos.y) / size.y;
		float scaled_size_x = size.x * scale;
		float start_x = start_pos.x + (1.0 - scale) * size.x * left_to_right;
		float offset_front = (1.0 - scale) * onethird * left_to_right;
		float offset_back = (1.0 - scale) * onethird * (1.0 - left_to_right);

		x = 0.0;
		for (i = 0; i <= (subdivide_w + 1); i++) {
			float u = i;
			float v = j;
			u /= (3.0 * (subdivide_w + 1.0));
			v /= (2.0 * (subdivide_h + 1.0));

			u *= scale;

			// front
			mesh->add_vertex3(Vector3(start_x + x, -y, -start_pos.z)); // double negative on the Z!
			mesh->add_normal(Vector3(0.0, 0.0, 1.0));
			mesh->add_uv(Vector2(offset_front + u, v));
			point++;

			// back
			mesh->add_vertex3(Vector3(start_x + scaled_size_x - x, -y, start_pos.z));
			mesh->add_normal(Vector3(0.0, 0.0, -1.0));
			mesh->add_uv(Vector2(twothirds + offset_back + u, v));
			point++;

			if (i > 0 && j == 1) {
				int i2 = i * 2;

				// front
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);

				// back
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
			} else if (i > 0 && j > 0) {
				int i2 = i * 2;

				// front
				mesh->add_index(msi + prevrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);

				// back
				mesh->add_index(msi + prevrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
			};

			x += scale * size.x / (subdivide_w + 1.0);
		};

		y += size.y / (subdivide_h + 1.0);
		prevrow = thisrow;
		thisrow = point;
	};

	// left + right
	Vector3 normal_left, normal_right;

	normal_left = Vector3(-size.y, size.x * left_to_right, 0.0);
	normal_right = Vector3(size.y, size.x * (1.0 - left_to_right), 0.0);
	normal_left.normalize();
	normal_right.normalize();

	y = start_pos.y;
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= (subdivide_h + 1); j++) {
		float left, right;
		float scale = (y - start_pos.y) / size.y;

		left = start_pos.x + (size.x * (1.0 - scale) * left_to_right);
		right = left + (size.x * scale);

		z = start_pos.z;
		for (i = 0; i <= (subdivide_d + 1); i++) {
			float u = i;
			float v = j;
			u /= (3.0 * (subdivide_d + 1.0));
			v /= (2.0 * (subdivide_h + 1.0));

			// right
			mesh->add_vertex3(Vector3(right, -y, -z));
			mesh->add_normal(normal_right);
			mesh->add_uv(Vector2(onethird + u, v));
			point++;

			// left
			mesh->add_vertex3(Vector3(left, -y, z));
			mesh->add_normal(normal_left);
			mesh->add_uv(Vector2(u, 0.5 + v));
			point++;

			if (i > 0 && j > 0) {
				int i2 = i * 2;

				// right
				mesh->add_index(msi + prevrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);
				mesh->add_index(msi + prevrow + i2);
				mesh->add_index(msi + thisrow + i2);
				mesh->add_index(msi + thisrow + i2 - 2);

				// left
				mesh->add_index(msi + prevrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
				mesh->add_index(msi + prevrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 + 1);
				mesh->add_index(msi + thisrow + i2 - 1);
			};

			z += size.z / (subdivide_d + 1.0);
		};

		y += size.y / (subdivide_h + 1.0);
		prevrow = thisrow;
		thisrow = point;
	};

	// bottom
	z = start_pos.z;
	thisrow = point;
	prevrow = 0;
	for (j = 0; j <= (subdivide_d + 1); j++) {
		x = start_pos.x;
		for (i = 0; i <= (subdivide_w + 1); i++) {
			float u = i;
			float v = j;
			u /= (3.0 * (subdivide_w + 1.0));
			v /= (2.0 * (subdivide_d + 1.0));

			// bottom
			mesh->add_vertex3(Vector3(x, start_pos.y, -z));
			mesh->add_normal(Vector3(0.0, -1.0, 0.0));
			mesh->add_uv(Vector2(twothirds + u, 0.5 + v));
			point++;

			if (i > 0 && j > 0) {
				// bottom
				mesh->add_index(msi + prevrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i);
				mesh->add_index(msi + thisrow + i - 1);
			};

			x += size.x / (subdivide_w + 1.0);
		};

		z += size.z / (subdivide_d + 1.0);
		prevrow = thisrow;
		thisrow = point;
	};
}

void MeshUtils::create_quad(Ref<Mesh> mesh, Size2 size, Vector3 center_offset) {
	ERR_FAIL_COND(!mesh.is_valid());

	Vector2 _size = Vector2(size.x / 2.0f, size.y / 2.0f);

	Vector3 quad_faces[4] = {
		Vector3(-_size.x, -_size.y, 0) + center_offset,
		Vector3(-_size.x, _size.y, 0) + center_offset,
		Vector3(_size.x, _size.y, 0) + center_offset,
		Vector3(_size.x, -_size.y, 0) + center_offset,
	};

	static const int indices[6] = {
		0, 1, 2,
		0, 2, 3
	};

	for (int i = 0; i < 6; i++) {
		int j = indices[i];

		mesh->add_vertex3(quad_faces[j]);
		mesh->add_normal(Vector3(0, 0, 1));

		static const Vector2 quad_uv[4] = {
			Vector2(0, 1),
			Vector2(0, 0),
			Vector2(1, 0),
			Vector2(1, 1),
		};

		mesh->add_uv(quad_uv[j]);
	}
}

void MeshUtils::create_quad_with_indices(Ref<Mesh> mesh, Size2 size, Vector3 center_offset) {
	ERR_FAIL_COND(!mesh.is_valid());

	int msi = mesh->get_vertex_count();

	Vector2 _size = Vector2(size.x / 2.0f, size.y / 2.0f);

	mesh->add_vertex3(Vector3(-_size.x, -_size.y, 0) + center_offset);
	mesh->add_vertex3(Vector3(-_size.x, _size.y, 0) + center_offset);
	mesh->add_vertex3(Vector3(_size.x, _size.y, 0) + center_offset);
	mesh->add_vertex3(Vector3(_size.x, -_size.y, 0) + center_offset);

	mesh->add_normal(Vector3(0, 0, 1));
	mesh->add_normal(Vector3(0, 0, 1));
	mesh->add_normal(Vector3(0, 0, 1));
	mesh->add_normal(Vector3(0, 0, 1));

	mesh->add_uv(Vector2(0, 1));
	mesh->add_uv(Vector2(0, 0));
	mesh->add_uv(Vector2(1, 0));
	mesh->add_uv(Vector2(1, 1));

	mesh->add_triangle(msi, msi + 1, msi + 2);
	mesh->add_triangle(msi, msi + 2, msi + 3);
}

void MeshUtils::create_sphere(Ref<Mesh> mesh, float radius, float height, int p_radial_segments, int p_rings, bool is_hemisphere) {
	ERR_FAIL_COND(!mesh.is_valid());

	int msi = mesh->get_vertex_count();

	int radial_segments = p_radial_segments > 4 ? p_radial_segments : 4;
	int rings = p_rings > 1 ? p_rings : 1;

	int i, j, prevrow, thisrow, point;
	float x, y, z;

	float scale = height * (is_hemisphere ? 1.0 : 0.5);

	// set our bounding box

	point = 0;

	thisrow = 0;
	prevrow = 0;
	for (j = 0; j <= (rings + 1); j++) {
		float v = j;
		float w;

		v /= (rings + 1);
		w = sin(Math_PI * v);
		y = scale * cos(Math_PI * v);

		for (i = 0; i <= radial_segments; i++) {
			float u = i;
			u /= radial_segments;

			x = sin(u * (Math_PI * 2.0));
			z = cos(u * (Math_PI * 2.0));

			if (is_hemisphere && y < 0.0) {
				mesh->add_vertex3(Vector3(x * radius * w, 0.0, z * radius * w));
				mesh->add_normal(Vector3(0.0, -1.0, 0.0));
			} else {
				Vector3 p = Vector3(x * radius * w, y, z * radius * w);
				mesh->add_vertex3(p);
				Vector3 normal = Vector3(x * w * scale, radius * (y / scale), z * w * scale);
				mesh->add_normal(normal.normalized());
			};

			mesh->add_uv(Vector2(u, v));
			point++;

			if (i > 0 && j > 0) {
				mesh->add_index(msi + prevrow + i - 1);
				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i - 1);

				mesh->add_index(msi + prevrow + i);
				mesh->add_index(msi + thisrow + i);
				mesh->add_index(msi + thisrow + i - 1);
			};
		};

		prevrow = thisrow;
		thisrow = point;
	};
}

void MeshUtils::create_point(Ref<Mesh> mesh) {
	ERR_FAIL_COND(!mesh.is_valid());

	//TODO This should set mesh type instead

	int msi = mesh->get_vertex_count();

	Vector2 _size = Vector2(0.01, 0.01);

	mesh->add_vertex3(Vector3(0, -_size.y, 0));
	mesh->add_vertex3(Vector3(-_size.x, _size.y, 0));
	mesh->add_vertex3(Vector3(_size.x, _size.y, 0));

	mesh->add_normal(Vector3(0, 0, 1));
	mesh->add_normal(Vector3(0, 0, 1));
	mesh->add_normal(Vector3(0, 0, 1));

	mesh->add_uv(Vector2(0.5, 1));
	mesh->add_uv(Vector2(0, 0));
	mesh->add_uv(Vector2(1, 0));

	mesh->add_triangle(msi, msi + 1, msi + 2);
}
#line 0

#line 1 "sfw/render_core/shortcut.cpp"
/*************************************************************************/
/*  shortcut.cpp                                                         */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

void ShortCut::set_shortcut(const Ref<InputEvent> &p_shortcut) {
	shortcut = p_shortcut;
	emit_changed();
}

Ref<InputEvent> ShortCut::get_shortcut() const {
	return shortcut;
}

bool ShortCut::is_shortcut(const Ref<InputEvent> &p_event) const {
	return shortcut.is_valid() && shortcut->shortcut_match(p_event);
}

String ShortCut::get_as_text() const {
	if (shortcut.is_valid()) {
		return shortcut->as_text();
	} else {
		return "None";
	}
}

bool ShortCut::is_valid() const {
	return shortcut.is_valid();
}

ShortCut::ShortCut() {
}

ShortCut::~ShortCut() {
}
#line 0

#line 1 "sfw/render_core/material.cpp"

void Material::bind() {
	if (!shader) {
		shader = ShaderCache::get_singleton()->get_shader(get_material_id());

		if (!shader) {
			shader = memnew(Shader());

			shader->set_vertex_shader_source(get_vertex_shader_source());
			shader->set_fragment_shader_source(get_fragment_shader_source());

			shader->compile();

			ShaderCache::get_singleton()->add_shader(get_material_id(), shader);
		}

		setup_uniforms();
	}

	if (current_material && current_material != this) {
		current_material->unbind();

		setup_state();
	}

	current_material = this;

	shader->bind();

	bind_uniforms();
}

void Material::unbind() {
}
void Material::bind_uniforms() {
}
void Material::setup_uniforms() {
}
void Material::setup_state() {
}

int32_t Material::get_uniform(const String &name) {
	int32_t uniform = glGetUniformLocation(shader->program, name.utf8().get_data());

	if (uniform == -1) {
		ERR_PRINT(name + " is not a valid glsl program variable!\n");
	}

	return uniform;
}

Material::Material() {
	shader = NULL;
}
Material::~Material() {
	if (current_material == this) {
		unbind();
		current_material = NULL;
	}
}

void Material::set_uniform(int32_t p_uniform, const Transform &p_transform) {
	const Transform &tr = p_transform;

	GLfloat matrix[16] = { /* build a 16x16 matrix */
		tr.basis.rows[0][0],
		tr.basis.rows[1][0],
		tr.basis.rows[2][0],
		0,
		tr.basis.rows[0][1],
		tr.basis.rows[1][1],
		tr.basis.rows[2][1],
		0,
		tr.basis.rows[0][2],
		tr.basis.rows[1][2],
		tr.basis.rows[2][2],
		0,
		tr.origin.x,
		tr.origin.y,
		tr.origin.z,
		1
	};

	glUniformMatrix4fv(p_uniform, 1, false, matrix);
}

void Material::set_uniform(int32_t p_uniform, const Transform2D &p_transform) {
	const Transform2D &tr = p_transform;

	GLfloat matrix[16] = { /* build a 16x16 matrix */
		tr.columns[0][0],
		tr.columns[0][1],
		0,
		0,
		tr.columns[1][0],
		tr.columns[1][1],
		0,
		0,
		0,
		0,
		1,
		0,
		tr.columns[2][0],
		tr.columns[2][1],
		0,
		1
	};

	glUniformMatrix4fv(p_uniform, 1, false, matrix);
}

void Material::set_uniform(int32_t p_uniform, const Projection &p_matrix) {
	GLfloat matrix[16];

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			matrix[i * 4 + j] = p_matrix.matrix[i][j];
		}
	}

	glUniformMatrix4fv(p_uniform, 1, false, matrix);
}

Material *Material::current_material = NULL;
#line 0

#line 1 "sfw/render_core/color_material_2d.cpp"

void ColorMaterial2D::bind_uniforms() {
	set_uniform(projection_matrix_location, RenderState::projection_matrix_2d);
	set_uniform(model_view_matrix_location, RenderState::model_view_matrix_2d);
}

void ColorMaterial2D::setup_uniforms() {
	projection_matrix_location = get_uniform("u_proj_matrix");
	model_view_matrix_location = get_uniform("u_model_view_matrix");
}

void ColorMaterial2D::unbind() {
	glDisable(GL_TEXTURE_2D);
}

void ColorMaterial2D::setup_state() {
	glEnable(GL_TEXTURE_2D);
}

String ColorMaterial2D::get_vertex_shader_source() {
	static const char *vertex_shader_source[] = {
#if defined(__APPLE__)
#else
		"#version 100\n"
		"precision mediump float;\n"
#endif
		"uniform mat4 u_proj_matrix;\n"
		"uniform mat4 u_model_view_matrix;\n"
		"\n"
		"attribute vec4 a_position;\n"
		"attribute vec4 a_color;\n"
		"\n"
		"varying vec4 v_color;\n"
		"\n"
		"void main() {\n"
		"  v_color = a_color;\n"
		"  gl_Position = u_proj_matrix * u_model_view_matrix * a_position;\n"
		"}"
	};

	return String(*vertex_shader_source);
}

String ColorMaterial2D::get_fragment_shader_source() {
	static const char *fragment_shader_source[] = {
#ifndef __APPLE__
		"#version 100\n"
		"#ifdef GL_ES\n"
		"    precision mediump float;\n"
		"#endif\n"
#endif
		"varying vec4 v_color;\n"
		"\n"
		"void main() {\n"
		"  gl_FragColor = v_color;\n"
		"}"
	};

	return String(*fragment_shader_source);
}

ColorMaterial2D::ColorMaterial2D() {
	projection_matrix_location = 0;
	model_view_matrix_location = 0;
}
#line 0

#line 1 "sfw/render_core/color_material.cpp"

void ColorMaterial::bind_uniforms() {
	set_uniform(projection_matrix_location, RenderState::projection_matrix_3d);
	set_uniform(camera_matrix_location, RenderState::camera_transform_3d);
	set_uniform(model_view_matrix_location, RenderState::model_view_matrix_3d);
}

void ColorMaterial::setup_uniforms() {
	projection_matrix_location = get_uniform("u_proj_matrix");
	camera_matrix_location = get_uniform("u_camera_matrix");
	model_view_matrix_location = get_uniform("u_model_view_matrix");
}

String ColorMaterial::get_vertex_shader_source() {
	static const char *vertex_shader_source[] = {
#if defined(__APPLE__)
#else
		"#version 100\n"
		"precision mediump float;\n"
#endif
		"uniform mat4 u_proj_matrix;\n"
		"uniform mat4 u_camera_matrix;\n"
		"uniform mat4 u_model_view_matrix;\n"
		"\n"
		"attribute vec4 a_position;\n"
		"attribute vec4 a_color;\n"
		"\n"
		"varying vec4 v_color;\n"
		"\n"
		"void main() {\n"
		"   v_color = a_color;\n"
		"   gl_Position = u_proj_matrix * u_camera_matrix * u_model_view_matrix * a_position;\n"
		"}\n"
	};

	return String(*vertex_shader_source);
}

String ColorMaterial::get_fragment_shader_source() {
	static const char *fragment_shader_source[] = {
#ifndef __APPLE__
		"#version 100\n"
		"#ifdef GL_ES\n"
		"    precision mediump float;\n"
		"#endif\n"
#endif
		"varying vec4 v_color;\n"
		"\n"
		"void main() { gl_FragColor = v_color; }\n"
	};

	return String(*fragment_shader_source);
}

ColorMaterial::ColorMaterial() {
	projection_matrix_location = 0;
	camera_matrix_location = 0;
	model_view_matrix_location = 0;
}
#line 0

#line 1 "sfw/render_core/colored_material.cpp"

void ColoredMaterial::bind_uniforms() {
	set_uniform(projection_matrix_location, RenderState::projection_matrix_3d);
	set_uniform(model_view_matrix_location, RenderState::model_view_matrix_3d);

	glUniform4f(tri_color_uniform_location, color.r, color.g, color.b, color.a);
}

void ColoredMaterial::setup_uniforms() {
	projection_matrix_location = get_uniform("u_proj_matrix");
	model_view_matrix_location = get_uniform("u_model_view_matrix");

	tri_color_uniform_location = get_uniform("fragment_color");
}

String ColoredMaterial::get_vertex_shader_source() {
	static const char *vertex_shader_source[] = {
#if defined(__APPLE__)
#else
		"#version 100\n"
		"precision mediump float;\n"
#endif
		"uniform mat4 u_proj_matrix;\n"
		"uniform mat4 u_model_view_matrix;\n"
		"\n"
		"attribute vec4 a_position;\n"
		"\n"
		"void main() {\n"
		"  gl_Position = u_proj_matrix * u_model_view_matrix * a_position;\n"
		"}"
	};

	return String(*vertex_shader_source);
}

String ColoredMaterial::get_fragment_shader_source() {
	static const char *fragment_shader_source[] = {
#ifndef __APPLE__
		"#version 100\n"
		"#ifdef GL_ES\n"
		"    precision mediump float;\n"
		"#endif\n"
#endif
		"\n"
		"uniform vec4 fragment_color;\n"
		"\n"
		"void main() {\n"
		"  gl_FragColor = fragment_color;\n"
		"}"
	};

	return String(*fragment_shader_source);
}

ColoredMaterial::ColoredMaterial() {
}
#line 0

#line 1 "sfw/render_core/font_material.cpp"

void FontMaterial::bind_uniforms() {
	set_uniform(projection_matrix_location, RenderState::projection_matrix_2d);
	set_uniform(model_view_matrix_location, RenderState::model_view_matrix_2d);

	if (texture.is_valid()) {
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture->get_gl_texture());
		glUniform1i(texture_location, 0);
	}
}

void FontMaterial::setup_uniforms() {
	projection_matrix_location = get_uniform("u_proj_matrix");
	model_view_matrix_location = get_uniform("u_model_view_matrix");

	texture_location = get_uniform("u_texture");
}

void FontMaterial::unbind() {
	glDisable(GL_TEXTURE_2D);
}

void FontMaterial::setup_state() {
	glEnable(GL_TEXTURE_2D);
}

String FontMaterial::get_vertex_shader_source() {
	static const char *vertex_shader_source[] = {
#if defined(__APPLE__)
#else
		"#version 100\n"
		"precision mediump float;\n"
#endif
		"uniform mat4 u_proj_matrix;\n"
		"uniform mat4 u_model_view_matrix;\n"
		"\n"
		"attribute vec4 a_position;\n"
		"attribute vec2 a_uv;\n"
		"attribute vec4 a_color;\n"
		"\n"
		"varying vec2 v_uv;\n"
		"varying vec4 v_color;\n"
		"\n"
		"void main() {\n"
		"  v_uv = a_uv;\n"
		"  v_color = a_color;\n"
		"  gl_Position = u_proj_matrix * u_model_view_matrix * a_position;\n"
		"}"
	};

	return String(*vertex_shader_source);
}

String FontMaterial::get_fragment_shader_source() {
	static const char *fragment_shader_source[] = {
#ifndef __APPLE__
		"#version 100\n"
		"#ifdef GL_ES\n"
		"    precision mediump float;\n"
		"#endif\n"
#endif
		"\n"
		"uniform sampler2D u_texture;\n"
		"\n"
		"varying vec2 v_uv;\n"
		"varying vec4 v_color;\n"
		"\n"
		"void main() {\n"
		"  vec4 col = texture2D(u_texture, v_uv);\n"
		"\n"
		"  if (col.r < 0.5) {\n"
		"    discard;\n"
		"  }\n"
		"\n"
		"  gl_FragColor = col * v_color;\n"
		"}"
	};

	return String(*fragment_shader_source);
}

FontMaterial::FontMaterial() {
	projection_matrix_location = 0;
	model_view_matrix_location = 0;

	texture_location = 0;
}
#line 0

#line 1 "sfw/render_core/texture_material_2d.cpp"

void TextureMaterial2D::bind_uniforms() {
	set_uniform(projection_matrix_location, RenderState::projection_matrix_2d);
	set_uniform(model_view_matrix_location, RenderState::model_view_matrix_2d);

	if (texture.is_valid()) {
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture->get_gl_texture());
		glUniform1i(texture_location, 0);
	}
}

void TextureMaterial2D::setup_uniforms() {
	projection_matrix_location = get_uniform("u_proj_matrix");
	model_view_matrix_location = get_uniform("u_model_view_matrix");

	texture_location = get_uniform("u_texture");
}

void TextureMaterial2D::unbind() {
	glDisable(GL_TEXTURE_2D);
}

void TextureMaterial2D::setup_state() {
	glEnable(GL_TEXTURE_2D);
}

String TextureMaterial2D::get_vertex_shader_source() {
	static const char *vertex_shader_source[] = {
#if defined(__APPLE__)
#else
		"#version 100\n"
		"precision mediump float;\n"
#endif
		"uniform mat4 u_proj_matrix;\n"
		"uniform mat4 u_model_view_matrix;\n"
		"\n"
		"attribute vec4 a_position;\n"
		"attribute vec2 a_uv;\n"
		"\n"
		"varying vec2 v_uv;\n"
		"\n"
		"void main() {\n"
		"  v_uv = a_uv;\n"
		"  gl_Position = u_proj_matrix * u_model_view_matrix * a_position;\n"
		"}"
	};

	return String(*vertex_shader_source);
}

String TextureMaterial2D::get_fragment_shader_source() {
	static const char *fragment_shader_source[] = {
#ifndef __APPLE__
		"#version 100\n"
		"#ifdef GL_ES\n"
		"    precision mediump float;\n"
		"#endif\n"
#endif
		"\n"
		"uniform sampler2D u_texture;\n"
		"\n"
		"varying vec2 v_uv;\n"
		"\n"
		"void main() {\n"
		"  vec4 col = texture2D(u_texture, v_uv);\n"
		"\n"
		"  if (col.a < 0.1) {\n"
		"    discard;\n"
		"  }\n"
		"\n"
		"  gl_FragColor = col;\n"
		"}"
	};

	return String(*fragment_shader_source);
}

TextureMaterial2D::TextureMaterial2D() {
	projection_matrix_location = 0;
	model_view_matrix_location = 0;

	texture_location = 0;
}
#line 0

#line 1 "sfw/render_core/texture_material.cpp"

void TextureMaterial::bind_uniforms() {
	set_uniform(projection_matrix_location, RenderState::projection_matrix_3d);
	set_uniform(camera_matrix_location, RenderState::camera_transform_3d);
	set_uniform(model_view_matrix_location, RenderState::model_view_matrix_3d);

	if (texture.is_valid()) {
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture->get_gl_texture());
		glUniform1i(texture_location, 0);
	}
}

void TextureMaterial::setup_uniforms() {
	projection_matrix_location = get_uniform("u_proj_matrix");
	camera_matrix_location = get_uniform("u_camera_matrix");
	model_view_matrix_location = get_uniform("u_model_view_matrix");

	texture_location = get_uniform("u_texture");
}

void TextureMaterial::unbind() {
	glDisable(GL_TEXTURE_2D);
}

void TextureMaterial::setup_state() {
	glEnable(GL_TEXTURE_2D);
}

String TextureMaterial::get_vertex_shader_source() {
	static const char *vertex_shader_source[] = {
#if defined(__APPLE__)
#else
		"#version 100\n"
		"precision mediump float;\n"
#endif
		"uniform mat4 u_proj_matrix;\n"
		"uniform mat4 u_camera_matrix;\n"
		"uniform mat4 u_model_view_matrix;\n"
		"\n"
		"attribute vec4 a_position;\n"
		"attribute vec2 a_uv;\n"
		"\n"
		"varying vec2 v_uv;\n"
		"\n"
		"void main() {\n"
		"  v_uv = a_uv;\n"
		"  gl_Position = u_proj_matrix * u_camera_matrix * u_model_view_matrix * a_position;\n"
		"}"
	};

	return String(*vertex_shader_source);
}

String TextureMaterial::get_fragment_shader_source() {
	static const char *fragment_shader_source[] = {
#ifndef __APPLE__
		"#version 100\n"
		"#ifdef GL_ES\n"
		"    precision mediump float;\n"
		"#endif\n"
#endif
		"uniform sampler2D u_texture;\n"
		"\n"
		"varying vec2 v_uv;\n"
		"\n"
		"void main() {\n"
		"  gl_FragColor = texture2D(u_texture, v_uv);\n"
		"}"
	};

	return String(*fragment_shader_source);
}

TextureMaterial::TextureMaterial() {
	projection_matrix_location = 0;
	camera_matrix_location = 0;
	model_view_matrix_location = 0;

	texture_location = 0;
}
#line 0

#line 1 "sfw/render_core/transparent_texture_material.cpp"

void TransparentTextureMaterial::bind_uniforms() {
	set_uniform(projection_matrix_location, RenderState::projection_matrix_3d);
	set_uniform(model_view_matrix_location, RenderState::model_view_matrix_3d);

	if (texture.is_valid()) {
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture->get_gl_texture());
		glUniform1i(texture_location, 0);
	}
}

void TransparentTextureMaterial::setup_uniforms() {
	projection_matrix_location = get_uniform("u_proj_matrix");
	model_view_matrix_location = get_uniform("u_model_view_matrix");

	texture_location = get_uniform("u_texture");
}

void TransparentTextureMaterial::unbind() {
	glDisable(GL_TEXTURE_2D);
}

void TransparentTextureMaterial::setup_state() {
	glEnable(GL_TEXTURE_2D);
}

String TransparentTextureMaterial::get_vertex_shader_source() {
	static const char *vertex_shader_source[] = {
#if defined(__APPLE__)
#else
		"#version 100\n"
		"precision mediump float;\n"
#endif
		"uniform mat4 u_proj_matrix;\n"
		"uniform mat4 u_model_view_matrix;\n"
		"\n"
		"attribute vec4 a_position;\n"
		"attribute vec2 a_uv;\n"
		"\n"
		"varying vec2 v_uv;\n"
		"\n"
		"void main() {\n"
		"  v_uv = a_uv;\n"
		"  gl_Position = u_proj_matrix * u_model_view_matrix * a_position;\n"
		"}"
	};

	return String(*vertex_shader_source);
}

String TransparentTextureMaterial::get_fragment_shader_source() {
	static const char *fragment_shader_source[] = {
#ifndef __APPLE__
		"#version 100\n"
		"#ifdef GL_ES\n"
		"    precision mediump float;\n"
		"#endif\n"
#endif
		"uniform sampler2D u_texture;\n"
		"\n"
		"varying vec2 v_uv;\n"
		"\n"
		"void main() {\n"
		"  vec4 col = texture2D(u_texture, v_uv);\n"
		"\n"
		"  if (col.a < 0.1) {\n"
		"    discard;\n"
		"  }\n"
		"\n"
		"  gl_FragColor = col;\n"
		"}"
	};

	return String(*fragment_shader_source);
}

TransparentTextureMaterial::TransparentTextureMaterial() {
	texture_location = 0;
}
#line 0

#line 1 "sfw/render_core/colored_texture_material_2d.cpp"

void ColoredTextureMaterial2D::bind_uniforms() {
	set_uniform(projection_matrix_location, RenderState::projection_matrix_2d);
	set_uniform(model_view_matrix_location, RenderState::model_view_matrix_2d);

	if (texture.is_valid()) {
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture->get_gl_texture());
		glUniform1i(texture_location, 0);
	}
}

void ColoredTextureMaterial2D::setup_uniforms() {
	projection_matrix_location = get_uniform("u_proj_matrix");
	model_view_matrix_location = get_uniform("u_model_view_matrix");

	texture_location = get_uniform("u_texture");
}

void ColoredTextureMaterial2D::unbind() {
	glDisable(GL_TEXTURE_2D);
}

void ColoredTextureMaterial2D::setup_state() {
	glEnable(GL_TEXTURE_2D);
}

String ColoredTextureMaterial2D::get_vertex_shader_source() {
	static const char *vertex_shader_source[] = {
#if defined(__APPLE__)
#else
		"#version 100\n"
		"precision mediump float;\n"
#endif
		"uniform mat4 u_proj_matrix;\n"
		"uniform mat4 u_model_view_matrix;\n"
		"\n"
		"attribute vec4 a_position;\n"
		"attribute vec2 a_uv;\n"
		"attribute vec4 a_color;\n"
		"\n"
		"varying vec4 v_color;\n"
		"varying vec2 v_uv;\n"
		"\n"
		"void main() {\n"
		"  v_uv = a_uv;\n"
		"  v_color = a_color;\n"
		"  gl_Position = u_proj_matrix * u_model_view_matrix * a_position;\n"
		"}"
	};

	return String(*vertex_shader_source);
}

String ColoredTextureMaterial2D::get_fragment_shader_source() {
	static const char *fragment_shader_source[] = {
#ifndef __APPLE__
		"#version 100\n"
		"#ifdef GL_ES\n"
		"    precision mediump float;\n"
		"#endif\n"
#endif
		"\n"
		"uniform sampler2D u_texture;\n"
		"\n"
		"varying vec4 v_color;\n"
		"varying vec2 v_uv;\n"
		"\n"
		"void main() {\n"
		"  vec4 col = texture2D(u_texture, v_uv);\n"
		"\n"
		"  if (col.a < 0.1) {\n"
		"    discard;\n"
		"  }\n"
		"\n"
		"  gl_FragColor = col * v_color;\n"
		"}"
	};

	return String(*fragment_shader_source);
}

ColoredTextureMaterial2D::ColoredTextureMaterial2D() {
	projection_matrix_location = 0;
	model_view_matrix_location = 0;

	texture_location = 0;
}
#line 0

#line 1 "sfw/render_core/image.cpp"
/*************************************************************************/
/*  image.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

const char *Image::format_names[Image::FORMAT_MAX] = {
	"Lum8", // luminance
	"LumAlpha8", // luminance-alpha
	"Red8",
	"RedGreen",
	"RGB8",
	"RGBA8",
	"RGBA4444",
	"RGBA5551",
	"RFloat", // float
	"RGFloat",
	"RGBFloat",
	"RGBAFloat",
};

void Image::_put_pixelb(int p_x, int p_y, uint32_t p_pixel_size, uint8_t *p_data, const uint8_t *p_pixel) {
	uint32_t ofs = (p_y * width + p_x) * p_pixel_size;
	memcpy(p_data + ofs, p_pixel, p_pixel_size);
}

void Image::_get_pixelb(int p_x, int p_y, uint32_t p_pixel_size, const uint8_t *p_data, uint8_t *p_pixel) {
	uint32_t ofs = (p_y * width + p_x) * p_pixel_size;
	memcpy(p_pixel, p_data + ofs, p_pixel_size);
}

int Image::get_format_pixel_size(Format p_format) {
	switch (p_format) {
		case FORMAT_L8:
			return 1; // luminance
		case FORMAT_LA8:
			return 2; // luminance-alpha
		case FORMAT_R8:
			return 1;
		case FORMAT_RG8:
			return 2;
		case FORMAT_RGB8:
			return 3;
		case FORMAT_RGBA8:
			return 4;
		case FORMAT_RGBA4444:
			return 2;
		case FORMAT_RGBA5551:
			return 2;
		case FORMAT_RF:
			return 4; // float
		case FORMAT_RGF:
			return 8;
		case FORMAT_RGBF:
			return 12;
		case FORMAT_RGBAF:
			return 16;

		case FORMAT_MAX: {
		}
	}
	return 0;
}

void Image::get_format_min_pixel_size(Format p_format, int &r_w, int &r_h) {
	r_w = 1;
	r_h = 1;
}

int Image::get_format_pixel_rshift(Format p_format) {
	return 0;
}

int Image::get_format_block_size(Format p_format) {
	return 1;
}

void Image::_get_mipmap_offset_and_size(int p_mipmap, int &r_offset, int &r_width, int &r_height) const {
	int w = width;
	int h = height;
	int ofs = 0;

	int pixel_size = get_format_pixel_size(format);
	int pixel_rshift = get_format_pixel_rshift(format);
	int block = get_format_block_size(format);
	int minw, minh;
	get_format_min_pixel_size(format, minw, minh);

	for (int i = 0; i < p_mipmap; i++) {
		int bw = w % block != 0 ? w + (block - w % block) : w;
		int bh = h % block != 0 ? h + (block - h % block) : h;

		int s = bw * bh;

		s *= pixel_size;
		s >>= pixel_rshift;
		ofs += s;
		w = MAX(minw, w >> 1);
		h = MAX(minh, h >> 1);
	}

	r_offset = ofs;
	r_width = w;
	r_height = h;
}

int Image::get_mipmap_offset(int p_mipmap) const {
	ERR_FAIL_INDEX_V(p_mipmap, get_mipmap_count() + 1, -1);

	int ofs, w, h;
	_get_mipmap_offset_and_size(p_mipmap, ofs, w, h);
	return ofs;
}

void Image::get_mipmap_offset_and_size(int p_mipmap, int &r_ofs, int &r_size) const {
	int ofs, w, h;
	_get_mipmap_offset_and_size(p_mipmap, ofs, w, h);
	int ofs2;
	_get_mipmap_offset_and_size(p_mipmap + 1, ofs2, w, h);
	r_ofs = ofs;
	r_size = ofs2 - ofs;
}

void Image::get_mipmap_offset_size_and_dimensions(int p_mipmap, int &r_ofs, int &r_size, int &w, int &h) const {
	int ofs;
	_get_mipmap_offset_and_size(p_mipmap, ofs, w, h);
	int ofs2, w2, h2;
	_get_mipmap_offset_and_size(p_mipmap + 1, ofs2, w2, h2);
	r_ofs = ofs;
	r_size = ofs2 - ofs;
}

int Image::get_width() const {
	return width;
}

int Image::get_height() const {
	return height;
}

Vector2 Image::get_size() const {
	return Vector2(width, height);
}

bool Image::has_mipmaps() const {
	return mipmaps;
}

int Image::get_mipmap_count() const {
	if (mipmaps) {
		return get_image_required_mipmaps(width, height, format);
	} else {
		return 0;
	}
}

// using template generates perfectly optimized code due to constant expression reduction and unused variable removal present in all compilers
template <uint32_t read_bytes, bool read_alpha, uint32_t write_bytes, bool write_alpha, bool read_gray, bool write_gray>
static void _convert(int p_width, int p_height, const uint8_t *p_src, uint8_t *p_dst) {
	uint32_t max_bytes = MAX(read_bytes, write_bytes);

	for (int y = 0; y < p_height; y++) {
		for (int x = 0; x < p_width; x++) {
			const uint8_t *rofs = &p_src[((y * p_width) + x) * (read_bytes + (read_alpha ? 1 : 0))];
			uint8_t *wofs = &p_dst[((y * p_width) + x) * (write_bytes + (write_alpha ? 1 : 0))];

			uint8_t rgba[4];

			if (read_gray) {
				rgba[0] = rofs[0];
				rgba[1] = rofs[0];
				rgba[2] = rofs[0];
			} else {
				for (uint32_t i = 0; i < max_bytes; i++) {
					rgba[i] = (i < read_bytes) ? rofs[i] : 0;
				}
			}

			if (read_alpha || write_alpha) {
				rgba[3] = read_alpha ? rofs[read_bytes] : 255;
			}

			if (write_gray) {
				// TODO: not correct grayscale, should use fixed point version of actual weights
				wofs[0] = uint8_t((uint16_t(rofs[0]) + uint16_t(rofs[1]) + uint16_t(rofs[2])) / 3);
			} else {
				for (uint32_t i = 0; i < write_bytes; i++) {
					wofs[i] = rgba[i];
				}
			}

			if (write_alpha) {
				wofs[write_bytes] = rgba[3];
			}
		}
	}
}

void Image::convert(Format p_new_format) {
	if (data.size() == 0) {
		return;
	}

	if (p_new_format == format) {
		return;
	}

	ERR_FAIL_COND_MSG(write_lock, "Cannot convert image when it is locked.");

	if (format > FORMAT_RGBA8 || p_new_format > FORMAT_RGBA8) {
		// use put/set pixel which is slower but works with non byte formats
		Image new_img(width, height, false, p_new_format);
		lock();
		new_img.lock();

		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				new_img.set_pixel(i, j, get_pixel(i, j));
			}
		}

		unlock();
		new_img.unlock();

		if (has_mipmaps()) {
			new_img.generate_mipmaps();
		}

		_copy_internals_from(new_img);

		return;
	}

	Image new_img(width, height, false, p_new_format);

	write_lock = true;
	const uint8_t *rptr = data.ptr();
	uint8_t *wptr = new_img.data.ptrw();

	int conversion_type = format | p_new_format << 8;

	switch (conversion_type) {
		case FORMAT_L8 | (FORMAT_LA8 << 8):
			_convert<1, false, 1, true, true, true>(width, height, rptr, wptr);
			break;
		case FORMAT_L8 | (FORMAT_R8 << 8):
			_convert<1, false, 1, false, true, false>(width, height, rptr, wptr);
			break;
		case FORMAT_L8 | (FORMAT_RG8 << 8):
			_convert<1, false, 2, false, true, false>(width, height, rptr, wptr);
			break;
		case FORMAT_L8 | (FORMAT_RGB8 << 8):
			_convert<1, false, 3, false, true, false>(width, height, rptr, wptr);
			break;
		case FORMAT_L8 | (FORMAT_RGBA8 << 8):
			_convert<1, false, 3, true, true, false>(width, height, rptr, wptr);
			break;
		case FORMAT_LA8 | (FORMAT_L8 << 8):
			_convert<1, true, 1, false, true, true>(width, height, rptr, wptr);
			break;
		case FORMAT_LA8 | (FORMAT_R8 << 8):
			_convert<1, true, 1, false, true, false>(width, height, rptr, wptr);
			break;
		case FORMAT_LA8 | (FORMAT_RG8 << 8):
			_convert<1, true, 2, false, true, false>(width, height, rptr, wptr);
			break;
		case FORMAT_LA8 | (FORMAT_RGB8 << 8):
			_convert<1, true, 3, false, true, false>(width, height, rptr, wptr);
			break;
		case FORMAT_LA8 | (FORMAT_RGBA8 << 8):
			_convert<1, true, 3, true, true, false>(width, height, rptr, wptr);
			break;
		case FORMAT_R8 | (FORMAT_L8 << 8):
			_convert<1, false, 1, false, false, true>(width, height, rptr, wptr);
			break;
		case FORMAT_R8 | (FORMAT_LA8 << 8):
			_convert<1, false, 1, true, false, true>(width, height, rptr, wptr);
			break;
		case FORMAT_R8 | (FORMAT_RG8 << 8):
			_convert<1, false, 2, false, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_R8 | (FORMAT_RGB8 << 8):
			_convert<1, false, 3, false, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_R8 | (FORMAT_RGBA8 << 8):
			_convert<1, false, 3, true, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RG8 | (FORMAT_L8 << 8):
			_convert<2, false, 1, false, false, true>(width, height, rptr, wptr);
			break;
		case FORMAT_RG8 | (FORMAT_LA8 << 8):
			_convert<2, false, 1, true, false, true>(width, height, rptr, wptr);
			break;
		case FORMAT_RG8 | (FORMAT_R8 << 8):
			_convert<2, false, 1, false, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RG8 | (FORMAT_RGB8 << 8):
			_convert<2, false, 3, false, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RG8 | (FORMAT_RGBA8 << 8):
			_convert<2, false, 3, true, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RGB8 | (FORMAT_L8 << 8):
			_convert<3, false, 1, false, false, true>(width, height, rptr, wptr);
			break;
		case FORMAT_RGB8 | (FORMAT_LA8 << 8):
			_convert<3, false, 1, true, false, true>(width, height, rptr, wptr);
			break;
		case FORMAT_RGB8 | (FORMAT_R8 << 8):
			_convert<3, false, 1, false, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RGB8 | (FORMAT_RG8 << 8):
			_convert<3, false, 2, false, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RGB8 | (FORMAT_RGBA8 << 8):
			_convert<3, false, 3, true, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RGBA8 | (FORMAT_L8 << 8):
			_convert<3, true, 1, false, false, true>(width, height, rptr, wptr);
			break;
		case FORMAT_RGBA8 | (FORMAT_LA8 << 8):
			_convert<3, true, 1, true, false, true>(width, height, rptr, wptr);
			break;
		case FORMAT_RGBA8 | (FORMAT_R8 << 8):
			_convert<3, true, 1, false, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RGBA8 | (FORMAT_RG8 << 8):
			_convert<3, true, 2, false, false, false>(width, height, rptr, wptr);
			break;
		case FORMAT_RGBA8 | (FORMAT_RGB8 << 8):
			_convert<3, true, 3, false, false, false>(width, height, rptr, wptr);
			break;
	}

	write_lock = false;

	bool gen_mipmaps = mipmaps;

	_copy_internals_from(new_img);

	if (gen_mipmaps) {
		generate_mipmaps();
	}
}

Image::Format Image::get_format() const {
	return format;
}

static double _bicubic_interp_kernel(double x) {
	x = ABS(x);

	double bc = 0;

	if (x <= 1) {
		bc = (1.5 * x - 2.5) * x * x + 1;
	} else if (x < 2) {
		bc = ((-0.5 * x + 2.5) * x - 4) * x + 2;
	}

	return bc;
}

template <int CC, class T>
static void _scale_cubic(const uint8_t *__restrict p_src, uint8_t *__restrict p_dst, uint32_t p_src_width, uint32_t p_src_height, uint32_t p_dst_width, uint32_t p_dst_height) {
	// get source image size
	int width = p_src_width;
	int height = p_src_height;
	double xfac = (double)width / p_dst_width;
	double yfac = (double)height / p_dst_height;
	// coordinates of source points and coefficients
	double ox, oy, dx, dy, k1, k2;
	int ox1, oy1, ox2, oy2;
	// destination pixel values
	// width and height decreased by 1
	int ymax = height - 1;
	int xmax = width - 1;
	// temporary pointer

	for (uint32_t y = 0; y < p_dst_height; y++) {
		// Y coordinates
		oy = (double)y * yfac - 0.5f;
		oy1 = (int)oy;
		dy = oy - (double)oy1;

		for (uint32_t x = 0; x < p_dst_width; x++) {
			// X coordinates
			ox = (double)x * xfac - 0.5f;
			ox1 = (int)ox;
			dx = ox - (double)ox1;

			// initial pixel value

			T *__restrict dst = ((T *)p_dst) + (y * p_dst_width + x) * CC;

			double color[CC];
			for (int i = 0; i < CC; i++) {
				color[i] = 0;
			}

			for (int n = -1; n < 3; n++) {
				// get Y coefficient
				k1 = _bicubic_interp_kernel(dy - (double)n);

				oy2 = oy1 + n;
				if (oy2 < 0) {
					oy2 = 0;
				}
				if (oy2 > ymax) {
					oy2 = ymax;
				}

				for (int m = -1; m < 3; m++) {
					// get X coefficient
					k2 = k1 * _bicubic_interp_kernel((double)m - dx);

					ox2 = ox1 + m;
					if (ox2 < 0) {
						ox2 = 0;
					}
					if (ox2 > xmax) {
						ox2 = xmax;
					}

					// get pixel of original image
					const T *__restrict p = ((T *)p_src) + (oy2 * p_src_width + ox2) * CC;

					for (int i = 0; i < CC; i++) {
						if (sizeof(T) == 2) { // half float
							color[i] = Math::half_to_float(p[i]);
						} else {
							color[i] += p[i] * k2;
						}
					}
				}
			}

			for (int i = 0; i < CC; i++) {
				if (sizeof(T) == 1) { // byte
					dst[i] = CLAMP(Math::fast_ftoi(color[i]), 0, 255);
				} else if (sizeof(T) == 2) { // half float
					dst[i] = Math::make_half_float(color[i]);
				} else {
					dst[i] = color[i];
				}
			}
		}
	}
}

template <int CC, class T>
static void _scale_bilinear(const uint8_t *__restrict p_src, uint8_t *__restrict p_dst, uint32_t p_src_width, uint32_t p_src_height, uint32_t p_dst_width, uint32_t p_dst_height) {
	enum {
		FRAC_BITS = 8,
		FRAC_LEN = (1 << FRAC_BITS),
		FRAC_HALF = (FRAC_LEN >> 1),
		FRAC_MASK = FRAC_LEN - 1
	};

	for (uint32_t i = 0; i < p_dst_height; i++) {
		// Add 0.5 in order to interpolate based on pixel center
		uint32_t src_yofs_up_fp = (i + 0.5) * p_src_height * FRAC_LEN / p_dst_height;
		// Calculate nearest src pixel center above current, and truncate to get y index
		uint32_t src_yofs_up = src_yofs_up_fp >= FRAC_HALF ? (src_yofs_up_fp - FRAC_HALF) >> FRAC_BITS : 0;
		uint32_t src_yofs_down = (src_yofs_up_fp + FRAC_HALF) >> FRAC_BITS;
		if (src_yofs_down >= p_src_height) {
			src_yofs_down = p_src_height - 1;
		}
		// Calculate distance to pixel center of src_yofs_up
		uint32_t src_yofs_frac = src_yofs_up_fp & FRAC_MASK;
		src_yofs_frac = src_yofs_frac >= FRAC_HALF ? src_yofs_frac - FRAC_HALF : src_yofs_frac + FRAC_HALF;

		uint32_t y_ofs_up = src_yofs_up * p_src_width * CC;
		uint32_t y_ofs_down = src_yofs_down * p_src_width * CC;

		for (uint32_t j = 0; j < p_dst_width; j++) {
			uint32_t src_xofs_left_fp = (j + 0.5) * p_src_width * FRAC_LEN / p_dst_width;
			uint32_t src_xofs_left = src_xofs_left_fp >= FRAC_HALF ? (src_xofs_left_fp - FRAC_HALF) >> FRAC_BITS : 0;
			uint32_t src_xofs_right = (src_xofs_left_fp + FRAC_HALF) >> FRAC_BITS;
			if (src_xofs_right >= p_src_width) {
				src_xofs_right = p_src_width - 1;
			}
			uint32_t src_xofs_frac = src_xofs_left_fp & FRAC_MASK;
			src_xofs_frac = src_xofs_frac >= FRAC_HALF ? src_xofs_frac - FRAC_HALF : src_xofs_frac + FRAC_HALF;

			src_xofs_left *= CC;
			src_xofs_right *= CC;

			for (uint32_t l = 0; l < CC; l++) {
				if (sizeof(T) == 1) { // uint8
					uint32_t p00 = p_src[y_ofs_up + src_xofs_left + l] << FRAC_BITS;
					uint32_t p10 = p_src[y_ofs_up + src_xofs_right + l] << FRAC_BITS;
					uint32_t p01 = p_src[y_ofs_down + src_xofs_left + l] << FRAC_BITS;
					uint32_t p11 = p_src[y_ofs_down + src_xofs_right + l] << FRAC_BITS;

					uint32_t interp_up = p00 + (((p10 - p00) * src_xofs_frac) >> FRAC_BITS);
					uint32_t interp_down = p01 + (((p11 - p01) * src_xofs_frac) >> FRAC_BITS);
					uint32_t interp = interp_up + (((interp_down - interp_up) * src_yofs_frac) >> FRAC_BITS);
					interp >>= FRAC_BITS;
					p_dst[i * p_dst_width * CC + j * CC + l] = interp;
				} else if (sizeof(T) == 2) { // half float

					float xofs_frac = float(src_xofs_frac) / (1 << FRAC_BITS);
					float yofs_frac = float(src_yofs_frac) / (1 << FRAC_BITS);
					const T *src = ((const T *)p_src);
					T *dst = ((T *)p_dst);

					float p00 = Math::half_to_float(src[y_ofs_up + src_xofs_left + l]);
					float p10 = Math::half_to_float(src[y_ofs_up + src_xofs_right + l]);
					float p01 = Math::half_to_float(src[y_ofs_down + src_xofs_left + l]);
					float p11 = Math::half_to_float(src[y_ofs_down + src_xofs_right + l]);

					float interp_up = p00 + (p10 - p00) * xofs_frac;
					float interp_down = p01 + (p11 - p01) * xofs_frac;
					float interp = interp_up + ((interp_down - interp_up) * yofs_frac);

					dst[i * p_dst_width * CC + j * CC + l] = Math::make_half_float(interp);
				} else if (sizeof(T) == 4) { // float

					float xofs_frac = float(src_xofs_frac) / (1 << FRAC_BITS);
					float yofs_frac = float(src_yofs_frac) / (1 << FRAC_BITS);
					const T *src = ((const T *)p_src);
					T *dst = ((T *)p_dst);

					float p00 = src[y_ofs_up + src_xofs_left + l];
					float p10 = src[y_ofs_up + src_xofs_right + l];
					float p01 = src[y_ofs_down + src_xofs_left + l];
					float p11 = src[y_ofs_down + src_xofs_right + l];

					float interp_up = p00 + (p10 - p00) * xofs_frac;
					float interp_down = p01 + (p11 - p01) * xofs_frac;
					float interp = interp_up + ((interp_down - interp_up) * yofs_frac);

					dst[i * p_dst_width * CC + j * CC + l] = interp;
				}
			}
		}
	}
}

template <int CC, class T>
static void _scale_nearest(const uint8_t *__restrict p_src, uint8_t *__restrict p_dst, uint32_t p_src_width, uint32_t p_src_height, uint32_t p_dst_width, uint32_t p_dst_height) {
	for (uint32_t i = 0; i < p_dst_height; i++) {
		uint32_t src_yofs = i * p_src_height / p_dst_height;
		uint32_t y_ofs = src_yofs * p_src_width * CC;

		for (uint32_t j = 0; j < p_dst_width; j++) {
			uint32_t src_xofs = j * p_src_width / p_dst_width;
			src_xofs *= CC;

			for (uint32_t l = 0; l < CC; l++) {
				const T *src = ((const T *)p_src);
				T *dst = ((T *)p_dst);

				T p = src[y_ofs + src_xofs + l];
				dst[i * p_dst_width * CC + j * CC + l] = p;
			}
		}
	}
}

#define LANCZOS_TYPE 3

static float _lanczos(float p_x) {
	return Math::abs(p_x) >= LANCZOS_TYPE ? 0 : Math::sincn(p_x) * Math::sincn(p_x / LANCZOS_TYPE);
}

template <int CC, class T>
static void _scale_lanczos(const uint8_t *__restrict p_src, uint8_t *__restrict p_dst, uint32_t p_src_width, uint32_t p_src_height, uint32_t p_dst_width, uint32_t p_dst_height) {
	int32_t src_width = p_src_width;
	int32_t src_height = p_src_height;
	int32_t dst_height = p_dst_height;
	int32_t dst_width = p_dst_width;

	uint32_t buffer_size = src_height * dst_width * CC;
	float *buffer = memnew_arr(float, buffer_size); // Store the first pass in a buffer

	{ // FIRST PASS (horizontal)

		float x_scale = float(src_width) / float(dst_width);

		float scale_factor = MAX(x_scale, 1); // A larger kernel is required only when downscaling
		int32_t half_kernel = LANCZOS_TYPE * scale_factor;

		float *kernel = memnew_arr(float, half_kernel * 2);

		for (int32_t buffer_x = 0; buffer_x < dst_width; buffer_x++) {
			// The corresponding point on the source image
			float src_x = (buffer_x + 0.5f) * x_scale; // Offset by 0.5 so it uses the pixel's center
			int32_t start_x = MAX(0, int32_t(src_x) - half_kernel + 1);
			int32_t end_x = MIN(src_width - 1, int32_t(src_x) + half_kernel);

			// Create the kernel used by all the pixels of the column
			for (int32_t target_x = start_x; target_x <= end_x; target_x++) {
				kernel[target_x - start_x] = _lanczos((target_x + 0.5f - src_x) / scale_factor);
			}

			for (int32_t buffer_y = 0; buffer_y < src_height; buffer_y++) {
				float pixel[CC] = { 0 };
				float weight = 0;

				for (int32_t target_x = start_x; target_x <= end_x; target_x++) {
					float lanczos_val = kernel[target_x - start_x];
					weight += lanczos_val;

					const T *__restrict src_data = ((const T *)p_src) + (buffer_y * src_width + target_x) * CC;

					for (uint32_t i = 0; i < CC; i++) {
						if (sizeof(T) == 2) { // half float
							pixel[i] += Math::half_to_float(src_data[i]) * lanczos_val;
						} else {
							pixel[i] += src_data[i] * lanczos_val;
						}
					}
				}

				float *dst_data = ((float *)buffer) + (buffer_y * dst_width + buffer_x) * CC;

				for (uint32_t i = 0; i < CC; i++) {
					dst_data[i] = pixel[i] / weight; // Normalize the sum of all the samples
				}
			}
		}

		memdelete_arr(kernel);
	} // End of first pass

	{ // SECOND PASS (vertical + result)

		float y_scale = float(src_height) / float(dst_height);

		float scale_factor = MAX(y_scale, 1);
		int32_t half_kernel = LANCZOS_TYPE * scale_factor;

		float *kernel = memnew_arr(float, half_kernel * 2);

		for (int32_t dst_y = 0; dst_y < dst_height; dst_y++) {
			float buffer_y = (dst_y + 0.5f) * y_scale;
			int32_t start_y = MAX(0, int32_t(buffer_y) - half_kernel + 1);
			int32_t end_y = MIN(src_height - 1, int32_t(buffer_y) + half_kernel);

			for (int32_t target_y = start_y; target_y <= end_y; target_y++) {
				kernel[target_y - start_y] = _lanczos((target_y + 0.5f - buffer_y) / scale_factor);
			}

			for (int32_t dst_x = 0; dst_x < dst_width; dst_x++) {
				float pixel[CC] = { 0 };
				float weight = 0;

				for (int32_t target_y = start_y; target_y <= end_y; target_y++) {
					float lanczos_val = kernel[target_y - start_y];
					weight += lanczos_val;

					float *buffer_data = ((float *)buffer) + (target_y * dst_width + dst_x) * CC;

					for (uint32_t i = 0; i < CC; i++) {
						pixel[i] += buffer_data[i] * lanczos_val;
					}
				}

				T *dst_data = ((T *)p_dst) + (dst_y * dst_width + dst_x) * CC;

				for (uint32_t i = 0; i < CC; i++) {
					pixel[i] /= weight;

					if (sizeof(T) == 1) { // byte
						dst_data[i] = CLAMP(Math::fast_ftoi(pixel[i]), 0, 255);
					} else if (sizeof(T) == 2) { // half float
						dst_data[i] = Math::make_half_float(pixel[i]);
					} else { // float
						dst_data[i] = pixel[i];
					}
				}
			}
		}

		memdelete_arr(kernel);
	} // End of second pass

	memdelete_arr(buffer);
}

static void _overlay(const uint8_t *__restrict p_src, uint8_t *__restrict p_dst, float p_alpha, uint32_t p_width, uint32_t p_height, uint32_t p_pixel_size) {
	uint16_t alpha = MIN((uint16_t)(p_alpha * 256.0f), 256);

	for (uint32_t i = 0; i < p_width * p_height * p_pixel_size; i++) {
		p_dst[i] = (p_dst[i] * (256 - alpha) + p_src[i] * alpha) >> 8;
	}
}

bool Image::is_size_po2() const {
	return uint32_t(width) == next_power_of_2(width) && uint32_t(height) == next_power_of_2(height);
}

void Image::resize_to_po2(bool p_square, Interpolation p_interpolation) {
	ERR_FAIL_COND_MSG(!_can_modify(format), "Cannot resize in compressed or custom image formats.");

	int w = next_power_of_2(width);
	int h = next_power_of_2(height);
	if (p_square) {
		w = h = MAX(w, h);
	}

	if (w == width && h == height) {
		if (!p_square || w == h) {
			return; // nothing to do
		}
	}

	resize(w, h, p_interpolation);
}

void Image::resize(int p_width, int p_height, Interpolation p_interpolation) {
	ERR_FAIL_COND_MSG(data.size() == 0, "Cannot resize image before creating it, use create() or create_from_data() first.");
	ERR_FAIL_COND_MSG(!_can_modify(format), "Cannot resize in compressed or custom image formats.");
	ERR_FAIL_COND_MSG(write_lock, "Cannot resize image when it is locked.");

	bool mipmap_aware = p_interpolation == INTERPOLATE_TRILINEAR /* || p_interpolation == INTERPOLATE_TRICUBIC */;

	ERR_FAIL_COND_MSG(p_width <= 0, "Image width must be greater than 0.");
	ERR_FAIL_COND_MSG(p_height <= 0, "Image height must be greater than 0.");
	ERR_FAIL_COND_MSG(p_width > MAX_WIDTH, "Image width cannot be greater than " + String::num(MAX_WIDTH) + ".");
	ERR_FAIL_COND_MSG(p_height > MAX_HEIGHT, "Image height cannot be greater than " + String::num(MAX_HEIGHT) + ".");

	if (p_width == width && p_height == height) {
		return;
	}

	Image dst(p_width, p_height, false, format);

	// Setup mipmap-aware scaling
	Image dst2;
	int mip1 = 0;
	int mip2 = 0;
	float mip1_weight = 0;
	if (mipmap_aware) {
		float avg_scale = ((float)p_width / width + (float)p_height / height) * 0.5f;
		if (avg_scale >= 1.0f) {
			mipmap_aware = false;
		} else {
			float level = Math::log(1.0f / avg_scale) / Math::log(2.0f);
			mip1 = CLAMP((int)Math::floor(level), 0, get_mipmap_count());
			mip2 = CLAMP((int)Math::ceil(level), 0, get_mipmap_count());
			mip1_weight = 1.0f - (level - mip1);
		}
	}
	bool interpolate_mipmaps = mipmap_aware && mip1 != mip2;
	if (interpolate_mipmaps) {
		dst2.create(p_width, p_height, false, format);
	}

	bool had_mipmaps = mipmaps;
	if (interpolate_mipmaps && !had_mipmaps) {
		generate_mipmaps();
	}
	// --

	write_lock = true;

	const unsigned char *r_ptr = data.ptr();
	unsigned char *w_ptr = dst.data.ptrw();

	switch (p_interpolation) {
		case INTERPOLATE_NEAREST: {
			if (format >= FORMAT_L8 && format <= FORMAT_RGBA8) {
				switch (get_format_pixel_size(format)) {
					case 1:
						_scale_nearest<1, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 2:
						_scale_nearest<2, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 3:
						_scale_nearest<3, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 4:
						_scale_nearest<4, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
				}
			} else if (format >= FORMAT_RF && format <= FORMAT_RGBAF) {
				switch (get_format_pixel_size(format)) {
					case 4:
						_scale_nearest<1, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 8:
						_scale_nearest<2, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 12:
						_scale_nearest<3, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 16:
						_scale_nearest<4, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
				}
			}

		} break;
		case INTERPOLATE_BILINEAR:
		case INTERPOLATE_TRILINEAR: {
			for (int i = 0; i < 2; ++i) {
				int src_width;
				int src_height;
				const unsigned char *src_ptr;

				if (!mipmap_aware) {
					if (i == 0) {
						// Standard behavior
						src_width = width;
						src_height = height;
						src_ptr = r_ptr;
					} else {
						// No need for a second iteration
						break;
					}
				} else {
					if (i == 0) {
						// Read from the first mipmap that will be interpolated
						// (if both levels are the same, we will not interpolate, but at least we'll sample from the right level)
						int offs;
						_get_mipmap_offset_and_size(mip1, offs, src_width, src_height);
						src_ptr = r_ptr + offs;
					} else if (!interpolate_mipmaps) {
						// No need generate a second image
						break;
					} else {
						// Switch to read from the second mipmap that will be interpolated
						int offs;
						_get_mipmap_offset_and_size(mip2, offs, src_width, src_height);
						src_ptr = r_ptr + offs;
						// Switch to write to the second destination image
						w_ptr = dst2.data.ptrw();
					}
				}

				if (format >= FORMAT_L8 && format <= FORMAT_RGBA8) {
					switch (get_format_pixel_size(format)) {
						case 1:
							_scale_bilinear<1, uint8_t>(src_ptr, w_ptr, src_width, src_height, p_width, p_height);
							break;
						case 2:
							_scale_bilinear<2, uint8_t>(src_ptr, w_ptr, src_width, src_height, p_width, p_height);
							break;
						case 3:
							_scale_bilinear<3, uint8_t>(src_ptr, w_ptr, src_width, src_height, p_width, p_height);
							break;
						case 4:
							_scale_bilinear<4, uint8_t>(src_ptr, w_ptr, src_width, src_height, p_width, p_height);
							break;
					}
				} else if (format >= FORMAT_RF && format <= FORMAT_RGBAF) {
					switch (get_format_pixel_size(format)) {
						case 4:
							_scale_bilinear<1, float>(src_ptr, w_ptr, src_width, src_height, p_width, p_height);
							break;
						case 8:
							_scale_bilinear<2, float>(src_ptr, w_ptr, src_width, src_height, p_width, p_height);
							break;
						case 12:
							_scale_bilinear<3, float>(src_ptr, w_ptr, src_width, src_height, p_width, p_height);
							break;
						case 16:
							_scale_bilinear<4, float>(src_ptr, w_ptr, src_width, src_height, p_width, p_height);
							break;
					}
				}
			}

			if (interpolate_mipmaps) {
				// Switch to read again from the first scaled mipmap to overlay it over the second
				_overlay(dst.data.ptr(), w_ptr, mip1_weight, p_width, p_height, get_format_pixel_size(format));
			}

		} break;
		case INTERPOLATE_CUBIC: {
			if (format >= FORMAT_L8 && format <= FORMAT_RGBA8) {
				switch (get_format_pixel_size(format)) {
					case 1:
						_scale_cubic<1, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 2:
						_scale_cubic<2, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 3:
						_scale_cubic<3, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 4:
						_scale_cubic<4, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
				}
			} else if (format >= FORMAT_RF && format <= FORMAT_RGBAF) {
				switch (get_format_pixel_size(format)) {
					case 4:
						_scale_cubic<1, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 8:
						_scale_cubic<2, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 12:
						_scale_cubic<3, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 16:
						_scale_cubic<4, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
				}
			}
		} break;
		case INTERPOLATE_LANCZOS: {
			if (format >= FORMAT_L8 && format <= FORMAT_RGBA8) {
				switch (get_format_pixel_size(format)) {
					case 1:
						_scale_lanczos<1, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 2:
						_scale_lanczos<2, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 3:
						_scale_lanczos<3, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 4:
						_scale_lanczos<4, uint8_t>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
				}
			} else if (format >= FORMAT_RF && format <= FORMAT_RGBAF) {
				switch (get_format_pixel_size(format)) {
					case 4:
						_scale_lanczos<1, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 8:
						_scale_lanczos<2, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 12:
						_scale_lanczos<3, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
					case 16:
						_scale_lanczos<4, float>(r_ptr, w_ptr, width, height, p_width, p_height);
						break;
				}
			}
		} break;
	}

	write_lock = false;

	if (interpolate_mipmaps) {
		dst._copy_internals_from(dst2);
	}

	if (had_mipmaps) {
		dst.generate_mipmaps();
	}

	_copy_internals_from(dst);
}

void Image::crop_from_point(int p_x, int p_y, int p_width, int p_height) {
	ERR_FAIL_COND_MSG(!_can_modify(format), "Cannot crop in compressed or custom image formats.");
	ERR_FAIL_COND_MSG(write_lock, "Cannot modify image when it is locked.");
	ERR_FAIL_COND_MSG(p_x < 0, "Start x position cannot be smaller than 0.");
	ERR_FAIL_COND_MSG(p_y < 0, "Start y position cannot be smaller than 0.");
	ERR_FAIL_COND_MSG(p_width <= 0, "Width of image must be greater than 0.");
	ERR_FAIL_COND_MSG(p_height <= 0, "Height of image must be greater than 0.");
	ERR_FAIL_COND_MSG(p_x + p_width > MAX_WIDTH, "End x position cannot be greater than " + String::num(MAX_WIDTH) + ".");
	ERR_FAIL_COND_MSG(p_y + p_height > MAX_HEIGHT, "End y position cannot be greater than " + String::num(MAX_HEIGHT) + ".");

	/* to save memory, cropping should be done in-place, however, since this function
	   will most likely either not be used much, or in critical areas, for now it won't, because
	   it's a waste of time. */

	if (p_width == width && p_height == height && p_x == 0 && p_y == 0) {
		return;
	}

	uint8_t pdata[16]; // largest is 16
	uint32_t pixel_size = get_format_pixel_size(format);

	Image dst(p_width, p_height, false, format);

	{
		write_lock = true;

		int m_h = p_y + p_height;
		int m_w = p_x + p_width;
		for (int y = p_y; y < m_h; y++) {
			for (int x = p_x; x < m_w; x++) {
				if ((x >= width || y >= height)) {
					for (uint32_t i = 0; i < pixel_size; i++) {
						pdata[i] = 0;
					}
				} else {
					_get_pixelb(x, y, pixel_size, data.ptr(), pdata);
				}

				dst._put_pixelb(x - p_x, y - p_y, pixel_size, dst.data.ptrw(), pdata);
			}
		}

		write_lock = false;
	}

	if (has_mipmaps()) {
		dst.generate_mipmaps();
	}
	_copy_internals_from(dst);
}

void Image::crop(int p_width, int p_height) {
	crop_from_point(0, 0, p_width, p_height);
}

void Image::flip_y() {
	ERR_FAIL_COND_MSG(!_can_modify(format), "Cannot flip_y in compressed or custom image formats.");

	bool used_mipmaps = has_mipmaps();
	if (used_mipmaps) {
		clear_mipmaps();
	}

	{
		write_lock = true;

		uint8_t up[16];
		uint8_t down[16];
		uint32_t pixel_size = get_format_pixel_size(format);

		for (int y = 0; y < height / 2; y++) {
			for (int x = 0; x < width; x++) {
				_get_pixelb(x, y, pixel_size, data.ptr(), up);
				_get_pixelb(x, height - y - 1, pixel_size, data.ptr(), down);

				_put_pixelb(x, height - y - 1, pixel_size, data.ptrw(), up);
				_put_pixelb(x, y, pixel_size, data.ptrw(), down);
			}
		}

		write_lock = false;
	}

	if (used_mipmaps) {
		generate_mipmaps();
	}
}

void Image::flip_x() {
	ERR_FAIL_COND_MSG(!_can_modify(format), "Cannot flip_x in compressed or custom image formats.");

	bool used_mipmaps = has_mipmaps();
	if (used_mipmaps) {
		clear_mipmaps();
	}

	{
		write_lock = true;

		uint8_t up[16];
		uint8_t down[16];
		uint32_t pixel_size = get_format_pixel_size(format);

		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width / 2; x++) {
				_get_pixelb(x, y, pixel_size, data.ptr(), up);
				_get_pixelb(width - x - 1, y, pixel_size, data.ptr(), down);

				_put_pixelb(width - x - 1, y, pixel_size, data.ptrw(), up);
				_put_pixelb(x, y, pixel_size, data.ptrw(), down);
			}
		}

		write_lock = false;
	}

	if (used_mipmaps) {
		generate_mipmaps();
	}
}

int Image::_get_dst_image_size(int p_width, int p_height, Format p_format, int &r_mipmaps, int p_mipmaps) {
	int size = 0;
	int w = p_width;
	int h = p_height;
	int mm = 0;

	int pixsize = get_format_pixel_size(p_format);
	int pixshift = get_format_pixel_rshift(p_format);
	int block = get_format_block_size(p_format);
	// technically, you can still compress up to 1 px no matter the format, so commenting this
	// int minw, minh;
	// get_format_min_pixel_size(p_format, minw, minh);
	int minw = 1, minh = 1;

	while (true) {
		int bw = w % block != 0 ? w + (block - w % block) : w;
		int bh = h % block != 0 ? h + (block - h % block) : h;

		int s = bw * bh;

		s *= pixsize;
		s >>= pixshift;

		size += s;

		if (p_mipmaps >= 0 && mm == p_mipmaps) {
			break;
		}

		if (p_mipmaps >= 0) {
			w = MAX(minw, w >> 1);
			h = MAX(minh, h >> 1);
		} else {
			if (w == minw && h == minh) {
				break;
			}
			w = MAX(minw, w >> 1);
			h = MAX(minh, h >> 1);
		}
		mm++;
	};

	r_mipmaps = mm;
	return size;
}

bool Image::_can_modify(Format p_format) const {
	return p_format <= FORMAT_RGBAF;
}

template <class Component, int CC, bool renormalize,
		void (*average_func)(Component &, const Component &, const Component &, const Component &, const Component &),
		void (*renormalize_func)(Component *)>
static void _generate_po2_mipmap(const Component *p_src, Component *p_dst, uint32_t p_width, uint32_t p_height) {
	// fast power of 2 mipmap generation
	uint32_t dst_w = MAX(p_width >> 1, 1);
	uint32_t dst_h = MAX(p_height >> 1, 1);

	int right_step = (p_width == 1) ? 0 : CC;
	int down_step = (p_height == 1) ? 0 : (p_width * CC);

	for (uint32_t i = 0; i < dst_h; i++) {
		const Component *rup_ptr = &p_src[i * 2 * down_step];
		const Component *rdown_ptr = rup_ptr + down_step;
		Component *dst_ptr = &p_dst[i * dst_w * CC];
		uint32_t count = dst_w;

		while (count) {
			count--;
			for (int j = 0; j < CC; j++) {
				average_func(dst_ptr[j], rup_ptr[j], rup_ptr[j + right_step], rdown_ptr[j], rdown_ptr[j + right_step]);
			}

			if (renormalize) {
				renormalize_func(dst_ptr);
			}

			dst_ptr += CC;
			rup_ptr += right_step * 2;
			rdown_ptr += right_step * 2;
		}
	}
}

void Image::shrink_x2() {
	ERR_FAIL_COND(!_can_modify(format));
	ERR_FAIL_COND_MSG(write_lock, "Cannot modify image when it is locked.");
	ERR_FAIL_COND(data.size() == 0);

	if (mipmaps) {
		// just use the lower mipmap as base and copy all
		Vector<uint8_t> new_img;

		int ofs = get_mipmap_offset(1);

		int new_size = data.size() - ofs;
		new_img.resize(new_size);
		ERR_FAIL_COND(new_img.size() == 0);

		{
			write_lock = true;
			memcpy(new_img.ptrw(), &data.ptr()[ofs], new_size);
			write_lock = false;
		}

		width = MAX(width / 2, 1);
		height = MAX(height / 2, 1);
		data = new_img;

	} else {
		Vector<uint8_t> new_img;

		ERR_FAIL_COND(!_can_modify(format));
		int ps = get_format_pixel_size(format);
		new_img.resize((width / 2) * (height / 2) * ps);
		ERR_FAIL_COND(new_img.size() == 0);
		ERR_FAIL_COND(data.size() == 0);

		{
			write_lock = true;

			switch (format) {
				case FORMAT_L8:
				case FORMAT_R8:
					_generate_po2_mipmap<uint8_t, 1, false, Image::average_4_uint8, Image::renormalize_uint8>(data.ptr(), new_img.ptrw(), width, height);
					break;
				case FORMAT_LA8:
					_generate_po2_mipmap<uint8_t, 2, false, Image::average_4_uint8, Image::renormalize_uint8>(data.ptr(), new_img.ptrw(), width, height);
					break;
				case FORMAT_RG8:
					_generate_po2_mipmap<uint8_t, 2, false, Image::average_4_uint8, Image::renormalize_uint8>(data.ptr(), new_img.ptrw(), width, height);
					break;
				case FORMAT_RGB8:
					_generate_po2_mipmap<uint8_t, 3, false, Image::average_4_uint8, Image::renormalize_uint8>(data.ptr(), new_img.ptrw(), width, height);
					break;
				case FORMAT_RGBA8:
					_generate_po2_mipmap<uint8_t, 4, false, Image::average_4_uint8, Image::renormalize_uint8>(data.ptr(), new_img.ptrw(), width, height);
					break;

				case FORMAT_RF:
					_generate_po2_mipmap<float, 1, false, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(data.ptr()), reinterpret_cast<float *>(new_img.ptrw()), width, height);
					break;
				case FORMAT_RGF:
					_generate_po2_mipmap<float, 2, false, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(data.ptr()), reinterpret_cast<float *>(new_img.ptrw()), width, height);
					break;
				case FORMAT_RGBF:
					_generate_po2_mipmap<float, 3, false, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(data.ptr()), reinterpret_cast<float *>(new_img.ptrw()), width, height);
					break;
				case FORMAT_RGBAF:
					_generate_po2_mipmap<float, 4, false, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(data.ptr()), reinterpret_cast<float *>(new_img.ptrw()), width, height);
					break;

				default: {
				}
			}

			write_lock = false;
		}

		width /= 2;
		height /= 2;
		data = new_img;
	}
}

void Image::normalize() {
	bool used_mipmaps = has_mipmaps();
	if (used_mipmaps) {
		clear_mipmaps();
	}

	lock();

	for (int y = 0; y < height; y++) {
		for (int x = 0; x < width; x++) {
			Color c = get_pixel(x, y);
			Vector3 v(c.r * 2.0 - 1.0, c.g * 2.0 - 1.0, c.b * 2.0 - 1.0);
			v.normalize();
			c.r = v.x * 0.5 + 0.5;
			c.g = v.y * 0.5 + 0.5;
			c.b = v.z * 0.5 + 0.5;
			set_pixel(x, y, c);
		}
	}

	unlock();

	if (used_mipmaps) {
		generate_mipmaps(true);
	}
}

int Image::generate_mipmaps(bool p_renormalize) {
	ERR_FAIL_COND_V_MSG(!_can_modify(format), 1, "Cannot generate mipmaps in compressed or custom image formats.");
	ERR_FAIL_COND_V_MSG(write_lock, 1, "Cannot modify image when it is locked.");
	ERR_FAIL_COND_V_MSG(format == FORMAT_RGBA4444 || format == FORMAT_RGBA5551, 1, "Cannot generate mipmaps in custom image formats.");
	ERR_FAIL_COND_V_MSG(width == 0 || height == 0, 2, "Cannot generate mipmaps with width or height equal to 0.");

	int mmcount;

	int size = _get_dst_image_size(width, height, format, mmcount);

	data.resize(size);

	uint8_t *wp = data.ptrw();

	int prev_ofs = 0;
	int prev_h = height;
	int prev_w = width;

	for (int i = 1; i <= mmcount; i++) {
		int ofs, w, h;
		_get_mipmap_offset_and_size(i, ofs, w, h);

		switch (format) {
			case FORMAT_L8:
			case FORMAT_R8:
				_generate_po2_mipmap<uint8_t, 1, false, Image::average_4_uint8, Image::renormalize_uint8>(&wp[prev_ofs], &wp[ofs], prev_w, prev_h);
				break;
			case FORMAT_LA8:
			case FORMAT_RG8:
				_generate_po2_mipmap<uint8_t, 2, false, Image::average_4_uint8, Image::renormalize_uint8>(&wp[prev_ofs], &wp[ofs], prev_w, prev_h);
				break;
			case FORMAT_RGB8:
				if (p_renormalize) {
					_generate_po2_mipmap<uint8_t, 3, true, Image::average_4_uint8, Image::renormalize_uint8>(&wp[prev_ofs], &wp[ofs], prev_w, prev_h);
				} else {
					_generate_po2_mipmap<uint8_t, 3, false, Image::average_4_uint8, Image::renormalize_uint8>(&wp[prev_ofs], &wp[ofs], prev_w, prev_h);
				}

				break;
			case FORMAT_RGBA8:
				if (p_renormalize) {
					_generate_po2_mipmap<uint8_t, 4, true, Image::average_4_uint8, Image::renormalize_uint8>(&wp[prev_ofs], &wp[ofs], prev_w, prev_h);
				} else {
					_generate_po2_mipmap<uint8_t, 4, false, Image::average_4_uint8, Image::renormalize_uint8>(&wp[prev_ofs], &wp[ofs], prev_w, prev_h);
				}
				break;
			case FORMAT_RF:
				_generate_po2_mipmap<float, 1, false, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(&wp[prev_ofs]), reinterpret_cast<float *>(&wp[ofs]), prev_w, prev_h);
				break;
			case FORMAT_RGF:
				_generate_po2_mipmap<float, 2, false, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(&wp[prev_ofs]), reinterpret_cast<float *>(&wp[ofs]), prev_w, prev_h);
				break;
			case FORMAT_RGBF:
				if (p_renormalize) {
					_generate_po2_mipmap<float, 3, true, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(&wp[prev_ofs]), reinterpret_cast<float *>(&wp[ofs]), prev_w, prev_h);
				} else {
					_generate_po2_mipmap<float, 3, false, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(&wp[prev_ofs]), reinterpret_cast<float *>(&wp[ofs]), prev_w, prev_h);
				}

				break;
			case FORMAT_RGBAF:
				if (p_renormalize) {
					_generate_po2_mipmap<float, 4, true, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(&wp[prev_ofs]), reinterpret_cast<float *>(&wp[ofs]), prev_w, prev_h);
				} else {
					_generate_po2_mipmap<float, 4, false, Image::average_4_float, Image::renormalize_float>(reinterpret_cast<const float *>(&wp[prev_ofs]), reinterpret_cast<float *>(&wp[ofs]), prev_w, prev_h);
				}

				break;

			default: {
			}
		}

		prev_ofs = ofs;
		prev_w = w;
		prev_h = h;
	}

	mipmaps = true;

	return 0;
}

void Image::clear_mipmaps() {
	if (!mipmaps) {
		return;
	}

	if (empty()) {
		return;
	}

	int ofs, w, h;
	_get_mipmap_offset_and_size(1, ofs, w, h);
	data.resize(ofs);

	mipmaps = false;
}

bool Image::empty() const {
	return (data.size() == 0);
}

Vector<uint8_t> Image::get_data() const {
	return data;
}

const uint8_t *Image::datar() const {
	return data.ptr();
}
uint8_t *Image::dataw() {
	return data.ptrw();
}
int Image::get_data_size() const {
	return data.size();
}

void Image::load_from_file(const String &file_name, Format p_format) {
	//stbi_set_flip_vertically_on_load(flags & IMAGE_FLIP ? 1 : 0);

	int img_n = 4;

	Error err;
	Vector<uint8_t> file_data = FileAccess::get_file_as_array(file_name, &err);

	ERR_FAIL_COND(err != OK);

	//case FORMAT_RF:
	//case FORMAT_RGF:
	//case FORMAT_RGBF:
	//case FORMAT_RGBAF:
	//img.pixels = stbi_loadf_from_file((const stbi_uc *)data, size, (int *)&img.x, (int *)&img.y, (int *)&img.n, n);

	int x;
	int y;
	int n;

	stbi_uc *pixels = stbi_load_from_memory(file_data.ptr(), file_data.size(), &x, &y, &n, img_n);

	ERR_FAIL_COND_MSG(!pixels, "Couldn't load image! " + file_name);

	if (n != img_n) {
		memdelete(pixels);
		ERR_PRINT("Couldn't load image! n != img_n");
		return;
	}

	int size = x * y * get_format_pixel_size(FORMAT_RGBA8);

	data.resize(size);
	{
		write_lock = true;
		memcpy(data.ptrw(), pixels, size);
		write_lock = false;
	}

	width = x;
	height = y;
	mipmaps = false;
	format = FORMAT_RGBA8;

	memdelete(pixels);

	if (p_format != FORMAT_RGBA8) {
		convert(p_format);
	}
}

void Image::create(int p_width, int p_height, bool p_use_mipmaps, Format p_format) {
	ERR_FAIL_COND_MSG(p_width <= 0, "Image width must be greater than 0.");
	ERR_FAIL_COND_MSG(p_height <= 0, "Image height must be greater than 0.");
	ERR_FAIL_COND_MSG(p_width > MAX_WIDTH, "Image width cannot be greater than " + String::num(MAX_WIDTH) + ".");
	ERR_FAIL_COND_MSG(p_height > MAX_HEIGHT, "Image height cannot be greater than " + String::num(MAX_HEIGHT) + ".");
	ERR_FAIL_COND_MSG(write_lock, "Cannot create image when it is locked.");
	ERR_FAIL_INDEX_MSG(p_format, FORMAT_MAX, "Image format out of range, please see Image's Format enum.");

	int mm = 0;
	int size = _get_dst_image_size(p_width, p_height, p_format, mm, p_use_mipmaps ? -1 : 0);
	data.resize(size);
	{
		write_lock = true;
		memset(data.ptrw(), 0, size);
		write_lock = false;
	}

	width = p_width;
	height = p_height;
	mipmaps = p_use_mipmaps;
	format = p_format;
}

void Image::create(int p_width, int p_height, bool p_use_mipmaps, Format p_format, const Vector<uint8_t> &p_data) {
	ERR_FAIL_COND_MSG(p_width <= 0, "Image width must be greater than 0.");
	ERR_FAIL_COND_MSG(p_height <= 0, "Image height must be greater than 0.");
	ERR_FAIL_COND_MSG(p_width > MAX_WIDTH, "Image width cannot be greater than " + String::num(MAX_WIDTH) + ".");
	ERR_FAIL_COND_MSG(p_height > MAX_HEIGHT, "Image height cannot be greater than " + String::num(MAX_HEIGHT) + ".");
	ERR_FAIL_INDEX_MSG(p_format, FORMAT_MAX, "Image format out of range, please see Image's Format enum.");

	int mm;
	int size = _get_dst_image_size(p_width, p_height, p_format, mm, p_use_mipmaps ? -1 : 0);

	ERR_FAIL_COND_MSG(p_data.size() != size, "Expected data size of " + String::num(size) + " bytes in Image::create(), got instead " + String::num(p_data.size()) + " bytes.");

	height = p_height;
	width = p_width;
	format = p_format;
	data = p_data;
	mipmaps = p_use_mipmaps;
}

void Image::create(const char **p_xpm) {
	int size_width = 0;
	int size_height = 0;
	int pixelchars = 0;
	mipmaps = false;
	bool has_alpha = false;

	enum ImageXPMStatus {
		READING_HEADER,
		READING_COLORS,
		READING_PIXELS,
		DONE
	};

	ImageXPMStatus status = READING_HEADER;
	int line = 0;

	HashMap<String, Color> colormap;
	int colormap_size = 0;
	uint32_t pixel_size = 0;
	uint8_t *w_ptr;

	while (status != DONE) {
		const char *line_ptr = p_xpm[line];

		switch (status) {
			case READING_HEADER: {
				String line_str = line_ptr;
				line_str.replace("\t", " ");

				size_width = line_str.get_slicec(' ', 0).to_int();
				size_height = line_str.get_slicec(' ', 1).to_int();
				colormap_size = line_str.get_slicec(' ', 2).to_int();
				pixelchars = line_str.get_slicec(' ', 3).to_int();
				ERR_FAIL_COND(colormap_size > 32766);
				ERR_FAIL_COND(pixelchars > 5);
				ERR_FAIL_COND(size_width > 32767);
				ERR_FAIL_COND(size_height > 32767);
				status = READING_COLORS;
			} break;
			case READING_COLORS: {
				String colorstring;
				for (int i = 0; i < pixelchars; i++) {
					colorstring += *line_ptr;
					line_ptr++;
				}
				// skip spaces
				while (*line_ptr == ' ' || *line_ptr == '\t' || *line_ptr == 0) {
					if (*line_ptr == 0) {
						break;
					}
					line_ptr++;
				}
				if (*line_ptr == 'c') {
					line_ptr++;
					while (*line_ptr == ' ' || *line_ptr == '\t' || *line_ptr == 0) {
						if (*line_ptr == 0) {
							break;
						}
						line_ptr++;
					}

					if (*line_ptr == '#') {
						line_ptr++;
						uint8_t col_r = 0;
						uint8_t col_g = 0;
						uint8_t col_b = 0;
						// uint8_t col_a=255;

						for (int i = 0; i < 6; i++) {
							char v = line_ptr[i];

							if (v >= '0' && v <= '9') {
								v -= '0';
							} else if (v >= 'A' && v <= 'F') {
								v = (v - 'A') + 10;
							} else if (v >= 'a' && v <= 'f') {
								v = (v - 'a') + 10;
							} else {
								break;
							}

							switch (i) {
								case 0:
									col_r = v << 4;
									break;
								case 1:
									col_r |= v;
									break;
								case 2:
									col_g = v << 4;
									break;
								case 3:
									col_g |= v;
									break;
								case 4:
									col_b = v << 4;
									break;
								case 5:
									col_b |= v;
									break;
							};
						}

						// magenta mask
						if (col_r == 255 && col_g == 0 && col_b == 255) {
							colormap[colorstring] = Color(0, 0, 0, 0);
							has_alpha = true;
						} else {
							colormap[colorstring] = Color(col_r / 255.0, col_g / 255.0, col_b / 255.0, 1.0);
						}
					}
				}
				if (line == colormap_size) {
					status = READING_PIXELS;
					create(size_width, size_height, false, has_alpha ? FORMAT_RGBA8 : FORMAT_RGB8);
					w_ptr = data.ptrw();
					pixel_size = has_alpha ? 4 : 3;
				}
			} break;
			case READING_PIXELS: {
				int y = line - colormap_size - 1;
				for (int x = 0; x < size_width; x++) {
					char pixelstr[6] = { 0, 0, 0, 0, 0, 0 };
					for (int i = 0; i < pixelchars; i++) {
						pixelstr[i] = line_ptr[x * pixelchars + i];
					}

					Color *colorptr = &colormap[pixelstr];
					ERR_FAIL_COND(!colorptr);
					uint8_t pixel[4];
					for (uint32_t i = 0; i < pixel_size; i++) {
						pixel[i] = CLAMP((*colorptr)[i] * 255, 0, 255);
					}
					_put_pixelb(x, y, pixel_size, w_ptr, pixel);
				}

				if (y == (size_height - 1)) {
					status = DONE;
				}
			} break;
			default: {
			}
		}

		line++;
	}
}

Error Image::save_png(const String &file_name) {
	ERR_FAIL_COND_V(format >= FORMAT_RF, ERR_UNAVAILABLE);

	if (width == 0 || height == 0) {
		return FAILED;
	}

	int pfs = get_format_pixel_size(format);

	write_lock = true;

	int out_length = 0;

	uint8_t *ret_arr = stbi_write_png_to_mem(data.ptr(), 0, width, height, pfs, &out_length);

	write_lock = false;

	if (!ret_arr || out_length == 0) {
		return FAILED;
	}

	FileAccess *f = FileAccess::create_and_open(file_name, FileAccess::WRITE);

	if (!f) {
		return FAILED;
	}

	f->store_buffer(ret_arr, out_length);

	return OK;
}
Error Image::save_bmp(const String &file_name) {
	ERR_FAIL_COND_V(format >= FORMAT_RF, ERR_UNAVAILABLE);

	if (width == 0 || height == 0) {
		return FAILED;
	}

	int pfs = get_format_pixel_size(format);

	write_lock = true;

	int ret = stbi_write_bmp(file_name.utf8().get_data(), width, height, pfs, data.ptr());

	write_lock = false;

	if (ret == 0) {
		return FAILED;
	}

	return OK;
}
Error Image::save_tga(const String &file_name) {
	ERR_FAIL_COND_V(format >= FORMAT_RF, ERR_UNAVAILABLE);

	if (width == 0 || height == 0) {
		return FAILED;
	}

	int pfs = get_format_pixel_size(format);

	write_lock = true;

	int ret = stbi_write_tga(file_name.utf8().get_data(), width, height, pfs, data.ptr());

	write_lock = false;

	if (ret == 0) {
		return FAILED;
	}

	return OK;
}
Error Image::save_jpg(const String &file_name, const int quality) {
	ERR_FAIL_COND_V(format >= FORMAT_RF, ERR_UNAVAILABLE);

	if (width == 0 || height == 0) {
		return FAILED;
	}

	int pfs = get_format_pixel_size(format);

	write_lock = true;

	int ret = stbi_write_jpg(file_name.utf8().get_data(), width, height, pfs, data.ptr(), quality);

	write_lock = false;

	if (ret == 0) {
		return FAILED;
	}

	return OK;
}
Error Image::save_hdr(const String &file_name) {
	ERR_FAIL_COND_V(format < FORMAT_RF, ERR_UNAVAILABLE);

	if (width == 0 || height == 0) {
		return FAILED;
	}

	int pfs = get_format_pixel_size(format) / 4;

	write_lock = true;

	int ret = stbi_write_hdr(file_name.utf8().get_data(), width, height, pfs, ((float *)data.ptr()));

	write_lock = false;

	if (ret == 0) {
		return FAILED;
	}

	return OK;
}

#define DETECT_ALPHA_MAX_THRESHOLD 254
#define DETECT_ALPHA_MIN_THRESHOLD 2

#define DETECT_ALPHA(m_value)                          \
	{                                                  \
		uint8_t value = m_value;                       \
		if (value < DETECT_ALPHA_MIN_THRESHOLD)        \
			bit = true;                                \
		else if (value < DETECT_ALPHA_MAX_THRESHOLD) { \
			detected = true;                           \
			break;                                     \
		}                                              \
	}

#define DETECT_NON_ALPHA(m_value) \
	{                             \
		uint8_t value = m_value;  \
		if (value > 0) {          \
			detected = true;      \
			break;                \
		}                         \
	}

bool Image::is_invisible() const {
	if (format == FORMAT_L8 ||
			format == FORMAT_RGB8 || format == FORMAT_RG8) {
		return false;
	}

	int len = data.size();

	if (len == 0) {
		return true;
	}

	int w, h;
	_get_mipmap_offset_and_size(1, len, w, h);

	const unsigned char *data_ptr = data.ptr();

	bool detected = false;

	switch (format) {
		case FORMAT_LA8: {
			for (int i = 0; i < (len >> 1); i++) {
				DETECT_NON_ALPHA(data_ptr[(i << 1) + 1]);
			}

		} break;
		case FORMAT_RGBA8: {
			for (int i = 0; i < (len >> 2); i++) {
				DETECT_NON_ALPHA(data_ptr[(i << 2) + 3])
			}

		} break;

		default: {
		}
	}

	return !detected;
}

Image::AlphaMode Image::detect_alpha() const {
	int len = data.size();

	if (len == 0) {
		return ALPHA_NONE;
	}

	int w, h;
	_get_mipmap_offset_and_size(1, len, w, h);

	const unsigned char *data_ptr = data.ptr();

	bool bit = false;
	bool detected = false;

	switch (format) {
		case FORMAT_LA8: {
			for (int i = 0; i < (len >> 1); i++) {
				DETECT_ALPHA(data_ptr[(i << 1) + 1]);
			}

		} break;
		case FORMAT_RGBA8: {
			for (int i = 0; i < (len >> 2); i++) {
				DETECT_ALPHA(data_ptr[(i << 2) + 3])
			}

		} break;

		default: {
		}
	}

	if (detected) {
		return ALPHA_BLEND;
	} else if (bit) {
		return ALPHA_BIT;
	} else {
		return ALPHA_NONE;
	}
}

int Image::get_image_data_size(int p_width, int p_height, Format p_format, bool p_mipmaps) {
	int mm;
	return _get_dst_image_size(p_width, p_height, p_format, mm, p_mipmaps ? -1 : 0);
}

int Image::get_image_required_mipmaps(int p_width, int p_height, Format p_format) {
	int mm;
	_get_dst_image_size(p_width, p_height, p_format, mm, -1);
	return mm;
}

int Image::get_image_mipmap_offset(int p_width, int p_height, Format p_format, int p_mipmap) {
	if (p_mipmap <= 0) {
		return 0;
	}
	int mm;
	return _get_dst_image_size(p_width, p_height, p_format, mm, p_mipmap - 1);
}

bool Image::is_compressed() const {
	return format > FORMAT_RGBAF;
}

Image::Image(const char **p_xpm) {
	width = 0;
	height = 0;
	mipmaps = false;
	format = FORMAT_L8;

	create(p_xpm);
}

Image::Image(int p_width, int p_height, bool p_use_mipmaps, Format p_format) {
	width = 0;
	height = 0;
	mipmaps = p_use_mipmaps;
	format = FORMAT_L8;
	write_lock = false;

	create(p_width, p_height, p_use_mipmaps, p_format);
}

Image::Image(int p_width, int p_height, bool p_mipmaps, Format p_format, const Vector<uint8_t> &p_data) {
	width = 0;
	height = 0;
	mipmaps = p_mipmaps;
	format = FORMAT_L8;
	write_lock = false;

	create(p_width, p_height, p_mipmaps, p_format, p_data);
}

Rect2 Image::get_used_rect() const {
	if (format != FORMAT_LA8 && format != FORMAT_RGBA8 && format != FORMAT_RGBAF && format != FORMAT_RGBA4444 && format != FORMAT_RGBA5551) {
		return Rect2(Vector2(), Vector2(width, height));
	}

	int len = data.size();

	if (len == 0) {
		return Rect2();
	}

	const_cast<Image *>(this)->lock();
	int minx = 0xFFFFFF, miny = 0xFFFFFFF;
	int maxx = -1, maxy = -1;
	for (int j = 0; j < height; j++) {
		for (int i = 0; i < width; i++) {
			if (!(get_pixel(i, j).a > 0)) {
				continue;
			}
			if (i > maxx) {
				maxx = i;
			}
			if (j > maxy) {
				maxy = j;
			}
			if (i < minx) {
				minx = i;
			}
			if (j < miny) {
				miny = j;
			}
		}
	}

	const_cast<Image *>(this)->unlock();

	if (maxx == -1) {
		return Rect2();
	} else {
		return Rect2(minx, miny, maxx - minx + 1, maxy - miny + 1);
	}
}

Ref<Image> Image::get_rect(const Rect2 &p_area) const {
	Ref<Image> img = memnew(Image(p_area.position.x, p_area.position.y, mipmaps, format));
	img->blit_rect(Ref<Image>((Image *)this), p_area, Vector2(0, 0));
	return img;
}

void Image::blit_rect(const Ref<Image> &p_src, const Rect2 &p_src_rect, const Vector2 &p_dest) {
	ERR_FAIL_COND_MSG(p_src.is_null(), "It's not a reference to a valid Image object.");
	int dsize = data.size();
	int srcdsize = p_src->data.size();
	ERR_FAIL_COND(dsize == 0);
	ERR_FAIL_COND(srcdsize == 0);
	ERR_FAIL_COND(format != p_src->format);
	ERR_FAIL_COND_MSG(!_can_modify(format), "Cannot blit_rect in compressed or custom image formats.");

	Rect2i clipped_src_rect = Rect2i(0, 0, p_src->width, p_src->height).clip(p_src_rect);

	if (p_dest.x < 0) {
		clipped_src_rect.position.x = ABS(p_dest.x);
	}
	if (p_dest.y < 0) {
		clipped_src_rect.position.y = ABS(p_dest.y);
	}

	if (clipped_src_rect.size.x <= 0 || clipped_src_rect.size.y <= 0) {
		return;
	}

	Vector2 src_underscan = Vector2(MIN(0, p_src_rect.position.x), MIN(0, p_src_rect.position.y));
	Rect2i dest_rect = Rect2i(0, 0, width, height).clip(Rect2i(p_dest - src_underscan, clipped_src_rect.size));

	write_lock = true;
	uint8_t *dst_data_ptr = data.ptrw();

	const uint8_t *src_data_ptr = p_src->data.ptr();

	int pixel_size = get_format_pixel_size(format);

	for (int i = 0; i < dest_rect.size.y; i++) {
		for (int j = 0; j < dest_rect.size.x; j++) {
			int src_x = clipped_src_rect.position.x + j;
			int src_y = clipped_src_rect.position.y + i;

			int dst_x = dest_rect.position.x + j;
			int dst_y = dest_rect.position.y + i;

			const uint8_t *src = &src_data_ptr[(src_y * p_src->width + src_x) * pixel_size];
			uint8_t *dst = &dst_data_ptr[(dst_y * width + dst_x) * pixel_size];

			for (int k = 0; k < pixel_size; k++) {
				dst[k] = src[k];
			}
		}
	}

	write_lock = false;
}

void Image::blit_rect_mask(const Ref<Image> &p_src, const Ref<Image> &p_mask, const Rect2 &p_src_rect, const Vector2 &p_dest) {
	ERR_FAIL_COND_MSG(p_src.is_null(), "It's not a reference to a valid Image object.");
	ERR_FAIL_COND_MSG(p_mask.is_null(), "It's not a reference to a valid Image object.");
	int dsize = data.size();
	int srcdsize = p_src->data.size();
	int maskdsize = p_mask->data.size();
	ERR_FAIL_COND(dsize == 0);
	ERR_FAIL_COND(srcdsize == 0);
	ERR_FAIL_COND(maskdsize == 0);
	ERR_FAIL_COND_MSG(p_src->width != p_mask->width, "Source image width is different from mask width.");
	ERR_FAIL_COND_MSG(p_src->height != p_mask->height, "Source image height is different from mask height.");
	ERR_FAIL_COND(format != p_src->format);

	Rect2i clipped_src_rect = Rect2i(0, 0, p_src->width, p_src->height).clip(p_src_rect);

	if (p_dest.x < 0) {
		clipped_src_rect.position.x = ABS(p_dest.x);
	}
	if (p_dest.y < 0) {
		clipped_src_rect.position.y = ABS(p_dest.y);
	}

	if (clipped_src_rect.size.x <= 0 || clipped_src_rect.size.y <= 0) {
		return;
	}

	Vector2 src_underscan = Vector2(MIN(0, p_src_rect.position.x), MIN(0, p_src_rect.position.y));
	Rect2i dest_rect = Rect2i(0, 0, width, height).clip(Rect2i(p_dest - src_underscan, clipped_src_rect.size));

	write_lock = true;

	uint8_t *dst_data_ptr = data.ptrw();

	const uint8_t *src_data_ptr = p_src->data.ptr();

	int pixel_size = get_format_pixel_size(format);

	Ref<Image> msk = p_mask;
	msk->lock();

	for (int i = 0; i < dest_rect.size.y; i++) {
		for (int j = 0; j < dest_rect.size.x; j++) {
			int src_x = clipped_src_rect.position.x + j;
			int src_y = clipped_src_rect.position.y + i;

			if (msk->get_pixel(src_x, src_y).a != 0) {
				int dst_x = dest_rect.position.x + j;
				int dst_y = dest_rect.position.y + i;

				const uint8_t *src = &src_data_ptr[(src_y * p_src->width + src_x) * pixel_size];
				uint8_t *dst = &dst_data_ptr[(dst_y * width + dst_x) * pixel_size];

				for (int k = 0; k < pixel_size; k++) {
					dst[k] = src[k];
				}
			}
		}
	}

	msk->unlock();

	write_lock = false;
}

void Image::blend_rect(const Ref<Image> &p_src, const Rect2 &p_src_rect, const Vector2 &p_dest) {
	ERR_FAIL_COND_MSG(p_src.is_null(), "It's not a reference to a valid Image object.");
	int dsize = data.size();
	int srcdsize = p_src->data.size();
	ERR_FAIL_COND(dsize == 0);
	ERR_FAIL_COND(srcdsize == 0);
	ERR_FAIL_COND(format != p_src->format);

	Rect2i clipped_src_rect = Rect2i(0, 0, p_src->width, p_src->height).clip(p_src_rect);

	if (p_dest.x < 0) {
		clipped_src_rect.position.x = ABS(p_dest.x);
	}
	if (p_dest.y < 0) {
		clipped_src_rect.position.y = ABS(p_dest.y);
	}

	if (clipped_src_rect.size.x <= 0 || clipped_src_rect.size.y <= 0) {
		return;
	}

	Vector2 src_underscan = Vector2(MIN(0, p_src_rect.position.x), MIN(0, p_src_rect.position.y));
	Rect2i dest_rect = Rect2i(0, 0, width, height).clip(Rect2i(p_dest - src_underscan, clipped_src_rect.size));

	lock();
	Ref<Image> img = p_src;
	img->lock();

	for (int i = 0; i < dest_rect.size.y; i++) {
		for (int j = 0; j < dest_rect.size.x; j++) {
			int src_x = clipped_src_rect.position.x + j;
			int src_y = clipped_src_rect.position.y + i;

			int dst_x = dest_rect.position.x + j;
			int dst_y = dest_rect.position.y + i;

			Color sc = img->get_pixel(src_x, src_y);
			if (sc.a != 0) {
				Color dc = get_pixel(dst_x, dst_y);
				dc = dc.blend(sc);
				set_pixel(dst_x, dst_y, dc);
			}
		}
	}

	img->unlock();
	unlock();
}

void Image::blend_rect_mask(const Ref<Image> &p_src, const Ref<Image> &p_mask, const Rect2 &p_src_rect, const Vector2 &p_dest) {
	ERR_FAIL_COND_MSG(p_src.is_null(), "It's not a reference to a valid Image object.");
	ERR_FAIL_COND_MSG(p_mask.is_null(), "It's not a reference to a valid Image object.");
	int dsize = data.size();
	int srcdsize = p_src->data.size();
	int maskdsize = p_mask->data.size();
	ERR_FAIL_COND(dsize == 0);
	ERR_FAIL_COND(srcdsize == 0);
	ERR_FAIL_COND(maskdsize == 0);
	ERR_FAIL_COND_MSG(p_src->width != p_mask->width, "Source image width is different from mask width.");
	ERR_FAIL_COND_MSG(p_src->height != p_mask->height, "Source image height is different from mask height.");
	ERR_FAIL_COND(format != p_src->format);

	Rect2i clipped_src_rect = Rect2i(0, 0, p_src->width, p_src->height).clip(p_src_rect);

	if (p_dest.x < 0) {
		clipped_src_rect.position.x = ABS(p_dest.x);
	}
	if (p_dest.y < 0) {
		clipped_src_rect.position.y = ABS(p_dest.y);
	}

	if (clipped_src_rect.size.x <= 0 || clipped_src_rect.size.y <= 0) {
		return;
	}

	Vector2 src_underscan = Vector2(MIN(0, p_src_rect.position.x), MIN(0, p_src_rect.position.y));
	Rect2i dest_rect = Rect2i(0, 0, width, height).clip(Rect2i(p_dest - src_underscan, clipped_src_rect.size));

	lock();
	Ref<Image> img = p_src;
	Ref<Image> msk = p_mask;
	img->lock();
	msk->lock();

	for (int i = 0; i < dest_rect.size.y; i++) {
		for (int j = 0; j < dest_rect.size.x; j++) {
			int src_x = clipped_src_rect.position.x + j;
			int src_y = clipped_src_rect.position.y + i;

			// If the mask's pixel is transparent then we skip it
			// Color c = msk->get_pixel(src_x, src_y);
			// if (c.a == 0) continue;
			if (msk->get_pixel(src_x, src_y).a != 0) {
				int dst_x = dest_rect.position.x + j;
				int dst_y = dest_rect.position.y + i;

				Color sc = img->get_pixel(src_x, src_y);
				if (sc.a != 0) {
					Color dc = get_pixel(dst_x, dst_y);
					dc = dc.blend(sc);
					set_pixel(dst_x, dst_y, dc);
				}
			}
		}
	}

	msk->unlock();
	img->unlock();
	unlock();
}

// Repeats `p_pixel` `p_count` times in consecutive memory.
// Results in the original pixel and `p_count - 1` subsequent copies of it.
void Image::_repeat_pixel_over_subsequent_memory(uint8_t *p_pixel, int p_pixel_size, int p_count) {
	int offset = 1;
	for (int stride = 1; offset + stride <= p_count; stride *= 2) {
		memcpy(p_pixel + offset * p_pixel_size, p_pixel, stride * p_pixel_size);
		offset += stride;
	}
	if (offset < p_count) {
		memcpy(p_pixel + offset * p_pixel_size, p_pixel, (p_count - offset) * p_pixel_size);
	}
}

void Image::fill(const Color &p_color) {
	ERR_FAIL_COND_MSG(!_can_modify(format), "Cannot fill in compressed or custom image formats.");

	lock();

	uint8_t *dst_data_ptr = data.ptrw();

	int pixel_size = get_format_pixel_size(format);

	// Put first pixel with the format-aware API.
	set_pixel(0, 0, p_color);

	_repeat_pixel_over_subsequent_memory(dst_data_ptr, pixel_size, width * height);

	unlock();
}

void Image::fill_rect(const Rect2 &p_rect, const Color &p_color) {
	ERR_FAIL_COND_MSG(!_can_modify(format), "Cannot fill rect in compressed or custom image formats.");

	Rect2i r = Rect2i(0, 0, width, height).clip(p_rect.abs());
	if (r.has_no_area()) {
		return;
	}

	lock();

	uint8_t *dst_data_ptr = data.ptrw();

	int pixel_size = get_format_pixel_size(format);

	// Put first pixel with the format-aware API.
	uint8_t *rect_first_pixel_ptr = &dst_data_ptr[(r.position.y * width + r.position.x) * pixel_size];
	set_pixelv(r.position, p_color);

	if (r.position.x == width) {
		// No need to fill rows separately.
		_repeat_pixel_over_subsequent_memory(rect_first_pixel_ptr, pixel_size, width * r.size.y);
	} else {
		_repeat_pixel_over_subsequent_memory(rect_first_pixel_ptr, pixel_size, r.size.x);
		for (int y = 1; y < r.size.y; y++) {
			memcpy(rect_first_pixel_ptr + y * width * pixel_size, rect_first_pixel_ptr, r.size.x * pixel_size);
		}
	}

	unlock();
}

void Image::lock() {
	ERR_FAIL_COND(data.size() == 0);
	write_lock = true;
}

void Image::unlock() {
	write_lock = false;
}

Color Image::get_pixelv(const Vector2 &p_src) const {
	return get_pixel(p_src.x, p_src.y);
}

Color Image::get_pixel(int p_x, int p_y) const {
	const uint8_t *ptr = data.ptr();
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_V_MSG(!ptr, Color(), "Image must be locked with 'lock()' before using get_pixel().");

	ERR_FAIL_INDEX_V(p_x, width, Color());
	ERR_FAIL_INDEX_V(p_y, height, Color());

#endif

	uint32_t ofs = p_y * width + p_x;

	switch (format) {
		case FORMAT_L8: {
			float l = ptr[ofs] / 255.0;
			return Color(l, l, l, 1);
		}
		case FORMAT_LA8: {
			float l = ptr[ofs * 2 + 0] / 255.0;
			float a = ptr[ofs * 2 + 1] / 255.0;
			return Color(l, l, l, a);
		}
		case FORMAT_R8: {
			float r = ptr[ofs] / 255.0;
			return Color(r, 0, 0, 1);
		}
		case FORMAT_RG8: {
			float r = ptr[ofs * 2 + 0] / 255.0;
			float g = ptr[ofs * 2 + 1] / 255.0;
			return Color(r, g, 0, 1);
		}
		case FORMAT_RGB8: {
			float r = ptr[ofs * 3 + 0] / 255.0;
			float g = ptr[ofs * 3 + 1] / 255.0;
			float b = ptr[ofs * 3 + 2] / 255.0;
			return Color(r, g, b, 1);
		}
		case FORMAT_RGBA8: {
			float r = ptr[ofs * 4 + 0] / 255.0;
			float g = ptr[ofs * 4 + 1] / 255.0;
			float b = ptr[ofs * 4 + 2] / 255.0;
			float a = ptr[ofs * 4 + 3] / 255.0;
			return Color(r, g, b, a);
		}
		case FORMAT_RGBA4444: {
			uint16_t u = ((uint16_t *)ptr)[ofs];
			float r = ((u >> 12) & 0xF) / 15.0;
			float g = ((u >> 8) & 0xF) / 15.0;
			float b = ((u >> 4) & 0xF) / 15.0;
			float a = (u & 0xF) / 15.0;
			return Color(r, g, b, a);
		}
		case FORMAT_RGBA5551: {
			uint16_t u = ((uint16_t *)ptr)[ofs];
			float r = ((u >> 11) & 0x1F) / 15.0;
			float g = ((u >> 6) & 0x1F) / 15.0;
			float b = ((u >> 1) & 0x1F) / 15.0;
			float a = (u & 0x1) / 1.0;
			return Color(r, g, b, a);
		}
		case FORMAT_RF: {
			float r = ((float *)ptr)[ofs];
			return Color(r, 0, 0, 1);
		}
		case FORMAT_RGF: {
			float r = ((float *)ptr)[ofs * 2 + 0];
			float g = ((float *)ptr)[ofs * 2 + 1];
			return Color(r, g, 0, 1);
		}
		case FORMAT_RGBF: {
			float r = ((float *)ptr)[ofs * 3 + 0];
			float g = ((float *)ptr)[ofs * 3 + 1];
			float b = ((float *)ptr)[ofs * 3 + 2];
			return Color(r, g, b, 1);
		}
		case FORMAT_RGBAF: {
			float r = ((float *)ptr)[ofs * 4 + 0];
			float g = ((float *)ptr)[ofs * 4 + 1];
			float b = ((float *)ptr)[ofs * 4 + 2];
			float a = ((float *)ptr)[ofs * 4 + 3];
			return Color(r, g, b, a);
		}
		default: {
			ERR_FAIL_V_MSG(Color(), "Can't get_pixel() on compressed image, sorry.");
		}
	}
}

void Image::set_pixelv(const Vector2 &p_dst, const Color &p_color) {
	set_pixel(p_dst.x, p_dst.y, p_color);
}

void Image::set_pixel(int p_x, int p_y, const Color &p_color) {
	uint8_t *ptr = data.ptrw();
#ifdef DEBUG_ENABLED
	ERR_FAIL_COND_MSG(!ptr, "Image must be locked with 'lock()' before using set_pixel().");

	ERR_FAIL_INDEX(p_x, width);
	ERR_FAIL_INDEX(p_y, height);

#endif

	uint32_t ofs = p_y * width + p_x;

	switch (format) {
		case FORMAT_L8: {
			ptr[ofs] = uint8_t(CLAMP(p_color.get_v() * 255.0, 0, 255));
		} break;
		case FORMAT_LA8: {
			ptr[ofs * 2 + 0] = uint8_t(CLAMP(p_color.get_v() * 255.0, 0, 255));
			ptr[ofs * 2 + 1] = uint8_t(CLAMP(p_color.a * 255.0, 0, 255));
		} break;
		case FORMAT_R8: {
			ptr[ofs] = uint8_t(CLAMP(p_color.r * 255.0, 0, 255));
		} break;
		case FORMAT_RG8: {
			ptr[ofs * 2 + 0] = uint8_t(CLAMP(p_color.r * 255.0, 0, 255));
			ptr[ofs * 2 + 1] = uint8_t(CLAMP(p_color.g * 255.0, 0, 255));
		} break;
		case FORMAT_RGB8: {
			ptr[ofs * 3 + 0] = uint8_t(CLAMP(p_color.r * 255.0, 0, 255));
			ptr[ofs * 3 + 1] = uint8_t(CLAMP(p_color.g * 255.0, 0, 255));
			ptr[ofs * 3 + 2] = uint8_t(CLAMP(p_color.b * 255.0, 0, 255));
		} break;
		case FORMAT_RGBA8: {
			ptr[ofs * 4 + 0] = uint8_t(CLAMP(p_color.r * 255.0, 0, 255));
			ptr[ofs * 4 + 1] = uint8_t(CLAMP(p_color.g * 255.0, 0, 255));
			ptr[ofs * 4 + 2] = uint8_t(CLAMP(p_color.b * 255.0, 0, 255));
			ptr[ofs * 4 + 3] = uint8_t(CLAMP(p_color.a * 255.0, 0, 255));

		} break;
		case FORMAT_RGBA4444: {
			uint16_t rgba = 0;

			rgba = uint16_t(CLAMP(p_color.r * 15.0, 0, 15)) << 12;
			rgba |= uint16_t(CLAMP(p_color.g * 15.0, 0, 15)) << 8;
			rgba |= uint16_t(CLAMP(p_color.b * 15.0, 0, 15)) << 4;
			rgba |= uint16_t(CLAMP(p_color.a * 15.0, 0, 15));

			((uint16_t *)ptr)[ofs] = rgba;

		} break;
		case FORMAT_RGBA5551: {
			uint16_t rgba = 0;

			rgba = uint16_t(CLAMP(p_color.r * 31.0, 0, 31)) << 11;
			rgba |= uint16_t(CLAMP(p_color.g * 31.0, 0, 31)) << 6;
			rgba |= uint16_t(CLAMP(p_color.b * 31.0, 0, 31)) << 1;
			rgba |= uint16_t(p_color.a > 0.5 ? 1 : 0);

			((uint16_t *)ptr)[ofs] = rgba;

		} break;
		case FORMAT_RF: {
			((float *)ptr)[ofs] = p_color.r;
		} break;
		case FORMAT_RGF: {
			((float *)ptr)[ofs * 2 + 0] = p_color.r;
			((float *)ptr)[ofs * 2 + 1] = p_color.g;
		} break;
		case FORMAT_RGBF: {
			((float *)ptr)[ofs * 3 + 0] = p_color.r;
			((float *)ptr)[ofs * 3 + 1] = p_color.g;
			((float *)ptr)[ofs * 3 + 2] = p_color.b;
		} break;
		case FORMAT_RGBAF: {
			((float *)ptr)[ofs * 4 + 0] = p_color.r;
			((float *)ptr)[ofs * 4 + 1] = p_color.g;
			((float *)ptr)[ofs * 4 + 2] = p_color.b;
			((float *)ptr)[ofs * 4 + 3] = p_color.a;
		} break;
		default: {
			ERR_FAIL_MSG("Can't set_pixel() on compressed image, sorry.");
		}
	}
}

Image::DetectChannels Image::get_detected_channels() {
	ERR_FAIL_COND_V(data.size() == 0, DETECTED_RGBA);
	ERR_FAIL_COND_V(is_compressed(), DETECTED_RGBA);
	bool r = false, g = false, b = false, a = false, c = false;
	lock();
	for (int i = 0; i < width; i++) {
		for (int j = 0; j < height; j++) {
			Color col = get_pixel(i, j);

			if (col.r > 0.001) {
				r = true;
			}
			if (col.g > 0.001) {
				g = true;
			}
			if (col.b > 0.001) {
				b = true;
			}
			if (col.a < 0.999) {
				a = true;
			}

			if (col.r != col.b || col.r != col.g || col.b != col.g) {
				c = true;
			}
		}
	}

	unlock();

	if (!c && !a) {
		return DETECTED_L;
	}
	if (!c && a) {
		return DETECTED_LA;
	}

	if (r && !g && !b && !a) {
		return DETECTED_R;
	}

	if (r && g && !b && !a) {
		return DETECTED_RG;
	}

	if (r && g && b && !a) {
		return DETECTED_RGB;
	}

	return DETECTED_RGBA;
}

void Image::optimize_channels() {
	switch (get_detected_channels()) {
		case DETECTED_L:
			convert(FORMAT_L8);
			break;
		case DETECTED_LA:
			convert(FORMAT_LA8);
			break;
		case DETECTED_R:
			convert(FORMAT_R8);
			break;
		case DETECTED_RG:
			convert(FORMAT_RG8);
			break;
		case DETECTED_RGB:
			convert(FORMAT_RGB8);
			break;
		case DETECTED_RGBA:
			convert(FORMAT_RGBA8);
			break;
	}
}

void Image::normalmap_to_xy() {
	convert(Image::FORMAT_RGBA8);

	{
		write_lock = true;

		int len = data.size() / 4;
		unsigned char *data_ptr = data.ptrw();

		for (int i = 0; i < len; i++) {
			data_ptr[(i << 2) + 3] = data_ptr[(i << 2) + 0]; // x to w
			data_ptr[(i << 2) + 0] = data_ptr[(i << 2) + 1]; // y to xz
			data_ptr[(i << 2) + 2] = data_ptr[(i << 2) + 1];
		}

		write_lock = false;
	}

	convert(Image::FORMAT_LA8);
}

Ref<Image> Image::rgbe_to_srgb() {
	return Ref<Image>();
}

void Image::bumpmap_to_normalmap(float bump_scale) {
	ERR_FAIL_COND(!_can_modify(format));
	ERR_FAIL_COND_MSG(write_lock, "Cannot modify image when it is locked.");
	convert(Image::FORMAT_RF);

	Vector<uint8_t> result_image; // rgba output
	result_image.resize(width * height * 4);

	{
		write_lock = true;

		unsigned char *write_ptr = result_image.ptrw();
		float *read_ptr = (float *)data.ptrw();

		for (int ty = 0; ty < height; ty++) {
			int py = ty + 1;
			if (py >= height) {
				py -= height;
			}

			for (int tx = 0; tx < width; tx++) {
				int px = tx + 1;
				if (px >= width) {
					px -= width;
				}
				float here = read_ptr[ty * width + tx];
				float to_right = read_ptr[ty * width + px];
				float above = read_ptr[py * width + tx];
				Vector3 up = Vector3(0, 1, (here - above) * bump_scale);
				Vector3 across = Vector3(1, 0, (to_right - here) * bump_scale);

				Vector3 normal = across.cross(up);
				normal.normalize();

				write_ptr[((ty * width + tx) << 2) + 0] = (127.5 + normal.x * 127.5);
				write_ptr[((ty * width + tx) << 2) + 1] = (127.5 + normal.y * 127.5);
				write_ptr[((ty * width + tx) << 2) + 2] = (127.5 + normal.z * 127.5);
				write_ptr[((ty * width + tx) << 2) + 3] = 255;
			}
		}

		write_lock = false;
	}
	format = FORMAT_RGBA8;
	data = result_image;
}

void Image::srgb_to_linear() {
	if (data.size() == 0) {
		return;
	}

	static const uint8_t srgb2lin[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27, 27, 28, 29, 29, 30, 31, 31, 32, 33, 33, 34, 35, 36, 36, 37, 38, 38, 39, 40, 41, 42, 42, 43, 44, 45, 46, 47, 47, 48, 49, 50, 51, 52, 53, 54, 55, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 92, 93, 94, 95, 97, 98, 99, 101, 102, 103, 105, 106, 107, 109, 110, 112, 113, 114, 116, 117, 119, 120, 122, 123, 125, 126, 128, 129, 131, 132, 134, 135, 137, 139, 140, 142, 144, 145, 147, 148, 150, 152, 153, 155, 157, 159, 160, 162, 164, 166, 167, 169, 171, 173, 175, 176, 178, 180, 182, 184, 186, 188, 190, 192, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 218, 220, 222, 224, 226, 228, 230, 232, 235, 237, 239, 241, 243, 245, 248, 250, 252, 255 };

	ERR_FAIL_COND(format != FORMAT_RGB8 && format != FORMAT_RGBA8);

	if (format == FORMAT_RGBA8) {
		write_lock = true;

		int len = data.size() / 4;
		unsigned char *data_ptr = data.ptrw();

		for (int i = 0; i < len; i++) {
			data_ptr[(i << 2) + 0] = srgb2lin[data_ptr[(i << 2) + 0]];
			data_ptr[(i << 2) + 1] = srgb2lin[data_ptr[(i << 2) + 1]];
			data_ptr[(i << 2) + 2] = srgb2lin[data_ptr[(i << 2) + 2]];
		}

		write_lock = false;
	} else if (format == FORMAT_RGB8) {
		write_lock = true;

		int len = data.size() / 3;
		unsigned char *data_ptr = data.ptrw();

		for (int i = 0; i < len; i++) {
			data_ptr[(i * 3) + 0] = srgb2lin[data_ptr[(i * 3) + 0]];
			data_ptr[(i * 3) + 1] = srgb2lin[data_ptr[(i * 3) + 1]];
			data_ptr[(i * 3) + 2] = srgb2lin[data_ptr[(i * 3) + 2]];
		}

		write_lock = false;
	}
}

void Image::premultiply_alpha() {
	if (data.size() == 0) {
		return;
	}

	if (format != FORMAT_RGBA8) {
		return; // not needed
	}

	write_lock = true;

	unsigned char *data_ptr = data.ptrw();

	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			uint8_t *ptr = &data_ptr[(i * width + j) * 4];

			ptr[0] = (uint16_t(ptr[0]) * uint16_t(ptr[3])) >> 8;
			ptr[1] = (uint16_t(ptr[1]) * uint16_t(ptr[3])) >> 8;
			ptr[2] = (uint16_t(ptr[2]) * uint16_t(ptr[3])) >> 8;
		}
	}

	write_lock = false;
}

void Image::fix_alpha_edges() {
	ERR_FAIL_COND(!_can_modify(format));
	ERR_FAIL_COND_MSG(write_lock, "Cannot modify image when it is locked.");

	if (data.size() == 0) {
		return;
	}

	if (format != FORMAT_RGBA8) {
		return; // not needed
	}

	write_lock = true;

	Vector<uint8_t> dcopy = data;
	const uint8_t *srcptr = dcopy.ptr();

	unsigned char *data_ptr = data.ptrw();

	const int max_radius = 4;
	const int alpha_threshold = 20;
	const int max_dist = 0x7FFFFFFF;

	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			const uint8_t *rptr = &srcptr[(i * width + j) * 4];
			uint8_t *wptr = &data_ptr[(i * width + j) * 4];

			if (rptr[3] >= alpha_threshold) {
				continue;
			}

			int closest_dist = max_dist;
			uint8_t closest_color[3];

			int from_x = MAX(0, j - max_radius);
			int to_x = MIN(width - 1, j + max_radius);
			int from_y = MAX(0, i - max_radius);
			int to_y = MIN(height - 1, i + max_radius);

			for (int k = from_y; k <= to_y; k++) {
				for (int l = from_x; l <= to_x; l++) {
					int dy = i - k;
					int dx = j - l;
					int dist = dy * dy + dx * dx;
					if (dist >= closest_dist) {
						continue;
					}

					const uint8_t *rp2 = &srcptr[(k * width + l) << 2];

					if (rp2[3] < alpha_threshold) {
						continue;
					}

					closest_dist = dist;
					closest_color[0] = rp2[0];
					closest_color[1] = rp2[1];
					closest_color[2] = rp2[2];
				}
			}

			if (closest_dist != max_dist) {
				wptr[0] = closest_color[0];
				wptr[1] = closest_color[1];
				wptr[2] = closest_color[2];
			}
		}
	}

	write_lock = false;
}

String Image::get_format_name(Format p_format) {
	ERR_FAIL_INDEX_V(p_format, FORMAT_MAX, String());
	return format_names[p_format];
}

void Image::average_4_uint8(uint8_t &p_out, const uint8_t &p_a, const uint8_t &p_b, const uint8_t &p_c, const uint8_t &p_d) {
	p_out = static_cast<uint8_t>((p_a + p_b + p_c + p_d + 2) >> 2);
}

void Image::average_4_float(float &p_out, const float &p_a, const float &p_b, const float &p_c, const float &p_d) {
	p_out = (p_a + p_b + p_c + p_d) * 0.25f;
}

void Image::average_4_half(uint16_t &p_out, const uint16_t &p_a, const uint16_t &p_b, const uint16_t &p_c, const uint16_t &p_d) {
	p_out = Math::make_half_float((Math::half_to_float(p_a) + Math::half_to_float(p_b) + Math::half_to_float(p_c) + Math::half_to_float(p_d)) * 0.25f);
}

void Image::average_4_rgbe9995(uint32_t &p_out, const uint32_t &p_a, const uint32_t &p_b, const uint32_t &p_c, const uint32_t &p_d) {
	p_out = ((Color::from_rgbe9995(p_a) + Color::from_rgbe9995(p_b) + Color::from_rgbe9995(p_c) + Color::from_rgbe9995(p_d)) * 0.25f).to_rgbe9995();
}

void Image::renormalize_uint8(uint8_t *p_rgb) {
	Vector3 n(p_rgb[0] / 255.0, p_rgb[1] / 255.0, p_rgb[2] / 255.0);
	n *= 2.0;
	n -= Vector3(1, 1, 1);
	n.normalize();
	n += Vector3(1, 1, 1);
	n *= 0.5;
	n *= 255;
	p_rgb[0] = CLAMP(int(n.x), 0, 255);
	p_rgb[1] = CLAMP(int(n.y), 0, 255);
	p_rgb[2] = CLAMP(int(n.z), 0, 255);
}

void Image::renormalize_float(float *p_rgb) {
	Vector3 n(p_rgb[0], p_rgb[1], p_rgb[2]);
	n.normalize();
	p_rgb[0] = n.x;
	p_rgb[1] = n.y;
	p_rgb[2] = n.z;
}

void Image::renormalize_half(uint16_t *p_rgb) {
	Vector3 n(Math::half_to_float(p_rgb[0]), Math::half_to_float(p_rgb[1]), Math::half_to_float(p_rgb[2]));
	n.normalize();
	p_rgb[0] = Math::make_half_float(n.x);
	p_rgb[1] = Math::make_half_float(n.y);
	p_rgb[2] = Math::make_half_float(n.z);
}

void Image::renormalize_rgbe9995(uint32_t *p_rgb) {
	// Never used
}

Ref<Image> Image::duplicate() const {
	Ref<Image> copy;
	copy.instance();
	copy->_copy_internals_from(*this);
	return copy;
}

Image::Image() {
	width = 0;
	height = 0;
	mipmaps = false;
	format = FORMAT_L8;

	write_lock = false;
}

Image::~Image() {
	write_lock = false;
}

#undef DETECT_ALPHA_MAX_THRESHOLD
#undef DETECT_ALPHA_MIN_THRESHOLD
#undef DETECT_ALPHA
#undef DETECT_NON_ALPHA
#line 0

#line 1 "sfw/render_core/app_window.cpp"
//-----------------------------------------------------------------------------
// fps locking

/*
static volatile float framerate = 0;
static volatile unsigned fps_active, timer_counter, loop_counter;
static int fps__timing_thread(void *arg) {
	int64_t ns_excess = 0;
	while (fps_active) {
		if (framerate <= 0) {
			loop_counter = timer_counter = 0;
			SFWTime::sleep_ms(250);
		} else {
			timer_counter++;
			int64_t tt = (int64_t)(1e9 / (float)framerate) - ns_excess;
			uint64_t took = -SFWTime::time_ns();
#if is(win32)
			timeBeginPeriod(1);
			Sleep(tt > 0 ? tt / 1e6 : 0);
#else
			sleep_ns((float)tt);
#endif
			took += time_ns();
			ns_excess = took - tt;
			if (ns_excess < 0)
				ns_excess = 0;
			//puts( strf("%lld", ns_excess) );
		}
	}
	fps_active = 1;

	(void)arg;
	return thread_exit(0), 0;
}
static void fps_locker(int on) {
	if (on) {
		// private threaded timer
		fps_active = 1, timer_counter = loop_counter = 0;
		thread_init(fps__timing_thread, 0, "fps__timing_thread()", 0);
	} else {
		fps_active = 0;
	}
}
// function that locks render to desired `framerate` framerate (in FPS).
// - assumes fps_locker() was enabled beforehand.
// - returns true if must render, else 0.
static int fps_wait() {
	if (framerate <= 0)
		return 1;
	if (!fps_active)
		return 1;

	// if we throttled too much, cpu idle wait
	while (fps_active && (loop_counter > timer_counter)) {
		//thread_yield();
		SFWTime::sleep_ns(100);
	}

	// max auto frameskip is 10: ie, even if speed is low paint at least one frame every 10
	enum { maxframeskip = 10 };
	if (timer_counter > loop_counter + maxframeskip) {
		loop_counter = timer_counter;
	}
	loop_counter++;

	// only draw if we are fast enough, otherwise skip the frame
	return loop_counter >= timer_counter;
}
static void AppWindow::vsync(float hz) {
	if (hz <= 0)
		return;
	do_once fps_locker(1);
	framerate = hz;
	fps_wait();
}
*/

//-----------------------------------------------------------------------------

#if 0 // deprecated
static void (*hooks[64])() = {0};
static void *userdatas[64] = {0};

bool AppWindow::hook(void (*func)(), void* user) {
    unhook( func );
    for( int i = 0; i < 64; ++i ) {
        if( !hooks[i] ) {
            hooks[i] = func;
            userdatas[i] = user;
            return true;
        }
    }
    return false;
}
void AppWindow::unhook(void (*func)()) {
    for( int i = 0; i < 64; ++i ) {
        if(hooks[i] == func) {
            hooks[i] = 0;
            userdatas[i] = 0;
        }
    }
}
#endif

// -----------------------------------------------------------------------------
// glfw

void AppWindow::glfw_error_callback(int error, const char *description) {
#ifdef __APPLE__
	if (error == 65544)
		return; // whitelisted
#endif

	CRASH_MSG(String(description) + " (error " + String::num(error) + ")");
}

void AppWindow::glfw_quit() {
	glfwTerminate();
}

void AppWindow::glfw_init() {
	glfwSetErrorCallback(glfw_error_callback);
	int ok = glfwInit();

	CRASH_COND(!ok);

	atexit(glfw_quit); //glfwTerminate);
}

void AppWindow::drop_callback(GLFWwindow *window, int count, const char **paths) {
}

void AppWindow::window_hints(unsigned flags) {
#ifdef __APPLE__
	glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_FALSE); // @todo: remove silicon mac M1 hack
#endif

#if defined(__APPLE__)
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
	//according to the documentation, it must be GLFW_OPENGL_ANY_PROFILE.
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_ANY_PROFILE);
#elif defined(_WIN64) || defined(_WIN32)
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
	//according to the documentation, it must be GLFW_OPENGL_ANY_PROFILE.
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_ANY_PROFILE);
#else
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);
	glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);
#endif

	//glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //osx+ems
	glfwWindowHint(GLFW_STENCIL_BITS, 8); //osx
	glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);

	//glfwWindowHint( GLFW_RED_BITS, 8 );
	//glfwWindowHint( GLFW_GREEN_BITS, 8 );
	//glfwWindowHint( GLFW_BLUE_BITS, 8 );
	//glfwWindowHint( GLFW_ALPHA_BITS, 8 );
	//glfwWindowHint( GLFW_DEPTH_BITS, 24 );

	//glfwWindowHint(GLFW_AUX_BUFFERS, Nth);
	//glfwWindowHint(GLFW_STEREO, GL_TRUE);
	glfwWindowHint(GLFW_DOUBLEBUFFER, GL_TRUE);

	// Prevent fullscreen window minimize on focus loss
	glfwWindowHint(GLFW_AUTO_ICONIFY, GL_FALSE);

	// Fix SRGB on intels
	glfwWindowHint(GLFW_SRGB_CAPABLE, GLFW_TRUE);

	glfwWindowHint(GLFW_FOCUSED, GLFW_TRUE);
	glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE);
	// glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
	// glfwWindowHint(GLFW_DECORATED, GLFW_FALSE); // makes it non-resizable
	//if(flags & WINDOW_MSAA2) glfwWindowHint(GLFW_SAMPLES, 2); // x2 AA
	//if(flags & WINDOW_MSAA4) glfwWindowHint(GLFW_SAMPLES, 4); // x4 AA
	//if(flags & WINDOW_MSAA8) glfwWindowHint(GLFW_SAMPLES, 8); // x8 AA

	AppWindow::get_singleton()->_window_flags = flags;
}

void AppWindow::glNewFrame() {
	// @transparent debug
	// if( input_down(KEY_F1) ) transparent(window_has_transparent()^1);
	// if( input_down(KEY_F2) ) maximize(window_has_maximize()^1);
	// @transparent debug

#if 0 // #ifdef __EMSCRIPTEN__
    int canvasWidth, canvasHeight;
    emscripten_get_canvas_element_size("#canvas", &canvasWidth, &canvasHeight);
    w = canvasWidth;
    h = canvasHeight;
    //printf("%dx%d\n", w, h);
#else
	//glfwGetWindowSize(window, &w, &h);
	glfwGetFramebufferSize(_window, &w, &h);
	//printf("%dx%d\n", w, h);
#endif

	AppWindow::get_singleton()->width = w;
	AppWindow::get_singleton()->height = h;

	glViewport(0, 0, width, height);
}

bool AppWindow::create_from_handle(void *handle, bool full_Screen, float canvas_scale, unsigned int flags, float window_scale) {
	// abort run if any test suite failed in unit-test mode

	glfw_init();
	//fwk_init();

	if (!t) {
		t = glfwGetTime();
	}

#ifdef __EMSCRIPTEN__
	canvas_scale = 1.f;
#endif

	_fullscreen = full_Screen;

	bool FLAGS_FULLSCREEN = _fullscreen;
	bool FLAGS_FULLSCREEN_DESKTOP = _fullscreen && canvas_scale == 1;
	bool FLAGS_WINDOWED = !_fullscreen;
	bool FLAGS_TRANSPARENT = _transparent || (flags & WINDOW_TRANSPARENT);

	if (FLAGS_TRANSPARENT) {
		FLAGS_FULLSCREEN = false;
		FLAGS_FULLSCREEN_DESKTOP = false;
		FLAGS_WINDOWED = true;
	}

	int winWidth = get_canvas().x * window_scale;
	int winHeight = get_canvas().y * window_scale;

	window_hints(flags);

	GLFWmonitor *monitor = NULL;
#ifndef __EMSCRIPTEN__
	if (FLAGS_FULLSCREEN || FLAGS_FULLSCREEN_DESKTOP) {
		monitor = glfwGetPrimaryMonitor();
	}

	if (FLAGS_FULLSCREEN_DESKTOP) {
		const GLFWvidmode *mode = glfwGetVideoMode(monitor);
		glfwWindowHint(GLFW_RED_BITS, mode->redBits);
		glfwWindowHint(GLFW_GREEN_BITS, mode->greenBits);
		glfwWindowHint(GLFW_BLUE_BITS, mode->blueBits);
		glfwWindowHint(GLFW_REFRESH_RATE, mode->refreshRate);

		winWidth = mode->width;
		winHeight = mode->height;
	}

	if (FLAGS_WINDOWED) {
#ifndef __EMSCRIPTEN__
		if (FLAGS_TRANSPARENT) { // @transparent
			//glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE); // see through. requires undecorated
			//glfwWindowHint(GLFW_FLOATING, GLFW_TRUE); // always on top
			glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE);
		}

		if (flags & WINDOW_BORDERLESS) {
			glfwWindowHint(GLFW_DECORATED, GLFW_FALSE);
		}
#endif
		// windowed
		float ratio = (float)winWidth / (winHeight + !winHeight);

		if (flags & WINDOW_SQUARE) {
			winWidth = winHeight = winWidth > winHeight ? winHeight : winWidth;
		}

		//if( flags & WINDOW_LANDSCAPE ) if( winWidth < winHeight ) winHeight = winWidth * ratio;
		if (flags & WINDOW_PORTRAIT) {
			if (winWidth > winHeight) {
				winWidth = winHeight * (1.f / ratio);
			}
		}
	}
#endif

	_window = handle ? (GLFWwindow *)handle : glfwCreateWindow(winWidth, winHeight, "", monitor, NULL);

	ERR_FAIL_COND_V_MSG(!_window, false, "GLFW Window creation failed");

	glfwGetFramebufferSize(_window, &w, &h); //glfwGetWindowSize(window, &w, &h);

	if (flags & WINDOW_FIXED) { // disable resizing
		glfwSetWindowSizeLimits(_window, w, h, w, h);
	}

	if (flags & (WINDOW_SQUARE | WINDOW_PORTRAIT | WINDOW_LANDSCAPE | WINDOW_ASPECT)) { // keep aspect ratio
		aspect_lock(w, h);
	}

#ifndef __EMSCRIPTEN__
	if (FLAGS_WINDOWED) {
		// center window
		monitor = monitor ? monitor : glfwGetPrimaryMonitor();
		const GLFWvidmode *mode = glfwGetVideoMode(monitor);

		int area_width = mode->width;
		int area_height = mode->height;
		glfwGetMonitorWorkarea(monitor, &xpos, &ypos, &area_width, &area_height);

		xpos = xpos + (area_width - winWidth) / 2;
		ypos = ypos + (area_height - winHeight) / 2;
		glfwSetWindowPos(_window, xpos, ypos);
		//printf("%dx%d @(%d,%d) [res:%dx%d]\n", winWidth, winHeight, xpos,ypos, area_width, area_height );

		wprev = w;
		hprev = h;
		xprev = xpos;
		yprev = ypos;
	}
#endif

	glfwMakeContextCurrent(_window);

#ifdef __EMSCRIPTEN__
	if (FLAGS_FULLSCREEN) {
		fullscreen(1);
	}
#else
	int gl_version = gladLoadGL(glfwGetProcAddress);
#endif

	//glDebugEnable();

	//glEnable(GL_TEXTURE_2D);

	// 0:disable vsync, 1:enable vsync, <0:adaptive (allow vsync when framerate is higher than syncrate and disable vsync when framerate drops below syncrate)
	//flags |= _vsync ? WINDOW_VSYNC : WINDOW_VSYNC_DISABLED;
	//flags |= _vsync_adaptive ? WINDOW_VSYNC_ADAPTIVE : 0;

	flags |= WINDOW_VSYNC_DISABLED;

	//int has_adaptive_vsync = glfwExtensionSupported("WGL_EXT_swap_control_tear") || glfwExtensionSupported("GLX_EXT_swap_control_tear") || //glfwExtensionSupported("EXT_swap_control_tear");
	//int wants_adaptive_vsync = (flags & WINDOW_VSYNC_ADAPTIVE);
	//int interval = has_adaptive_vsync && wants_adaptive_vsync ? -1 : (flags & WINDOW_VSYNC_DISABLED ? 0 : 1);
	//glfwSwapInterval(interval);

	//const GLFWvidmode *mode = glfwGetVideoMode(monitor ? monitor : glfwGetPrimaryMonitor());

	//PRINTF("Build version: %s\n", BUILD_VERSION);
	//PRINTF("Monitor: %s (%dHz, vsync=%d)\n", glfwGetMonitorName(monitor ? monitor : glfwGetPrimaryMonitor()), mode->refreshRate, interval);
	//PRINTF("GPU device: %s\n", glGetString(GL_RENDERER));
	//PRINTF("GPU driver: %s\n", glGetString(GL_VERSION));

#ifndef __EMSCRIPTEN__
	LOG_MSG("GPU OpenGL: " + String::num(GLAD_VERSION_MAJOR(gl_version)) + " " + String::num(GLAD_VERSION_MINOR(gl_version)));

	if (FLAGS_TRANSPARENT) { // @transparent
		glfwSetWindowAttrib(_window, GLFW_DECORATED, GLFW_FALSE); // @todo: is decorated an attrib or a hint?

		if (canvas_scale >= 1) {
			glfwMaximizeWindow(_window);
		}
	}
#endif

	width = get_width();
	height = get_height();

	RenderState::window_update_render_rect_size(width, height);

	// cursor(flags & WINDOW_NO_MOUSE ? false : true);
	glfwSetDropCallback(_window, drop_callback);

	// camera inits for fwk_pre_init() -> ddraw_flush() -> get_active_camera()
	// static camera_t cam = {0}; id44(cam.view); id44(cam.proj); extern camera_t *last_camera; last_camera = &cam;
	//fwk_pre_init();

	//fwk_post_init(mode->refreshRate);

	Input::get_singleton()->_setup_window_callbacks();

	return true;
}

bool AppWindow::create(bool full_Screen, float canvas_scale, unsigned int flags, float window_scale) {
	return create_from_handle(NULL, full_Screen, canvas_scale, flags, window_scale);
}

char *AppWindow::get_stats() {
	static double num_frames = 0, begin = FLT_MAX, prev_frame = 0;

	double now = SFWTime::time_ss();
	if (boot_time < 0) {
		boot_time = now;
	}

	if (begin > now) {
		begin = now;
		num_frames = 0;
	}
	if ((now - begin) >= 0.25f) {
		fps = num_frames * (1.f / (now - begin));
	}
	if ((now - begin) > 1) {
		begin = now + ((now - begin) - 1);
		num_frames = 0;
	}

	//const char *cmdline = app_cmdline();

	// @todo: print %used/%avail kib mem, %used/%avail objs as well
	static char buf[256];
	snprintf(buf, 256, "%s | boot %.2fs | %5.2ffps (%.2fms)",
			title,
			!boot_time ? now : boot_time,
			fps, (now - prev_frame) * 1000.f);
	//cmdline[0] ? " | " : "", cmdline[0] ? cmdline : "");

	prev_frame = now;
	++num_frames;

	return buf + strspn(buf, " ");
}

int AppWindow::frame_begin() {
	glfwPollEvents();

	if (glfwWindowShouldClose(_window)) {
		return 0;
	}

	glNewFrame();

	double now = paused ? t : glfwGetTime();
	dt = now - t;
	t = now;

	glfwSetWindowTitle(_window, title);

	return 1;
}

void AppWindow::frame_end() {
}

void AppWindow::frame_swap() {
	glfwSwapBuffers(_window);
	// emscripten_webgl_commit_frame();
}

void AppWindow::reset_viewport() {
	glViewport(0, 0, width, height);
}

void AppWindow::resize() {
#ifdef __EMSCRIPTEN__
	EM_ASM(canvas.canResize = 0);
	if (g->flags & WINDOW_FIXED)
		return;
	EM_ASM(canvas.canResize = 1);
	Vector2 size = canvas();
	if (size.x != last_canvas_size.x || size.y != last_canvas_size.y) {
		w = size.x;
		h = size.y;
		width = w;
		height = h;
		last_canvas_size = Vector2(w, h);
		emscripten_set_canvas_size(w, h);
	}
#endif /* __EMSCRIPTEN__ */
}

Vector2 AppWindow::get_canvas() {
#ifdef __EMSCRIPTEN__
	int width = EM_ASM_INT_V(return canvas.width);
	int height = EM_ASM_INT_V(return canvas.height);
	return Vector2(width, height);
#else
	glfw_init();
	const GLFWvidmode *mode = glfwGetVideoMode(glfwGetPrimaryMonitor());
	CRASH_COND(!mode);
	return Vector2(mode->width, mode->height);
#endif /* __EMSCRIPTEN__ */
}

int AppWindow::get_width() {
	return w;
}
int AppWindow::get_height() {
	return h;
}
double AppWindow::get_time() {
	return t;
}
double AppWindow::get_delta() {
	return dt;
}

double AppWindow::get_fps() {
	return fps;
}
void AppWindow::fps_lock(float fps) {
	hz = fps;
}
void AppWindow::fps_unlock() {
	hz = 0;
}
double AppWindow::get_fps_target() {
	return hz;
}

uint64_t AppWindow::frame() {
	return frame_count;
}
void AppWindow::set_title(const char *title_) {
	snprintf(title, 128, "%s", title_);
	if (!title[0]) {
		glfwSetWindowTitle(_window, title);
	}
}
void AppWindow::set_color(unsigned color) {
	unsigned r = (color >> 0) & 255;
	unsigned g = (color >> 8) & 255;
	unsigned b = (color >> 16) & 255;
	unsigned a = (color >> 24) & 255;
	winbgcolor = Color(r / 255.0, g / 255.0, b / 255.0, a / 255.0);
}

int AppWindow::has_icon() {
	return _has_icon;
}
void AppWindow::set_icon(const char *file_icon) {
	/*
	int len = 0;
	void *data = vfs_load(file_icon, &len);
	if (!data)
		data = file_read(file_icon), len = file_size(file_icon);

	if (data && len) {
		image_t img = image_from_mem(data, len, IMAGE_RGBA);
		if (img.w && img.h && img.pixels) {
			GLFWimage images[1];
			images[0].width = img.w;
			images[0].height = img.h;
			images[0].pixels = img.pixels;
			glfwSetWindowIcon(window, 1, images);
			has_icon = 1;
			return;
		}
	}
#if 0 // is(win32)
	HANDLE hIcon = LoadImageA(0, file_icon, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);
	if( hIcon ) {
		HWND hWnd = glfwGetWin32Window(window);
		SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
		SendMessage(hWnd, WM_SETICON, ICON_BIG,   (LPARAM)hIcon);
		SendMessage(GetWindow(hWnd, GW_OWNER), WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
		SendMessage(GetWindow(hWnd, GW_OWNER), WM_SETICON, ICON_BIG,   (LPARAM)hIcon);
		has_icon = 1;
		return;
	}
#endif
	*/
}
void *AppWindow::get_handle() {
	return _window;
}

Vector2 AppWindow::dpi() {
	Vector2 dpi = Vector2(1, 1);

#if !defined(__EMSCRIPTEN__) && !defined(__APPLE__) // @todo: remove silicon mac M1 hack`
	glfwGetMonitorContentScale(glfwGetPrimaryMonitor(), &dpi.x, &dpi.y);
#endif
	return dpi;
}

// -----------------------------------------------------------------------------
// fullscreen

GLFWmonitor *AppWindow::find_monitor(int wx, int wy) {
	GLFWmonitor *monitor = glfwGetPrimaryMonitor();

	// find best monitor given current window coordinates. @todo: select by ocuppied window area inside each monitor instead.
	int num_monitors = 0;
	GLFWmonitor **monitors = glfwGetMonitors(&num_monitors);
#ifdef __EMSCRIPTEN__
	return *monitors;
#else
	for (int i = 0; i < num_monitors; ++i) {
		int mx = 0, my = 0, mw = 0, mh = 0;
		glfwGetMonitorWorkarea(monitors[i], &mx, &my, &mw, &mh);
		monitor = wx >= mx && wx <= (mx + mw) && wy >= my && wy <= (my + mh) ? monitors[i] : monitor;
	}
	return monitor;
#endif
}

#if 0 // to deprecate

void AppWindow::fullscreen(int enabled) {
    fullscreen = !!enabled;
#ifndef __EMSCRIPTEN__
    if( fullscreen ) {
        int wx = 0, wy = 0; glfwGetWindowPos(window, &wx, &wy);
        GLFWmonitor *monitor = find_monitor(wx, wy);

        wprev = w, hprev = h, xprev = wx, yprev = wy; // save window context for further restoring

        int width, height;
        glfwGetMonitorWorkarea(monitor, NULL, NULL, &width, &height);
        glfwSetWindowMonitor(window, monitor, 0, 0, width, height, GLFW_DONT_CARE);
    } else {
        glfwSetWindowMonitor(window, NULL, xpos, ypos, wprev, hprev, GLFW_DONT_CARE);
        glfwSetWindowPos(window, xprev, yprev);
    }
#endif
}
int AppWindow::has_fullscreen() {
    return fullscreen;
}

#else

int AppWindow::has_fullscreen() {
#ifdef __EMSCRIPTEN__
	EmscriptenFullscreenChangeEvent fsce;
	emscripten_get_fullscreen_status(&fsce);
	return !!fsce.isFullscreen;
#else
	return !!glfwGetWindowMonitor(_window);
#endif /* __EMSCRIPTEN__ */
}

void AppWindow::set_fullscreen(int enabled) {
	if (has_fullscreen() == enabled) {
		return;
	}

#ifdef __EMSCRIPTEN__

#if 0 // deprecated: crash
    if( enabled ) {
        emscripten_exit_soft_fullscreen();

        /* Workaround https://github.com/kripken/emscripten/issues/5124#issuecomment-292849872 */
        EM_ASM(JSEvents.inEventHandler = true);
        EM_ASM(JSEvents.currentEventHandler = {allowsDeferredCalls:true});

        EmscriptenFullscreenStrategy strategy = {0};
        strategy.scaleMode = EMSCRIPTEN_FULLSCREEN_SCALE_STRETCH; // _ASPECT
        strategy.canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF; // _NONE _HIDEF
        strategy.filteringMode = EMSCRIPTEN_FULLSCREEN_FILTERING_DEFAULT; // _NEAREST

        emscripten_request_fullscreen_strategy(NULL, EM_FALSE/*EM_TRUE*/, &strategy);
        //emscripten_enter_soft_fullscreen(NULL, &strategy);
    } else {
        emscripten_exit_fullscreen();
    }
#else
	if (enabled)
		EM_ASM(Module.requestFullscreen(1, 1));
	else
		EM_ASM(Module.exitFullscreen());
#endif

#else

#if 0
    if( enabled ) {
        /*glfwGetWindowPos(g->window, &g->window_xpos, &g->window_ypos);*/
        glfwGetWindowSize(g->window, &g->width, &g->height);
        glfwSetWindowMonitor(g->window, glfwGetPrimaryMonitor(), 0, 0, g->width, g->height, GLFW_DONT_CARE);
    } else {
        glfwSetWindowMonitor(g->window, NULL, 0, 0, g->width, g->height, GLFW_DONT_CARE);
    }
#else
	if (enabled) {
		int wx = 0, wy = 0;
		glfwGetWindowPos(_window, &wx, &wy);
		GLFWmonitor *monitor = find_monitor(wx, wy);

		wprev = w, hprev = h, xprev = wx, yprev = wy; // save window context for further restoring

		int width, height;
		glfwGetMonitorWorkarea(monitor, NULL, NULL, &width, &height);
		glfwSetWindowMonitor(_window, monitor, 0, 0, width, height, GLFW_DONT_CARE);
	} else {
		glfwSetWindowMonitor(_window, NULL, xpos, ypos, wprev, hprev, GLFW_DONT_CARE);
		glfwSetWindowPos(_window, xprev, yprev);
	}
#endif

#endif
}

#endif

void AppWindow::set_pause(int enabled) {
	paused = enabled;
}
int AppWindow::has_pause() {
	return paused;
}
void AppWindow::set_focus() {
	glfwFocusWindow(_window);
}
int AppWindow::has_focus() {
	return glfwGetWindowAttrib(_window, GLFW_FOCUSED);
}

void AppWindow::create_default_cursors() {
	if (_cursors_initialized) {
		return;
	}

	_cursors_initialized = true;

	unsigned int pixels[16 * 16] = { 0x01000000 }; // ABGR(le) glfw3 note: A(0x00) means 0xFF for some reason
	GLFWimage image = { 16, 16, (unsigned char *)pixels };
	GLFWcursor *empty;

	for (int x = 0; x < 16 * 16; ++x) {
		pixels[x] = pixels[0];
	}

	empty = glfwCreateCursor(&image, 0, 0);

	for (int i = 0; i < 7; ++i) {
		cursors[i] = i ? glfwCreateStandardCursor(cursor_enums[i]) : empty;
	}
}

void AppWindow::set_cursor_shape(const CURSOR_SHAPES mode) {
	_cursorshape = static_cast<int>(mode);

	create_default_cursors();

	glfwSetCursor(_window, _cursorshape < 7 ? cursors[_cursorshape] : NULL);
}

void AppWindow::set_mouse_mode(MouseMode p_mode) {
	int im;

	if (p_mode == MOUSE_MODE_HIDDEN) {
		im = GLFW_CURSOR_HIDDEN;
	} else if (p_mode == MOUSE_MODE_CAPTURED) {
		im = GLFW_CURSOR_DISABLED;
	} else {
		//MOUSE_MODE_VISIBLE
		im = GLFW_CURSOR_NORMAL;
	}

	glfwSetInputMode(_window, GLFW_CURSOR, im);
}
AppWindow::MouseMode AppWindow::get_mouse_mode() const {
	int im = glfwGetInputMode(_window, GLFW_CURSOR);

	if (im == GLFW_CURSOR_HIDDEN) {
		return MOUSE_MODE_HIDDEN;
	} else if (im == GLFW_CURSOR_DISABLED) {
		return MOUSE_MODE_CAPTURED;
	}

	return MOUSE_MODE_VISIBLE;
}

void AppWindow::set_visible(int visible) {
	if (!_window) {
		return;
	}

	//if(window) (visible ? glfwRestoreWindow : glfwIconifyWindow)(window);
	(visible ? glfwShowWindow : glfwHideWindow)(_window);

// call glfwpollevents in linux to flush visiblity changes that would happen in next frame otherwise
#if defined(__linux__) || defined(__APPLE__)
	glfwPollEvents();
#endif
}
int AppWindow::has_visible() {
	return glfwGetWindowAttrib(_window, GLFW_VISIBLE);
}

double AppWindow::get_aspect() {
	return (double)w / (h + !h);
}
void AppWindow::aspect_lock(unsigned numer, unsigned denom) {
	if (!_window) {
		return;
	}

	if (numer * denom != 0) {
		glfwSetWindowAspectRatio(_window, numer, denom);
	} else {
		glfwSetWindowAspectRatio(_window, GLFW_DONT_CARE, GLFW_DONT_CARE);
	}
}
void AppWindow::aspect_unlock() {
	if (!_window) {
		return;
	}

	AppWindow::aspect_lock(0, 0);
}

void AppWindow::set_transparent(int enabled) {
#ifndef __EMSCRIPTEN__
	if (!has_fullscreen()) {
		if (enabled) {
			glfwSetWindowAttrib(_window, GLFW_DECORATED, GLFW_FALSE);
			//glfwSetWindowAttrib(window, GLFW_MOUSE_PASSTHROUGH , GLFW_TRUE);
			//glfwMaximizeWindow(window);
		} else {
			//glfwRestoreWindow(window);
			//glfwSetWindowAttrib(window, GLFW_MOUSE_PASSTHROUGH , GLFW_FALSE);
			glfwSetWindowAttrib(_window, GLFW_DECORATED, GLFW_TRUE);
		}
	}
#endif
}
int AppWindow::has_transparent() {
#ifndef __EMSCRIPTEN__
	return glfwGetWindowAttrib(_window, GLFW_DECORATED) != GLFW_TRUE;
#else
	return 0;
#endif
}

void AppWindow::set_maximize(int enabled) {
#ifndef __EMSCRIPTEN__
	if (!has_fullscreen()) {
		if (enabled) {
			glfwMaximizeWindow(_window);
		} else {
			glfwRestoreWindow(_window);
		}
	}
#endif
}
int AppWindow::has_maximize() {
#ifndef __EMSCRIPTEN__
	return glfwGetWindowAttrib(_window, GLFW_MAXIMIZED) == GLFW_TRUE;
#else
	return 0;
#endif
}

const char *AppWindow::get_clipboard() {
	return glfwGetClipboardString(_window);
}
void AppWindow::set_clipboard(const char *text) {
	glfwSetClipboardString(_window, text);
}

double AppWindow::get_scale() { // ok? @testme
	float xscale, yscale;
	GLFWmonitor *monitor = glfwGetPrimaryMonitor();
	glfwGetMonitorContentScale(monitor, &xscale, &yscale);
	return MAX(xscale, yscale);
}

void *AppWindow::get_window_handle() {
	return _window;
}

AppWindow *AppWindow::get_singleton() {
	return _singleton;
}

AppWindow::AppWindow() {
	_singleton = this;

	_window = NULL;

	boot_time = 0;

	w = 0;
	h = 0;
	xpos = 0;
	ypos = 0;
	paused = 0;
	fullscreen = 0;
	xprev = 0;
	yprev = 0;
	wprev = 0;
	hprev = 0;
	frame_count = 0;
	t = 0;
	dt = 0;
	fps = 0;
	hz = 0.00;
	locked_aspect_ratio = 0;
	title[0] = '\0';

	_has_icon = 0;

	_cursorshape = 1;

	width = 0;
	height = 0;
	keep_running = true;
	_window_flags = 0;

	_fullscreen = false;
	_transparent = false;
	_vsync = false;
	_vsync_adaptive = false;

	_cursors_initialized = false;

	for (int i = 0; i < 7; ++i) {
		cursors[i] = NULL;
	}

	cursor_enums[0] = 0;
	cursor_enums[1] = GLFW_ARROW_CURSOR;
	cursor_enums[2] = GLFW_IBEAM_CURSOR;
	cursor_enums[3] = GLFW_HRESIZE_CURSOR;
	cursor_enums[4] = GLFW_VRESIZE_CURSOR;
	cursor_enums[5] = GLFW_HAND_CURSOR;
	cursor_enums[6] = GLFW_CROSSHAIR_CURSOR;
}
AppWindow::~AppWindow() {
	_singleton = NULL;
}

AppWindow *AppWindow::_singleton = NULL;
#line 0

#line 1 "sfw/render_core/keyboard.cpp"
/*************************************************************************/
/*  keyboard.cpp                                                         */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

struct _KeyCodeText {
	int code;
	const char *text;
};

static const _KeyCodeText _keycodes[] = {

	/* clang-format off */
		{KEY_ESCAPE                        ,"Escape"},
		{KEY_TAB                           ,"Tab"},
		{KEY_BACKTAB                       ,"BackTab"},
		{KEY_BACKSPACE                     ,"BackSpace"},
		{KEY_ENTER                         ,"Enter"},
		{KEY_KP_ENTER                      ,"Kp Enter"},
		{KEY_INSERT                        ,"Insert"},
		{KEY_DELETE                        ,"Delete"},
		{KEY_PAUSE                         ,"Pause"},
		{KEY_PRINT                         ,"Print"},
		{KEY_SYSREQ                        ,"SysReq"},
		{KEY_CLEAR                         ,"Clear"},
		{KEY_HOME                          ,"Home"},
		{KEY_END                           ,"End"},
		{KEY_LEFT                          ,"Left"},
		{KEY_UP                            ,"Up"},
		{KEY_RIGHT                         ,"Right"},
		{KEY_DOWN                          ,"Down"},
		{KEY_PAGEUP                        ,"PageUp"},
		{KEY_PAGEDOWN                      ,"PageDown"},
		{KEY_SHIFT                         ,"Shift"},
		{KEY_CONTROL                       ,"Control"},
#ifdef OSX_ENABLED
		{KEY_META                          ,"Command"},
#else
		{KEY_META                          ,"Meta"},
#endif
		{KEY_ALT                           ,"Alt"},
		{KEY_CAPSLOCK                      ,"CapsLock"},
		{KEY_NUMLOCK                       ,"NumLock"},
		{KEY_SCROLLLOCK                    ,"ScrollLock"},
		{KEY_F1                            ,"F1"},
		{KEY_F2                            ,"F2"},
		{KEY_F3                            ,"F3"},
		{KEY_F4                            ,"F4"},
		{KEY_F5                            ,"F5"},
		{KEY_F6                            ,"F6"},
		{KEY_F7                            ,"F7"},
		{KEY_F8                            ,"F8"},
		{KEY_F9                            ,"F9"},
		{KEY_F10                           ,"F10"},
		{KEY_F11                           ,"F11"},
		{KEY_F12                           ,"F12"},
		{KEY_F13                           ,"F13"},
		{KEY_F14                           ,"F14"},
		{KEY_F15                           ,"F15"},
		{KEY_F16                           ,"F16"},
		{KEY_KP_MULTIPLY                   ,"Kp Multiply"},
		{KEY_KP_DIVIDE                     ,"Kp Divide"},
		{KEY_KP_SUBTRACT                   ,"Kp Subtract"},
		{KEY_KP_PERIOD                     ,"Kp Period"},
		{KEY_KP_ADD                        ,"Kp Add"},
		{KEY_KP_0                          ,"Kp 0"},
		{KEY_KP_1                          ,"Kp 1"},
		{KEY_KP_2                          ,"Kp 2"},
		{KEY_KP_3                          ,"Kp 3"},
		{KEY_KP_4                          ,"Kp 4"},
		{KEY_KP_5                          ,"Kp 5"},
		{KEY_KP_6                          ,"Kp 6"},
		{KEY_KP_7                          ,"Kp 7"},
		{KEY_KP_8                          ,"Kp 8"},
		{KEY_KP_9                          ,"Kp 9"},
		{KEY_SUPER_L                       ,"Super L"},
		{KEY_SUPER_R                       ,"Super R"},
		{KEY_MENU                          ,"Menu"},
		{KEY_HYPER_L                       ,"Hyper L"},
		{KEY_HYPER_R                       ,"Hyper R"},
		{KEY_HELP                          ,"Help"},
		{KEY_DIRECTION_L                   ,"Direction L"},
		{KEY_DIRECTION_R                   ,"Direction R"},
		{KEY_BACK                          ,"Back"},
		{KEY_FORWARD                       ,"Forward"},
		{KEY_STOP                          ,"Stop"},
		{KEY_REFRESH                       ,"Refresh"},
		{KEY_VOLUMEDOWN                    ,"VolumeDown"},
		{KEY_VOLUMEMUTE                    ,"VolumeMute"},
		{KEY_VOLUMEUP                      ,"VolumeUp"},
		{KEY_BASSBOOST                     ,"BassBoost"},
		{KEY_BASSUP                        ,"BassUp"},
		{KEY_BASSDOWN                      ,"BassDown"},
		{KEY_TREBLEUP                      ,"TrebleUp"},
		{KEY_TREBLEDOWN                    ,"TrebleDown"},
		{KEY_MEDIAPLAY                     ,"MediaPlay"},
		{KEY_MEDIASTOP                     ,"MediaStop"},
		{KEY_MEDIAPREVIOUS                 ,"MediaPrevious"},
		{KEY_MEDIANEXT                     ,"MediaNext"},
		{KEY_MEDIARECORD                   ,"MediaRecord"},
		{KEY_HOMEPAGE                      ,"HomePage"},
		{KEY_FAVORITES                     ,"Favorites"},
		{KEY_SEARCH                        ,"Search"},
		{KEY_STANDBY                       ,"StandBy"},
		{KEY_LAUNCHMAIL                    ,"LaunchMail"},
		{KEY_LAUNCHMEDIA                   ,"LaunchMedia"},
		{KEY_LAUNCH0                       ,"Launch0"},
		{KEY_LAUNCH1                       ,"Launch1"},
		{KEY_LAUNCH2                       ,"Launch2"},
		{KEY_LAUNCH3                       ,"Launch3"},
		{KEY_LAUNCH4                       ,"Launch4"},
		{KEY_LAUNCH5                       ,"Launch5"},
		{KEY_LAUNCH6                       ,"Launch6"},
		{KEY_LAUNCH7                       ,"Launch7"},
		{KEY_LAUNCH8                       ,"Launch8"},
		{KEY_LAUNCH9                       ,"Launch9"},
		{KEY_LAUNCHA                       ,"LaunchA"},
		{KEY_LAUNCHB                       ,"LaunchB"},
		{KEY_LAUNCHC                       ,"LaunchC"},
		{KEY_LAUNCHD                       ,"LaunchD"},
		{KEY_LAUNCHE                       ,"LaunchE"},
		{KEY_LAUNCHF                       ,"LaunchF"},

		{KEY_UNKNOWN                       ,"Unknown"},

		{KEY_SPACE                         ,"Space"},
		{KEY_EXCLAM                        ,"Exclam"},
		{KEY_QUOTEDBL                      ,"QuoteDbl"},
		{KEY_NUMBERSIGN                    ,"NumberSign"},
		{KEY_DOLLAR                        ,"Dollar"},
		{KEY_PERCENT                       ,"Percent"},
		{KEY_AMPERSAND                     ,"Ampersand"},
		{KEY_APOSTROPHE                    ,"Apostrophe"},
		{KEY_PARENLEFT                     ,"ParenLeft"},
		{KEY_PARENRIGHT                    ,"ParenRight"},
		{KEY_ASTERISK                      ,"Asterisk"},
		{KEY_PLUS                          ,"Plus"},
		{KEY_COMMA                         ,"Comma"},
		{KEY_MINUS                         ,"Minus"},
		{KEY_PERIOD                        ,"Period"},
		{KEY_SLASH                         ,"Slash"},
		{KEY_0                             ,"0"},
		{KEY_1                             ,"1"},
		{KEY_2                             ,"2"},
		{KEY_3                             ,"3"},
		{KEY_4                             ,"4"},
		{KEY_5                             ,"5"},
		{KEY_6                             ,"6"},
		{KEY_7                             ,"7"},
		{KEY_8                             ,"8"},
		{KEY_9                             ,"9"},
		{KEY_COLON                         ,"Colon"},
		{KEY_SEMICOLON                     ,"Semicolon"},
		{KEY_LESS                          ,"Less"},
		{KEY_EQUAL                         ,"Equal"},
		{KEY_GREATER                       ,"Greater"},
		{KEY_QUESTION                      ,"Question"},
		{KEY_AT                            ,"At"},
		{KEY_A                             ,"A"},
		{KEY_B                             ,"B"},
		{KEY_C                             ,"C"},
		{KEY_D                             ,"D"},
		{KEY_E                             ,"E"},
		{KEY_F                             ,"F"},
		{KEY_G                             ,"G"},
		{KEY_H                             ,"H"},
		{KEY_I                             ,"I"},
		{KEY_J                             ,"J"},
		{KEY_K                             ,"K"},
		{KEY_L                             ,"L"},
		{KEY_M                             ,"M"},
		{KEY_N                             ,"N"},
		{KEY_O                             ,"O"},
		{KEY_P                             ,"P"},
		{KEY_Q                             ,"Q"},
		{KEY_R                             ,"R"},
		{KEY_S                             ,"S"},
		{KEY_T                             ,"T"},
		{KEY_U                             ,"U"},
		{KEY_V                             ,"V"},
		{KEY_W                             ,"W"},
		{KEY_X                             ,"X"},
		{KEY_Y                             ,"Y"},
		{KEY_Z                             ,"Z"},
		{KEY_BRACKETLEFT                   ,"BracketLeft"},
		{KEY_BACKSLASH                     ,"BackSlash"},
		{KEY_BRACKETRIGHT                  ,"BracketRight"},
		{KEY_ASCIICIRCUM                   ,"AsciiCircum"},
		{KEY_UNDERSCORE                    ,"UnderScore"},
		{KEY_QUOTELEFT                     ,"QuoteLeft"},
		{KEY_BRACELEFT                     ,"BraceLeft"},
		{KEY_BAR                           ,"Bar"},
		{KEY_BRACERIGHT                    ,"BraceRight"},
		{KEY_ASCIITILDE                    ,"AsciiTilde"},
		{KEY_NOBREAKSPACE                  ,"NoBreakSpace"},
		{KEY_EXCLAMDOWN                    ,"ExclamDown"},
		{KEY_CENT                          ,"Cent"},
		{KEY_STERLING                      ,"Sterling"},
		{KEY_CURRENCY                      ,"Currency"},
		{KEY_YEN                           ,"Yen"},
		{KEY_BROKENBAR                     ,"BrokenBar"},
		{KEY_SECTION                       ,"Section"},
		{KEY_DIAERESIS                     ,"Diaeresis"},
		{KEY_COPYRIGHT                     ,"Copyright"},
		{KEY_ORDFEMININE                   ,"Ordfeminine"},
		{KEY_GUILLEMOTLEFT                 ,"GuillemotLeft"},
		{KEY_NOTSIGN                       ,"NotSign"},
		{KEY_HYPHEN                        ,"Hyphen"},
		{KEY_REGISTERED                    ,"Registered"},
		{KEY_MACRON                        ,"Macron"},
		{KEY_DEGREE                        ,"Degree"},
		{KEY_PLUSMINUS                     ,"PlusMinus"},
		{KEY_TWOSUPERIOR                   ,"TwoSuperior"},
		{KEY_THREESUPERIOR                 ,"ThreeSuperior"},
		{KEY_ACUTE                         ,"Acute"},
		{KEY_MU                            ,"Mu"},
		{KEY_PARAGRAPH                     ,"Paragraph"},
		{KEY_PERIODCENTERED                ,"PeriodCentered"},
		{KEY_CEDILLA                       ,"Cedilla"},
		{KEY_ONESUPERIOR                   ,"OneSuperior"},
		{KEY_MASCULINE                     ,"Masculine"},
		{KEY_GUILLEMOTRIGHT                ,"GuillemotRight"},
		{KEY_ONEQUARTER                    ,"OneQuarter"},
		{KEY_ONEHALF                       ,"OneHalf"},
		{KEY_THREEQUARTERS                 ,"ThreeQuarters"},
		{KEY_QUESTIONDOWN                  ,"QuestionDown"},
		{KEY_AGRAVE                        ,"Agrave"},
		{KEY_AACUTE                        ,"Aacute"},
		{KEY_ACIRCUMFLEX                   ,"AcircumFlex"},
		{KEY_ATILDE                        ,"Atilde"},
		{KEY_ADIAERESIS                    ,"Adiaeresis"},
		{KEY_ARING                         ,"Aring"},
		{KEY_AE                            ,"Ae"},
		{KEY_CCEDILLA                      ,"Ccedilla"},
		{KEY_EGRAVE                        ,"Egrave"},
		{KEY_EACUTE                        ,"Eacute"},
		{KEY_ECIRCUMFLEX                   ,"Ecircumflex"},
		{KEY_EDIAERESIS                    ,"Ediaeresis"},
		{KEY_IGRAVE                        ,"Igrave"},
		{KEY_IACUTE                        ,"Iacute"},
		{KEY_ICIRCUMFLEX                   ,"Icircumflex"},
		{KEY_IDIAERESIS                    ,"Idiaeresis"},
		{KEY_ETH                           ,"Eth"},
		{KEY_NTILDE                        ,"Ntilde"},
		{KEY_OGRAVE                        ,"Ograve"},
		{KEY_OACUTE                        ,"Oacute"},
		{KEY_OCIRCUMFLEX                   ,"Ocircumflex"},
		{KEY_OTILDE                        ,"Otilde"},
		{KEY_ODIAERESIS                    ,"Odiaeresis"},
		{KEY_MULTIPLY                      ,"Multiply"},
		{KEY_OOBLIQUE                      ,"Ooblique"},
		{KEY_UGRAVE                        ,"Ugrave"},
		{KEY_UACUTE                        ,"Uacute"},
		{KEY_UCIRCUMFLEX                   ,"Ucircumflex"},
		{KEY_UDIAERESIS                    ,"Udiaeresis"},
		{KEY_YACUTE                        ,"Yacute"},
		{KEY_THORN                         ,"Thorn"},
		{KEY_SSHARP                        ,"Ssharp"},

		{KEY_DIVISION                      ,"Division"},
		{KEY_YDIAERESIS                    ,"Ydiaeresis"},
		{0                                 ,nullptr}
	/* clang-format on */
};

bool keycode_has_unicode(uint32_t p_keycode) {
	switch (p_keycode) {
		case KEY_ESCAPE:
		case KEY_TAB:
		case KEY_BACKTAB:
		case KEY_BACKSPACE:
		case KEY_ENTER:
		case KEY_KP_ENTER:
		case KEY_INSERT:
		case KEY_DELETE:
		case KEY_PAUSE:
		case KEY_PRINT:
		case KEY_SYSREQ:
		case KEY_CLEAR:
		case KEY_HOME:
		case KEY_END:
		case KEY_LEFT:
		case KEY_UP:
		case KEY_RIGHT:
		case KEY_DOWN:
		case KEY_PAGEUP:
		case KEY_PAGEDOWN:
		case KEY_SHIFT:
		case KEY_CONTROL:
		case KEY_META:
		case KEY_ALT:
		case KEY_CAPSLOCK:
		case KEY_NUMLOCK:
		case KEY_SCROLLLOCK:
		case KEY_F1:
		case KEY_F2:
		case KEY_F3:
		case KEY_F4:
		case KEY_F5:
		case KEY_F6:
		case KEY_F7:
		case KEY_F8:
		case KEY_F9:
		case KEY_F10:
		case KEY_F11:
		case KEY_F12:
		case KEY_F13:
		case KEY_F14:
		case KEY_F15:
		case KEY_F16:
		case KEY_SUPER_L:
		case KEY_SUPER_R:
		case KEY_MENU:
		case KEY_HYPER_L:
		case KEY_HYPER_R:
		case KEY_HELP:
		case KEY_DIRECTION_L:
		case KEY_DIRECTION_R:
		case KEY_BACK:
		case KEY_FORWARD:
		case KEY_STOP:
		case KEY_REFRESH:
		case KEY_VOLUMEDOWN:
		case KEY_VOLUMEMUTE:
		case KEY_VOLUMEUP:
		case KEY_BASSBOOST:
		case KEY_BASSUP:
		case KEY_BASSDOWN:
		case KEY_TREBLEUP:
		case KEY_TREBLEDOWN:
		case KEY_MEDIAPLAY:
		case KEY_MEDIASTOP:
		case KEY_MEDIAPREVIOUS:
		case KEY_MEDIANEXT:
		case KEY_MEDIARECORD:
		case KEY_HOMEPAGE:
		case KEY_FAVORITES:
		case KEY_SEARCH:
		case KEY_STANDBY:
		case KEY_OPENURL:
		case KEY_LAUNCHMAIL:
		case KEY_LAUNCHMEDIA:
		case KEY_LAUNCH0:
		case KEY_LAUNCH1:
		case KEY_LAUNCH2:
		case KEY_LAUNCH3:
		case KEY_LAUNCH4:
		case KEY_LAUNCH5:
		case KEY_LAUNCH6:
		case KEY_LAUNCH7:
		case KEY_LAUNCH8:
		case KEY_LAUNCH9:
		case KEY_LAUNCHA:
		case KEY_LAUNCHB:
		case KEY_LAUNCHC:
		case KEY_LAUNCHD:
		case KEY_LAUNCHE:
		case KEY_LAUNCHF:
			return false;
	}

	return true;
}

String keycode_get_string(uint32_t p_code) {
	String codestr;
	if (p_code & KEY_MASK_SHIFT) {
		codestr += find_keycode_name(KEY_SHIFT);
		codestr += "+";
	}
	if (p_code & KEY_MASK_ALT) {
		codestr += find_keycode_name(KEY_ALT);
		codestr += "+";
	}
	if (p_code & KEY_MASK_CTRL) {
		codestr += find_keycode_name(KEY_CONTROL);
		codestr += "+";
	}
	if (p_code & KEY_MASK_META) {
		codestr += find_keycode_name(KEY_META);
		codestr += "+";
	}

	p_code &= KEY_CODE_MASK;

	const _KeyCodeText *kct = &_keycodes[0];

	while (kct->text) {
		if (kct->code == (int)p_code) {
			codestr += kct->text;
			return codestr;
		}
		kct++;
	}

	codestr += String::chr(p_code);

	return codestr;
}

int find_keycode(const String &p_code) {
	const _KeyCodeText *kct = &_keycodes[0];

	while (kct->text) {
		if (p_code.nocasecmp_to(kct->text) == 0) {
			return kct->code;
		}
		kct++;
	}

	return 0;
}

const char *find_keycode_name(int p_keycode) {
	const _KeyCodeText *kct = &_keycodes[0];

	while (kct->text) {
		if (kct->code == p_keycode) {
			return kct->text;
		}
		kct++;
	}

	return "";
}

int keycode_get_count() {
	const _KeyCodeText *kct = &_keycodes[0];

	int count = 0;
	while (kct->text) {
		count++;
		kct++;
	}
	return count;
}

int keycode_get_value_by_index(int p_index) {
	return _keycodes[p_index].code;
}

const char *keycode_get_name_by_index(int p_index) {
	return _keycodes[p_index].text;
}
#line 0

#line 1 "sfw/render_core/input_map.cpp"
/*************************************************************************/
/*  input_map.cpp                                                        */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

InputMap *InputMap::singleton = nullptr;

int InputMap::ALL_DEVICES = -1;

/**
 * Returns an nonexistent action error message with a suggestion of the closest
 * matching action name (if possible).
 */
String InputMap::suggest_actions(const StringName &p_action) const {
	List<StringName> actions = get_actions();
	StringName closest_action;
	float closest_similarity = 0.0;

	// Find the most action with the most similar name.
	for (List<StringName>::Element *E = actions.front(); E; E = E->next()) {
		const float similarity = String(E->get()).similarity(p_action);

		if (similarity > closest_similarity) {
			closest_action = E->get();
			closest_similarity = similarity;
		}
	}

	String error_message = vformat("The InputMap action \"%s\" doesn't exist.", p_action);

	if (closest_similarity >= 0.4) {
		// Only include a suggestion in the error message if it's similar enough.
		error_message += vformat(" Did you mean \"%s\"?", closest_action);
	}
	return error_message;
}

void InputMap::add_action(const StringName &p_action, float p_deadzone) {
	ERR_FAIL_COND_MSG(input_map.has(p_action), "InputMap already has action \"" + String(p_action) + "\".");
	input_map[p_action] = Action();
	static int last_id = 1;
	input_map[p_action].id = last_id;
	input_map[p_action].deadzone = p_deadzone;
	last_id++;
}

void InputMap::erase_action(const StringName &p_action) {
	ERR_FAIL_COND_MSG(!input_map.has(p_action), suggest_actions(p_action));

	input_map.erase(p_action);
}

Array InputMap::_get_actions() {
	Array ret;
	List<StringName> actions = get_actions();
	if (actions.empty()) {
		return ret;
	}

	for (const List<StringName>::Element *E = actions.front(); E; E = E->next()) {
		ret.push_back(E->get());
	}

	return ret;
}

List<StringName> InputMap::get_actions() const {
	List<StringName> actions = List<StringName>();
	if (input_map.empty()) {
		return actions;
	}

	for (RBMap<StringName, Action>::Element *E = input_map.front(); E; E = E->next()) {
		actions.push_back(E->key());
	}

	return actions;
}

List<Ref<InputEvent>>::Element *InputMap::_find_event(Action &p_action, const Ref<InputEvent> &p_event, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength) const {
	ERR_FAIL_COND_V(!p_event.is_valid(), nullptr);

	for (List<Ref<InputEvent>>::Element *E = p_action.inputs.front(); E; E = E->next()) {
		const Ref<InputEvent> e = E->get();

		//if (e.type != Ref<InputEvent>::KEY && e.device != p_event.device) -- unsure about the KEY comparison, why is this here?
		//	continue;

		int device = e->get_device();
		if (device == ALL_DEVICES || device == p_event->get_device()) {
			if (e->action_match(p_event, p_exact_match, p_pressed, p_strength, p_raw_strength, p_action.deadzone)) {
				return E;
			}
		}
	}

	return nullptr;
}

bool InputMap::has_action(const StringName &p_action) const {
	return input_map.has(p_action);
}

float InputMap::action_get_deadzone(const StringName &p_action) {
	ERR_FAIL_COND_V_MSG(!input_map.has(p_action), 0.0f, suggest_actions(p_action));

	return input_map[p_action].deadzone;
}

void InputMap::action_set_deadzone(const StringName &p_action, float p_deadzone) {
	ERR_FAIL_COND_MSG(!input_map.has(p_action), suggest_actions(p_action));

	input_map[p_action].deadzone = p_deadzone;
}

void InputMap::action_add_event(const StringName &p_action, const Ref<InputEvent> &p_event) {
	ERR_FAIL_COND_MSG(p_event.is_null(), "It's not a reference to a valid InputEvent object.");
	ERR_FAIL_COND_MSG(!input_map.has(p_action), suggest_actions(p_action));

	if (_find_event(input_map[p_action], p_event, true)) {
		return; // Already added.
	}

	input_map[p_action].inputs.push_back(p_event);
}

bool InputMap::action_has_event(const StringName &p_action, const Ref<InputEvent> &p_event) {
	ERR_FAIL_COND_V_MSG(!input_map.has(p_action), false, suggest_actions(p_action));

	return (_find_event(input_map[p_action], p_event, true) != nullptr);
}

void InputMap::action_erase_event(const StringName &p_action, const Ref<InputEvent> &p_event) {
	ERR_FAIL_COND_MSG(!input_map.has(p_action), suggest_actions(p_action));

	List<Ref<InputEvent>>::Element *E = _find_event(input_map[p_action], p_event, true);
	if (E) {
		input_map[p_action].inputs.erase(E);
		if (Input::get_singleton()->is_action_pressed(p_action)) {
			Input::get_singleton()->action_release(p_action);
		}
	}
}

void InputMap::action_erase_events(const StringName &p_action) {
	ERR_FAIL_COND_MSG(!input_map.has(p_action), suggest_actions(p_action));

	input_map[p_action].inputs.clear();
}

Array InputMap::_get_action_list(const StringName &p_action) {
	Array ret;
	const List<Ref<InputEvent>> *al = get_action_list(p_action);
	if (al) {
		for (const List<Ref<InputEvent>>::Element *E = al->front(); E; E = E->next()) {
			ret.push_back(E->get());
		}
	}

	return ret;
}

const List<Ref<InputEvent>> *InputMap::get_action_list(const StringName &p_action) {
	const RBMap<StringName, Action>::Element *E = input_map.find(p_action);
	if (!E) {
		return nullptr;
	}

	return &E->get().inputs;
}

bool InputMap::event_is_action(const Ref<InputEvent> &p_event, const StringName &p_action, bool p_exact_match) const {
	return event_get_action_status(p_event, p_action, p_exact_match);
}

bool InputMap::event_get_action_status(const Ref<InputEvent> &p_event, const StringName &p_action, bool p_exact_match, bool *p_pressed, float *p_strength, float *p_raw_strength) const {
	RBMap<StringName, Action>::Element *E = input_map.find(p_action);
	ERR_FAIL_COND_V_MSG(!E, false, suggest_actions(p_action));

	Ref<InputEventAction> input_event_action = p_event;
	if (input_event_action.is_valid()) {
		bool pressed = input_event_action->is_pressed();
		if (p_pressed != nullptr) {
			*p_pressed = pressed;
		}
		if (p_strength != nullptr) {
			*p_strength = pressed ? input_event_action->get_strength() : 0.0f;
		}
		return input_event_action->get_action() == p_action;
	}

	bool pressed;
	float strength;
	float raw_strength;
	List<Ref<InputEvent>>::Element *event = _find_event(E->get(), p_event, p_exact_match, &pressed, &strength, &raw_strength);
	if (event != nullptr) {
		if (p_pressed != nullptr) {
			*p_pressed = pressed;
		}
		if (p_strength != nullptr) {
			*p_strength = strength;
		}
		if (p_raw_strength != nullptr) {
			*p_raw_strength = raw_strength;
		}
		return true;
	} else {
		return false;
	}
}

const RBMap<StringName, InputMap::Action> &InputMap::get_action_map() const {
	return input_map;
}

void InputMap::load_default() {
	Ref<InputEventKey> key;

	add_action("ui_accept");
	key.instance();
	key->set_scancode(KEY_ENTER);
	action_add_event("ui_accept", key);

	key.instance();
	key->set_scancode(KEY_KP_ENTER);
	action_add_event("ui_accept", key);

	key.instance();
	key->set_scancode(KEY_SPACE);
	action_add_event("ui_accept", key);

	add_action("ui_select");
	key.instance();
	key->set_scancode(KEY_SPACE);
	action_add_event("ui_select", key);

	add_action("ui_cancel");
	key.instance();
	key->set_scancode(KEY_ESCAPE);
	action_add_event("ui_cancel", key);

	add_action("ui_focus_next");
	key.instance();
	key->set_scancode(KEY_TAB);
	action_add_event("ui_focus_next", key);

	add_action("ui_focus_prev");
	key.instance();
	key->set_scancode(KEY_TAB);
	key->set_shift(true);
	action_add_event("ui_focus_prev", key);

	add_action("ui_left");
	key.instance();
	key->set_scancode(KEY_LEFT);
	action_add_event("ui_left", key);

	add_action("ui_right");
	key.instance();
	key->set_scancode(KEY_RIGHT);
	action_add_event("ui_right", key);

	add_action("ui_up");
	key.instance();
	key->set_scancode(KEY_UP);
	action_add_event("ui_up", key);

	add_action("ui_down");
	key.instance();
	key->set_scancode(KEY_DOWN);
	action_add_event("ui_down", key);

	add_action("ui_page_up");
	key.instance();
	key->set_scancode(KEY_PAGEUP);
	action_add_event("ui_page_up", key);

	add_action("ui_page_down");
	key.instance();
	key->set_scancode(KEY_PAGEDOWN);
	action_add_event("ui_page_down", key);

	add_action("ui_home");
	key.instance();
	key->set_scancode(KEY_HOME);
	action_add_event("ui_home", key);

	add_action("ui_end");
	key.instance();
	key->set_scancode(KEY_END);
	action_add_event("ui_end", key);
}

InputMap::InputMap() {
	ERR_FAIL_COND_MSG(singleton, "Singleton in InputMap already exist.");
	singleton = this;
}
#line 0

#line 1 "sfw/render_core/scene.cpp"

void Scene::input_event(const Ref<InputEvent> &event) {
}
void Scene::update(float delta) {
}
void Scene::render() {
}

Scene::Scene() {
}

Scene::~Scene() {
}
#line 0

#line 1 "sfw/render_core/input.cpp"
/*************************************************************************/
/*  input.cpp                                                            */
/*  From https://github.com/Relintai/pandemonium_engine (MIT)            */
/*************************************************************************/

Input *Input::get_singleton() {
	return singleton;
}

void Input::set_mouse_mode(MouseMode p_mode) {
	AppWindow::get_singleton()->set_mouse_mode((AppWindow::MouseMode)p_mode);
}

Input::MouseMode Input::get_mouse_mode() const {
	return (MouseMode)AppWindow::get_singleton()->get_mouse_mode();
}

bool Input::is_key_pressed(int p_scancode) const {
	_THREAD_SAFE_METHOD_
	return keys_pressed.has(p_scancode);
}

bool Input::is_physical_key_pressed(int p_scancode) const {
	_THREAD_SAFE_METHOD_
	return physical_keys_pressed.has(p_scancode);
}

bool Input::is_mouse_button_pressed(int p_button) const {
	_THREAD_SAFE_METHOD_
	return (mouse_button_mask & (1 << (p_button - 1))) != 0;
}

bool Input::is_action_pressed(const StringName &p_action, bool p_exact) const {
	ERR_FAIL_COND_V_MSG(!InputMap::get_singleton()->has_action(p_action), false, InputMap::get_singleton()->suggest_actions(p_action));
	return action_state.has(p_action) && action_state[p_action].pressed && (p_exact ? action_state[p_action].exact : true);
}

bool Input::is_action_just_pressed(const StringName &p_action, bool p_exact) const {
	ERR_FAIL_COND_V_MSG(!InputMap::get_singleton()->has_action(p_action), false, InputMap::get_singleton()->suggest_actions(p_action));
	const RBMap<StringName, Action>::Element *E = action_state.find(p_action);
	if (!E) {
		return false;
	}

	if (p_exact && E->get().exact == false) {
		return false;
	}

	// Backward compatibility for legacy behavior, only return true if currently pressed.
	bool pressed_requirement = legacy_just_pressed_behavior ? E->get().pressed : true;

	return pressed_requirement && E->get().pressed_idle_frame == Application::get_singleton()->get_idle_frames();
}

bool Input::is_action_just_released(const StringName &p_action, bool p_exact) const {
	ERR_FAIL_COND_V_MSG(!InputMap::get_singleton()->has_action(p_action), false, InputMap::get_singleton()->suggest_actions(p_action));
	const RBMap<StringName, Action>::Element *E = action_state.find(p_action);
	if (!E) {
		return false;
	}

	if (p_exact && E->get().exact == false) {
		return false;
	}

	// Backward compatibility for legacy behavior, only return true if currently released.
	bool released_requirement = legacy_just_pressed_behavior ? !E->get().pressed : true;

	return released_requirement && E->get().released_idle_frame == Application::get_singleton()->get_idle_frames();
}

float Input::get_action_strength(const StringName &p_action, bool p_exact) const {
	ERR_FAIL_COND_V_MSG(!InputMap::get_singleton()->has_action(p_action), 0.0, InputMap::get_singleton()->suggest_actions(p_action));
	const RBMap<StringName, Action>::Element *E = action_state.find(p_action);
	if (!E) {
		return 0.0f;
	}

	if (p_exact && E->get().exact == false) {
		return 0.0f;
	}

	return E->get().strength;
}

float Input::get_action_raw_strength(const StringName &p_action, bool p_exact) const {
	ERR_FAIL_COND_V_MSG(!InputMap::get_singleton()->has_action(p_action), 0.0, InputMap::get_singleton()->suggest_actions(p_action));
	const RBMap<StringName, Action>::Element *E = action_state.find(p_action);
	if (!E) {
		return 0.0f;
	}

	if (p_exact && E->get().exact == false) {
		return 0.0f;
	}

	return E->get().raw_strength;
}

float Input::get_axis(const StringName &p_negative_action, const StringName &p_positive_action) const {
	return get_action_strength(p_positive_action) - get_action_strength(p_negative_action);
}

Vector2 Input::get_vector(const StringName &p_negative_x, const StringName &p_positive_x, const StringName &p_negative_y, const StringName &p_positive_y, float p_deadzone) const {
	Vector2 vector = Vector2(
			get_action_raw_strength(p_positive_x) - get_action_raw_strength(p_negative_x),
			get_action_raw_strength(p_positive_y) - get_action_raw_strength(p_negative_y));

	if (p_deadzone < 0.0f) {
		// If the deadzone isn't specified, get it from the average of the actions.
		p_deadzone = 0.25 *
				(InputMap::get_singleton()->action_get_deadzone(p_positive_x) +
						InputMap::get_singleton()->action_get_deadzone(p_negative_x) +
						InputMap::get_singleton()->action_get_deadzone(p_positive_y) +
						InputMap::get_singleton()->action_get_deadzone(p_negative_y));
	}

	// Circular length limiting and deadzone.
	float length = vector.length();
	if (length <= p_deadzone) {
		return Vector2();
	} else if (length > 1.0f) {
		return vector / length;
	} else {
		// Inverse lerp length to map (p_deadzone, 1) to (0, 1).
		return vector * (Math::inverse_lerp(p_deadzone, 1.0f, length) / length);
	}
	return vector;
}

Point2 Input::get_mouse_position() const {
	return mouse_pos;
}
Point2 Input::get_last_mouse_speed() {
	mouse_speed_track.update(Vector2());
	return mouse_speed_track.speed;
}

int Input::get_mouse_button_mask() const {
	return mouse_button_mask; // do not trust OS implementation, should remove it - OS::get_singleton()->get_mouse_button_state();
}

void Input::set_mouse_position(const Point2 &p_posf) {
	mouse_pos = p_posf;
}

void Input::warp_mouse_position(const Vector2 &p_to) {
	//OS::get_singleton()->warp_mouse_position(p_to);
}

Point2i Input::warp_mouse_motion(const Ref<InputEventMouseMotion> &p_motion, const Rect2 &p_rect) {
	// The relative distance reported for the next event after a warp is in the boundaries of the
	// size of the rect on that axis, but it may be greater, in which case there's not problem as fmod()
	// will warp it, but if the pointer has moved in the opposite direction between the pointer relocation
	// and the subsequent event, the reported relative distance will be less than the size of the rect
	// and thus fmod() will be disabled for handling the situation.
	// And due to this mouse warping mechanism being stateless, we need to apply some heuristics to
	// detect the warp: if the relative distance is greater than the half of the size of the relevant rect
	// (checked per each axis), it will be considered as the consequence of a former pointer warp.

	const Point2i rel_sgn(p_motion->get_relative().x >= 0.0f ? 1 : -1, p_motion->get_relative().y >= 0.0 ? 1 : -1);
	const Size2i warp_margin = p_rect.size * 0.5f;
	const Point2i rel_warped(
			Math::fmod(p_motion->get_relative().x + rel_sgn.x * warp_margin.x, p_rect.size.x) - rel_sgn.x * warp_margin.x,
			Math::fmod(p_motion->get_relative().y + rel_sgn.y * warp_margin.y, p_rect.size.y) - rel_sgn.y * warp_margin.y);

	const Point2i pos_local = p_motion->get_global_position() - p_rect.position;
	const Point2i pos_warped(Math::fposmod(pos_local.x, p_rect.size.x), Math::fposmod(pos_local.y, p_rect.size.y));
	//if (pos_warped != pos_local) {
	//OS::get_singleton()->warp_mouse_position(pos_warped + p_rect.position);
	//}

	return rel_warped;
}

void Input::action_press(const StringName &p_action, float p_strength) {
	// Create or retrieve existing action.
	Action &action = action_state[p_action];

	action.pressed_idle_frame = Application::get_singleton()->get_idle_frames();
	action.pressed = true;
	action.exact = true;
	action.strength = p_strength;
	action.raw_strength = p_strength;
}

void Input::action_release(const StringName &p_action) {
	// Create or retrieve existing action.
	Action &action = action_state[p_action];

	action.released_idle_frame = Application::get_singleton()->get_idle_frames();
	action.pressed = false;
	action.exact = true;
	action.strength = 0.0f;
	action.raw_strength = 0.0f;
}

Input::CursorShape Input::get_default_cursor_shape() const {
	return default_shape;
}

void Input::set_default_cursor_shape(CursorShape p_shape) {
	if (default_shape == p_shape) {
		return;
	}

	default_shape = p_shape;
	// The default shape is set in Viewport::_gui_input_event. To instantly
	// see the shape in the viewport we need to trigger a mouse motion event.
	Ref<InputEventMouseMotion> mm;
	mm.instance();
	mm->set_position(mouse_pos);
	mm->set_global_position(mouse_pos);
	parse_input_event(mm);
}

Input::CursorShape Input::get_current_cursor_shape() const {
	//return (Input::CursorShape)OS::get_singleton()->get_cursor_shape();
	return CURSOR_ARROW;
}

void Input::set_custom_mouse_cursor(const Ref<Reference> &p_cursor, CursorShape p_shape, const Vector2 &p_hotspot) {
	ERR_FAIL_INDEX(p_shape, Input::CURSOR_MAX);

	//OS::get_singleton()->set_custom_mouse_cursor(p_cursor, (OS::CursorShape)p_shape, p_hotspot);
}

void Input::parse_input_event(const Ref<InputEvent> &p_event) {
	_THREAD_SAFE_METHOD_

	ERR_FAIL_COND(p_event.is_null());

	if (use_accumulated_input) {
		if (buffered_events.empty() || !buffered_events.back()->get()->accumulate(p_event)) {
			buffered_events.push_back(p_event);
		}
	} else if (use_input_buffering) {
		buffered_events.push_back(p_event);
	} else {
		_parse_input_event_impl(p_event, false);
	}
}

void Input::flush_buffered_events() {
	_THREAD_SAFE_METHOD_

	while (buffered_events.front()) {
		// The final delivery of the input event involves releasing the lock.
		// While the lock is released, another thread may lock it and add new events to the back.
		// Therefore, we get each event and pop it while we still have the lock,
		// to ensure the list is in a consistent state.
		List<Ref<InputEvent>>::Element *E = buffered_events.front();
		Ref<InputEvent> e = E->get();
		buffered_events.pop_front();

		_parse_input_event_impl(e, false);
	}
}

bool Input::is_using_input_buffering() {
	return use_input_buffering;
}

void Input::set_use_input_buffering(bool p_enable) {
	use_input_buffering = p_enable;
}

bool Input::is_using_accumulated_input() {
	return use_accumulated_input;
}

void Input::set_use_accumulated_input(bool p_enable) {
	use_accumulated_input = p_enable;
}

void Input::release_pressed_events() {
	flush_buffered_events(); // this is needed to release actions strengths

	keys_pressed.clear();
	physical_keys_pressed.clear();

	for (RBMap<StringName, Input::Action>::Element *E = action_state.front(); E; E = E->next()) {
		if (E->get().pressed) {
			action_release(E->key());
		}
	}
}

void Input::set_main_loop(Application *p_main_loop) {
	main_loop = p_main_loop;
}

void Input::iteration(real_t p_step) {
	if (use_input_buffering || use_accumulated_input) {
		flush_buffered_events();
	}
}

Input::Input() {
	singleton = this;

	use_input_buffering = false;
	use_accumulated_input = true;
	mouse_button_mask = 0;
	main_loop = NULL;
	default_shape = CURSOR_ARROW;
	window_has_focus = true;

	last_mouse_pos_valid = false;
	last_click_ms = 0;
	last_click_button_index = 0;
	last_button_state = 0;

	last_key_modifier_state = 0;
}

unsigned int Input::get_mouse_button_state(unsigned int p_button, int p_action) {
	unsigned int mask = 1 << (p_button - 1);

	if (p_action == GLFW_PRESS) {
		last_button_state |= mask;
	} else {
		last_button_state &= ~mask;
	}

	return last_button_state;
}

void Input::get_key_modifier_state(int mods, Ref<InputEventWithModifiers> state) {
	state->set_shift((mods & GLFW_MOD_SHIFT));
	state->set_control((mods & GLFW_MOD_CONTROL));
	state->set_alt((mods & GLFW_MOD_ALT)); //altgr should not count as alt
	state->set_metakey((mods & GLFW_MOD_SUPER));
}

struct GLFWKeyMap {
	int glfw_code;
	int sfw_code;
} glfw_keymap[] = {
	/* The unknown key */
	{ GLFW_KEY_UNKNOWN, 0 },

	/* Printable keys */
	{ GLFW_KEY_SPACE, KEY_SPACE },
	{ GLFW_KEY_APOSTROPHE, KEY_APOSTROPHE },
	{ GLFW_KEY_COMMA, KEY_COMMA },
	{ GLFW_KEY_MINUS, KEY_MINUS },
	{ GLFW_KEY_PERIOD, KEY_PERIOD },
	{ GLFW_KEY_SLASH, KEY_SLASH },
	{ GLFW_KEY_0, KEY_0 },
	{ GLFW_KEY_1, KEY_1 },
	{ GLFW_KEY_2, KEY_2 },
	{ GLFW_KEY_3, KEY_3 },
	{ GLFW_KEY_4, KEY_4 },
	{ GLFW_KEY_5, KEY_5 },
	{ GLFW_KEY_6, KEY_6 },
	{ GLFW_KEY_7, KEY_7 },
	{ GLFW_KEY_8, KEY_8 },
	{ GLFW_KEY_9, KEY_9 },
	{ GLFW_KEY_SEMICOLON, KEY_SEMICOLON },
	{ GLFW_KEY_EQUAL, KEY_EQUAL },
	{ GLFW_KEY_A, KEY_A },
	{ GLFW_KEY_B, KEY_B },
	{ GLFW_KEY_C, KEY_C },
	{ GLFW_KEY_D, KEY_D },
	{ GLFW_KEY_E, KEY_E },
	{ GLFW_KEY_F, KEY_F },
	{ GLFW_KEY_G, KEY_G },
	{ GLFW_KEY_H, KEY_H },
	{ GLFW_KEY_I, KEY_I },
	{ GLFW_KEY_J, KEY_J },
	{ GLFW_KEY_K, KEY_K },
	{ GLFW_KEY_L, KEY_L },
	{ GLFW_KEY_M, KEY_M },
	{ GLFW_KEY_N, KEY_N },
	{ GLFW_KEY_O, KEY_O },
	{ GLFW_KEY_P, KEY_P },
	{ GLFW_KEY_Q, KEY_Q },
	{ GLFW_KEY_R, KEY_R },
	{ GLFW_KEY_S, KEY_S },
	{ GLFW_KEY_T, KEY_T },
	{ GLFW_KEY_U, KEY_U },
	{ GLFW_KEY_V, KEY_V },
	{ GLFW_KEY_W, KEY_W },
	{ GLFW_KEY_X, KEY_X },
	{ GLFW_KEY_Y, KEY_Y },
	{ GLFW_KEY_Z, KEY_Z },
	{ GLFW_KEY_LEFT_BRACKET, KEY_BRACKETLEFT },
	{ GLFW_KEY_BACKSLASH, KEY_BACKSLASH },
	{ GLFW_KEY_RIGHT_BRACKET, KEY_BRACKETRIGHT },
	{ GLFW_KEY_GRAVE_ACCENT, KEY_QUOTELEFT },
	{ GLFW_KEY_WORLD_1, KEY_EXCLAMDOWN },
	{ GLFW_KEY_WORLD_2, KEY_CENT },

	/* Function keys */
	{ GLFW_KEY_ESCAPE, KEY_ESCAPE },
	{ GLFW_KEY_ENTER, KEY_ENTER },
	{ GLFW_KEY_TAB, KEY_TAB },
	{ GLFW_KEY_BACKSPACE, KEY_BACKSPACE },
	{ GLFW_KEY_INSERT, KEY_INSERT },
	{ GLFW_KEY_DELETE, KEY_DELETE },
	{ GLFW_KEY_RIGHT, KEY_RIGHT },
	{ GLFW_KEY_LEFT, KEY_LEFT },
	{ GLFW_KEY_DOWN, KEY_DOWN },
	{ GLFW_KEY_UP, KEY_UP },
	{ GLFW_KEY_PAGE_UP, KEY_PAGEUP },
	{ GLFW_KEY_PAGE_DOWN, KEY_PAGEDOWN },
	{ GLFW_KEY_HOME, KEY_HOME },
	{ GLFW_KEY_END, KEY_END },
	{ GLFW_KEY_CAPS_LOCK, KEY_CAPSLOCK },
	{ GLFW_KEY_SCROLL_LOCK, KEY_SCROLLLOCK },
	{ GLFW_KEY_NUM_LOCK, KEY_NUMLOCK },
	{ GLFW_KEY_PRINT_SCREEN, KEY_PRINT },
	{ GLFW_KEY_PAUSE, KEY_PAUSE },
	{ GLFW_KEY_F1, KEY_F1 },
	{ GLFW_KEY_F2, KEY_F2 },
	{ GLFW_KEY_F3, KEY_F3 },
	{ GLFW_KEY_F4, KEY_F4 },
	{ GLFW_KEY_F5, KEY_F5 },
	{ GLFW_KEY_F6, KEY_F6 },
	{ GLFW_KEY_F7, KEY_F7 },
	{ GLFW_KEY_F8, KEY_F8 },
	{ GLFW_KEY_F9, KEY_F9 },
	{ GLFW_KEY_F10, KEY_F10 },
	{ GLFW_KEY_F11, KEY_F11 },
	{ GLFW_KEY_F12, KEY_F12 },
	{ GLFW_KEY_F13, KEY_F13 },
	{ GLFW_KEY_F14, KEY_F14 },
	{ GLFW_KEY_F15, KEY_F15 },
	{ GLFW_KEY_F16, KEY_F16 },
	{ GLFW_KEY_F17, 0 },
	{ GLFW_KEY_F18, 0 },
	{ GLFW_KEY_F19, 0 },
	{ GLFW_KEY_F20, 0 },
	{ GLFW_KEY_F21, 0 },
	{ GLFW_KEY_F22, 0 },
	{ GLFW_KEY_F23, 0 },
	{ GLFW_KEY_F24, 0 },
	{ GLFW_KEY_F25, 0 },
	{ GLFW_KEY_KP_0, KEY_KP_0 },
	{ GLFW_KEY_KP_1, KEY_KP_1 },
	{ GLFW_KEY_KP_2, KEY_KP_2 },
	{ GLFW_KEY_KP_3, KEY_KP_3 },
	{ GLFW_KEY_KP_4, KEY_KP_4 },
	{ GLFW_KEY_KP_5, KEY_KP_5 },
	{ GLFW_KEY_KP_6, KEY_KP_6 },
	{ GLFW_KEY_KP_7, KEY_KP_7 },
	{ GLFW_KEY_KP_8, KEY_KP_8 },
	{ GLFW_KEY_KP_9, KEY_KP_9 },
	{ GLFW_KEY_KP_DECIMAL, KEY_KP_PERIOD },
	{ GLFW_KEY_KP_DIVIDE, KEY_KP_DIVIDE },
	{ GLFW_KEY_KP_MULTIPLY, KEY_KP_MULTIPLY },
	{ GLFW_KEY_KP_SUBTRACT, KEY_KP_SUBTRACT },
	{ GLFW_KEY_KP_ADD, KEY_KP_ADD },
	{ GLFW_KEY_KP_ENTER, KEY_KP_ENTER },
	{ GLFW_KEY_KP_EQUAL, KEY_EQUAL },
	{ GLFW_KEY_LEFT_SHIFT, KEY_SHIFT },
	{ GLFW_KEY_LEFT_CONTROL, KEY_CONTROL },
	{ GLFW_KEY_LEFT_ALT, KEY_ALT },
	{ GLFW_KEY_LEFT_SUPER, KEY_SUPER_L },
	{ GLFW_KEY_RIGHT_SHIFT, KEY_SHIFT },
	{ GLFW_KEY_RIGHT_CONTROL, KEY_CONTROL },
	{ GLFW_KEY_RIGHT_ALT, 0 }, //altgr?
	{ GLFW_KEY_RIGHT_SUPER, KEY_SUPER_R },
	{ GLFW_KEY_MENU, KEY_MENU },
	{ 0, 0 },
};

int Input::glfw_to_sfw_code(int glfw_code) {
	for (int i = 0; glfw_keymap[i].glfw_code; i++) {
		if (glfw_keymap[i].glfw_code == glfw_code) {
			return glfw_keymap[i].sfw_code;
		}
	}

	return 0;
}

void Input::GLFWkeyfunCallback(GLFWwindow *window, int glfw_keycode, int scancode, int action, int mods) {
	Input *self = Input::get_singleton();

	self->last_key_modifier_state = mods;

	unsigned int keycode = glfw_to_sfw_code(glfw_keycode);
	unsigned int physical_keycode = keycode;
	unsigned int unicode = scancode;

	bool keypress = action == GLFW_PRESS;
	bool echo = action == GLFW_REPEAT;

	if (physical_keycode == 0 && keycode == 0 && unicode == 0) {
		return;
	}

	if (keycode == 0) {
		keycode = physical_keycode;
	}

	Ref<InputEventKey> k;
	k.instance();

	get_key_modifier_state(mods, k);

	k->set_pressed(keypress);

	if (keycode >= 'a' && keycode <= 'z') {
		keycode -= 'a' - 'A';
	}

	k->set_scancode(keycode);
	k->set_physical_scancode(physical_keycode);
	k->set_unicode(unicode);
	k->set_echo(echo);

	//don't set mod state if modifier keys are released by themselves
	//else event.is_action() will not work correctly here
	if (!k->is_pressed()) {
		if (k->get_scancode() == KEY_SHIFT) {
			k->set_shift(false);
		} else if (k->get_scancode() == KEY_CONTROL) {
			k->set_control(false);
		} else if (k->get_scancode() == KEY_ALT) {
			k->set_alt(false);
		} else if (k->get_scancode() == KEY_META) {
			k->set_metakey(false);
		}
	}

	bool last_is_pressed = Input::get_singleton()->is_key_pressed(k->get_scancode());
	if (k->is_pressed()) {
		if (last_is_pressed) {
			k->set_echo(true);
		}
	}

	self->parse_input_event(k);
}
void Input::GLFWcharfunCallback(GLFWwindow *window, unsigned int codepoint) {
	ERR_PRINT("GLFWcharfunCallback");
}
void Input::GLFWcharmodsfunCallback(GLFWwindow *window, unsigned int codepoint, int mods) {
	ERR_PRINT("GLFWcharmodsfunCallback");
}

void Input::GLFWmousebuttonfunCallback(GLFWwindow *window, int button, int action, int mods) {
	Input *self = Input::get_singleton();

	self->last_key_modifier_state = mods;

	bool pressed = action == GLFW_PRESS;

	Vector2 last_mouse_pos = self->last_mouse_pos;

	Ref<InputEventMouseButton> mb;
	mb.instance();

	get_key_modifier_state(mods, mb);

	mb->set_button_index(button + 1);
	mb->set_button_mask(self->get_mouse_button_state(mb->get_button_index(), action));
	mb->set_position(last_mouse_pos);
	mb->set_global_position(mb->get_position());

	mb->set_pressed(pressed);

	if (pressed) {
		uint64_t diff = SFWTime::time_us() / 1000 - self->last_click_ms;

		if (mb->get_button_index() == self->last_click_button_index) {
			if (diff < 400 && Point2(self->last_click_pos).distance_to(last_mouse_pos) < 5) {
				self->last_click_ms = 0;
				self->last_click_pos = Point2(-100, -100);
				self->last_click_button_index = -1;
				mb->set_doubleclick(true);
			}

		} else if (mb->get_button_index() < 4 || mb->get_button_index() > 7) {
			self->last_click_button_index = mb->get_button_index();
		}

		if (!mb->is_doubleclick()) {
			self->last_click_ms += diff;
			self->last_click_pos = last_mouse_pos;
		}
	}

	self->parse_input_event(mb);
}
void Input::GLFWcursorposfunCallback(GLFWwindow *window, double xpos, double ypos) {
	Input *self = Input::get_singleton();

	Point2 pos(xpos, ypos);

	if (!self->last_mouse_pos_valid) {
		self->last_mouse_pos = pos;
		self->last_mouse_pos_valid = true;
	}

	Point2 rel = pos - self->last_mouse_pos;

	MouseMode mouse_mode = self->get_mouse_mode();

	if (mouse_mode == MOUSE_MODE_CAPTURED) {
		int w = AppWindow::get_singleton()->get_width();
		int h = AppWindow::get_singleton()->get_height();

		pos = Point2i(w / 2, h / 2);
	}

	Ref<InputEventMouseMotion> mm;
	mm.instance();
	mm->set_pressure((self->last_button_state & (1 << (BUTTON_LEFT - 1))) ? 1.0f : 0.0f);

	// Make the absolute position integral so it doesn't look _too_ weird :)
	Point2i posi(pos);

	get_key_modifier_state(self->last_key_modifier_state, mm);
	mm->set_button_mask(self->last_button_state);
	mm->set_position(posi);
	mm->set_global_position(posi);
	mm->set_speed(self->get_last_mouse_speed());

	mm->set_relative(rel);

	self->last_mouse_pos = pos;

	// printf("rel: %d,%d\n", rel.x, rel.y );
	// Don't propagate the motion event unless we have focus
	// this is so that the relative motion doesn't get messed up
	// after we regain focus.
	if (self->window_has_focus || mouse_mode != MOUSE_MODE_CAPTURED) {
		self->parse_input_event(mm);
	}
}
void Input::GLFWcursorenterfunCallback(GLFWwindow *window, int entered) {
	Input *self = Input::get_singleton();

	self->last_mouse_pos_valid = false;

	if (entered) {
		if (self->main_loop && (self->get_mouse_mode() != MOUSE_MODE_CAPTURED)) {
			self->main_loop->notification(Application::NOTIFICATION_WM_MOUSE_ENTER);
		}
	} else {
		if (self->main_loop && (self->get_mouse_mode() != MOUSE_MODE_CAPTURED)) {
			self->main_loop->notification(Application::NOTIFICATION_WM_MOUSE_EXIT);
		}
	}
}
void Input::GLFWscrollfunCallback(GLFWwindow *window, double xoffset, double yoffset) {
	ERR_PRINT("GLFWscrollfunCallback");
}
void Input::GLFWdropfunCallback(GLFWwindow *window, int path_count, const char *paths[]) {
	ERR_PRINT("GLFWdropfunCallback");
}
void Input::GLFWjoystickfunCallback(int jid, int event) {
	ERR_PRINT("GLFWjoystickfunCallback");
}

void Input::GLFWwindowfocusfunCallback(GLFWwindow *window, int focused) {
	Input *self = Input::get_singleton();

	self->window_has_focus = focused;

	if (focused) {
		self->main_loop->notification(Application::NOTIFICATION_WM_FOCUS_IN);
	} else {
		self->release_pressed_events();
		self->main_loop->notification(Application::NOTIFICATION_WM_FOCUS_OUT);
	}
}

void Input::_setup_window_callbacks() {
	GLFWwindow *window = (GLFWwindow *)AppWindow::get_singleton()->get_handle();

	glfwSetKeyCallback(window, &Input::GLFWkeyfunCallback);
	//glfwSetCharCallback(window, &Input::GLFWcharfunCallback);
	//glfwSetCharModsCallback(window, &Input::GLFWcharmodsfunCallback);
	glfwSetMouseButtonCallback(window, &Input::GLFWmousebuttonfunCallback);
	glfwSetCursorPosCallback(window, &Input::GLFWcursorposfunCallback);
	glfwSetCursorEnterCallback(window, &Input::GLFWcursorenterfunCallback);
	//glfwSetScrollCallback(window, &Input::GLFWscrollfunCallback);
	//glfwSetDropCallback(window, &Input::GLFWdropfunCallback);
	//glfwSetJoystickCallback(&Input::GLFWjoystickfunCallback);
	glfwSetWindowFocusCallback(window, &Input::GLFWwindowfocusfunCallback);
}

void Input::_parse_input_event_impl(const Ref<InputEvent> &p_event, bool p_is_emulated) {
	// This function does the final delivery of the input event to user land.
	// Regardless where the event came from originally, this has to happen on the main thread.
	DEV_ASSERT(Thread::get_caller_id() == Thread::get_main_id());

	// Notes on mouse-touch emulation:
	// - Emulated mouse events are parsed, that is, re-routed to this method, so they make the same effects
	//   as true mouse events. The only difference is the situation is flagged as emulated so they are not
	//   emulated back to touch events in an endless loop.
	// - Emulated touch events are handed right to the main loop (i.e., the SceneTree) because they don't
	//   require additional handling by this class.

	Ref<InputEventKey> k = p_event;
	if (k.is_valid() && !k->is_echo() && k->get_scancode() != 0) {
		if (k->is_pressed()) {
			keys_pressed.insert(k->get_scancode());
		} else {
			keys_pressed.erase(k->get_scancode());
		}
	}
	if (k.is_valid() && !k->is_echo() && k->get_physical_scancode() != 0) {
		if (k->is_pressed()) {
			physical_keys_pressed.insert(k->get_physical_scancode());
		} else {
			physical_keys_pressed.erase(k->get_physical_scancode());
		}
	}

	Ref<InputEventMouseButton> mb = p_event;

	if (mb.is_valid()) {
		if (mb->is_pressed()) {
			mouse_button_mask |= (1 << (mb->get_button_index() - 1));
		} else {
			mouse_button_mask &= ~(1 << (mb->get_button_index() - 1));
		}

		Point2 pos = mb->get_global_position();
		if (mouse_pos != pos) {
			set_mouse_position(pos);
		}
	}

	Ref<InputEventMouseMotion> mm = p_event;

	if (mm.is_valid()) {
		Point2 position = mm->get_global_position();
		if (mouse_pos != position) {
			set_mouse_position(position);
		}
		Vector2 relative = mm->get_relative();
		mouse_speed_track.update(relative);
	}

	for (const RBMap<StringName, InputMap::Action>::Element *E = InputMap::get_singleton()->get_action_map().front(); E; E = E->next()) {
		if (InputMap::get_singleton()->event_is_action(p_event, E->key())) {
			Action &action = action_state[E->key()];

			// If not echo and action pressed state has changed
			if (!p_event->is_echo() && is_action_pressed(E->key(), false) != p_event->is_action_pressed(E->key())) {
				if (p_event->is_action_pressed(E->key())) {
					action.pressed = true;
					action.pressed_idle_frame = Application::get_singleton()->get_idle_frames();
				} else {
					action.pressed = false;
					action.released_idle_frame = Application::get_singleton()->get_idle_frames();
				}

				action.strength = 0.0f;
				action.raw_strength = 0.0f;
				action.exact = InputMap::get_singleton()->event_is_action(p_event, E->key(), true);
			}

			action.strength = p_event->get_action_strength(E->key());
			action.raw_strength = p_event->get_action_raw_strength(E->key());
		}
	}

	if (main_loop) {
		_THREAD_SAFE_UNLOCK_
		main_loop->input_event(p_event);
		_THREAD_SAFE_LOCK_
	}
}

String Input::_hex_str(uint8_t p_byte) {
	static const char *dict = "0123456789abcdef";
	char ret[3];
	ret[2] = 0;

	ret[0] = dict[p_byte >> 4];
	ret[1] = dict[p_byte & 0xf];

	return ret;
};

Input *Input::singleton = nullptr;

void Input::SpeedTrack::update(const Vector2 &p_delta_p) {
	uint64_t tick = SFWTime::time_us();
	uint32_t tdiff = tick - last_tick;
	float delta_t = tdiff / 1000000.0;
	last_tick = tick;

	if (delta_t > max_ref_frame) {
		// First movement in a long time, reset and start again.
		speed = Vector2();
		accum = p_delta_p;
		accum_t = 0;
		return;
	}

	accum += p_delta_p;
	accum_t += delta_t;

	if (accum_t < min_ref_frame) {
		// Not enough time has passed to calculate speed precisely.
		return;
	}

	speed = accum / accum_t;
	accum = Vector2();
	accum_t = 0;
}

void Input::SpeedTrack::reset() {
	last_tick = SFWTime::time_us();
	speed = Vector2();
	accum = Vector2();
	accum_t = 0;
}

Input::SpeedTrack::SpeedTrack() {
	min_ref_frame = 0.1;
	max_ref_frame = 3.0;
	reset();
}
#line 0

//===================  RENDER IMMEDIATE SECTION  ===================

#line 1 "sfw/render_immediate/renderer.cpp"

bool Renderer::get_depth_buffer_enable() const {
	return _depth_buffer;
}
void Renderer::set_depth_buffer_enable(const bool p_depth_buffer) {
	_depth_buffer = p_depth_buffer;
}

Renderer::FaceCulling Renderer::get_face_culling() const {
	return _face_culling;
}
void Renderer::set_face_culling(const FaceCulling p_face_culling) {
	if (_face_culling == p_face_culling) {
		return;
	}

	bool were_disabled = _face_culling == FACE_CULLING_OFF;

	_face_culling = p_face_culling;

	switch (p_face_culling) {
		case FACE_CULLING_OFF:
			if (!were_disabled) {
				glDisable(GL_CULL_FACE);
			}

			break;
		case FACE_CULLING_FRONT:
			if (were_disabled) {
				glEnable(GL_CULL_FACE);
			}

			glCullFace(GL_FRONT);
			break;
		case FACE_CULLING_BACK:
			if (were_disabled) {
				glEnable(GL_CULL_FACE);
			}

			glCullFace(GL_BACK);
			break;
		case FACE_CULLING_FRONT_AND_BACK:
			if (were_disabled) {
				glEnable(GL_CULL_FACE);
			}

			glCullFace(GL_FRONT_AND_BACK);
			break;
	}
}

void Renderer::draw_point(const Vector2 &p_position, const Color &p_color) {
	//Ugly but oh well
	draw_rect(Rect2(p_position, Vector2(1, 1)), p_color);
}
void Renderer::draw_line(const Vector2 &p_from, const Vector2 &p_to, const Color &p_color, const real_t p_width) {
	_2d_mesh->clear();

	Vector2 offset = (p_from - p_to).rotated(Math_PI / 2.0).normalized();
	offset *= p_width / 2.0;

	_2d_mesh->add_color(p_color);
	_2d_mesh->add_vertex2(p_from.x - offset.x, p_from.y - offset.y);

	_2d_mesh->add_color(p_color);
	_2d_mesh->add_vertex2(p_to.x + offset.x, p_to.y + offset.y);

	_2d_mesh->add_color(p_color);
	_2d_mesh->add_vertex2(p_to.x - offset.x, p_to.y - offset.y);

	_2d_mesh->add_color(p_color);
	_2d_mesh->add_vertex2(p_from.x + offset.x, p_from.y + offset.y);

	//mesh->add_vertex2(-w2, -h2);
	//mesh->add_vertex2(w2, h2);
	//mesh->add_vertex2(-w2, h2);
	//mesh->add_vertex2(w2, -h2);

	_2d_mesh->add_triangle(1, 0, 2);
	_2d_mesh->add_triangle(0, 1, 3);

	_2d_mesh->upload();

	_color_material_2d->bind();
	_2d_mesh->render();
}
void Renderer::draw_line_rect(const Rect2 &p_rect, const Color &p_color, const real_t p_width) {
	Vector2 rect_end = p_rect.get_end();

	//Ugly but oh well
	draw_line(p_rect.position, Vector2(rect_end.x, p_rect.position.y), p_color, p_width);
	draw_line(p_rect.position, Vector2(p_rect.position.x, rect_end.y), p_color, p_width);
	draw_line(rect_end, Vector2(rect_end.x, p_rect.position.y), p_color, p_width);
	draw_line(rect_end, Vector2(p_rect.position.x, rect_end.y), p_color, p_width);
}
void Renderer::draw_rect(const Rect2 &p_rect, const Color &p_color) {
	_2d_mesh->clear();

	Vector2 rect_end = p_rect.get_end();

	_2d_mesh->add_color(p_color);
	_2d_mesh->add_vertex2(p_rect.position.x, p_rect.position.y);

	_2d_mesh->add_color(p_color);
	_2d_mesh->add_vertex2(rect_end.x, rect_end.y);

	_2d_mesh->add_color(p_color);
	_2d_mesh->add_vertex2(p_rect.position.x, rect_end.y);

	_2d_mesh->add_color(p_color);
	_2d_mesh->add_vertex2(rect_end.x, p_rect.position.y);

	_2d_mesh->add_triangle(1, 0, 2);
	_2d_mesh->add_triangle(0, 1, 3);

	_2d_mesh->upload();

	_color_material_2d->bind();
	_2d_mesh->render();
}

void Renderer::draw_texture(const Ref<Texture> &p_texture, const Rect2 &p_dst_rect, const Color &p_modulate) {
	_2d_mesh->clear();

	Vector2 rect_end = p_dst_rect.get_end();

	_2d_mesh->add_uv(0, 0);
	_2d_mesh->add_color(p_modulate);
	_2d_mesh->add_vertex2(p_dst_rect.position.x, p_dst_rect.position.y);

	_2d_mesh->add_uv(1, 1);
	_2d_mesh->add_color(p_modulate);
	_2d_mesh->add_vertex2(rect_end.x, rect_end.y);

	_2d_mesh->add_uv(0, 1);
	_2d_mesh->add_color(p_modulate);
	_2d_mesh->add_vertex2(p_dst_rect.position.x, rect_end.y);

	_2d_mesh->add_uv(1, 0);
	_2d_mesh->add_color(p_modulate);
	_2d_mesh->add_vertex2(rect_end.x, p_dst_rect.position.y);

	_2d_mesh->add_triangle(1, 0, 2);
	_2d_mesh->add_triangle(0, 1, 3);

	_2d_mesh->upload();

	_texture_material_2d->texture = p_texture;
	_texture_material_2d->bind();
	_2d_mesh->render();
}
void Renderer::draw_texture_clipped(const Ref<Texture> &p_texture, const Rect2 &p_src_rect, const Rect2 &p_dst_rect, const Color &p_modulate) {
	_2d_mesh->clear();

	Rect2 uv = Rect2(0, 0, 1, 1);

	if (p_texture.is_valid()) {
		Vector2 ts = p_texture->get_size();

		Vector2 ss = p_src_rect.position;
		Vector2 se = p_src_rect.get_end();

		uv.position.x = ss.x / ts.x;
		uv.position.x = ss.y / ts.y;
		uv.size.x = se.x / ts.x;
		uv.size.x = se.y / ts.y;
	}

	Vector2 rect_end = p_dst_rect.get_end();

	_2d_mesh->add_uv(uv.position.x, uv.position.y);
	_2d_mesh->add_color(p_modulate);
	_2d_mesh->add_vertex2(p_dst_rect.position.x, p_dst_rect.position.y);

	_2d_mesh->add_uv(uv.size.x, uv.size.y);
	_2d_mesh->add_color(p_modulate);
	_2d_mesh->add_vertex2(rect_end.x, rect_end.y);

	_2d_mesh->add_uv(uv.position.x, uv.size.y);
	_2d_mesh->add_color(p_modulate);
	_2d_mesh->add_vertex2(p_dst_rect.position.x, rect_end.y);

	_2d_mesh->add_uv(uv.size.x, uv.position.y);
	_2d_mesh->add_color(p_modulate);
	_2d_mesh->add_vertex2(rect_end.x, p_dst_rect.position.y);

	_2d_mesh->add_triangle(1, 0, 2);
	_2d_mesh->add_triangle(0, 1, 3);

	_2d_mesh->upload();

	_texture_material_2d->texture = p_texture;
	_texture_material_2d->bind();
	_2d_mesh->render();
}

void Renderer::draw_texture_tr(const Transform2D &p_transform_2d, const Ref<Texture> &p_texture, const Rect2 &p_dst_rect, const Color &p_modulate) {
	camera_2d_push_model_view_matrix(p_transform_2d);
	draw_texture(p_texture, p_dst_rect, p_modulate);
	camera_2d_pop_model_view_matrix();
}
void Renderer::draw_texture_clipped_tr(const Transform2D &p_transform_2d, const Ref<Texture> &p_texture, const Rect2 &p_src_rect, const Rect2 &p_dst_rect, const Color &p_modulate) {
	camera_2d_push_model_view_matrix(p_transform_2d);
	draw_texture_clipped(p_texture, p_src_rect, p_dst_rect, p_modulate);
	camera_2d_pop_model_view_matrix();
}

void Renderer::draw_mesh_2d(const Ref<Mesh> &p_mesh, const Ref<Texture> &p_texture, const Vector2 &p_position) {
	ERR_FAIL_COND(!p_mesh.is_valid());

	_texture_material_2d->texture = p_texture;
	Ref<Mesh> mesh = p_mesh;

	camera_2d_push_model_view_matrix(Transform2D().translated(p_position));

	_texture_material_2d->bind();
	mesh->render();
	camera_2d_pop_model_view_matrix();
}
void Renderer::draw_mesh_2d_tr(const Ref<Mesh> &p_mesh, const Ref<Texture> &p_texture, const Transform2D &p_transform_2d) {
	ERR_FAIL_COND(!p_mesh.is_valid());

	_texture_material_2d->texture = p_texture;
	Ref<Mesh> mesh = p_mesh;

	camera_2d_push_model_view_matrix(p_transform_2d);

	_texture_material_2d->bind();

	mesh->render();
	camera_2d_pop_model_view_matrix();
}
void Renderer::draw_mesh_2d_mat(const Ref<Mesh> &p_mesh, const Ref<Material> &p_material, const Vector2 &p_position) {
	ERR_FAIL_COND(!p_mesh.is_valid());
	ERR_FAIL_COND(!p_material.is_valid());

	Ref<Material> material = p_material;
	Ref<Mesh> mesh = p_mesh;

	camera_2d_push_model_view_matrix(Transform2D().translated(p_position));

	material->bind();

	mesh->render();
	camera_2d_pop_model_view_matrix();
}
void Renderer::draw_mesh_2d_mat_tr(const Ref<Mesh> &p_mesh, const Ref<Material> &p_material, const Transform2D &p_transform_2d) {
	ERR_FAIL_COND(!p_mesh.is_valid());
	ERR_FAIL_COND(!p_material.is_valid());

	Ref<Material> material = p_material;
	Ref<Mesh> mesh = p_mesh;

	camera_2d_push_model_view_matrix(p_transform_2d);

	material->bind();

	mesh->render();
	camera_2d_pop_model_view_matrix();
}

void Renderer::draw_text_2d(const String &p_text, const Ref<Font> &p_font, const Vector2 &p_position, const Color &p_color) {
	ERR_FAIL_COND(!p_font.is_valid());

	_font_mesh->clear();
	p_font->generate_mesh(p_text, _font_mesh, p_color);
	_font_mesh->upload();

	_font_material->texture = p_font->get_texture();

	camera_2d_push_model_view_matrix(Transform2D().translated(p_position));

	_font_material->bind();

	_font_mesh->render();
	camera_2d_pop_model_view_matrix();
}
void Renderer::draw_text_2d_tf(const String &p_text, const Ref<Font> &p_font, const Transform2D &p_transform_2d, const Color &p_color) {
	camera_2d_push_model_view_matrix(p_transform_2d);
	draw_text_2d(p_text, p_font, Vector2(), p_color);
	camera_2d_pop_model_view_matrix();
}
void Renderer::draw_text_2d_tf_material(const String &p_text, const Ref<Font> &p_font, const Ref<Material> &p_material, const Transform2D &p_transform_2d, const Color &p_color) {
	ERR_FAIL_COND(!p_font.is_valid());
	ERR_FAIL_COND(!p_material.is_valid());

	_font_mesh->clear();
	p_font->generate_mesh(p_text, _font_mesh, p_color);
	_font_mesh->upload();

	Ref<Material> material = p_material;

	camera_2d_push_model_view_matrix(p_transform_2d);

	material->bind();

	_font_mesh->render();
	camera_2d_pop_model_view_matrix();
}

void Renderer::draw_mesh_3d(const Ref<Mesh> &p_mesh, const Ref<Material> &p_material, const Transform &p_transform) {
	ERR_FAIL_COND(!p_mesh.is_valid());
	ERR_FAIL_COND(!p_material.is_valid());

	Ref<Mesh> mesh = p_mesh;
	Ref<Material> material = p_material;

	camera_3d_push_model_view_matrix(p_transform);

	material->bind();
	mesh->render();

	camera_3d_pop_model_view_matrix();
}
void Renderer::draw_mesh_3d_colored(const Ref<Mesh> &p_mesh, const Color &p_color, const Transform &p_transform) {
	ERR_FAIL_COND(!p_mesh.is_valid());

	Ref<Mesh> mesh = p_mesh;
	_colored_material_3d->color = p_color;

	camera_3d_push_model_view_matrix(p_transform);

	_colored_material_3d->bind();
	mesh->render();

	camera_3d_pop_model_view_matrix();
}
void Renderer::draw_mesh_3d_vertex_colored(const Ref<Mesh> &p_mesh, const Transform &p_transform) {
	ERR_FAIL_COND(!p_mesh.is_valid());

	Ref<Mesh> mesh = p_mesh;

	camera_3d_push_model_view_matrix(p_transform);

	_color_material_3d->bind();
	mesh->render();

	camera_3d_pop_model_view_matrix();
}
void Renderer::draw_mesh_3d_textured(const Ref<Mesh> &p_mesh, const Ref<Texture> &p_texture, const Transform &p_transform) {
	ERR_FAIL_COND(!p_mesh.is_valid());
	ERR_FAIL_COND(!p_texture.is_valid());

	_texture_material_3d->texture = p_texture;
	Ref<Mesh> mesh = p_mesh;

	camera_3d_push_model_view_matrix(p_transform);

	_texture_material_3d->bind();
	mesh->render();

	camera_3d_pop_model_view_matrix();
}

void Renderer::camera_2d_bind() {
	RenderState::model_view_matrix_2d = _camera_2d_model_view_matrix;
	RenderState::projection_matrix_2d = _camera_2d_projection_matrix;
}
void Renderer::camera_2d_reset() {
	RenderState::model_view_matrix_2d = Transform2D();
	RenderState::projection_matrix_2d = Transform();

	_camera_2d_model_view_matrix_stack.clear();
	_camera_2d_projection_matrix_stack.clear();

	_camera_2d_projection_matrix = RenderState::projection_matrix_2d;
	_camera_2d_model_view_matrix = RenderState::model_view_matrix_2d;
}

Transform Renderer::camera_2d_get_current_projection_matrix() const {
	return _camera_2d_projection_matrix;
}
void Renderer::camera_2d_push_projection_matrix(const Transform &p_transform) {
	_camera_2d_projection_matrix_stack.push_back(_camera_2d_projection_matrix);

	_camera_2d_projection_matrix *= p_transform;

	RenderState::projection_matrix_2d = _camera_2d_projection_matrix;
}
void Renderer::camera_2d_pop_projection_matrix() {
	if (_camera_2d_projection_matrix_stack.empty()) {
		return;
	}

	_camera_2d_projection_matrix = _camera_2d_projection_matrix_stack[_camera_2d_projection_matrix_stack.size() - 1];

	RenderState::projection_matrix_2d = _camera_2d_projection_matrix;

	_camera_2d_projection_matrix_stack.resize(_camera_2d_projection_matrix_stack.size() - 1);
}
int Renderer::get_camera_2d_projection_matrix_stack_size() const {
	return _camera_2d_projection_matrix_stack.size();
}
void Renderer::camera_2d_projection_matrix_stack_clear() {
	_camera_2d_projection_matrix_stack.clear();

	_camera_2d_projection_matrix = Transform();
	RenderState::projection_matrix_2d = _camera_2d_projection_matrix;
}

Transform2D Renderer::camera_2d_get_current_model_view_matrix() const {
	return _camera_2d_model_view_matrix;
}

void Renderer::camera_2d_push_model_view_matrix(const Transform2D &p_transform_2d) {
	_camera_2d_model_view_matrix_stack.push_back(_camera_2d_model_view_matrix);

	_camera_2d_model_view_matrix *= p_transform_2d;

	RenderState::model_view_matrix_2d = _camera_2d_model_view_matrix;
}
void Renderer::camera_2d_pop_model_view_matrix() {
	if (_camera_2d_model_view_matrix_stack.empty()) {
		return;
	}

	_camera_2d_model_view_matrix = _camera_2d_model_view_matrix_stack[_camera_2d_model_view_matrix_stack.size() - 1];

	RenderState::model_view_matrix_2d = _camera_2d_model_view_matrix;

	_camera_2d_model_view_matrix_stack.resize(_camera_2d_model_view_matrix_stack.size() - 1);
}

int Renderer::get_camera_2d_model_view_matrix_stack_size() const {
	return _camera_2d_model_view_matrix_stack.size();
}
void Renderer::camera_2d_model_view_matrix_stack_clear() {
	_camera_2d_model_view_matrix_stack.clear();

	_camera_2d_model_view_matrix = Transform2D();
	RenderState::model_view_matrix_2d = _camera_2d_model_view_matrix;
}

void Renderer::camera_2d_projection_set_to_window() {
	Vector2 size = get_window_size();

	Transform canvas_transform;
	canvas_transform.translate_local(-(size.x / 2.0f), -(size.y / 2.0f), 0.0f);
	//canvas_transform.scale(Vector3(2.0f / size.x, 2.0f / size.y, 1.0f));
	canvas_transform.scale(Vector3(2.0f / size.x, -2.0f / size.y, 1.0f));

	RenderState::projection_matrix_2d = canvas_transform;
	_camera_2d_projection_matrix_stack.clear();
	_camera_2d_projection_matrix = canvas_transform;
}

void Renderer::camera_2d_projection_set_to_size(const Size2i &p_size) {
	Transform canvas_transform;
	canvas_transform.translate_local(-(p_size.x / 2.0f), -(p_size.y / 2.0f), 0.0f);
	//canvas_transform.scale(Vector3(2.0f / size.x, 2.0f / size.y, 1.0f));
	canvas_transform.scale(Vector3(2.0f / p_size.x, -2.0f / p_size.y, 1.0f));

	RenderState::projection_matrix_2d = canvas_transform;
	_camera_2d_projection_matrix_stack.clear();
	_camera_2d_projection_matrix = canvas_transform;
}

void Renderer::camera_2d_projection_set_to_render_target() {
	Vector2 size = RenderState::render_rect.size;

	Transform canvas_transform;
	canvas_transform.translate_local(-(size.x / 2.0f), -(size.y / 2.0f), 0.0f);
	//canvas_transform.scale(Vector3(2.0f / size.x, 2.0f / size.y, 1.0f));
	canvas_transform.scale(Vector3(2.0f / size.x, -2.0f / size.y, 1.0f));

	RenderState::projection_matrix_2d = canvas_transform;
	_camera_2d_projection_matrix_stack.clear();
	_camera_2d_projection_matrix = canvas_transform;
}

void Renderer::camera_2d_projection_set_to_transform(const Transform &p_transform) {
	RenderState::projection_matrix_2d = p_transform;
	_camera_2d_projection_matrix_stack.clear();
	_camera_2d_projection_matrix = p_transform;
}

void Renderer::camera_3d_bind() {
	RenderState::camera_transform_3d = _camera_3d_camera_transform_matrix;
	RenderState::model_view_matrix_3d = _camera_3d_model_view_matrix;
	RenderState::projection_matrix_3d = _camera_3d_projection;
}

void Renderer::camera_3d_reset() {
	_camera_3d_projection = Projection();
	_camera_3d_camera_transform_matrix = Transform();
	_camera_3d_model_view_matrix = Transform();

	_camera_3d_camera_transform_matrix_stack.clear();
	_camera_3d_model_view_matrix_stack.clear();

	RenderState::camera_transform_3d = _camera_3d_camera_transform_matrix;
	RenderState::model_view_matrix_3d = _camera_3d_model_view_matrix;
	RenderState::projection_matrix_3d = _camera_3d_projection;
}

Transform Renderer::camera_3d_get_current_camera_transform_matrix() const {
	return _camera_3d_camera_transform_matrix;
}
void Renderer::camera_3d_push_camera_transform_matrix(const Transform &p_transform) {
	_camera_3d_camera_transform_matrix_stack.push_back(_camera_3d_camera_transform_matrix);

	_camera_3d_camera_transform_matrix *= p_transform;

	RenderState::camera_transform_3d = _camera_3d_camera_transform_matrix;
}
void Renderer::camera_3d_pop_camera_transform_matrix() {
	if (_camera_3d_camera_transform_matrix_stack.empty()) {
		return;
	}

	_camera_3d_camera_transform_matrix = _camera_3d_camera_transform_matrix_stack[_camera_3d_camera_transform_matrix_stack.size() - 1];

	RenderState::camera_transform_3d = _camera_3d_camera_transform_matrix;

	_camera_3d_camera_transform_matrix_stack.resize(_camera_3d_camera_transform_matrix_stack.size() - 1);
}
int Renderer::get_camera_3d_camera_transform_matrix_stack_size() const {
	return _camera_3d_camera_transform_matrix_stack.size();
}
void Renderer::camera_3d_camera_transform_matrix_stack_clear() {
	_camera_3d_camera_transform_matrix_stack.clear();
	_camera_3d_camera_transform_matrix = Transform();
	RenderState::camera_transform_3d = _camera_3d_camera_transform_matrix;
}

Transform Renderer::camera_3d_get_current_model_view_matrix() const {
	return _camera_3d_model_view_matrix;
}
void Renderer::camera_3d_push_model_view_matrix(const Transform &p_transform) {
	_camera_3d_model_view_matrix_stack.push_back(_camera_3d_model_view_matrix);

	_camera_3d_model_view_matrix *= p_transform;

	RenderState::model_view_matrix_3d = _camera_3d_model_view_matrix;
}
void Renderer::camera_3d_pop_model_view_matrix() {
	if (_camera_3d_model_view_matrix_stack.empty()) {
		return;
	}

	_camera_3d_model_view_matrix = _camera_3d_model_view_matrix_stack[_camera_3d_model_view_matrix_stack.size() - 1];

	RenderState::model_view_matrix_3d = _camera_3d_model_view_matrix;

	_camera_3d_model_view_matrix_stack.resize(_camera_3d_model_view_matrix_stack.size() - 1);
}
int Renderer::get_camera_3d_model_view_matrix_stack_size() const {
	return _camera_3d_model_view_matrix_stack.size();
}
void Renderer::get_camera_3d_model_view_matrix_stack_clear() {
	_camera_3d_model_view_matrix_stack.clear();
	_camera_3d_model_view_matrix = Transform();

	RenderState::model_view_matrix_3d = _camera_3d_model_view_matrix;
}

// Aspect Ratio = w / h
void Renderer::camera_3d_projection_set_to_orthographic(float aspect_ratio, float size, float znear, float zfar, bool vaspect) {
	_camera_3d_projection.set_orthogonal(
			size,
			aspect_ratio,
			znear,
			zfar,
			vaspect);

	RenderState::projection_matrix_3d = _camera_3d_projection;

	_last_camera_3d_data.type = LastCamera3DData::TYPE_ORTOGRAPHIC;
	_last_camera_3d_data.size = size;
	_last_camera_3d_data.aspect_ratio = aspect_ratio;
	_last_camera_3d_data.znear = znear;
	_last_camera_3d_data.zfar = zfar;
	_last_camera_3d_data.vaspect = vaspect;
	_last_camera_3d_data.fov = 70;
	_last_camera_3d_data.offset = 0;
}
void Renderer::camera_3d_projection_set_to_perspective(float aspect_ratio, float size, float znear, float zfar, bool vaspect, float fov) {
	_camera_3d_projection.set_perspective(
			fov,
			aspect_ratio,
			znear,
			zfar,
			vaspect);

	RenderState::projection_matrix_3d = _camera_3d_projection;

	_last_camera_3d_data.type = LastCamera3DData::TYPE_PERSPECTIVE;
	_last_camera_3d_data.size = size;
	_last_camera_3d_data.aspect_ratio = aspect_ratio;
	_last_camera_3d_data.znear = znear;
	_last_camera_3d_data.zfar = zfar;
	_last_camera_3d_data.vaspect = vaspect;
	_last_camera_3d_data.fov = fov;
	_last_camera_3d_data.offset = 0;
}
void Renderer::camera_3d_projection_set_to_frustum(float aspect_ratio, float size, float znear, float zfar, bool vaspect, float offset) {
	_camera_3d_projection.set_frustum(
			size,
			aspect_ratio,
			offset,
			znear,
			zfar,
			vaspect);

	RenderState::projection_matrix_3d = _camera_3d_projection;

	_last_camera_3d_data.type = LastCamera3DData::TYPE_FRUSTUM;
	_last_camera_3d_data.size = size;
	_last_camera_3d_data.aspect_ratio = aspect_ratio;
	_last_camera_3d_data.znear = znear;
	_last_camera_3d_data.zfar = zfar;
	_last_camera_3d_data.vaspect = vaspect;
	_last_camera_3d_data.fov = 70;
	_last_camera_3d_data.offset = offset;
}

Projection Renderer::camera_3d_get_projection_matrix() const {
	return _camera_3d_projection;
}
void Renderer::camera_3d_set_projection_matrix(const Projection &p_projection) {
	_camera_3d_projection = p_projection;

	RenderState::projection_matrix_3d = _camera_3d_projection;
}

Vector3 Renderer::camera_3d_project_ray_normal(const Point2 &p_pos) const {
	Vector3 ray = camera_3d_project_local_ray_normal(p_pos);
	return _camera_3d_camera_transform_matrix.basis.xform(ray).normalized();
};

Vector3 Renderer::camera_3d_project_local_ray_normal(const Point2 &p_pos) const {
	if (_last_camera_3d_data.type == LastCamera3DData::TYPE_ORTOGRAPHIC) {
		return Vector3(0, 0, -1);
	}

	Size2 viewport_size = RenderState::render_rect.size;
	Vector2 cpos = p_pos;
	Vector3 ray;

	Projection cm;
	cm.set_perspective(70, viewport_size.aspect(), _last_camera_3d_data.znear, _last_camera_3d_data.zfar, true);
	Vector2 screen_he = cm.get_viewport_half_extents();
	ray = Vector3(((cpos.x / viewport_size.width) * 2.0 - 1.0) * screen_he.x, ((1.0 - (cpos.y / viewport_size.height)) * 2.0 - 1.0) * screen_he.y, -_last_camera_3d_data.znear).normalized();

	return ray;
};

Vector3 Renderer::camera_3d_project_ray_origin(const Point2 &p_pos) const {
	Size2 viewport_size = RenderState::render_rect.size;
	Vector2 cpos = p_pos;
	ERR_FAIL_COND_V(viewport_size.y == 0, Vector3());

	Vector2 pos = cpos / viewport_size;
	float vsize, hsize;

	vsize = _last_camera_3d_data.size / viewport_size.aspect();
	hsize = _last_camera_3d_data.size;

	Vector3 ray;
	ray.x = pos.x * (hsize)-hsize / 2;
	ray.y = (1.0 - pos.y) * (vsize)-vsize / 2;
	ray.z = -_last_camera_3d_data.znear;
	ray = _camera_3d_camera_transform_matrix.xform(ray);
	return ray;
};

bool Renderer::camera_3d_is_position_behind(const Vector3 &p_pos) const {
	Transform t = _camera_3d_camera_transform_matrix;
	Vector3 eyedir = -t.basis.get_axis(2).normalized();
	return eyedir.dot(p_pos - t.origin) < _last_camera_3d_data.znear;
}

Vector<Vector3> Renderer::camera_3d_get_near_plane_points() const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	if (_last_camera_3d_data.type == LastCamera3DData::TYPE_ORTOGRAPHIC) {
		cm.set_orthogonal(_last_camera_3d_data.size, viewport_size.aspect(), _last_camera_3d_data.znear, _last_camera_3d_data.zfar, true);
	} else {
		cm.set_perspective(_last_camera_3d_data.fov, viewport_size.aspect(), _last_camera_3d_data.znear, _last_camera_3d_data.zfar, true);
	}

	Vector3 endpoints[8];
	cm.get_endpoints(Transform(), endpoints);

	Vector<Vector3> points;
	points.push_back(Vector3());
	for (int i = 0; i < 4; i++) {
		points.push_back(endpoints[i + 4]);
	}
	return points;
}

Point2 Renderer::camera_3d_unproject_position(const Vector3 &p_pos) const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	if (_last_camera_3d_data.type == LastCamera3DData::TYPE_ORTOGRAPHIC) {
		cm.set_orthogonal(_last_camera_3d_data.size, viewport_size.aspect(), _last_camera_3d_data.znear, _last_camera_3d_data.zfar, true);
	} else {
		cm.set_perspective(_last_camera_3d_data.fov, viewport_size.aspect(), _last_camera_3d_data.znear, _last_camera_3d_data.zfar, true);
	}

	Plane p(_camera_3d_camera_transform_matrix.xform_inv(p_pos), 1.0);

	p = cm.xform(p);
	p.normal /= p.d;

	Point2 res;
	res.x = (p.normal.x * 0.5 + 0.5) * viewport_size.x;
	res.y = (-p.normal.y * 0.5 + 0.5) * viewport_size.y;

	return res;
}

Vector3 Renderer::camera_3d_project_position(const Point2 &p_point, float p_z_depth) const {
	if (p_z_depth == 0) {
		return _camera_3d_camera_transform_matrix.origin;
	}

	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	if (_last_camera_3d_data.type == LastCamera3DData::TYPE_ORTOGRAPHIC) {
		cm.set_orthogonal(_last_camera_3d_data.size, viewport_size.aspect(), p_z_depth, _last_camera_3d_data.zfar, true);
	} else {
		cm.set_perspective(_last_camera_3d_data.fov, viewport_size.aspect(), p_z_depth, _last_camera_3d_data.zfar, true);
	}

	Vector2 vp_he = cm.get_viewport_half_extents();

	Vector2 point;
	point.x = (p_point.x / viewport_size.x) * 2.0 - 1.0;
	point.y = (1.0 - (p_point.y / viewport_size.y)) * 2.0 - 1.0;
	point *= vp_he;

	Vector3 p(point.x, point.y, -p_z_depth);

	return _camera_3d_camera_transform_matrix.xform(p);
}

void Renderer::clear_screen(const Color &p_color) {
	glClearColor(p_color.r, p_color.g, p_color.b, p_color.a);

	if (!_depth_buffer) {
		glClear(GL_COLOR_BUFFER_BIT);
	} else {
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	}
}

Vector2i Renderer::get_window_size() const {
	return Vector2i(AppWindow::get_singleton()->get_width(), AppWindow::get_singleton()->get_height());
}

float Renderer::get_window_aspect() const {
	return AppWindow::get_singleton()->get_aspect();
}

void Renderer::initialize() {
	ERR_FAIL_COND(_singleton);

	memnew(Renderer);
}
void Renderer::destroy() {
	ERR_FAIL_COND(!_singleton);

	memdelete(_singleton);
}

Renderer::Renderer() {
	_singleton = this;

	_depth_buffer = false;
	_face_culling = FACE_CULLING_OFF;

	_2d_mesh.instance();
	_2d_mesh->vertex_dimesions = 2;
	_3d_mesh.instance();
	_font_mesh.instance();
	_font_mesh->vertex_dimesions = 2;

	_texture_material_2d.instance();
	_font_material.instance();
	_color_material_2d.instance();

	_texture_material_3d.instance();
	_color_material_3d.instance();
	_colored_material_3d.instance();
}
Renderer::~Renderer() {
	_singleton = NULL;
}

Renderer *Renderer::get_singleton() {
	return _singleton;
}

Renderer *Renderer::_singleton = NULL;
#line 0

//===================  RENDER OBJECTS SECTION  ===================

#line 1 "sfw/render_objects/camera_3d.cpp"

Transform Camera3D::get_camera_transform() {
	return _camera_transform;
}
void Camera3D::set_camera_transform(const Transform &p_value) {
	_camera_transform = p_value;

	if (current_camera == this) {
		RenderState::camera_transform_3d = _camera_transform;
	}
}

Transform Camera3D::get_model_view_matrix() {
	return _model_view_matrix;
}
void Camera3D::set_model_view_matrix(const Transform &p_value) {
	_model_view_matrix = p_value;

	if (current_camera == this) {
		RenderState::model_view_matrix_3d = _model_view_matrix;
	}
}

Projection Camera3D::get_projection_matrix() {
	return _projection_matrix;
}
void Camera3D::set_projection_matrix(const Projection &p_value) {
	_projection_matrix = p_value;

	if (current_camera == this) {
		RenderState::projection_matrix_3d = _projection_matrix;
	}
}

void Camera3D::bind() {
	make_current();

	_model_view_matrix = Transform();

	RenderState::camera_transform_3d = _camera_transform;
	RenderState::model_view_matrix_3d = _model_view_matrix;
	RenderState::projection_matrix_3d = _projection_matrix;
}

void Camera3D::make_current() {
	current_camera = this;
}

Vector3 Camera3D::project_ray_normal(const Point2 &p_pos) const {
	Vector3 ray = project_local_ray_normal(p_pos);
	return transform.basis.xform(ray).normalized();
};

Vector3 Camera3D::project_local_ray_normal(const Point2 &p_pos) const {
	Size2 viewport_size = RenderState::render_rect.size;
	Vector2 cpos = p_pos;
	Vector3 ray;

	Projection cm;
	cm.set_perspective(70, viewport_size.aspect(), znear, zfar, true);
	Vector2 screen_he = cm.get_viewport_half_extents();
	ray = Vector3(((cpos.x / viewport_size.width) * 2.0 - 1.0) * screen_he.x, ((1.0 - (cpos.y / viewport_size.height)) * 2.0 - 1.0) * screen_he.y, -znear).normalized();

	return ray;
};

Vector3 Camera3D::project_ray_origin(const Point2 &p_pos) const {
	Size2 viewport_size = RenderState::render_rect.size;
	Vector2 cpos = p_pos;
	ERR_FAIL_COND_V(viewport_size.y == 0, Vector3());

	Vector2 pos = cpos / viewport_size;
	float vsize, hsize;

	vsize = size / viewport_size.aspect();
	hsize = size;

	Vector3 ray;
	ray.x = pos.x * (hsize)-hsize / 2;
	ray.y = (1.0 - pos.y) * (vsize)-vsize / 2;
	ray.z = -znear;
	ray = transform.xform(ray);
	return ray;
};

bool Camera3D::is_position_behind(const Vector3 &p_pos) const {
	Transform t = transform;
	Vector3 eyedir = -t.basis.get_axis(2).normalized();
	return eyedir.dot(p_pos - t.origin) < znear;
}

Vector<Vector3> Camera3D::get_near_plane_points() const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_perspective(70, viewport_size.aspect(), znear, zfar, true);

	Vector3 endpoints[8];
	cm.get_endpoints(Transform(), endpoints);

	Vector<Vector3> points;
	points.push_back(Vector3());
	for (int i = 0; i < 4; i++) {
		points.push_back(endpoints[i + 4]);
	}
	return points;
}

Point2 Camera3D::unproject_position(const Vector3 &p_pos) const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_perspective(70, viewport_size.aspect(), znear, zfar, true);

	Plane p(transform.xform_inv(p_pos), 1.0);

	p = cm.xform(p);
	p.normal /= p.d;

	Point2 res;
	res.x = (p.normal.x * 0.5 + 0.5) * viewport_size.x;
	res.y = (-p.normal.y * 0.5 + 0.5) * viewport_size.y;

	return res;
}

Vector3 Camera3D::project_position(const Point2 &p_point, float p_z_depth) const {
	if (p_z_depth == 0) {
		return transform.origin;
	}

	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_perspective(70, viewport_size.aspect(), p_z_depth, zfar, true);

	Vector2 vp_he = cm.get_viewport_half_extents();

	Vector2 point;
	point.x = (p_point.x / viewport_size.x) * 2.0 - 1.0;
	point.y = (1.0 - (p_point.y / viewport_size.y)) * 2.0 - 1.0;
	point *= vp_he;

	Vector3 p(point.x, point.y, -p_z_depth);

	return transform.xform(p);
}

Camera3D::Camera3D() {
	screen_aspect_ratio = 1; //p_viewport_size.width / (float)p_viewport_size.height,

	znear = 0.05;
	zfar = 100;
	size = 1.0;

	vaspect = false;
}
Camera3D::~Camera3D() {
}

Camera3D *Camera3D::current_camera = NULL;

void OrthographicCamera::bind() {
	_projection_matrix.set_orthogonal(
			size,
			screen_aspect_ratio,
			znear,
			zfar,
			vaspect);

	Camera3D::bind();
}

Vector3 OrthographicCamera::project_local_ray_normal(const Point2 &p_pos) const {
	return Vector3(0, 0, -1);
};

Point2 OrthographicCamera::unproject_position(const Vector3 &p_pos) const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_orthogonal(size, viewport_size.aspect(), znear, zfar, true);

	Plane p(transform.xform_inv(p_pos), 1.0);

	p = cm.xform(p);
	p.normal /= p.d;

	Point2 res;
	res.x = (p.normal.x * 0.5 + 0.5) * viewport_size.x;
	res.y = (-p.normal.y * 0.5 + 0.5) * viewport_size.y;

	return res;
}

Vector3 OrthographicCamera::project_position(const Point2 &p_point, float p_z_depth) const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_orthogonal(size, viewport_size.aspect(), p_z_depth, zfar, true);

	Vector2 vp_he = cm.get_viewport_half_extents();

	Vector2 point;
	point.x = (p_point.x / viewport_size.x) * 2.0 - 1.0;
	point.y = (1.0 - (p_point.y / viewport_size.y)) * 2.0 - 1.0;
	point *= vp_he;

	Vector3 p(point.x, point.y, -p_z_depth);

	return transform.xform(p);
}

Vector<Vector3> OrthographicCamera::get_near_plane_points() const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_orthogonal(size, viewport_size.aspect(), znear, zfar, true);

	Vector3 endpoints[8];
	cm.get_endpoints(Transform(), endpoints);

	Vector<Vector3> points;
	points.push_back(Vector3());
	for (int i = 0; i < 4; i++) {
		points.push_back(endpoints[i + 4]);
	}
	return points;
}

OrthographicCamera::OrthographicCamera() :
		Camera3D() {
}
OrthographicCamera::~OrthographicCamera() {
}

void PerspectiveCamera::bind() {
	_projection_matrix.set_perspective(
			fov,
			screen_aspect_ratio,
			znear,
			zfar,
			vaspect);

	Camera3D::bind();
}

Vector3 PerspectiveCamera::project_local_ray_normal(const Point2 &p_pos) const {
	Size2 viewport_size = RenderState::render_rect.size;
	Vector2 cpos = p_pos;
	Vector3 ray;

	Projection cm;
	cm.set_perspective(fov, viewport_size.aspect(), znear, zfar, false);
	Vector2 screen_he = cm.get_viewport_half_extents();
	ray = Vector3(((cpos.x / viewport_size.width) * 2.0 - 1.0) * screen_he.x, ((1.0 - (cpos.y / viewport_size.height)) * 2.0 - 1.0) * screen_he.y, -znear).normalized();

	return ray;
};

Vector3 PerspectiveCamera::project_ray_origin(const Point2 &p_pos) const {
	return transform.origin;
};

Point2 PerspectiveCamera::unproject_position(const Vector3 &p_pos) const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_perspective(fov, viewport_size.aspect(), znear, zfar, true);
	Plane p(transform.xform_inv(p_pos), 1.0);

	p = cm.xform(p);
	p.normal /= p.d;

	Point2 res;
	res.x = (p.normal.x * 0.5 + 0.5) * viewport_size.x;
	res.y = (-p.normal.y * 0.5 + 0.5) * viewport_size.y;

	return res;
}

Vector3 PerspectiveCamera::project_position(const Point2 &p_point, float p_z_depth) const {
	if (p_z_depth == 0) {
		return transform.origin;
	}

	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_perspective(fov, viewport_size.aspect(), p_z_depth, zfar, true);

	Vector2 vp_he = cm.get_viewport_half_extents();

	Vector2 point;
	point.x = (p_point.x / viewport_size.x) * 2.0 - 1.0;
	point.y = (1.0 - (p_point.y / viewport_size.y)) * 2.0 - 1.0;
	point *= vp_he;

	Vector3 p(point.x, point.y, -p_z_depth);

	return transform.xform(p);
}

Vector<Vector3> PerspectiveCamera::get_near_plane_points() const {
	Size2 viewport_size = RenderState::render_rect.size;

	Projection cm;

	cm.set_perspective(fov, viewport_size.aspect(), znear, zfar, true);

	Vector3 endpoints[8];
	cm.get_endpoints(Transform(), endpoints);

	Vector<Vector3> points;
	points.push_back(Vector3());
	for (int i = 0; i < 4; i++) {
		points.push_back(endpoints[i + 4]);
	}
	return points;
}

PerspectiveCamera::PerspectiveCamera() :
		Camera3D() {
	fov = 70;
}

PerspectiveCamera::~PerspectiveCamera() {
}

void FrustumCamera::bind() {
	_projection_matrix.set_frustum(
			size,
			screen_aspect_ratio,
			offset,
			znear,
			zfar,
			vaspect);

	Camera3D::bind();
}

FrustumCamera::FrustumCamera() :
		Camera3D() {
	offset = 0;

	_projection_matrix.set_frustum(
			size,
			screen_aspect_ratio,
			offset,
			znear,
			zfar,
			vaspect);
}

FrustumCamera::~FrustumCamera() {
}
#line 0

#line 1 "sfw/render_objects/sprite.cpp"

void Sprite::render() {
	/*
	mesh_instance->position.x = position.x;
	mesh_instance->position.y = position.y;

	mesh_instance->rotation.z = rotation;

	mesh_instance->scale.x = scale.x;
	mesh_instance->scale.y = scale.y;
	*/

	mesh_instance->transform = transform;
	mesh_instance->render();
}

void Sprite::update_mesh() {
	Ref<Mesh> mesh = mesh_instance->mesh;

	mesh->clear();

	float w2 = width / 2.0;
	float h2 = height / 2.0;

	/*
	mesh->add_uv(region_x, region_y);
	mesh->add_vertex2(-w2, h2);

	mesh->add_uv(region_x + region_width, region_y + region_height);
	mesh->add_vertex2(w2, -h2);

	mesh->add_uv(region_x, region_y + region_height);
	mesh->add_vertex2(-w2, -h2);

	mesh->add_uv(region_x + region_width, region_y);
	mesh->add_vertex2(w2, h2);
	*/

	mesh->add_uv(region_x, region_y);
	mesh->add_vertex2(-w2, -h2);

	mesh->add_uv(region_x + region_width, region_y + region_height);
	mesh->add_vertex2(w2, h2);

	mesh->add_uv(region_x, region_y + region_height);

	mesh->add_vertex2(-w2, h2);

	mesh->add_uv(region_x + region_width, region_y);

	mesh->add_vertex2(w2, -h2);

	mesh->add_triangle(1, 0, 2);
	mesh->add_triangle(0, 1, 3);

	mesh->upload();
}

Sprite::Sprite() {
	mesh_instance = memnew(MeshInstance2D());
	mesh_instance->mesh = Ref<Mesh>(memnew(Mesh(2)));

	width = 1;
	height = 1;

	region_x = 0;
	region_y = 0;
	region_width = 1;
	region_height = 1;
}

Sprite::~Sprite() {
	memdelete(mesh_instance);
}
#line 0

#line 1 "sfw/render_objects/camera_2d.cpp"

Transform2D Camera2D::get_model_view_matrix() {
	return _model_view_matrix;
}
void Camera2D::set_model_view_matrix(const Transform2D &p_value) {
	_model_view_matrix = p_value;

	if (current_camera == this) {
		RenderState::model_view_matrix_2d = _model_view_matrix;
	}
}

Transform Camera2D::get_projection_matrix() {
	return _projection_matrix;
}
void Camera2D::set_projection_matrix(const Transform &p_value) {
	_projection_matrix = p_value;

	if (current_camera == this) {
		RenderState::projection_matrix_2d = _projection_matrix;
	}
}

void Camera2D::bind() {
	make_current();

	Transform canvas_transform;
	canvas_transform.translate_local(-(size.width / 2.0f), -(size.height / 2.0f), 0.0f);
	//canvas_transform.scale(Vector3(2.0f / size.width, 2.0f / size.height, 1.0f));
	canvas_transform.scale(Vector3(2.0f / size.width, -2.0f / size.height, 1.0f));

	_projection_matrix = canvas_transform;
	_model_view_matrix = Transform2D();

	RenderState::model_view_matrix_2d = _model_view_matrix;
	RenderState::projection_matrix_2d = _projection_matrix;
}

void Camera2D::make_current() {
	current_camera = this;
}

void Camera2D::set_size_to_render_target() {
	size = RenderState::render_rect.size;
}

Camera2D::Camera2D() {
}
Camera2D::~Camera2D() {
}

Camera2D *Camera2D::current_camera = NULL;
#line 0

#line 1 "sfw/render_objects/mesh_instance_3d.cpp"

void MeshInstance3D::render() {
	if (!mesh.is_valid()) {
		return;
	}

	Transform mat_orig = Camera3D::current_camera->get_model_view_matrix();

	Camera3D::current_camera->set_model_view_matrix(mat_orig * transform);

	if (material.is_valid()) {
		material->bind();
	}

	mesh->render();

	for (int i = 0; i < children.size(); ++i) {
		MeshInstance3D *c = children[i];

		if (c) {
			c->render();
		}
	}

	Camera3D::current_camera->set_model_view_matrix(mat_orig);
}

MeshInstance3D::MeshInstance3D() {
}
MeshInstance3D::~MeshInstance3D() {
	for (int i = 0; i < children.size(); ++i) {
		memdelete(children[i]);
	}

	children.clear();
}
#line 0

#line 1 "sfw/render_objects/object_3d.cpp"

Object3D::Object3D() {
}

Object3D::~Object3D() {
}
#line 0

#line 1 "sfw/render_objects/tile_map.cpp"

void TileMap::build_mesh() {
	if (!mesh.is_valid()) {
		mesh = Ref<Mesh>(memnew(Mesh(2)));
	} else {
		mesh->clear();
	}

	if (!data) {
		//mesh->upload();

		return;
	}

	float asx = 1.0 / atlas_size_x;
	float asy = 1.0 / atlas_size_y;

	for (int x = 0; x < size_x; ++x) {
		int x_offset = x * size_x;

		for (int y = 0; y < size_y; ++y) {
			uint8_t d = data[x_offset + y];

			if (d == 0) {
				continue;
			}

			float px;
			float py;

			switch (d) {
				case 1:
					px = 1;
					py = 0;
					break;
				case 2:
					px = 0;
					py = 1;
					break;
			}

			px /= atlas_size_x;
			py /= atlas_size_y;

			add_rect(x, y, px, py, asx, asy);
		}
	}

	mesh->upload();
}

void TileMap::allocate_data() {
	if (size_x <= 0 || size_y <= 0) {
		return;
	}

	if (data) {
		memdelete_arr(data);
	}

	int size = size_x * size_y;

	data = memnew_arr(uint8_t, size);

	for (int i = 0; i < size; ++i) {
		data[i] = 0;
	}
}

void TileMap::add_rect(const int x, const int y, const float uv_x, const float uv_y, const float uv_size_x, const float uv_size_y) {
	int vc = static_cast<int>(mesh->vertices.size() / mesh->vertex_dimesions);

	mesh->add_vertex2(x, y + 1);
	mesh->add_uv(uv_x, uv_y + uv_size_y);

	mesh->add_vertex2(x + 1, y);
	mesh->add_uv(uv_x + uv_size_x, uv_y);

	mesh->add_vertex2(x, y);
	mesh->add_uv(uv_x, uv_y);

	mesh->add_vertex2(x + 1, y + 1);
	mesh->add_uv(uv_x + uv_size_x, uv_y + uv_size_y);

	mesh->add_triangle(vc + 1, vc + 0, vc + 2);
	mesh->add_triangle(vc + 0, vc + 1, vc + 3);
}

uint8_t TileMap::get_data(const int x, const int y) const {
	//3d-ben: data[(x * size_x * size_x) + (y * size_y) + size_z] etc

	return data[x * size_x + y];
}

void TileMap::set_data(const int x, const int y, const uint8_t value) {
	data[x * size_x + y] = value;
}

void TileMap::render() {
	if (!mesh.is_valid()) {
		return;
	}

	Transform2D mat_orig = Camera2D::current_camera->get_model_view_matrix();

	Camera2D::current_camera->set_model_view_matrix(mat_orig * transform);

	if (material.is_valid()) {
		material->bind();
	}

	mesh->render();

	Camera2D::current_camera->set_model_view_matrix(mat_orig);
}

TileMap::TileMap() {
	data = NULL;
	size_x = 16;
	size_y = 16;

	atlas_size_x = 1;
	atlas_size_y = 1;
}
TileMap::~TileMap() {
	if (data) {
		memdelete_arr(data);
	}
}
#line 0

#line 1 "sfw/render_objects/text_2d.cpp"

Color Text2D::get_text_color() const {
	return _text_color;
}
void Text2D::set_text_color(const Color &p_color) {
	_text_color = p_color;
}

String Text2D::get_text() const {
	return _text;
}
void Text2D::set_text(const String &p_text) {
	_text = p_text;
}

Ref<Font> Text2D::get_font() const {
	return _font;
}
void Text2D::set_font(const Ref<Font> &p_font) {
	_font = p_font;

	if (_font.is_valid()) {
		_material->texture = _font->get_texture();
	}
}

Vector2 Text2D::get_text_size() {
	return _text_size;
}

void Text2D::update() {
	_mesh->clear();

	if (!_font.is_valid()) {
		return;
	}

	_text_size = _font->generate_mesh(_text, _mesh, _text_color);

	_mesh->upload();
}

void Text2D::render() {
	Transform2D mat_orig = Camera2D::current_camera->get_model_view_matrix();

	Camera2D::current_camera->set_model_view_matrix(mat_orig * transform);

	_material->bind();
	_mesh->render();

	Camera2D::current_camera->set_model_view_matrix(mat_orig);
}

Text2D::Text2D() {
	_material.instance();
	_mesh.instance();
	_mesh->vertex_dimesions = 2;
}
Text2D::~Text2D() {
}
#line 0

#line 1 "sfw/render_objects/object_2d.cpp"

Object2D::Object2D() {
}

Object2D::~Object2D() {
}
#line 0

#line 1 "sfw/render_objects/mesh_instance_2d.cpp"

void MeshInstance2D::render() {
	if (!mesh.is_valid()) {
		return;
	}

	Transform2D mat_orig = Camera2D::current_camera->get_model_view_matrix();

	Camera2D::current_camera->set_model_view_matrix(mat_orig * transform);

	if (material.is_valid()) {
		material->bind();
	}

	mesh->render();

	for (int i = 0; i < children.size(); ++i) {
		MeshInstance2D *c = children[i];

		if (c) {
			c->render();
		}
	}

	Camera2D::current_camera->set_model_view_matrix(mat_orig);
}

MeshInstance2D::MeshInstance2D() {
}
MeshInstance2D::~MeshInstance2D() {
	for (int i = 0; i < children.size(); ++i) {
		memdelete(children[i]);
	}

	children.clear();
}
#line 0

//===================  GUI SECTION  ===================

// [SECTION] Forward declarations

struct ImBitVector; // Store 1-bit per value
struct ImRect; // An axis-aligned rectangle (2 points)
struct ImDrawDataBuilder; // Helper to build a ImDrawData instance
struct ImDrawListSharedData; // Data shared between all ImDrawList instances
struct ImGuiBoxSelectState; // Box-selection state (currently used by multi-selection, could potentially be used by others)
struct ImGuiColorMod; // Stacked color modifier, backup of modified data so we can restore it
struct ImGuiContext; // Main Dear ImGui context
struct ImGuiContextHook; // Hook for extensions like ImGuiTestEngine
struct ImGuiDataVarInfo; // Variable information (e.g. to access style variables from an enum)
struct ImGuiDataTypeInfo; // Type information associated to a ImGuiDataType enum
struct ImGuiGroupData; // Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiInputTextState; // Internal state of the currently focused/edited text input box
struct ImGuiInputTextDeactivateData; // Short term storage to backup text of a deactivating InputText() while another is stealing active id
struct ImGuiLastItemData; // Status storage for last submitted items
struct ImGuiLocEntry; // A localization entry.
struct ImGuiMenuColumns; // Simple column measurement, currently used for MenuItem() only
struct ImGuiMultiSelectState; // Multi-selection persistent state (for focused selection).
struct ImGuiMultiSelectTempData; // Multi-selection temporary state (while traversing).
struct ImGuiNavItemData; // Result of a gamepad/keyboard directional navigation move query result
struct ImGuiMetricsConfig; // Storage for ShowMetricsWindow() and DebugNodeXXX() functions
struct ImGuiNextWindowData; // Storage for SetNextWindow** functions
struct ImGuiNextItemData; // Storage for SetNextItem** functions
struct ImGuiOldColumnData; // Storage data for a single column for legacy Columns() api
struct ImGuiOldColumns; // Storage data for a columns set for legacy Columns() api
struct ImGuiPopupData; // Storage for current popup stack
struct ImGuiSettingsHandler; // Storage for one type registered in the .ini file
struct ImGuiStackSizes; // Storage of stack sizes for debugging/asserting
struct ImGuiStyleMod; // Stacked style modifier, backup of modified data so we can restore it
struct ImGuiTabBar; // Storage for a tab bar
struct ImGuiTabItem; // Storage for a tab item (within a tab bar)
struct ImGuiTable; // Storage for a table
struct ImGuiTableHeaderData; // Storage for TableAngledHeadersRow()
struct ImGuiTableColumn; // Storage for one column of a table
struct ImGuiTableInstanceData; // Storage for one instance of a same table
struct ImGuiTableTempData; // Temporary storage for one table (one per table in the stack), shared between tables.
struct ImGuiTableSettings; // Storage for a table .ini settings
struct ImGuiTableColumnsSettings; // Storage for a column .ini settings
struct ImGuiTreeNodeStackData; // Temporary storage for TreeNode().
struct ImGuiTypingSelectState; // Storage for GetTypingSelectRequest()
struct ImGuiTypingSelectRequest; // Storage for GetTypingSelectRequest() (aimed to be public)
struct ImGuiWindow; // Storage for one window
struct ImGuiWindowTempData; // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame, in practice we currently keep it for each window)
struct ImGuiWindowSettings; // Storage for a window .ini settings (we keep one of those even if the actual window wasn't instanced during this session)

// Enumerations
// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
enum ImGuiLocKey : int; // -> enum ImGuiLocKey              // Enum: a localization entry for translation.
typedef int ImGuiLayoutType; // -> enum ImGuiLayoutType_         // Enum: Horizontal or vertical

// Flags
typedef int ImGuiActivateFlags; // -> enum ImGuiActivateFlags_      // Flags: for navigation/focus function (will be for ActivateItem() later)
typedef int ImGuiDebugLogFlags; // -> enum ImGuiDebugLogFlags_      // Flags: for ShowDebugLogWindow(), g.DebugLogFlags
typedef int ImGuiFocusRequestFlags; // -> enum ImGuiFocusRequestFlags_  // Flags: for FocusWindow();
typedef int ImGuiItemStatusFlags; // -> enum ImGuiItemStatusFlags_    // Flags: for g.LastItemData.StatusFlags
typedef int ImGuiOldColumnFlags; // -> enum ImGuiOldColumnFlags_     // Flags: for BeginColumns()
typedef int ImGuiNavHighlightFlags; // -> enum ImGuiNavHighlightFlags_  // Flags: for RenderNavHighlight()
typedef int ImGuiNavMoveFlags; // -> enum ImGuiNavMoveFlags_       // Flags: for navigation requests
typedef int ImGuiNextItemDataFlags; // -> enum ImGuiNextItemDataFlags_  // Flags: for SetNextItemXXX() functions
typedef int ImGuiNextWindowDataFlags; // -> enum ImGuiNextWindowDataFlags_// Flags: for SetNextWindowXXX() functions
typedef int ImGuiScrollFlags; // -> enum ImGuiScrollFlags_        // Flags: for ScrollToItem() and navigation requests
typedef int ImGuiSeparatorFlags; // -> enum ImGuiSeparatorFlags_     // Flags: for SeparatorEx()
typedef int ImGuiTextFlags; // -> enum ImGuiTextFlags_          // Flags: for TextEx()
typedef int ImGuiTooltipFlags; // -> enum ImGuiTooltipFlags_       // Flags: for BeginTooltipEx()
typedef int ImGuiTypingSelectFlags; // -> enum ImGuiTypingSelectFlags_  // Flags: for GetTypingSelectRequest()
typedef int ImGuiWindowRefreshFlags; // -> enum ImGuiWindowRefreshFlags_ // Flags: for SetNextWindowRefreshPolicy()

typedef void (*ImGuiErrorLogCallback)(void *user_data, const char *fmt, ...);

static bool InputTextFilterCharacter(ImGuiContext *ctx, unsigned int *p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void *user_data, bool input_source_is_clipboard = false);
static int InputTextCalcTextLenAndLineCount(const char *text_begin, const char **out_text_end);
static ImVec2 InputTextCalcTextSizeW(ImGuiContext *ctx, const ImWchar *text_begin, const ImWchar *text_end, const ImWchar **remaining = NULL, ImVec2 *out_offset = NULL, bool stop_on_new_line = false);

namespace ImStb {

#undef IMSTB_TEXTEDIT_STRING
#undef IMSTB_TEXTEDIT_CHARTYPE
#define IMSTB_TEXTEDIT_STRING ImGuiInputTextState
#define IMSTB_TEXTEDIT_CHARTYPE ImWchar
#define IMSTB_TEXTEDIT_GETWIDTH_NEWLINE (-1.0f)
#define IMSTB_TEXTEDIT_UNDOSTATECOUNT 99
#define IMSTB_TEXTEDIT_UNDOCHARCOUNT 999
#line 1 "sfw/render_gui/imstb_textedit.h"
// [DEAR IMGUI]
// This is a slightly modified version of stb_textedit.h 1.14.
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// - Fix in stb_textedit_find_charpos to handle last line (see https://github.com/ocornut/imgui/issues/6000 + #6783)
// Grep for [DEAR IMGUI] to find the changes.
// - Also renamed macros used or defined outside of IMSTB_TEXTEDIT_IMPLEMENTATION block from STB_TEXTEDIT_* to IMSTB_TEXTEDIT_*

// stb_textedit.h - v1.14  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
//
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining IMSTB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.14 (2021-07-11) page up/down, various fixes
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//   Louis Schnellbach: page up/down in 1.14
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATECOUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHARCOUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTEDIT_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_IMSTB_TEXTEDIT_H
#define INCLUDE_IMSTB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef IMSTB_TEXTEDIT_UNDOSTATECOUNT
#define IMSTB_TEXTEDIT_UNDOSTATECOUNT 99
#endif
#ifndef IMSTB_TEXTEDIT_UNDOCHARCOUNT
#define IMSTB_TEXTEDIT_UNDOCHARCOUNT 999
#endif
#ifndef IMSTB_TEXTEDIT_CHARTYPE
#define IMSTB_TEXTEDIT_CHARTYPE int
#endif
#ifndef IMSTB_TEXTEDIT_POSITIONTYPE
#define IMSTB_TEXTEDIT_POSITIONTYPE int
#endif

typedef struct
{
	// private data
	IMSTB_TEXTEDIT_POSITIONTYPE where;
	IMSTB_TEXTEDIT_POSITIONTYPE insert_length;
	IMSTB_TEXTEDIT_POSITIONTYPE delete_length;
	int char_storage;
} StbUndoRecord;

typedef struct
{
	// private data
	StbUndoRecord undo_rec[IMSTB_TEXTEDIT_UNDOSTATECOUNT];
	IMSTB_TEXTEDIT_CHARTYPE undo_char[IMSTB_TEXTEDIT_UNDOCHARCOUNT];
	short undo_point, redo_point;
	int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
	/////////////////////
	//
	// public data
	//

	int cursor;
	// position of the text cursor within the string

	int select_start; // selection start point
	int select_end;
	// selection start and end point in characters; if equal, no selection.
	// note that start may be less than or greater than end (e.g. when
	// dragging the mouse, start is where the initial click was, and you
	// can drag in either direction)

	unsigned char insert_mode;
	// each textfield keeps its own insert mode state. to keep an app-wide
	// insert mode, copy this value in/out of the app state

	int row_count_per_page;
	// page size in number of row.
	// this value MUST be set to >0 for pageup or pagedown in multilines documents.

	/////////////////////
	//
	// private data
	//
	unsigned char cursor_at_end_of_line; // not implemented yet
	unsigned char initialized;
	unsigned char has_preferred_x;
	unsigned char single_line;
	unsigned char padding1, padding2, padding3;
	float preferred_x; // this determines where the cursor up/down tries to seek to along x
	StbUndoState undostate;
} STB_TexteditState;

////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
	float x0, x1; // starting x location, end x location (allows for align=right, etc)
	float baseline_y_delta; // position of baseline relative to previous row's baseline
	float ymin, ymax; // height of row above and below baseline
	int num_chars;
} StbTexteditRow;
#endif //INCLUDE_IMSTB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////

// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef IMSTB_TEXTEDIT_IMPLEMENTATION

#ifndef IMSTB_TEXTEDIT_memmove
#include <string.h>
#define IMSTB_TEXTEDIT_memmove memmove
#endif

/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(IMSTB_TEXTEDIT_STRING *str, float x, float y) {
	StbTexteditRow r;
	int n = STB_TEXTEDIT_STRINGLEN(str);
	float base_y = 0, prev_x;
	int i = 0, k;

	r.x0 = r.x1 = 0;
	r.ymin = r.ymax = 0;
	r.num_chars = 0;

	// search rows to find one that straddles 'y'
	while (i < n) {
		STB_TEXTEDIT_LAYOUTROW(&r, str, i);
		if (r.num_chars <= 0)
			return n;

		if (i == 0 && y < base_y + r.ymin)
			return 0;

		if (y < base_y + r.ymax)
			break;

		i += r.num_chars;
		base_y += r.baseline_y_delta;
	}

	// below all text, return 'after' last character
	if (i >= n)
		return n;

	// check if it's before the beginning of the line
	if (x < r.x0)
		return i;

	// check if it's before the end of the line
	if (x < r.x1) {
		// search characters in row for one that straddles 'x'
		prev_x = r.x0;
		for (k = 0; k < r.num_chars; ++k) {
			float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
			if (x < prev_x + w) {
				if (x < prev_x + w / 2)
					return k + i;
				else
					return k + i + 1;
			}
			prev_x += w;
		}
		// shouldn't happen, but if it does, fall through to end-of-line case
	}

	// if the last character is a newline, return that. otherwise return 'after' the last character
	if (STB_TEXTEDIT_GETCHAR(str, i + r.num_chars - 1) == STB_TEXTEDIT_NEWLINE)
		return i + r.num_chars - 1;
	else
		return i + r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y) {
	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
	// goes off the top or bottom of the text
	if (state->single_line) {
		StbTexteditRow r;
		STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
		y = r.ymin;
	}

	state->cursor = stb_text_locate_coord(str, x, y);
	state->select_start = state->cursor;
	state->select_end = state->cursor;
	state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y) {
	int p = 0;

	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
	// goes off the top or bottom of the text
	if (state->single_line) {
		StbTexteditRow r;
		STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
		y = r.ymin;
	}

	if (state->select_start == state->select_end)
		state->select_start = state->cursor;

	p = stb_text_locate_coord(str, x, y);
	state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
	float x, y; // position of n'th character
	float height; // height of line
	int first_char, length; // first char of row, and length
	int prev_first; // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, IMSTB_TEXTEDIT_STRING *str, int n, int single_line) {
	StbTexteditRow r;
	int prev_start = 0;
	int z = STB_TEXTEDIT_STRINGLEN(str);
	int i = 0, first;

	if (n == z && single_line) {
		// special case if it's at the end (may not be needed?)
		STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
		find->y = 0;
		find->first_char = 0;
		find->length = z;
		find->height = r.ymax - r.ymin;
		find->x = r.x1;
		return;
	}

	// search rows to find the one that straddles character n
	find->y = 0;

	for (;;) {
		STB_TEXTEDIT_LAYOUTROW(&r, str, i);
		if (n < i + r.num_chars)
			break;
		if (i + r.num_chars == z && z > 0 && STB_TEXTEDIT_GETCHAR(str, z - 1) != STB_TEXTEDIT_NEWLINE) // [DEAR IMGUI] special handling for last line
			break; // [DEAR IMGUI]
		prev_start = i;
		i += r.num_chars;
		find->y += r.baseline_y_delta;
		if (i == z) // [DEAR IMGUI]
		{
			r.num_chars = 0; // [DEAR IMGUI]
			break; // [DEAR IMGUI]
		}
	}

	find->first_char = first = i;
	find->length = r.num_chars;
	find->height = r.ymax - r.ymin;
	find->prev_first = prev_start;

	// now scan to find xpos
	find->x = r.x0;
	for (i = 0; first + i < n; ++i)
		find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s) ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	int n = STB_TEXTEDIT_STRINGLEN(str);
	if (STB_TEXT_HAS_SELECTION(state)) {
		if (state->select_start > n)
			state->select_start = n;
		if (state->select_end > n)
			state->select_end = n;
		// if clamping forced them to be equal, move the cursor to match
		if (state->select_start == state->select_end)
			state->cursor = state->select_start;
	}
	if (state->cursor > n)
		state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len) {
	stb_text_makeundo_delete(str, state, where, len);
	STB_TEXTEDIT_DELETECHARS(str, where, len);
	state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	stb_textedit_clamp(str, state);
	if (STB_TEXT_HAS_SELECTION(state)) {
		if (state->select_start < state->select_end) {
			stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
			state->select_end = state->cursor = state->select_start;
		} else {
			stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
			state->select_start = state->cursor = state->select_end;
		}
		state->has_preferred_x = 0;
	}
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state) {
	if (state->select_end < state->select_start) {
		int temp = state->select_end;
		state->select_end = state->select_start;
		state->select_start = temp;
	}
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state) {
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_sortselection(state);
		state->cursor = state->select_start;
		state->select_end = state->select_start;
		state->has_preferred_x = 0;
	}
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_sortselection(state);
		stb_textedit_clamp(str, state);
		state->cursor = state->select_end;
		state->select_start = state->select_end;
		state->has_preferred_x = 0;
	}
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary(IMSTB_TEXTEDIT_STRING *str, int idx) {
	return idx > 0 ? (STB_TEXTEDIT_IS_SPACE(STB_TEXTEDIT_GETCHAR(str, idx - 1)) && !STB_TEXTEDIT_IS_SPACE(STB_TEXTEDIT_GETCHAR(str, idx))) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous(IMSTB_TEXTEDIT_STRING *str, int c) {
	--c; // always move at least one character
	while (c >= 0 && !is_word_boundary(str, c))
		--c;

	if (c < 0)
		c = 0;

	return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next(IMSTB_TEXTEDIT_STRING *str, int c) {
	const int len = STB_TEXTEDIT_STRINGLEN(str);
	++c; // always move at least one character
	while (c < len && !is_word_boundary(str, c))
		++c;

	if (c > len)
		c = len;

	return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state) {
	if (!STB_TEXT_HAS_SELECTION(state))
		state->select_start = state->select_end = state->cursor;
	else
		state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_delete_selection(str, state); // implicitly clamps
		state->has_preferred_x = 0;
		return 1;
	}
	return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE *text, int len) {
	// if there's a selection, the paste should delete it
	stb_textedit_clamp(str, state);
	stb_textedit_delete_selection(str, state);
	// try to insert the characters
	if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
		stb_text_makeundo_insert(state, state->cursor, len);
		state->cursor += len;
		state->has_preferred_x = 0;
		return 1;
	}
	// note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)
	return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key) {
retry:
	switch (key) {
		default: {
			int c = STB_TEXTEDIT_KEYTOTEXT(key);
			if (c > 0) {
				IMSTB_TEXTEDIT_CHARTYPE ch = (IMSTB_TEXTEDIT_CHARTYPE)c;

				// can't add newline in single-line mode
				if (c == '\n' && state->single_line)
					break;

				if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
					stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
					STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
					if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
						++state->cursor;
						state->has_preferred_x = 0;
					}
				} else {
					stb_textedit_delete_selection(str, state); // implicitly clamps
					if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
						stb_text_makeundo_insert(state, state->cursor, 1);
						++state->cursor;
						state->has_preferred_x = 0;
					}
				}
			}
			break;
		}

#ifdef STB_TEXTEDIT_K_INSERT
		case STB_TEXTEDIT_K_INSERT:
			state->insert_mode = !state->insert_mode;
			break;
#endif

		case STB_TEXTEDIT_K_UNDO:
			stb_text_undo(str, state);
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_REDO:
			stb_text_redo(str, state);
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_LEFT:
			// if currently there's a selection, move cursor to start of selection
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_first(state);
			else if (state->cursor > 0)
				--state->cursor;
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_RIGHT:
			// if currently there's a selection, move cursor to end of selection
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_last(str, state);
			else
				++state->cursor;
			stb_textedit_clamp(str, state);
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_clamp(str, state);
			stb_textedit_prep_selection_at_cursor(state);
			// move selection left
			if (state->select_end > 0)
				--state->select_end;
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
		case STB_TEXTEDIT_K_WORDLEFT:
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_first(state);
			else {
				state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
				stb_textedit_clamp(str, state);
			}
			break;

		case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
			if (!STB_TEXT_HAS_SELECTION(state))
				stb_textedit_prep_selection_at_cursor(state);

			state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
			state->select_end = state->cursor;

			stb_textedit_clamp(str, state);
			break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
		case STB_TEXTEDIT_K_WORDRIGHT:
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_last(str, state);
			else {
				state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
				stb_textedit_clamp(str, state);
			}
			break;

		case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
			if (!STB_TEXT_HAS_SELECTION(state))
				stb_textedit_prep_selection_at_cursor(state);

			state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
			state->select_end = state->cursor;

			stb_textedit_clamp(str, state);
			break;
#endif

		case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor(state);
			// move selection right
			++state->select_end;
			stb_textedit_clamp(str, state);
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_DOWN:
		case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:
		case STB_TEXTEDIT_K_PGDOWN:
		case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT: {
			StbFindState find;
			StbTexteditRow row;
			int i, j, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
			int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN;
			int row_count = is_page ? state->row_count_per_page : 1;

			if (!is_page && state->single_line) {
				// on windows, up&down in single-line behave like left&right
				key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
				goto retry;
			}

			if (sel)
				stb_textedit_prep_selection_at_cursor(state);
			else if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_last(str, state);

			// compute current position of cursor point
			stb_textedit_clamp(str, state);
			stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

			for (j = 0; j < row_count; ++j) {
				float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;
				int start = find.first_char + find.length;

				if (find.length == 0)
					break;

				// [DEAR IMGUI]
				// going down while being on the last line shouldn't bring us to that line end
				if (STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE)
					break;

				// now find character position down a row
				state->cursor = start;
				STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
				x = row.x0;
				for (i = 0; i < row.num_chars; ++i) {
					float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
#ifdef IMSTB_TEXTEDIT_GETWIDTH_NEWLINE
					if (dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE)
						break;
#endif
					x += dx;
					if (x > goal_x)
						break;
					++state->cursor;
				}
				stb_textedit_clamp(str, state);

				state->has_preferred_x = 1;
				state->preferred_x = goal_x;

				if (sel)
					state->select_end = state->cursor;

				// go to next line
				find.first_char = find.first_char + find.length;
				find.length = row.num_chars;
			}
			break;
		}

		case STB_TEXTEDIT_K_UP:
		case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:
		case STB_TEXTEDIT_K_PGUP:
		case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT: {
			StbFindState find;
			StbTexteditRow row;
			int i, j, prev_scan, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
			int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP;
			int row_count = is_page ? state->row_count_per_page : 1;

			if (!is_page && state->single_line) {
				// on windows, up&down become left&right
				key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
				goto retry;
			}

			if (sel)
				stb_textedit_prep_selection_at_cursor(state);
			else if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_first(state);

			// compute current position of cursor point
			stb_textedit_clamp(str, state);
			stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

			for (j = 0; j < row_count; ++j) {
				float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

				// can only go up if there's a previous row
				if (find.prev_first == find.first_char)
					break;

				// now find character position up a row
				state->cursor = find.prev_first;
				STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
				x = row.x0;
				for (i = 0; i < row.num_chars; ++i) {
					float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
#ifdef IMSTB_TEXTEDIT_GETWIDTH_NEWLINE
					if (dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE)
						break;
#endif
					x += dx;
					if (x > goal_x)
						break;
					++state->cursor;
				}
				stb_textedit_clamp(str, state);

				state->has_preferred_x = 1;
				state->preferred_x = goal_x;

				if (sel)
					state->select_end = state->cursor;

				// go to previous line
				// (we need to scan previous line the hard way. maybe we could expose this as a new API function?)
				prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;
				while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)
					--prev_scan;
				find.first_char = find.prev_first;
				find.prev_first = prev_scan;
			}
			break;
		}

		case STB_TEXTEDIT_K_DELETE:
		case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_delete_selection(str, state);
			else {
				int n = STB_TEXTEDIT_STRINGLEN(str);
				if (state->cursor < n)
					stb_textedit_delete(str, state, state->cursor, 1);
			}
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_BACKSPACE:
		case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_delete_selection(str, state);
			else {
				stb_textedit_clamp(str, state);
				if (state->cursor > 0) {
					stb_textedit_delete(str, state, state->cursor - 1, 1);
					--state->cursor;
				}
			}
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
		case STB_TEXTEDIT_K_TEXTSTART2:
#endif
		case STB_TEXTEDIT_K_TEXTSTART:
			state->cursor = state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
		case STB_TEXTEDIT_K_TEXTEND2:
#endif
		case STB_TEXTEDIT_K_TEXTEND:
			state->cursor = STB_TEXTEDIT_STRINGLEN(str);
			state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
		case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor(state);
			state->cursor = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
		case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor(state);
			state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_LINESTART2
		case STB_TEXTEDIT_K_LINESTART2:
#endif
		case STB_TEXTEDIT_K_LINESTART:
			stb_textedit_clamp(str, state);
			stb_textedit_move_to_first(state);
			if (state->single_line)
				state->cursor = 0;
			else
				while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor - 1) != STB_TEXTEDIT_NEWLINE)
					--state->cursor;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_LINEEND2
		case STB_TEXTEDIT_K_LINEEND2:
#endif
		case STB_TEXTEDIT_K_LINEEND: {
			int n = STB_TEXTEDIT_STRINGLEN(str);
			stb_textedit_clamp(str, state);
			stb_textedit_move_to_first(state);
			if (state->single_line)
				state->cursor = n;
			else
				while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
					++state->cursor;
			state->has_preferred_x = 0;
			break;
		}

#ifdef STB_TEXTEDIT_K_LINESTART2
		case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_clamp(str, state);
			stb_textedit_prep_selection_at_cursor(state);
			if (state->single_line)
				state->cursor = 0;
			else
				while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor - 1) != STB_TEXTEDIT_NEWLINE)
					--state->cursor;
			state->select_end = state->cursor;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_LINEEND2
		case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
			int n = STB_TEXTEDIT_STRINGLEN(str);
			stb_textedit_clamp(str, state);
			stb_textedit_prep_selection_at_cursor(state);
			if (state->single_line)
				state->cursor = n;
			else
				while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
					++state->cursor;
			state->select_end = state->cursor;
			state->has_preferred_x = 0;
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state) {
	state->redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT;
	state->redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state) {
	if (state->undo_point > 0) {
		// if the 0th undo state has characters, clean those up
		if (state->undo_rec[0].char_storage >= 0) {
			int n = state->undo_rec[0].insert_length, i;
			// delete n characters from all other records
			state->undo_char_point -= n;
			IMSTB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t)(state->undo_char_point * sizeof(IMSTB_TEXTEDIT_CHARTYPE)));
			for (i = 0; i < state->undo_point; ++i)
				if (state->undo_rec[i].char_storage >= 0)
					state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
		}
		--state->undo_point;
		IMSTB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec + 1, (size_t)(state->undo_point * sizeof(state->undo_rec[0])));
	}
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state) {
	int k = IMSTB_TEXTEDIT_UNDOSTATECOUNT - 1;

	if (state->redo_point <= k) {
		// if the k'th undo state has characters, clean those up
		if (state->undo_rec[k].char_storage >= 0) {
			int n = state->undo_rec[k].insert_length, i;
			// move the remaining redo character data to the end of the buffer
			state->redo_char_point += n;
			IMSTB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point - n, (size_t)((IMSTB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point) * sizeof(IMSTB_TEXTEDIT_CHARTYPE)));
			// adjust the position of all the other records to account for above memmove
			for (i = state->redo_point; i < k; ++i)
				if (state->undo_rec[i].char_storage >= 0)
					state->undo_rec[i].char_storage += n;
		}
		// now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
		// [DEAR IMGUI]
		size_t move_size = (size_t)((IMSTB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));
		const char *buf_begin = (char *)state->undo_rec;
		(void)buf_begin;
		const char *buf_end = (char *)state->undo_rec + sizeof(state->undo_rec);
		(void)buf_end;
		IM_ASSERT(((char *)(state->undo_rec + state->redo_point)) >= buf_begin);
		IM_ASSERT(((char *)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
		IMSTB_TEXTEDIT_memmove(state->undo_rec + state->redo_point + 1, state->undo_rec + state->redo_point, move_size);

		// now move redo_point to point to the new one
		++state->redo_point;
	}
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars) {
	// any time we create a new undo record, we discard redo
	stb_textedit_flush_redo(state);

	// if we have no free records, we have to make room, by sliding the
	// existing records down
	if (state->undo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
		stb_textedit_discard_undo(state);

	// if the characters to store won't possibly fit in the buffer, we can't undo
	if (numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT) {
		state->undo_point = 0;
		state->undo_char_point = 0;
		return NULL;
	}

	// if we don't have enough free characters in the buffer, we have to make room
	while (state->undo_char_point + numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT)
		stb_textedit_discard_undo(state);

	return &state->undo_rec[state->undo_point++];
}

static IMSTB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len) {
	StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
	if (r == NULL)
		return NULL;

	r->where = pos;
	r->insert_length = (IMSTB_TEXTEDIT_POSITIONTYPE)insert_len;
	r->delete_length = (IMSTB_TEXTEDIT_POSITIONTYPE)delete_len;

	if (insert_len == 0) {
		r->char_storage = -1;
		return NULL;
	} else {
		r->char_storage = state->undo_char_point;
		state->undo_char_point += insert_len;
		return &state->undo_char[r->char_storage];
	}
}

static void stb_text_undo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	StbUndoState *s = &state->undostate;
	StbUndoRecord u, *r;
	if (s->undo_point == 0)
		return;

	// we need to do two things: apply the undo record, and create a redo record
	u = s->undo_rec[s->undo_point - 1];
	r = &s->undo_rec[s->redo_point - 1];
	r->char_storage = -1;

	r->insert_length = u.delete_length;
	r->delete_length = u.insert_length;
	r->where = u.where;

	if (u.delete_length) {
		// if the undo record says to delete characters, then the redo record will
		// need to re-insert the characters that get deleted, so we need to store
		// them.

		// there are three cases:
		//    there's enough room to store the characters
		//    characters stored for *redoing* don't leave room for redo
		//    characters stored for *undoing* don't leave room for redo
		// if the last is true, we have to bail

		if (s->undo_char_point + u.delete_length >= IMSTB_TEXTEDIT_UNDOCHARCOUNT) {
			// the undo records take up too much character space; there's no space to store the redo characters
			r->insert_length = 0;
		} else {
			int i;

			// there's definitely room to store the characters eventually
			while (s->undo_char_point + u.delete_length > s->redo_char_point) {
				// should never happen:
				if (s->redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
					return;
				// there's currently not enough room, so discard a redo record
				stb_textedit_discard_redo(s);
			}
			r = &s->undo_rec[s->redo_point - 1];

			r->char_storage = s->redo_char_point - u.delete_length;
			s->redo_char_point = s->redo_char_point - u.delete_length;

			// now save the characters
			for (i = 0; i < u.delete_length; ++i)
				s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
		}

		// now we can carry out the deletion
		STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
	}

	// check type of recorded action:
	if (u.insert_length) {
		// easy case: was a deletion, so we need to insert n characters
		STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
		s->undo_char_point -= u.insert_length;
	}

	state->cursor = u.where + u.insert_length;

	s->undo_point--;
	s->redo_point--;
}

static void stb_text_redo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	StbUndoState *s = &state->undostate;
	StbUndoRecord *u, r;
	if (s->redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
		return;

	// we need to do two things: apply the redo record, and create an undo record
	u = &s->undo_rec[s->undo_point];
	r = s->undo_rec[s->redo_point];

	// we KNOW there must be room for the undo record, because the redo record
	// was derived from an undo record

	u->delete_length = r.insert_length;
	u->insert_length = r.delete_length;
	u->where = r.where;
	u->char_storage = -1;

	if (r.delete_length) {
		// the redo record requires us to delete characters, so the undo record
		// needs to store the characters

		if (s->undo_char_point + u->insert_length > s->redo_char_point) {
			u->insert_length = 0;
			u->delete_length = 0;
		} else {
			int i;
			u->char_storage = s->undo_char_point;
			s->undo_char_point = s->undo_char_point + u->insert_length;

			// now save the characters
			for (i = 0; i < u->insert_length; ++i)
				s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
		}

		STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
	}

	if (r.insert_length) {
		// easy case: need to insert n characters
		STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
		s->redo_char_point += r.insert_length;
	}

	state->cursor = r.where + r.insert_length;

	s->undo_point++;
	s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length) {
	stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length) {
	int i;
	IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
	if (p) {
		for (i = 0; i < length; ++i)
			p[i] = STB_TEXTEDIT_GETCHAR(str, where + i);
	}
}

static void stb_text_makeundo_replace(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length) {
	int i;
	IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
	if (p) {
		for (i = 0; i < old_length; ++i)
			p[i] = STB_TEXTEDIT_GETCHAR(str, where + i);
	}
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line) {
	state->undostate.undo_point = 0;
	state->undostate.undo_char_point = 0;
	state->undostate.redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT;
	state->undostate.redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT;
	state->select_end = state->select_start = 0;
	state->cursor = 0;
	state->has_preferred_x = 0;
	state->preferred_x = 0;
	state->cursor_at_end_of_line = 0;
	state->initialized = 1;
	state->single_line = (unsigned char)is_single_line;
	state->insert_mode = 0;
	state->row_count_per_page = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line) {
	stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE const *ctext, int len) {
	return stb_textedit_paste_internal(str, state, (IMSTB_TEXTEDIT_CHARTYPE *)ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif //IMSTB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
#line 0

} // namespace ImStb

#line 1 "sfw/render_gui/imgui_internal.h"
// dear imgui, v1.91.1
// (internal structures/api)

// You may use this file to debug, understand or extend Dear ImGui features but we don't provide any guarantee of forward compatibility.

/*

Index of this file:

// [SECTION] Header mess
// [SECTION] Forward declarations
// [SECTION] Context pointer
// [SECTION] STB libraries includes
// [SECTION] Macros
// [SECTION] Generic helpers
// [SECTION] ImDrawList support
// [SECTION] Data types support
// [SECTION] Widgets support: flags, enums, data structures
// [SECTION] Popup support
// [SECTION] Inputs support
// [SECTION] Clipper support
// [SECTION] Navigation support
// [SECTION] Typing-select support
// [SECTION] Columns support
// [SECTION] Box-select support
// [SECTION] Multi-select support
// [SECTION] Docking support
// [SECTION] Viewport support
// [SECTION] Settings support
// [SECTION] Localization support
// [SECTION] Metrics, Debug tools
// [SECTION] Generic context hooks
// [SECTION] ImGuiContext (main imgui context)
// [SECTION] ImGuiWindowTempData, ImGuiWindow
// [SECTION] Tab bar, Tab item support
// [SECTION] Table support
// [SECTION] ImGui internal API
// [SECTION] ImFontAtlas internal API
// [SECTION] Test Engine specific hooks (imgui_test_engine)

*/

#ifndef IMGUI_DISABLE

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

#include <limits.h> // INT_MIN, INT_MAX
#include <math.h> // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <stdio.h> // FILE*, sscanf
#include <stdlib.h> // NULL, malloc, free, qsort, atoi, atof

// Enable SSE intrinsics if available
#if (defined __SSE__ || defined __x86_64__ || defined _M_X64 || (defined(_M_IX86_FP) && (_M_IX86_FP >= 1))) && !defined(IMGUI_DISABLE_SSE)
#define IMGUI_ENABLE_SSE
#include <immintrin.h>
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#pragma warning(disable : 26812) // The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)
#pragma warning(disable : 26495) // [Static Analyzer] Variable 'XXX' is uninitialized. Always initialize a member variable (type.6).
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning(disable : 5054) // operator '|': deprecated between enumerations of different types
#endif
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option" // warning: unknown warning group 'xxx'
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok, for ImFloor()
#pragma clang diagnostic ignored "-Wunused-function" // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes" // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma clang diagnostic ignored "-Wdouble-promotion"
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored "-Wmissing-noreturn" // warning: function 'xxx' could be declared with attribute 'noreturn'
#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage" // warning: 'xxx' is an unsafe pointer used for buffer access
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#pragma GCC diagnostic ignored "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#endif

// In 1.89.4, we moved the implementation of "courtesy maths operators" from imgui_internal.h in imgui.h
// As they are frequently requested, we do not want to encourage to many people using imgui_internal.h
#if defined(IMGUI_DEFINE_MATH_OPERATORS) && !defined(IMGUI_DEFINE_MATH_OPERATORS_IMPLEMENTED)
#error Please '#define IMGUI_DEFINE_MATH_OPERATORS' _BEFORE_ including imgui.h!
#endif

// Legacy defines
#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS // Renamed in 1.74
#error Use IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#endif
#ifdef IMGUI_DISABLE_MATH_FUNCTIONS // Renamed in 1.74
#error Use IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#endif

// Enable stb_truetype by default unless FreeType is enabled.
// You can compile with both by defining both IMGUI_ENABLE_FREETYPE and IMGUI_ENABLE_STB_TRUETYPE together.
#ifndef IMGUI_ENABLE_FREETYPE
#define IMGUI_ENABLE_STB_TRUETYPE
#endif

//-----------------------------------------------------------------------------
// [SECTION] Context pointer
// See implementation of this variable in imgui.cpp for comments and details.
//-----------------------------------------------------------------------------

#ifndef GImGui
extern IMGUI_API ImGuiContext *GImGui; // Current implicit context pointer
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries includes
//-------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Macros
//-----------------------------------------------------------------------------

// Debug Printing Into TTY
// (since IMGUI_VERSION_NUM >= 18729: IMGUI_DEBUG_LOG was reworked into IMGUI_DEBUG_PRINTF (and removed framecount from it). If you were using a #define IMGUI_DEBUG_LOG please rename)
#ifndef IMGUI_DEBUG_PRINTF
#ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#define IMGUI_DEBUG_PRINTF(_FMT, ...) printf(_FMT, __VA_ARGS__)
#else
#define IMGUI_DEBUG_PRINTF(_FMT, ...) ((void)0)
#endif
#endif

// Debug Logging for ShowDebugLogWindow(). This is designed for relatively rare events so please don't spam.
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
#define IMGUI_DEBUG_LOG(...) ImGui::DebugLog(__VA_ARGS__)
#else
#define IMGUI_DEBUG_LOG(...) ((void)0)
#endif
#define IMGUI_DEBUG_LOG_ACTIVEID(...)                           \
	do {                                                        \
		if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) \
			IMGUI_DEBUG_LOG(__VA_ARGS__);                       \
	} while (0)
#define IMGUI_DEBUG_LOG_FOCUS(...)                           \
	do {                                                     \
		if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus) \
			IMGUI_DEBUG_LOG(__VA_ARGS__);                    \
	} while (0)
#define IMGUI_DEBUG_LOG_POPUP(...)                           \
	do {                                                     \
		if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup) \
			IMGUI_DEBUG_LOG(__VA_ARGS__);                    \
	} while (0)
#define IMGUI_DEBUG_LOG_NAV(...)                           \
	do {                                                   \
		if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav) \
			IMGUI_DEBUG_LOG(__VA_ARGS__);                  \
	} while (0)
#define IMGUI_DEBUG_LOG_SELECTION(...)                           \
	do {                                                         \
		if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection) \
			IMGUI_DEBUG_LOG(__VA_ARGS__);                        \
	} while (0)
#define IMGUI_DEBUG_LOG_CLIPPER(...)                           \
	do {                                                       \
		if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper) \
			IMGUI_DEBUG_LOG(__VA_ARGS__);                      \
	} while (0)
#define IMGUI_DEBUG_LOG_IO(...)                           \
	do {                                                  \
		if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) \
			IMGUI_DEBUG_LOG(__VA_ARGS__);                 \
	} while (0)
#define IMGUI_DEBUG_LOG_INPUTROUTING(...)                           \
	do {                                                            \
		if (g.DebugLogFlags & ImGuiDebugLogFlags_EventInputRouting) \
			IMGUI_DEBUG_LOG(__VA_ARGS__);                           \
	} while (0)

// Static Asserts
#define IM_STATIC_ASSERT(_COND) static_assert(_COND, "")

// "Paranoid" Debug Asserts are meant to only be enabled during specific debugging/work, otherwise would slow down the code too much.
// We currently don't have many of those so the effect is currently negligible, but onward intent to add more aggressive ones in the code.
//#define IMGUI_DEBUG_PARANOID
#ifdef IMGUI_DEBUG_PARANOID
#define IM_ASSERT_PARANOID(_EXPR) IM_ASSERT(_EXPR)
#else
#define IM_ASSERT_PARANOID(_EXPR)
#endif

// Error handling
// Down the line in some frameworks/languages we would like to have a way to redirect those to the programmer and recover from more faults.
#ifndef IM_ASSERT_USER_ERROR
#define IM_ASSERT_USER_ERROR(_EXP, _MSG) IM_ASSERT((_EXP) && _MSG) // Recoverable User Error
#endif

// Misc Macros
#define IM_PI 3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE "\r\n" // Play it nice with Windows users (Update: since 2018-05, Notepad finally appears to support Unix-style carriage returns!)
#else
#define IM_NEWLINE "\n"
#endif
#ifndef IM_TABSIZE // Until we move this to runtime and/or add proper tab support, at least allow users to compile-time override
#define IM_TABSIZE (4)
#endif
#define IM_MEMALIGN(_OFF, _ALIGN) (((_OFF) + ((_ALIGN) - 1)) & ~((_ALIGN) - 1)) // Memory align e.g. IM_ALIGN(0,4)=0, IM_ALIGN(1,4)=4, IM_ALIGN(4,4)=4, IM_ALIGN(5,4)=8
#define IM_F32_TO_INT8_UNBOUND(_VAL) ((int)((_VAL) * 255.0f + ((_VAL) >= 0 ? 0.5f : -0.5f))) // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL) ((int)(ImSaturate(_VAL) * 255.0f + 0.5f)) // Saturated, always output 0..255
#define IM_TRUNC(_VAL) ((float)(int)(_VAL)) // ImTrunc() is not inlined in MSVC debug builds
#define IM_ROUND(_VAL) ((float)(int)((_VAL) + 0.5f)) //
#define IM_STRINGIFY_HELPER(_X) #_X
#define IM_STRINGIFY(_X) IM_STRINGIFY_HELPER(_X) // Preprocessor idiom to stringify e.g. an integer.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
#define IM_FLOOR IM_TRUNC
#endif

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif

// Warnings
#if defined(_MSC_VER) && !defined(__clang__)
#define IM_MSVC_WARNING_SUPPRESS(XXXX) __pragma(warning(suppress : XXXX))
#else
#define IM_MSVC_WARNING_SUPPRESS(XXXX)
#endif

// Debug Tools
// Use 'Metrics/Debugger->Tools->Item Picker' to break into the call-stack of a specific item.
// This will call IM_DEBUG_BREAK() which you may redefine yourself. See https://github.com/scottt/debugbreak for more reference.
#ifndef IM_DEBUG_BREAK
#if defined(_MSC_VER)
#define IM_DEBUG_BREAK() __debugbreak()
#elif defined(__clang__)
#define IM_DEBUG_BREAK() __builtin_debugtrap()
#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define IM_DEBUG_BREAK() __asm__ volatile("int3;nop")
#elif defined(__GNUC__) && defined(__thumb__)
#define IM_DEBUG_BREAK() __asm__ volatile(".inst 0xde01")
#elif defined(__GNUC__) && defined(__arm__) && !defined(__thumb__)
#define IM_DEBUG_BREAK() __asm__ volatile(".inst 0xe7f001f0")
#else
#define IM_DEBUG_BREAK() IM_ASSERT(0) // It is expected that you define IM_DEBUG_BREAK() into something that will break nicely in a debugger!
#endif
#endif // #ifndef IM_DEBUG_BREAK

// Format specifiers, printing 64-bit hasn't been decently standardized...
// In a real application you should be using PRId64 and PRIu64 from <inttypes.h> (non-windows) and on Windows define them yourself.
#if defined(_MSC_VER) && !defined(__clang__)
#define IM_PRId64 "I64d"
#define IM_PRIu64 "I64u"
#define IM_PRIX64 "I64X"
#else
#define IM_PRId64 "lld"
#define IM_PRIu64 "llu"
#define IM_PRIX64 "llX"
#endif

//-----------------------------------------------------------------------------
// [SECTION] Generic helpers
// Note that the ImXXX helpers functions are lower-level than ImGui functions.
// ImGui functions or the ImGui context are never called/used from other ImXXX functions.
//-----------------------------------------------------------------------------
// - Helpers: Hashing
// - Helpers: Sorting
// - Helpers: Bit manipulation
// - Helpers: String
// - Helpers: Formatting
// - Helpers: UTF-8 <> wchar conversions
// - Helpers: ImVec2/ImVec4 operators
// - Helpers: Maths
// - Helpers: Geometry
// - Helper: ImVec1
// - Helper: ImVec2ih
// - Helper: ImRect
// - Helper: ImBitArray
// - Helper: ImBitVector
// - Helper: ImSpan<>, ImSpanAllocator<>
// - Helper: ImPool<>
// - Helper: ImChunkStream<>
// - Helper: ImGuiTextIndex
// - Helper: ImGuiStorage
//-----------------------------------------------------------------------------

// Helpers: Hashing
IMGUI_API ImGuiID ImHashData(const void *data, size_t data_size, ImGuiID seed = 0);
IMGUI_API ImGuiID ImHashStr(const char *data, size_t data_size = 0, ImGuiID seed = 0);

// Helpers: Sorting
#ifndef ImQsort
static inline void ImQsort(void *base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const *, void const *)) {
	if (count > 1)
		qsort(base, count, size_of_element, compare_func);
}
#endif

// Helpers: Color Blending
IMGUI_API ImU32 ImAlphaBlendColors(ImU32 col_a, ImU32 col_b);

// Helpers: Bit manipulation
static inline bool ImIsPowerOfTwo(int v) {
	return v != 0 && (v & (v - 1)) == 0;
}
static inline bool ImIsPowerOfTwo(ImU64 v) {
	return v != 0 && (v & (v - 1)) == 0;
}
static inline int ImUpperPowerOfTwo(int v) {
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

// Helpers: String
IMGUI_API int ImStricmp(const char *str1, const char *str2); // Case insensitive compare.
IMGUI_API int ImStrnicmp(const char *str1, const char *str2, size_t count); // Case insensitive compare to a certain count.
IMGUI_API void ImStrncpy(char *dst, const char *src, size_t count); // Copy to a certain count and always zero terminate (strncpy doesn't).
IMGUI_API char *ImStrdup(const char *str); // Duplicate a string.
IMGUI_API char *ImStrdupcpy(char *dst, size_t *p_dst_size, const char *str); // Copy in provided buffer, recreate buffer if needed.
IMGUI_API const char *ImStrchrRange(const char *str_begin, const char *str_end, char c); // Find first occurrence of 'c' in string range.
IMGUI_API const char *ImStreolRange(const char *str, const char *str_end); // End end-of-line
IMGUI_API const char *ImStristr(const char *haystack, const char *haystack_end, const char *needle, const char *needle_end); // Find a substring in a string range.
IMGUI_API void ImStrTrimBlanks(char *str); // Remove leading and trailing blanks from a buffer.
IMGUI_API const char *ImStrSkipBlank(const char *str); // Find first non-blank character.
IMGUI_API int ImStrlenW(const ImWchar *str); // Computer string length (ImWchar string)
IMGUI_API const ImWchar *ImStrbolW(const ImWchar *buf_mid_line, const ImWchar *buf_begin); // Find beginning-of-line (ImWchar string)
IM_MSVC_RUNTIME_CHECKS_OFF
static inline char ImToUpper(char c) {
	return (c >= 'a' && c <= 'z') ? c &= ~32 : c;
}
static inline bool ImCharIsBlankA(char c) {
	return c == ' ' || c == '\t';
}
static inline bool ImCharIsBlankW(unsigned int c) {
	return c == ' ' || c == '\t' || c == 0x3000;
}
static inline bool ImCharIsXdigitA(char c) {
	return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');
}
IM_MSVC_RUNTIME_CHECKS_RESTORE

// Helpers: Formatting
IMGUI_API int ImFormatString(char *buf, size_t buf_size, const char *fmt, ...) IM_FMTARGS(3);
IMGUI_API int ImFormatStringV(char *buf, size_t buf_size, const char *fmt, va_list args) IM_FMTLIST(3);
IMGUI_API void ImFormatStringToTempBuffer(const char **out_buf, const char **out_buf_end, const char *fmt, ...) IM_FMTARGS(3);
IMGUI_API void ImFormatStringToTempBufferV(const char **out_buf, const char **out_buf_end, const char *fmt, va_list args) IM_FMTLIST(3);
IMGUI_API const char *ImParseFormatFindStart(const char *format);
IMGUI_API const char *ImParseFormatFindEnd(const char *format);
IMGUI_API const char *ImParseFormatTrimDecorations(const char *format, char *buf, size_t buf_size);
IMGUI_API void ImParseFormatSanitizeForPrinting(const char *fmt_in, char *fmt_out, size_t fmt_out_size);
IMGUI_API const char *ImParseFormatSanitizeForScanning(const char *fmt_in, char *fmt_out, size_t fmt_out_size);
IMGUI_API int ImParseFormatPrecision(const char *format, int default_value);

// Helpers: UTF-8 <> wchar conversions
IMGUI_API const char *ImTextCharToUtf8(char out_buf[5], unsigned int c); // return out_buf
IMGUI_API int ImTextStrToUtf8(char *out_buf, int out_buf_size, const ImWchar *in_text, const ImWchar *in_text_end); // return output UTF-8 bytes count
IMGUI_API int ImTextCharFromUtf8(unsigned int *out_char, const char *in_text, const char *in_text_end); // read one character. return input UTF-8 bytes count
IMGUI_API int ImTextStrFromUtf8(ImWchar *out_buf, int out_buf_size, const char *in_text, const char *in_text_end, const char **in_remaining = NULL); // return input UTF-8 bytes count
IMGUI_API int ImTextCountCharsFromUtf8(const char *in_text, const char *in_text_end); // return number of UTF-8 code-points (NOT bytes count)
IMGUI_API int ImTextCountUtf8BytesFromChar(const char *in_text, const char *in_text_end); // return number of bytes to express one char in UTF-8
IMGUI_API int ImTextCountUtf8BytesFromStr(const ImWchar *in_text, const ImWchar *in_text_end); // return number of bytes to express string in UTF-8
IMGUI_API const char *ImTextFindPreviousUtf8Codepoint(const char *in_text_start, const char *in_text_curr); // return previous UTF-8 code-point.
IMGUI_API int ImTextCountLines(const char *in_text, const char *in_text_end); // return number of lines taken by text. trailing carriage return doesn't count as an extra line.

// Helpers: File System
#ifdef IMGUI_DISABLE_FILE_FUNCTIONS
#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef void *ImFileHandle;
static inline ImFileHandle ImFileOpen(const char *, const char *) {
	return NULL;
}
static inline bool ImFileClose(ImFileHandle) {
	return false;
}
static inline ImU64 ImFileGetSize(ImFileHandle) {
	return (ImU64)-1;
}
static inline ImU64 ImFileRead(void *, ImU64, ImU64, ImFileHandle) {
	return 0;
}
static inline ImU64 ImFileWrite(const void *, ImU64, ImU64, ImFileHandle) {
	return 0;
}
#endif
#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef FILE *ImFileHandle;
IMGUI_API ImFileHandle ImFileOpen(const char *filename, const char *mode);
IMGUI_API bool ImFileClose(ImFileHandle file);
IMGUI_API ImU64 ImFileGetSize(ImFileHandle file);
IMGUI_API ImU64 ImFileRead(void *data, ImU64 size, ImU64 count, ImFileHandle file);
IMGUI_API ImU64 ImFileWrite(const void *data, ImU64 size, ImU64 count, ImFileHandle file);
#else
#define IMGUI_DISABLE_TTY_FUNCTIONS // Can't use stdout, fflush if we are not using default file functions
#endif
IMGUI_API void *ImFileLoadToMemory(const char *filename, const char *mode, size_t *out_file_size = NULL, int padding_bytes = 0);

// Helpers: Maths
IM_MSVC_RUNTIME_CHECKS_OFF
// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
#ifndef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#define ImFabs(X) fabsf(X)
#define ImSqrt(X) sqrtf(X)
#define ImFmod(X, Y) fmodf((X), (Y))
#define ImCos(X) cosf(X)
#define ImSin(X) sinf(X)
#define ImAcos(X) acosf(X)
#define ImAtan2(Y, X) atan2f((Y), (X))
#define ImAtof(STR) atof(STR)
#define ImCeil(X) ceilf(X)
static inline float ImPow(float x, float y) {
	return powf(x, y);
} // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision
static inline double ImPow(double x, double y) {
	return pow(x, y);
}
static inline float ImLog(float x) {
	return logf(x);
} // DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision
static inline double ImLog(double x) {
	return log(x);
}
static inline int ImAbs(int x) {
	return x < 0 ? -x : x;
}
static inline float ImAbs(float x) {
	return fabsf(x);
}
static inline double ImAbs(double x) {
	return fabs(x);
}
static inline float ImSign(float x) {
	return (x < 0.0f) ? -1.0f : (x > 0.0f) ? 1.0f
										   : 0.0f;
} // Sign operator - returns -1, 0 or 1 based on sign of argument
static inline double ImSign(double x) {
	return (x < 0.0) ? -1.0 : (x > 0.0) ? 1.0
										: 0.0;
}
#ifdef IMGUI_ENABLE_SSE
static inline float ImRsqrt(float x) {
	return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x)));
}
#else
static inline float ImRsqrt(float x) {
	return 1.0f / sqrtf(x);
}
#endif
static inline double ImRsqrt(double x) {
	return 1.0 / sqrt(x);
}
#endif
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for those types)
template <typename T>
static inline T ImMin(T lhs, T rhs) {
	return lhs < rhs ? lhs : rhs;
}
template <typename T>
static inline T ImMax(T lhs, T rhs) {
	return lhs >= rhs ? lhs : rhs;
}
template <typename T>
static inline T ImClamp(T v, T mn, T mx) {
	return (v < mn) ? mn : (v > mx) ? mx
									: v;
}
template <typename T>
static inline T ImLerp(T a, T b, float t) {
	return (T)(a + (b - a) * t);
}
template <typename T>
static inline void ImSwap(T &a, T &b) {
	T tmp = a;
	a = b;
	b = tmp;
}
template <typename T>
static inline T ImAddClampOverflow(T a, T b, T mn, T mx) {
	if (b < 0 && (a < mn - b))
		return mn;
	if (b > 0 && (a > mx - b))
		return mx;
	return a + b;
}
template <typename T>
static inline T ImSubClampOverflow(T a, T b, T mn, T mx) {
	if (b > 0 && (a < mn + b))
		return mn;
	if (b < 0 && (a > mx + b))
		return mx;
	return a - b;
}
// - Misc maths helpers
static inline ImVec2 ImMin(const ImVec2 &lhs, const ImVec2 &rhs) {
	return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y);
}
static inline ImVec2 ImMax(const ImVec2 &lhs, const ImVec2 &rhs) {
	return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y);
}
static inline ImVec2 ImClamp(const ImVec2 &v, const ImVec2 &mn, const ImVec2 &mx) {
	return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x
													 : v.x,
			(v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y
											   : v.y);
}
static inline ImVec2 ImLerp(const ImVec2 &a, const ImVec2 &b, float t) {
	return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
}
static inline ImVec2 ImLerp(const ImVec2 &a, const ImVec2 &b, const ImVec2 &t) {
	return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y);
}
static inline ImVec4 ImLerp(const ImVec4 &a, const ImVec4 &b, float t) {
	return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t);
}
static inline float ImSaturate(float f) {
	return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f
										  : f;
}
static inline float ImLengthSqr(const ImVec2 &lhs) {
	return (lhs.x * lhs.x) + (lhs.y * lhs.y);
}
static inline float ImLengthSqr(const ImVec4 &lhs) {
	return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w);
}
static inline float ImInvLength(const ImVec2 &lhs, float fail_value) {
	float d = (lhs.x * lhs.x) + (lhs.y * lhs.y);
	if (d > 0.0f)
		return ImRsqrt(d);
	return fail_value;
}
static inline float ImTrunc(float f) {
	return (float)(int)(f);
}
static inline ImVec2 ImTrunc(const ImVec2 &v) {
	return ImVec2((float)(int)(v.x), (float)(int)(v.y));
}
static inline float ImFloor(float f) {
	return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1);
} // Decent replacement for floorf()
static inline ImVec2 ImFloor(const ImVec2 &v) {
	return ImVec2(ImFloor(v.x), ImFloor(v.y));
}
static inline int ImModPositive(int a, int b) {
	return (a + b) % b;
}
static inline float ImDot(const ImVec2 &a, const ImVec2 &b) {
	return a.x * b.x + a.y * b.y;
}
static inline ImVec2 ImRotate(const ImVec2 &v, float cos_a, float sin_a) {
	return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a);
}
static inline float ImLinearSweep(float current, float target, float speed) {
	if (current < target)
		return ImMin(current + speed, target);
	if (current > target)
		return ImMax(current - speed, target);
	return current;
}
static inline float ImLinearRemapClamp(float s0, float s1, float d0, float d1, float x) {
	return ImSaturate((x - s0) / (s1 - s0)) * (d1 - d0) + d0;
}
static inline ImVec2 ImMul(const ImVec2 &lhs, const ImVec2 &rhs) {
	return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y);
}
static inline bool ImIsFloatAboveGuaranteedIntegerPrecision(float f) {
	return f <= -16777216 || f >= 16777216;
}
static inline float ImExponentialMovingAverage(float avg, float sample, int n) {
	avg -= avg / n;
	avg += sample / n;
	return avg;
}
IM_MSVC_RUNTIME_CHECKS_RESTORE

// Helpers: Geometry
IMGUI_API ImVec2 ImBezierCubicCalc(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, float t);
IMGUI_API ImVec2 ImBezierCubicClosestPoint(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, const ImVec2 &p, int num_segments); // For curves with explicit number of segments
IMGUI_API ImVec2 ImBezierCubicClosestPointCasteljau(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, const ImVec2 &p, float tess_tol); // For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol
IMGUI_API ImVec2 ImBezierQuadraticCalc(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, float t);
IMGUI_API ImVec2 ImLineClosestPoint(const ImVec2 &a, const ImVec2 &b, const ImVec2 &p);
IMGUI_API bool ImTriangleContainsPoint(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c, const ImVec2 &p);
IMGUI_API ImVec2 ImTriangleClosestPoint(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c, const ImVec2 &p);
IMGUI_API void ImTriangleBarycentricCoords(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c, const ImVec2 &p, float &out_u, float &out_v, float &out_w);
inline float ImTriangleArea(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c) {
	return ImFabs((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) * 0.5f;
}
inline bool ImTriangleIsClockwise(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c) {
	return ((b.x - a.x) * (c.y - b.y)) - ((c.x - b.x) * (b.y - a.y)) > 0.0f;
}

// Helper: ImVec1 (1D vector)
// (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)
IM_MSVC_RUNTIME_CHECKS_OFF
struct ImVec1 {
	float x;
	constexpr ImVec1() : x(0.0f) {}
	constexpr ImVec1(float _x) : x(_x) {}
};

// Helper: ImVec2ih (2D vector, half-size integer, for long-term packed storage)
struct ImVec2ih {
	short x, y;
	constexpr ImVec2ih() : x(0), y(0) {}
	constexpr ImVec2ih(short _x, short _y) : x(_x), y(_y) {}
	constexpr explicit ImVec2ih(const ImVec2 &rhs) : x((short)rhs.x), y((short)rhs.y) {}
};

// Helper: ImRect (2D axis aligned bounding-box)
// NB: we can't rely on ImVec2 math operators being available here!
struct IMGUI_API ImRect {
	ImVec2 Min; // Upper-left
	ImVec2 Max; // Lower-right

	constexpr ImRect() : Min(0.0f, 0.0f), Max(0.0f, 0.0f) {}
	constexpr ImRect(const ImVec2 &min, const ImVec2 &max) : Min(min), Max(max) {}
	constexpr ImRect(const ImVec4 &v) : Min(v.x, v.y), Max(v.z, v.w) {}
	constexpr ImRect(float x1, float y1, float x2, float y2) : Min(x1, y1), Max(x2, y2) {}

	ImVec2 GetCenter() const { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
	ImVec2 GetSize() const { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
	float GetWidth() const { return Max.x - Min.x; }
	float GetHeight() const { return Max.y - Min.y; }
	float GetArea() const { return (Max.x - Min.x) * (Max.y - Min.y); }
	ImVec2 GetTL() const { return Min; } // Top-left
	ImVec2 GetTR() const { return ImVec2(Max.x, Min.y); } // Top-right
	ImVec2 GetBL() const { return ImVec2(Min.x, Max.y); } // Bottom-left
	ImVec2 GetBR() const { return Max; } // Bottom-right
	bool Contains(const ImVec2 &p) const { return p.x >= Min.x && p.y >= Min.y && p.x < Max.x && p.y < Max.y; }
	bool Contains(const ImRect &r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
	bool ContainsWithPad(const ImVec2 &p, const ImVec2 &pad) const { return p.x >= Min.x - pad.x && p.y >= Min.y - pad.y && p.x < Max.x + pad.x && p.y < Max.y + pad.y; }
	bool Overlaps(const ImRect &r) const { return r.Min.y < Max.y && r.Max.y > Min.y && r.Min.x < Max.x && r.Max.x > Min.x; }
	void Add(const ImVec2 &p) {
		if (Min.x > p.x)
			Min.x = p.x;
		if (Min.y > p.y)
			Min.y = p.y;
		if (Max.x < p.x)
			Max.x = p.x;
		if (Max.y < p.y)
			Max.y = p.y;
	}
	void Add(const ImRect &r) {
		if (Min.x > r.Min.x)
			Min.x = r.Min.x;
		if (Min.y > r.Min.y)
			Min.y = r.Min.y;
		if (Max.x < r.Max.x)
			Max.x = r.Max.x;
		if (Max.y < r.Max.y)
			Max.y = r.Max.y;
	}
	void Expand(const float amount) {
		Min.x -= amount;
		Min.y -= amount;
		Max.x += amount;
		Max.y += amount;
	}
	void Expand(const ImVec2 &amount) {
		Min.x -= amount.x;
		Min.y -= amount.y;
		Max.x += amount.x;
		Max.y += amount.y;
	}
	void Translate(const ImVec2 &d) {
		Min.x += d.x;
		Min.y += d.y;
		Max.x += d.x;
		Max.y += d.y;
	}
	void TranslateX(float dx) {
		Min.x += dx;
		Max.x += dx;
	}
	void TranslateY(float dy) {
		Min.y += dy;
		Max.y += dy;
	}
	void ClipWith(const ImRect &r) {
		Min = ImMax(Min, r.Min);
		Max = ImMin(Max, r.Max);
	} // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
	void ClipWithFull(const ImRect &r) {
		Min = ImClamp(Min, r.Min, r.Max);
		Max = ImClamp(Max, r.Min, r.Max);
	} // Full version, ensure both points are fully clipped.
	void Floor() {
		Min.x = IM_TRUNC(Min.x);
		Min.y = IM_TRUNC(Min.y);
		Max.x = IM_TRUNC(Max.x);
		Max.y = IM_TRUNC(Max.y);
	}
	bool IsInverted() const { return Min.x > Max.x || Min.y > Max.y; }
	ImVec4 ToVec4() const { return ImVec4(Min.x, Min.y, Max.x, Max.y); }
};

// Helper: ImBitArray
#define IM_BITARRAY_TESTBIT(_ARRAY, _N) ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
#define IM_BITARRAY_CLEARBIT(_ARRAY, _N) ((_ARRAY[(_N) >> 5] &= ~((ImU32)1 << ((_N) & 31)))) // Macro version of ImBitArrayClearBit(): ensure args have side-effect or are costly!
inline size_t ImBitArrayGetStorageSizeInBytes(int bitcount) {
	return (size_t)((bitcount + 31) >> 5) << 2;
}
inline void ImBitArrayClearAllBits(ImU32 *arr, int bitcount) {
	memset(arr, 0, ImBitArrayGetStorageSizeInBytes(bitcount));
}
inline bool ImBitArrayTestBit(const ImU32 *arr, int n) {
	ImU32 mask = (ImU32)1 << (n & 31);
	return (arr[n >> 5] & mask) != 0;
}
inline void ImBitArrayClearBit(ImU32 *arr, int n) {
	ImU32 mask = (ImU32)1 << (n & 31);
	arr[n >> 5] &= ~mask;
}
inline void ImBitArraySetBit(ImU32 *arr, int n) {
	ImU32 mask = (ImU32)1 << (n & 31);
	arr[n >> 5] |= mask;
}
inline void ImBitArraySetBitRange(ImU32 *arr, int n, int n2) // Works on range [n..n2)
{
	n2--;
	while (n <= n2) {
		int a_mod = (n & 31);
		int b_mod = (n2 > (n | 31) ? 31 : (n2 & 31)) + 1;
		ImU32 mask = (ImU32)(((ImU64)1 << b_mod) - 1) & ~(ImU32)(((ImU64)1 << a_mod) - 1);
		arr[n >> 5] |= mask;
		n = (n + 32) & ~31;
	}
}

typedef ImU32 *ImBitArrayPtr; // Name for use in structs

// Helper: ImBitArray class (wrapper over ImBitArray functions)
// Store 1-bit per value.
template <int BITCOUNT, int OFFSET = 0>
struct ImBitArray {
	ImU32 Storage[(BITCOUNT + 31) >> 5];
	ImBitArray() { ClearAllBits(); }
	void ClearAllBits() { memset(Storage, 0, sizeof(Storage)); }
	void SetAllBits() { memset(Storage, 255, sizeof(Storage)); }
	bool TestBit(int n) const {
		n += OFFSET;
		IM_ASSERT(n >= 0 && n < BITCOUNT);
		return IM_BITARRAY_TESTBIT(Storage, n);
	}
	void SetBit(int n) {
		n += OFFSET;
		IM_ASSERT(n >= 0 && n < BITCOUNT);
		ImBitArraySetBit(Storage, n);
	}
	void ClearBit(int n) {
		n += OFFSET;
		IM_ASSERT(n >= 0 && n < BITCOUNT);
		ImBitArrayClearBit(Storage, n);
	}
	void SetBitRange(int n, int n2) {
		n += OFFSET;
		n2 += OFFSET;
		IM_ASSERT(n >= 0 && n < BITCOUNT && n2 > n && n2 <= BITCOUNT);
		ImBitArraySetBitRange(Storage, n, n2);
	} // Works on range [n..n2)
	bool operator[](int n) const {
		n += OFFSET;
		IM_ASSERT(n >= 0 && n < BITCOUNT);
		return IM_BITARRAY_TESTBIT(Storage, n);
	}
};

// Helper: ImBitVector
// Store 1-bit per value.
struct IMGUI_API ImBitVector {
	ImVector<ImU32> Storage;
	void Create(int sz) {
		Storage.resize((sz + 31) >> 5);
		memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0]));
	}
	void Clear() { Storage.clear(); }
	bool TestBit(int n) const {
		IM_ASSERT(n < (Storage.Size << 5));
		return IM_BITARRAY_TESTBIT(Storage.Data, n);
	}
	void SetBit(int n) {
		IM_ASSERT(n < (Storage.Size << 5));
		ImBitArraySetBit(Storage.Data, n);
	}
	void ClearBit(int n) {
		IM_ASSERT(n < (Storage.Size << 5));
		ImBitArrayClearBit(Storage.Data, n);
	}
};
IM_MSVC_RUNTIME_CHECKS_RESTORE

// Helper: ImSpan<>
// Pointing to a span of data we don't own.
template <typename T>
struct ImSpan {
	T *Data;
	T *DataEnd;

	// Constructors, destructor
	inline ImSpan() { Data = DataEnd = NULL; }
	inline ImSpan(T *data, int size) {
		Data = data;
		DataEnd = data + size;
	}
	inline ImSpan(T *data, T *data_end) {
		Data = data;
		DataEnd = data_end;
	}

	inline void set(T *data, int size) {
		Data = data;
		DataEnd = data + size;
	}
	inline void set(T *data, T *data_end) {
		Data = data;
		DataEnd = data_end;
	}
	inline int size() const { return (int)(ptrdiff_t)(DataEnd - Data); }
	inline int size_in_bytes() const { return (int)(ptrdiff_t)(DataEnd - Data) * (int)sizeof(T); }
	inline T &operator[](int i) {
		T *p = Data + i;
		IM_ASSERT(p >= Data && p < DataEnd);
		return *p;
	}
	inline const T &operator[](int i) const {
		const T *p = Data + i;
		IM_ASSERT(p >= Data && p < DataEnd);
		return *p;
	}

	inline T *begin() { return Data; }
	inline const T *begin() const { return Data; }
	inline T *end() { return DataEnd; }
	inline const T *end() const { return DataEnd; }

	// Utilities
	inline int index_from_ptr(const T *it) const {
		IM_ASSERT(it >= Data && it < DataEnd);
		const ptrdiff_t off = it - Data;
		return (int)off;
	}
};

// Helper: ImSpanAllocator<>
// Facilitate storing multiple chunks into a single large block (the "arena")
// - Usage: call Reserve() N times, allocate GetArenaSizeInBytes() worth, pass it to SetArenaBasePtr(), call GetSpan() N times to retrieve the aligned ranges.
template <int CHUNKS>
struct ImSpanAllocator {
	char *BasePtr;
	int CurrOff;
	int CurrIdx;
	int Offsets[CHUNKS];
	int Sizes[CHUNKS];

	ImSpanAllocator() { memset(this, 0, sizeof(*this)); }
	inline void Reserve(int n, size_t sz, int a = 4) {
		IM_ASSERT(n == CurrIdx && n < CHUNKS);
		CurrOff = IM_MEMALIGN(CurrOff, a);
		Offsets[n] = CurrOff;
		Sizes[n] = (int)sz;
		CurrIdx++;
		CurrOff += (int)sz;
	}
	inline int GetArenaSizeInBytes() { return CurrOff; }
	inline void SetArenaBasePtr(void *base_ptr) { BasePtr = (char *)base_ptr; }
	inline void *GetSpanPtrBegin(int n) {
		IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS);
		return (void *)(BasePtr + Offsets[n]);
	}
	inline void *GetSpanPtrEnd(int n) {
		IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS);
		return (void *)(BasePtr + Offsets[n] + Sizes[n]);
	}
	template <typename T>
	inline void GetSpan(int n, ImSpan<T> *span) { span->set((T *)GetSpanPtrBegin(n), (T *)GetSpanPtrEnd(n)); }
};

// Helper: ImPool<>
// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
typedef int ImPoolIdx;
template <typename T>
struct ImPool {
	ImVector<T> Buf; // Contiguous data
	ImGuiStorage Map; // ID->Index
	ImPoolIdx FreeIdx; // Next free idx to use
	ImPoolIdx AliveCount; // Number of active/alive items (for display purpose)

	ImPool() { FreeIdx = AliveCount = 0; }
	~ImPool() { Clear(); }
	T *GetByKey(ImGuiID key) {
		int idx = Map.GetInt(key, -1);
		return (idx != -1) ? &Buf[idx] : NULL;
	}
	T *GetByIndex(ImPoolIdx n) { return &Buf[n]; }
	ImPoolIdx GetIndex(const T *p) const {
		IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size);
		return (ImPoolIdx)(p - Buf.Data);
	}
	T *GetOrAddByKey(ImGuiID key) {
		int *p_idx = Map.GetIntRef(key, -1);
		if (*p_idx != -1)
			return &Buf[*p_idx];
		*p_idx = FreeIdx;
		return Add();
	}
	bool Contains(const T *p) const { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }
	void Clear() {
		for (int n = 0; n < Map.Data.Size; n++) {
			int idx = Map.Data[n].val_i;
			if (idx != -1)
				Buf[idx].~T();
		}
		Map.Clear();
		Buf.clear();
		FreeIdx = AliveCount = 0;
	}
	T *Add() {
		int idx = FreeIdx;
		if (idx == Buf.Size) {
			Buf.resize(Buf.Size + 1);
			FreeIdx++;
		} else {
			FreeIdx = *(int *)&Buf[idx];
		}
		IM_PLACEMENT_NEW(&Buf[idx])
		T();
		AliveCount++;
		return &Buf[idx];
	}
	void Remove(ImGuiID key, const T *p) { Remove(key, GetIndex(p)); }
	void Remove(ImGuiID key, ImPoolIdx idx) {
		Buf[idx].~T();
		*(int *)&Buf[idx] = FreeIdx;
		FreeIdx = idx;
		Map.SetInt(key, -1);
		AliveCount--;
	}
	void Reserve(int capacity) {
		Buf.reserve(capacity);
		Map.Data.reserve(capacity);
	}

	// To iterate a ImPool: for (int n = 0; n < pool.GetMapSize(); n++) if (T* t = pool.TryGetMapData(n)) { ... }
	// Can be avoided if you know .Remove() has never been called on the pool, or AliveCount == GetMapSize()
	int GetAliveCount() const { return AliveCount; } // Number of active/alive items in the pool (for display purpose)
	int GetBufSize() const { return Buf.Size; }
	int GetMapSize() const { return Map.Data.Size; } // It is the map we need iterate to find valid items, since we don't have "alive" storage anywhere
	T *TryGetMapData(ImPoolIdx n) {
		int idx = Map.Data[n].val_i;
		if (idx == -1)
			return NULL;
		return GetByIndex(idx);
	}
};

// Helper: ImChunkStream<>
// Build and iterate a contiguous stream of variable-sized structures.
// This is used by Settings to store persistent data while reducing allocation count.
// We store the chunk size first, and align the final size on 4 bytes boundaries.
// The tedious/zealous amount of casting is to avoid -Wcast-align warnings.
template <typename T>
struct ImChunkStream {
	ImVector<char> Buf;

	void clear() { Buf.clear(); }
	bool empty() const { return Buf.Size == 0; }
	int size() const { return Buf.Size; }
	T *alloc_chunk(size_t sz) {
		size_t HDR_SZ = 4;
		sz = IM_MEMALIGN(HDR_SZ + sz, 4u);
		int off = Buf.Size;
		Buf.resize(off + (int)sz);
		((int *)(void *)(Buf.Data + off))[0] = (int)sz;
		return (T *)(void *)(Buf.Data + off + (int)HDR_SZ);
	}
	T *begin() {
		size_t HDR_SZ = 4;
		if (!Buf.Data)
			return NULL;
		return (T *)(void *)(Buf.Data + HDR_SZ);
	}
	T *next_chunk(T *p) {
		size_t HDR_SZ = 4;
		IM_ASSERT(p >= begin() && p < end());
		p = (T *)(void *)((char *)(void *)p + chunk_size(p));
		if (p == (T *)(void *)((char *)end() + HDR_SZ))
			return (T *)0;
		IM_ASSERT(p < end());
		return p;
	}
	int chunk_size(const T *p) { return ((const int *)p)[-1]; }
	T *end() { return (T *)(void *)(Buf.Data + Buf.Size); }
	int offset_from_ptr(const T *p) {
		IM_ASSERT(p >= begin() && p < end());
		const ptrdiff_t off = (const char *)p - Buf.Data;
		return (int)off;
	}
	T *ptr_from_offset(int off) {
		IM_ASSERT(off >= 4 && off < Buf.Size);
		return (T *)(void *)(Buf.Data + off);
	}
	void swap(ImChunkStream<T> &rhs) { rhs.Buf.swap(Buf); }
};

// Helper: ImGuiTextIndex
// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.
struct ImGuiTextIndex {
	ImVector<int> LineOffsets;
	int EndOffset = 0; // Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)

	void clear() {
		LineOffsets.clear();
		EndOffset = 0;
	}
	int size() { return LineOffsets.Size; }
	const char *get_line_begin(const char *base, int n) { return base + LineOffsets[n]; }
	const char *get_line_end(const char *base, int n) { return base + (n + 1 < LineOffsets.Size ? (LineOffsets[n + 1] - 1) : EndOffset); }
	void append(const char *base, int old_size, int new_size);
};

// Helper: ImGuiStorage
IMGUI_API ImGuiStoragePair *ImLowerBound(ImGuiStoragePair *in_begin, ImGuiStoragePair *in_end, ImGuiID key);
//-----------------------------------------------------------------------------
// [SECTION] ImDrawList support
//-----------------------------------------------------------------------------

// ImDrawList: Helper function to calculate a circle's segment count given its radius and a "maximum error" value.
// Estimation of number of circle segment based on error is derived using method described in https://stackoverflow.com/a/2244088/15194693
// Number of segments (N) is calculated using equation:
//   N = ceil ( pi / acos(1 - error / r) )     where r > 0, error <= r
// Our equation is significantly simpler that one in the post thanks for choosing segment that is
// perpendicular to X axis. Follow steps in the article from this starting condition and you will
// will get this result.
//
// Rendering circles with an odd number of segments, while mathematically correct will produce
// asymmetrical results on the raster grid. Therefore we're rounding N to next even number (7->8, 8->8, 9->10 etc.)
#define IM_ROUNDUP_TO_EVEN(_V) ((((_V) + 1) / 2) * 2)
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN 4
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX 512
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD, _MAXERROR) ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)

// Raw equation from IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC rewritten for 'r' and 'error'.
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N, _MAXERROR) ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_ERROR(_N, _RAD) ((1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))) / (_RAD))

// ImDrawList: Lookup table size for adaptive arc drawing, cover full circle.
#ifndef IM_DRAWLIST_ARCFAST_TABLE_SIZE
#define IM_DRAWLIST_ARCFAST_TABLE_SIZE 48 // Number of samples in lookup table.
#endif
#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.

// Data shared between all ImDrawList instances
// You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
struct IMGUI_API ImDrawListSharedData {
	ImVec2 TexUvWhitePixel; // UV of white pixel in the atlas
	ImFont *Font; // Current/default font (optional, for simplified AddText overload)
	float FontSize; // Current/default font size (optional, for simplified AddText overload)
	float FontScale; // Current/default font scale (== FontSize / Font->FontSize)
	float CurveTessellationTol; // Tessellation tolerance when using PathBezierCurveTo()
	float CircleSegmentMaxError; // Number of circle segments to use per pixel of radius for AddCircle() etc
	ImVec4 ClipRectFullscreen; // Value for PushClipRectFullscreen()
	ImDrawListFlags InitialFlags; // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)

	// [Internal] Temp write buffer
	ImVector<ImVec2> TempBuffer;

	// [Internal] Lookup tables
	ImVec2 ArcFastVtx[IM_DRAWLIST_ARCFAST_TABLE_SIZE]; // Sample points on the quarter of the circle.
	float ArcFastRadiusCutoff; // Cutoff radius after which arc drawing will fallback to slower PathArcTo()
	ImU8 CircleSegmentCounts[64]; // Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)
	const ImVec4 *TexUvLines; // UV of anti-aliased lines in the atlas

	ImDrawListSharedData();
	void SetCircleTessellationMaxError(float max_error);
};

struct ImDrawDataBuilder {
	ImVector<ImDrawList *> *Layers[2]; // Pointers to global layers for: regular, tooltip. LayersP[0] is owned by DrawData.
	ImVector<ImDrawList *> LayerData1;

	ImDrawDataBuilder() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Data types support
//-----------------------------------------------------------------------------

struct ImGuiDataVarInfo {
	ImGuiDataType Type;
	ImU32 Count; // 1+
	ImU32 Offset; // Offset in parent structure
	void *GetVarPtr(void *parent) const { return (void *)((unsigned char *)parent + Offset); }
};

struct ImGuiDataTypeStorage {
	ImU8 Data[8]; // Opaque storage to fit any data up to ImGuiDataType_COUNT
};

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
struct ImGuiDataTypeInfo {
	size_t Size; // Size in bytes
	const char *Name; // Short descriptive name for the type, for debugging
	const char *PrintFmt; // Default printf format for the type
	const char *ScanFmt; // Default scanf format for the type
};

// Extend ImGuiDataType_
enum ImGuiDataTypePrivate_ {
	ImGuiDataType_String = ImGuiDataType_COUNT + 1,
	ImGuiDataType_Pointer,
	ImGuiDataType_ID,
};

//-----------------------------------------------------------------------------
// [SECTION] Widgets support: flags, enums, data structures
//-----------------------------------------------------------------------------

// Extend ImGuiItemFlags
// - input: PushItemFlag() manipulates g.CurrentItemFlags, ItemAdd() calls may add extra flags.
// - output: stored in g.LastItemData.InFlags
enum ImGuiItemFlagsPrivate_ {
	// Controlled by user
	ImGuiItemFlags_Disabled = 1 << 10, // false     // Disable interactions (DOES NOT affect visuals, see BeginDisabled()/EndDisabled() for full disable feature, and github #211).
	ImGuiItemFlags_ReadOnly = 1 << 11, // false     // [ALPHA] Allow hovering interactions but underlying value is not changed.
	ImGuiItemFlags_MixedValue = 1 << 12, // false     // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)
	ImGuiItemFlags_NoWindowHoverableCheck = 1 << 13, // false     // Disable hoverable check in ItemHoverable()
	ImGuiItemFlags_AllowOverlap = 1 << 14, // false     // Allow being overlapped by another widget. Not-hovered to Hovered transition deferred by a frame.

	// Controlled by widget code
	ImGuiItemFlags_Inputable = 1 << 20, // false     // [WIP] Auto-activate input mode when tab focused. Currently only used and supported by a few items before it becomes a generic feature.
	ImGuiItemFlags_HasSelectionUserData = 1 << 21, // false     // Set by SetNextItemSelectionUserData()
	ImGuiItemFlags_IsMultiSelect = 1 << 22, // false     // Set by SetNextItemSelectionUserData()

	ImGuiItemFlags_Default_ = ImGuiItemFlags_AutoClosePopups, // Please don't change, use PushItemFlag() instead.

	// Obsolete
	//ImGuiItemFlags_SelectableDontClosePopup = !ImGuiItemFlags_AutoClosePopups, // Can't have a redirect as we inverted the behavior
};

// Status flags for an already submitted item
// - output: stored in g.LastItemData.StatusFlags
enum ImGuiItemStatusFlags_ {
	ImGuiItemStatusFlags_None = 0,
	ImGuiItemStatusFlags_HoveredRect = 1 << 0, // Mouse position is within item rectangle (does NOT mean that the window is in correct z-order and can be hovered!, this is only one part of the most-common IsItemHovered test)
	ImGuiItemStatusFlags_HasDisplayRect = 1 << 1, // g.LastItemData.DisplayRect is valid
	ImGuiItemStatusFlags_Edited = 1 << 2, // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
	ImGuiItemStatusFlags_ToggledSelection = 1 << 3, // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected", only state changes, in order to easily handle clipping with less issues.
	ImGuiItemStatusFlags_ToggledOpen = 1 << 4, // Set when TreeNode() reports toggling their open state.
	ImGuiItemStatusFlags_HasDeactivated = 1 << 5, // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
	ImGuiItemStatusFlags_Deactivated = 1 << 6, // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.
	ImGuiItemStatusFlags_HoveredWindow = 1 << 7, // Override the HoveredWindow test to allow cross-window hover testing.
	ImGuiItemStatusFlags_Visible = 1 << 8, // [WIP] Set when item is overlapping the current clipping rectangle (Used internally. Please don't use yet: API/system will change as we refactor Itemadd()).
	ImGuiItemStatusFlags_HasClipRect = 1 << 9, // g.LastItemData.ClipRect is valid.
	ImGuiItemStatusFlags_HasShortcut = 1 << 10, // g.LastItemData.Shortcut valid. Set by SetNextItemShortcut() -> ItemAdd().

// Additional status + semantic for ImGuiTestEngine
#ifdef IMGUI_ENABLE_TEST_ENGINE
	ImGuiItemStatusFlags_Openable = 1 << 20, // Item is an openable (e.g. TreeNode)
	ImGuiItemStatusFlags_Opened = 1 << 21, // Opened status
	ImGuiItemStatusFlags_Checkable = 1 << 22, // Item is a checkable (e.g. CheckBox, MenuItem)
	ImGuiItemStatusFlags_Checked = 1 << 23, // Checked status
	ImGuiItemStatusFlags_Inputable = 1 << 24, // Item is a text-inputable (e.g. InputText, SliderXXX, DragXXX)
#endif
};

// Extend ImGuiHoveredFlags_
enum ImGuiHoveredFlagsPrivate_ {
	ImGuiHoveredFlags_DelayMask_ = ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_NoSharedDelay,
	ImGuiHoveredFlags_AllowedMaskForIsWindowHovered = ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_AnyWindow | ImGuiHoveredFlags_NoPopupHierarchy | ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_Stationary,
	ImGuiHoveredFlags_AllowedMaskForIsItemHovered = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped | ImGuiHoveredFlags_AllowWhenDisabled | ImGuiHoveredFlags_NoNavOverride | ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayMask_,
};

// Extend ImGuiInputTextFlags_
enum ImGuiInputTextFlagsPrivate_ {
	// [Internal]
	ImGuiInputTextFlags_Multiline = 1 << 26, // For internal use by InputTextMultiline()
	ImGuiInputTextFlags_NoMarkEdited = 1 << 27, // For internal use by functions using InputText() before reformatting data
	ImGuiInputTextFlags_MergedItem = 1 << 28, // For internal use by TempInputText(), will skip calling ItemAdd(). Require bounding-box to strictly match.
	ImGuiInputTextFlags_LocalizeDecimalPoint = 1 << 29, // For internal use by InputScalar() and TempInputScalar()
};

// Extend ImGuiButtonFlags_
enum ImGuiButtonFlagsPrivate_ {
	ImGuiButtonFlags_PressedOnClick = 1 << 4, // return true on click (mouse down event)
	ImGuiButtonFlags_PressedOnClickRelease = 1 << 5, // [Default] return true on click + release on same item <-- this is what the majority of Button are using
	ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1 << 6, // return true on click + release even if the release event is not done while hovering the item
	ImGuiButtonFlags_PressedOnRelease = 1 << 7, // return true on release (default requires click+release)
	ImGuiButtonFlags_PressedOnDoubleClick = 1 << 8, // return true on double-click (default requires click+release)
	ImGuiButtonFlags_PressedOnDragDropHold = 1 << 9, // return true when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
	ImGuiButtonFlags_Repeat = 1 << 10, // hold to repeat
	ImGuiButtonFlags_FlattenChildren = 1 << 11, // allow interactions even if a child window is overlapping
	ImGuiButtonFlags_AllowOverlap = 1 << 12, // require previous frame HoveredId to either match id or be null before being usable.
	ImGuiButtonFlags_DontClosePopups = 1 << 13, // disable automatically closing parent popup on press // [UNUSED]
	//ImGuiButtonFlags_Disabled             = 1 << 14,  // disable interactions -> use BeginDisabled() or ImGuiItemFlags_Disabled
	ImGuiButtonFlags_AlignTextBaseLine = 1 << 15, // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
	ImGuiButtonFlags_NoKeyModifiers = 1 << 16, // disable mouse interaction if a key modifier is held
	ImGuiButtonFlags_NoHoldingActiveId = 1 << 17, // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
	ImGuiButtonFlags_NoNavFocus = 1 << 18, // don't override navigation focus when activated (FIXME: this is essentially used every time an item uses ImGuiItemFlags_NoNav, but because legacy specs don't requires LastItemData to be set ButtonBehavior(), we can't poll g.LastItemData.InFlags)
	ImGuiButtonFlags_NoHoveredOnFocus = 1 << 19, // don't report as hovered when nav focus is on this item
	ImGuiButtonFlags_NoSetKeyOwner = 1 << 20, // don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
	ImGuiButtonFlags_NoTestKeyOwner = 1 << 21, // don't test key/input owner when polling the key (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
	ImGuiButtonFlags_PressedOnMask_ = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,
	ImGuiButtonFlags_PressedOnDefault_ = ImGuiButtonFlags_PressedOnClickRelease,
};

// Extend ImGuiComboFlags_
enum ImGuiComboFlagsPrivate_ {
	ImGuiComboFlags_CustomPreview = 1 << 20, // enable BeginComboPreview()
};

// Extend ImGuiSliderFlags_
enum ImGuiSliderFlagsPrivate_ {
	ImGuiSliderFlags_Vertical = 1 << 20, // Should this slider be orientated vertically?
	ImGuiSliderFlags_ReadOnly = 1 << 21, // Consider using g.NextItemData.ItemFlags |= ImGuiItemFlags_ReadOnly instead.
};

// Extend ImGuiSelectableFlags_
enum ImGuiSelectableFlagsPrivate_ {
	// NB: need to be in sync with last value of ImGuiSelectableFlags_
	ImGuiSelectableFlags_NoHoldingActiveID = 1 << 20,
	ImGuiSelectableFlags_SelectOnNav = 1 << 21, // (WIP) Auto-select when moved into. This is not exposed in public API as to handle multi-select and modifiers we will need user to explicitly control focus scope. May be replaced with a BeginSelection() API.
	ImGuiSelectableFlags_SelectOnClick = 1 << 22, // Override button behavior to react on Click (default is Click+Release)
	ImGuiSelectableFlags_SelectOnRelease = 1 << 23, // Override button behavior to react on Release (default is Click+Release)
	ImGuiSelectableFlags_SpanAvailWidth = 1 << 24, // Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251d379, 2bcafc86 for menus)
	ImGuiSelectableFlags_SetNavIdOnHover = 1 << 25, // Set Nav/Focus ID on mouse hover (used by MenuItem)
	ImGuiSelectableFlags_NoPadWithHalfSpacing = 1 << 26, // Disable padding each side with ItemSpacing * 0.5f
	ImGuiSelectableFlags_NoSetKeyOwner = 1 << 27, // Don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
};

// Extend ImGuiTreeNodeFlags_
enum ImGuiTreeNodeFlagsPrivate_ {
	ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 28, // FIXME-WIP: Hard-coded for CollapsingHeader()
	ImGuiTreeNodeFlags_UpsideDownArrow = 1 << 29, // FIXME-WIP: Turn Down arrow into an Up arrow, but reversed trees (#6517)
	ImGuiTreeNodeFlags_OpenOnMask_ = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow,
};

enum ImGuiSeparatorFlags_ {
	ImGuiSeparatorFlags_None = 0,
	ImGuiSeparatorFlags_Horizontal = 1 << 0, // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
	ImGuiSeparatorFlags_Vertical = 1 << 1,
	ImGuiSeparatorFlags_SpanAllColumns = 1 << 2, // Make separator cover all columns of a legacy Columns() set.
};

// Flags for FocusWindow(). This is not called ImGuiFocusFlags to avoid confusion with public-facing ImGuiFocusedFlags.
// FIXME: Once we finishing replacing more uses of GetTopMostPopupModal()+IsWindowWithinBeginStackOf()
// and FindBlockingModal() with this, we may want to change the flag to be opt-out instead of opt-in.
enum ImGuiFocusRequestFlags_ {
	ImGuiFocusRequestFlags_None = 0,
	ImGuiFocusRequestFlags_RestoreFocusedChild = 1 << 0, // Find last focused child (if any) and focus it instead.
	ImGuiFocusRequestFlags_UnlessBelowModal = 1 << 1, // Do not set focus if the window is below a modal.
};

enum ImGuiTextFlags_ {
	ImGuiTextFlags_None = 0,
	ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0,
};

enum ImGuiTooltipFlags_ {
	ImGuiTooltipFlags_None = 0,
	ImGuiTooltipFlags_OverridePrevious = 1 << 1, // Clear/ignore previously submitted tooltip (defaults to append)
};

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiLayoutType_ {
	ImGuiLayoutType_Horizontal = 0,
	ImGuiLayoutType_Vertical = 1
};

enum ImGuiLogType {
	ImGuiLogType_None = 0,
	ImGuiLogType_TTY,
	ImGuiLogType_File,
	ImGuiLogType_Buffer,
	ImGuiLogType_Clipboard,
};

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiAxis {
	ImGuiAxis_None = -1,
	ImGuiAxis_X = 0,
	ImGuiAxis_Y = 1
};

enum ImGuiPlotType {
	ImGuiPlotType_Lines,
	ImGuiPlotType_Histogram,
};

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColorMod {
	ImGuiCol Col;
	ImVec4 BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod {
	ImGuiStyleVar VarIdx;
	union {
		int BackupInt[2];
		float BackupFloat[2];
	};
	ImGuiStyleMod(ImGuiStyleVar idx, int v) {
		VarIdx = idx;
		BackupInt[0] = v;
	}
	ImGuiStyleMod(ImGuiStyleVar idx, float v) {
		VarIdx = idx;
		BackupFloat[0] = v;
	}
	ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v) {
		VarIdx = idx;
		BackupFloat[0] = v.x;
		BackupFloat[1] = v.y;
	}
};

// Storage data for BeginComboPreview()/EndComboPreview()
struct IMGUI_API ImGuiComboPreviewData {
	ImRect PreviewRect;
	ImVec2 BackupCursorPos;
	ImVec2 BackupCursorMaxPos;
	ImVec2 BackupCursorPosPrevLine;
	float BackupPrevLineTextBaseOffset;
	ImGuiLayoutType BackupLayout;

	ImGuiComboPreviewData() { memset(this, 0, sizeof(*this)); }
};

// Stacked storage data for BeginGroup()/EndGroup()
struct IMGUI_API ImGuiGroupData {
	ImGuiID WindowID;
	ImVec2 BackupCursorPos;
	ImVec2 BackupCursorMaxPos;
	ImVec2 BackupCursorPosPrevLine;
	ImVec1 BackupIndent;
	ImVec1 BackupGroupOffset;
	ImVec2 BackupCurrLineSize;
	float BackupCurrLineTextBaseOffset;
	ImGuiID BackupActiveIdIsAlive;
	bool BackupActiveIdPreviousFrameIsAlive;
	bool BackupHoveredIdIsAlive;
	bool BackupIsSameLine;
	bool EmitItem;
};

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
struct IMGUI_API ImGuiMenuColumns {
	ImU32 TotalWidth;
	ImU32 NextTotalWidth;
	ImU16 Spacing;
	ImU16 OffsetIcon; // Always zero for now
	ImU16 OffsetLabel; // Offsets are locked in Update()
	ImU16 OffsetShortcut;
	ImU16 OffsetMark;
	ImU16 Widths[4]; // Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)

	ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }
	void Update(float spacing, bool window_reappearing);
	float DeclColumns(float w_icon, float w_label, float w_shortcut, float w_mark);
	void CalcNextTotalWidth(bool update_offsets);
};

// Internal temporary state for deactivating InputText() instances.
struct IMGUI_API ImGuiInputTextDeactivatedState {
	ImGuiID ID; // widget id owning the text state (which just got deactivated)
	ImVector<char> TextA; // text buffer

	ImGuiInputTextDeactivatedState() { memset(this, 0, sizeof(*this)); }
	void ClearFreeMemory() {
		ID = 0;
		TextA.clear();
	}
};
// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
struct IMGUI_API ImGuiInputTextState {
	ImGuiContext *Ctx; // parent UI context (needs to be set explicitly by parent).
	ImGuiID ID; // widget id owning the text state
	int CurLenW, CurLenA; // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.
	ImVector<ImWchar> TextW; // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
	ImVector<char> TextA; // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.
	ImVector<char> InitialTextA; // value to revert to when pressing Escape = backup of end-user buffer at the time of focus (in UTF-8, unaltered)
	bool TextAIsValid; // temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)
	int BufCapacityA; // end-user buffer capacity
	ImVec2 Scroll; // horizontal offset (managed manually) + vertical scrolling (pulled from child window's own Scroll.y)
	ImStb::STB_TexteditState Stb; // state for stb_textedit.h
	float CursorAnim; // timer for cursor blink, reset on every user action so the cursor reappears immediately
	bool CursorFollow; // set when we want scrolling to follow the current cursor position (not always!)
	bool SelectedAllMouseLock; // after a double-click to select all, we ignore further mouse drags to update selection
	bool Edited; // edited this frame
	ImGuiInputTextFlags Flags; // copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.
	bool ReloadUserBuf; // force a reload of user buf so it may be modified externally. may be automatic in future version.
	int ReloadSelectionStart; // POSITIONS ARE IN IMWCHAR units *NOT* UTF-8 this is why this is not exposed yet.
	int ReloadSelectionEnd;

	ImGuiInputTextState() { memset(this, 0, sizeof(*this)); }
	void ClearText() {
		CurLenW = CurLenA = 0;
		TextW[0] = 0;
		TextA[0] = 0;
		CursorClamp();
	}
	void ClearFreeMemory() {
		TextW.clear();
		TextA.clear();
		InitialTextA.clear();
	}
	int GetUndoAvailCount() const { return Stb.undostate.undo_point; }
	int GetRedoAvailCount() const { return IMSTB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point; }
	void OnKeyPressed(int key); // Cannot be inline because we call in code in stb_textedit.h implementation

	// Cursor & Selection
	void CursorAnimReset() { CursorAnim = -0.30f; } // After a user-input the cursor stays on for a while without blinking
	void CursorClamp() {
		Stb.cursor = ImMin(Stb.cursor, CurLenW);
		Stb.select_start = ImMin(Stb.select_start, CurLenW);
		Stb.select_end = ImMin(Stb.select_end, CurLenW);
	}
	bool HasSelection() const { return Stb.select_start != Stb.select_end; }
	void ClearSelection() { Stb.select_start = Stb.select_end = Stb.cursor; }
	int GetCursorPos() const { return Stb.cursor; }
	int GetSelectionStart() const { return Stb.select_start; }
	int GetSelectionEnd() const { return Stb.select_end; }
	void SelectAll() {
		Stb.select_start = 0;
		Stb.cursor = Stb.select_end = CurLenW;
		Stb.has_preferred_x = 0;
	}

	// Reload user buf (WIP #2890)
	// If you modify underlying user-passed const char* while active you need to call this (InputText V2 may lift this)
	//   strcpy(my_buf, "hello");
	//   if (ImGuiInputTextState* state = ImGui::GetInputTextState(id)) // id may be ImGui::GetItemID() is last item
	//       state->ReloadUserBufAndSelectAll();
	void ReloadUserBufAndSelectAll() {
		ReloadUserBuf = true;
		ReloadSelectionStart = 0;
		ReloadSelectionEnd = INT_MAX;
	}
	void ReloadUserBufAndKeepSelection() {
		ReloadUserBuf = true;
		ReloadSelectionStart = Stb.select_start;
		ReloadSelectionEnd = Stb.select_end;
	}
	void ReloadUserBufAndMoveToEnd() {
		ReloadUserBuf = true;
		ReloadSelectionStart = ReloadSelectionEnd = INT_MAX;
	}
};

enum ImGuiWindowRefreshFlags_ {
	ImGuiWindowRefreshFlags_None = 0,
	ImGuiWindowRefreshFlags_TryToAvoidRefresh = 1 << 0, // [EXPERIMENTAL] Try to keep existing contents, USER MUST NOT HONOR BEGIN() RETURNING FALSE AND NOT APPEND.
	ImGuiWindowRefreshFlags_RefreshOnHover = 1 << 1, // [EXPERIMENTAL] Always refresh on hover
	ImGuiWindowRefreshFlags_RefreshOnFocus = 1 << 2, // [EXPERIMENTAL] Always refresh on focus
	// Refresh policy/frequency, Load Balancing etc.
};

enum ImGuiNextWindowDataFlags_ {
	ImGuiNextWindowDataFlags_None = 0,
	ImGuiNextWindowDataFlags_HasPos = 1 << 0,
	ImGuiNextWindowDataFlags_HasSize = 1 << 1,
	ImGuiNextWindowDataFlags_HasContentSize = 1 << 2,
	ImGuiNextWindowDataFlags_HasCollapsed = 1 << 3,
	ImGuiNextWindowDataFlags_HasSizeConstraint = 1 << 4,
	ImGuiNextWindowDataFlags_HasFocus = 1 << 5,
	ImGuiNextWindowDataFlags_HasBgAlpha = 1 << 6,
	ImGuiNextWindowDataFlags_HasScroll = 1 << 7,
	ImGuiNextWindowDataFlags_HasChildFlags = 1 << 8,
	ImGuiNextWindowDataFlags_HasRefreshPolicy = 1 << 9,
};

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData {
	ImGuiNextWindowDataFlags Flags;
	ImGuiCond PosCond;
	ImGuiCond SizeCond;
	ImGuiCond CollapsedCond;
	ImVec2 PosVal;
	ImVec2 PosPivotVal;
	ImVec2 SizeVal;
	ImVec2 ContentSizeVal;
	ImVec2 ScrollVal;
	ImGuiChildFlags ChildFlags;
	bool CollapsedVal;
	ImRect SizeConstraintRect;
	ImGuiSizeCallback SizeCallback;
	void *SizeCallbackUserData;
	float BgAlphaVal; // Override background alpha
	ImVec2 MenuBarOffsetMinVal; // (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)
	ImGuiWindowRefreshFlags RefreshFlagsVal;

	ImGuiNextWindowData() { memset(this, 0, sizeof(*this)); }
	inline void ClearFlags() { Flags = ImGuiNextWindowDataFlags_None; }
};

enum ImGuiNextItemDataFlags_ {
	ImGuiNextItemDataFlags_None = 0,
	ImGuiNextItemDataFlags_HasWidth = 1 << 0,
	ImGuiNextItemDataFlags_HasOpen = 1 << 1,
	ImGuiNextItemDataFlags_HasShortcut = 1 << 2,
	ImGuiNextItemDataFlags_HasRefVal = 1 << 3,
	ImGuiNextItemDataFlags_HasStorageID = 1 << 4,
};

struct ImGuiNextItemData {
	ImGuiNextItemDataFlags Flags;
	ImGuiItemFlags ItemFlags; // Currently only tested/used for ImGuiItemFlags_AllowOverlap and ImGuiItemFlags_HasSelectionUserData.
	// Non-flags members are NOT cleared by ItemAdd() meaning they are still valid during NavProcessItem()
	ImGuiID FocusScopeId; // Set by SetNextItemSelectionUserData()
	ImGuiSelectionUserData SelectionUserData; // Set by SetNextItemSelectionUserData() (note that NULL/0 is a valid value, we use -1 == ImGuiSelectionUserData_Invalid to mark invalid values)
	float Width; // Set by SetNextItemWidth()
	ImGuiKeyChord Shortcut; // Set by SetNextItemShortcut()
	ImGuiInputFlags ShortcutFlags; // Set by SetNextItemShortcut()
	bool OpenVal; // Set by SetNextItemOpen()
	ImU8 OpenCond; // Set by SetNextItemOpen()
	ImGuiDataTypeStorage RefVal; // Not exposed yet, for ImGuiInputTextFlags_ParseEmptyAsRefVal
	ImGuiID StorageId; // Set by SetNextItemStorageID()

	ImGuiNextItemData() {
		memset(this, 0, sizeof(*this));
		SelectionUserData = -1;
	}
	inline void ClearFlags() {
		Flags = ImGuiNextItemDataFlags_None;
		ItemFlags = ImGuiItemFlags_None;
	} // Also cleared manually by ItemAdd()!
};

// Status storage for the last submitted item
struct ImGuiLastItemData {
	ImGuiID ID;
	ImGuiItemFlags InFlags; // See ImGuiItemFlags_
	ImGuiItemStatusFlags StatusFlags; // See ImGuiItemStatusFlags_
	ImRect Rect; // Full rectangle
	ImRect NavRect; // Navigation scoring rectangle (not displayed)
	// Rarely used fields are not explicitly cleared, only valid when the corresponding ImGuiItemStatusFlags ar set.
	ImRect DisplayRect; // Display rectangle. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) is set.
	ImRect ClipRect; // Clip rectangle at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasClipRect) is set..
	ImGuiKeyChord Shortcut; // Shortcut at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasShortcut) is set..

	ImGuiLastItemData() { memset(this, 0, sizeof(*this)); }
};

// Store data emitted by TreeNode() for usage by TreePop()
// - To implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere: store the minimum amount of data
//   which we can't infer in TreePop(), to perform the equivalent of NavApplyItemToResult().
//   Only stored when the node is a potential candidate for landing on a Left arrow jump.
struct ImGuiTreeNodeStackData {
	ImGuiID ID;
	ImGuiTreeNodeFlags TreeFlags;
	ImGuiItemFlags InFlags; // Used for nav landing
	ImRect NavRect; // Used for nav landing
};

struct IMGUI_API ImGuiStackSizes {
	short SizeOfIDStack;
	short SizeOfColorStack;
	short SizeOfStyleVarStack;
	short SizeOfFontStack;
	short SizeOfFocusScopeStack;
	short SizeOfGroupStack;
	short SizeOfItemFlagsStack;
	short SizeOfBeginPopupStack;
	short SizeOfDisabledStack;

	ImGuiStackSizes() { memset(this, 0, sizeof(*this)); }
	void SetToContextState(ImGuiContext *ctx);
	void CompareWithContextState(ImGuiContext *ctx);
};

// Data saved for each window pushed into the stack
struct ImGuiWindowStackData {
	ImGuiWindow *Window;
	ImGuiLastItemData ParentLastItemDataBackup;
	ImGuiStackSizes StackSizesOnBegin; // Store size of various stacks for asserting
	bool DisabledOverrideReenable; // Non-child window override disabled flag
};

struct ImGuiShrinkWidthItem {
	int Index;
	float Width;
	float InitialWidth;
};

struct ImGuiPtrOrIndex {
	void *Ptr; // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
	int Index; // Usually index in a main pool.

	ImGuiPtrOrIndex(void *ptr) {
		Ptr = ptr;
		Index = -1;
	}
	ImGuiPtrOrIndex(int index) {
		Ptr = NULL;
		Index = index;
	}
};

//-----------------------------------------------------------------------------
// [SECTION] Popup support
//-----------------------------------------------------------------------------

enum ImGuiPopupPositionPolicy {
	ImGuiPopupPositionPolicy_Default,
	ImGuiPopupPositionPolicy_ComboBox,
	ImGuiPopupPositionPolicy_Tooltip,
};

// Storage for popup stacks (g.OpenPopupStack and g.BeginPopupStack)
struct ImGuiPopupData {
	ImGuiID PopupId; // Set on OpenPopup()
	ImGuiWindow *Window; // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
	ImGuiWindow *RestoreNavWindow; // Set on OpenPopup(), a NavWindow that will be restored on popup close
	int ParentNavLayer; // Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value
	int OpenFrameCount; // Set on OpenPopup()
	ImGuiID OpenParentId; // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
	ImVec2 OpenPopupPos; // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
	ImVec2 OpenMousePos; // Set on OpenPopup(), copy of mouse position at the time of opening popup

	ImGuiPopupData() {
		memset(this, 0, sizeof(*this));
		ParentNavLayer = OpenFrameCount = -1;
	}
};

//-----------------------------------------------------------------------------
// [SECTION] Inputs support
//-----------------------------------------------------------------------------

// Bit array for named keys
typedef ImBitArray<ImGuiKey_NamedKey_COUNT, -ImGuiKey_NamedKey_BEGIN> ImBitArrayForNamedKeys;

// [Internal] Key ranges
#define ImGuiKey_LegacyNativeKey_BEGIN 0
#define ImGuiKey_LegacyNativeKey_END 512
#define ImGuiKey_Keyboard_BEGIN (ImGuiKey_NamedKey_BEGIN)
#define ImGuiKey_Keyboard_END (ImGuiKey_GamepadStart)
#define ImGuiKey_Gamepad_BEGIN (ImGuiKey_GamepadStart)
#define ImGuiKey_Gamepad_END (ImGuiKey_GamepadRStickDown + 1)
#define ImGuiKey_Mouse_BEGIN (ImGuiKey_MouseLeft)
#define ImGuiKey_Mouse_END (ImGuiKey_MouseWheelY + 1)
#define ImGuiKey_Aliases_BEGIN (ImGuiKey_Mouse_BEGIN)
#define ImGuiKey_Aliases_END (ImGuiKey_Mouse_END)

// [Internal] Named shortcuts for Navigation
#define ImGuiKey_NavKeyboardTweakSlow ImGuiMod_Ctrl
#define ImGuiKey_NavKeyboardTweakFast ImGuiMod_Shift
#define ImGuiKey_NavGamepadTweakSlow ImGuiKey_GamepadL1
#define ImGuiKey_NavGamepadTweakFast ImGuiKey_GamepadR1
#define ImGuiKey_NavGamepadActivate (g.IO.ConfigNavSwapGamepadButtons ? ImGuiKey_GamepadFaceRight : ImGuiKey_GamepadFaceDown)
#define ImGuiKey_NavGamepadCancel (g.IO.ConfigNavSwapGamepadButtons ? ImGuiKey_GamepadFaceDown : ImGuiKey_GamepadFaceRight)
#define ImGuiKey_NavGamepadMenu ImGuiKey_GamepadFaceLeft
#define ImGuiKey_NavGamepadInput ImGuiKey_GamepadFaceUp

enum ImGuiInputEventType {
	ImGuiInputEventType_None = 0,
	ImGuiInputEventType_MousePos,
	ImGuiInputEventType_MouseWheel,
	ImGuiInputEventType_MouseButton,
	ImGuiInputEventType_Key,
	ImGuiInputEventType_Text,
	ImGuiInputEventType_Focus,
	ImGuiInputEventType_COUNT
};

enum ImGuiInputSource {
	ImGuiInputSource_None = 0,
	ImGuiInputSource_Mouse, // Note: may be Mouse or TouchScreen or Pen. See io.MouseSource to distinguish them.
	ImGuiInputSource_Keyboard,
	ImGuiInputSource_Gamepad,
	ImGuiInputSource_COUNT
};

// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?
// Using ImVec2() would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'
struct ImGuiInputEventMousePos {
	float PosX, PosY;
	ImGuiMouseSource MouseSource;
};
struct ImGuiInputEventMouseWheel {
	float WheelX, WheelY;
	ImGuiMouseSource MouseSource;
};
struct ImGuiInputEventMouseButton {
	int Button;
	bool Down;
	ImGuiMouseSource MouseSource;
};
struct ImGuiInputEventKey {
	ImGuiKey Key;
	bool Down;
	float AnalogValue;
};
struct ImGuiInputEventText {
	unsigned int Char;
};
struct ImGuiInputEventAppFocused {
	bool Focused;
};

struct ImGuiInputEvent {
	ImGuiInputEventType Type;
	ImGuiInputSource Source;
	ImU32 EventId; // Unique, sequential increasing integer to identify an event (if you need to correlate them to other data).
	union {
		ImGuiInputEventMousePos MousePos; // if Type == ImGuiInputEventType_MousePos
		ImGuiInputEventMouseWheel MouseWheel; // if Type == ImGuiInputEventType_MouseWheel
		ImGuiInputEventMouseButton MouseButton; // if Type == ImGuiInputEventType_MouseButton
		ImGuiInputEventKey Key; // if Type == ImGuiInputEventType_Key
		ImGuiInputEventText Text; // if Type == ImGuiInputEventType_Text
		ImGuiInputEventAppFocused AppFocused; // if Type == ImGuiInputEventType_Focus
	};
	bool AddedByTestEngine;

	ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }
};

// Input function taking an 'ImGuiID owner_id' argument defaults to (ImGuiKeyOwner_Any == 0) aka don't test ownership, which matches legacy behavior.
#define ImGuiKeyOwner_Any ((ImGuiID)0) // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
#define ImGuiKeyOwner_NoOwner ((ImGuiID) - 1) // Require key to have no owner.
//#define ImGuiKeyOwner_None ImGuiKeyOwner_NoOwner  // We previously called this 'ImGuiKeyOwner_None' but it was inconsistent with our pattern that _None values == 0 and quite dangerous. Also using _NoOwner makes the IsKeyPressed() calls more explicit.

typedef ImS16 ImGuiKeyRoutingIndex;

// Routing table entry (sizeof() == 16 bytes)
struct ImGuiKeyRoutingData {
	ImGuiKeyRoutingIndex NextEntryIndex;
	ImU16 Mods; // Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits.
	ImU8 RoutingCurrScore; // [DEBUG] For debug display
	ImU8 RoutingNextScore; // Lower is better (0: perfect score)
	ImGuiID RoutingCurr;
	ImGuiID RoutingNext;

	ImGuiKeyRoutingData() {
		NextEntryIndex = -1;
		Mods = 0;
		RoutingCurrScore = RoutingNextScore = 255;
		RoutingCurr = RoutingNext = ImGuiKeyOwner_NoOwner;
	}
};

// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.
// Stored in main context (1 instance)
struct ImGuiKeyRoutingTable {
	ImGuiKeyRoutingIndex Index[ImGuiKey_NamedKey_COUNT]; // Index of first entry in Entries[]
	ImVector<ImGuiKeyRoutingData> Entries;
	ImVector<ImGuiKeyRoutingData> EntriesNext; // Double-buffer to avoid reallocation (could use a shared buffer)

	ImGuiKeyRoutingTable() { Clear(); }
	void Clear() {
		for (int n = 0; n < IM_ARRAYSIZE(Index); n++)
			Index[n] = -1;
		Entries.clear();
		EntriesNext.clear();
	}
};

// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)
// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.
struct ImGuiKeyOwnerData {
	ImGuiID OwnerCurr;
	ImGuiID OwnerNext;
	bool LockThisFrame; // Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.
	bool LockUntilRelease; // Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.

	ImGuiKeyOwnerData() {
		OwnerCurr = OwnerNext = ImGuiKeyOwner_NoOwner;
		LockThisFrame = LockUntilRelease = false;
	}
};

// Extend ImGuiInputFlags_
// Flags for extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(), SetKeyOwner(), SetItemKeyOwner()
// Don't mistake with ImGuiInputTextFlags! (which is for ImGui::InputText() function)
enum ImGuiInputFlagsPrivate_ {
	// Flags for IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(), Shortcut()
	// - Repeat mode: Repeat rate selection
	ImGuiInputFlags_RepeatRateDefault = 1 << 1, // Repeat rate: Regular (default)
	ImGuiInputFlags_RepeatRateNavMove = 1 << 2, // Repeat rate: Fast
	ImGuiInputFlags_RepeatRateNavTweak = 1 << 3, // Repeat rate: Faster
												 // - Repeat mode: Specify when repeating key pressed can be interrupted.
												 // - In theory ImGuiInputFlags_RepeatUntilOtherKeyPress may be a desirable default, but it would break too many behavior so everything is opt-in.
	ImGuiInputFlags_RepeatUntilRelease = 1 << 4, // Stop repeating when released (default for all functions except Shortcut). This only exists to allow overriding Shortcut() default behavior.
	ImGuiInputFlags_RepeatUntilKeyModsChange = 1 << 5, // Stop repeating when released OR if keyboard mods are changed (default for Shortcut)
	ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone = 1 << 6, // Stop repeating when released OR if keyboard mods are leaving the None state. Allows going from Mod+Key to Key by releasing Mod.
	ImGuiInputFlags_RepeatUntilOtherKeyPress = 1 << 7, // Stop repeating when released OR if any other keyboard key is pressed during the repeat

	// Flags for SetKeyOwner(), SetItemKeyOwner()
	// - Locking key away from non-input aware code. Locking is useful to make input-owner-aware code steal keys from non-input-owner-aware code. If all code is input-owner-aware locking would never be necessary.
	ImGuiInputFlags_LockThisFrame = 1 << 20, // Further accesses to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared at end of frame.
	ImGuiInputFlags_LockUntilRelease = 1 << 21, // Further accesses to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared when the key is released or at end of each frame if key is released.

	// - Condition for SetItemKeyOwner()
	ImGuiInputFlags_CondHovered = 1 << 22, // Only set if item is hovered (default to both)
	ImGuiInputFlags_CondActive = 1 << 23, // Only set if item is active (default to both)
	ImGuiInputFlags_CondDefault_ = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,

	// [Internal] Mask of which function support which flags
	ImGuiInputFlags_RepeatRateMask_ = ImGuiInputFlags_RepeatRateDefault | ImGuiInputFlags_RepeatRateNavMove | ImGuiInputFlags_RepeatRateNavTweak,
	ImGuiInputFlags_RepeatUntilMask_ = ImGuiInputFlags_RepeatUntilRelease | ImGuiInputFlags_RepeatUntilKeyModsChange | ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone | ImGuiInputFlags_RepeatUntilOtherKeyPress,
	ImGuiInputFlags_RepeatMask_ = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_,
	ImGuiInputFlags_CondMask_ = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,
	ImGuiInputFlags_RouteTypeMask_ = ImGuiInputFlags_RouteActive | ImGuiInputFlags_RouteFocused | ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteAlways,
	ImGuiInputFlags_RouteOptionsMask_ = ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused | ImGuiInputFlags_RouteFromRootWindow,
	ImGuiInputFlags_SupportedByIsKeyPressed = ImGuiInputFlags_RepeatMask_,
	ImGuiInputFlags_SupportedByIsMouseClicked = ImGuiInputFlags_Repeat,
	ImGuiInputFlags_SupportedByShortcut = ImGuiInputFlags_RepeatMask_ | ImGuiInputFlags_RouteTypeMask_ | ImGuiInputFlags_RouteOptionsMask_,
	ImGuiInputFlags_SupportedBySetNextItemShortcut = ImGuiInputFlags_RepeatMask_ | ImGuiInputFlags_RouteTypeMask_ | ImGuiInputFlags_RouteOptionsMask_ | ImGuiInputFlags_Tooltip,
	ImGuiInputFlags_SupportedBySetKeyOwner = ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease,
	ImGuiInputFlags_SupportedBySetItemKeyOwner = ImGuiInputFlags_SupportedBySetKeyOwner | ImGuiInputFlags_CondMask_,
};

//-----------------------------------------------------------------------------
// [SECTION] Clipper support
//-----------------------------------------------------------------------------

// Note that Max is exclusive, so perhaps should be using a Begin/End convention.
struct ImGuiListClipperRange {
	int Min;
	int Max;
	bool PosToIndexConvert; // Begin/End are absolute position (will be converted to indices later)
	ImS8 PosToIndexOffsetMin; // Add to Min after converting to indices
	ImS8 PosToIndexOffsetMax; // Add to Min after converting to indices

	static ImGuiListClipperRange FromIndices(int min, int max) {
		ImGuiListClipperRange r = { min, max, false, 0, 0 };
		return r;
	}
	static ImGuiListClipperRange FromPositions(float y1, float y2, int off_min, int off_max) {
		ImGuiListClipperRange r = { (int)y1, (int)y2, true, (ImS8)off_min, (ImS8)off_max };
		return r;
	}
};

// Temporary clipper data, buffers shared/reused between instances
struct ImGuiListClipperData {
	ImGuiListClipper *ListClipper;
	float LossynessOffset;
	int StepNo;
	int ItemsFrozen;
	ImVector<ImGuiListClipperRange> Ranges;

	ImGuiListClipperData() { memset(this, 0, sizeof(*this)); }
	void Reset(ImGuiListClipper *clipper) {
		ListClipper = clipper;
		StepNo = ItemsFrozen = 0;
		Ranges.resize(0);
	}
};

//-----------------------------------------------------------------------------
// [SECTION] Navigation support
//-----------------------------------------------------------------------------

enum ImGuiActivateFlags_ {
	ImGuiActivateFlags_None = 0,
	ImGuiActivateFlags_PreferInput = 1 << 0, // Favor activation that requires keyboard text input (e.g. for Slider/Drag). Default for Enter key.
	ImGuiActivateFlags_PreferTweak = 1 << 1, // Favor activation for tweaking with arrows or gamepad (e.g. for Slider/Drag). Default for Space key and if keyboard is not used.
	ImGuiActivateFlags_TryToPreserveState = 1 << 2, // Request widget to preserve state if it can (e.g. InputText will try to preserve cursor/selection)
	ImGuiActivateFlags_FromTabbing = 1 << 3, // Activation requested by a tabbing request
	ImGuiActivateFlags_FromShortcut = 1 << 4, // Activation requested by an item shortcut via SetNextItemShortcut() function.
};

// Early work-in-progress API for ScrollToItem()
enum ImGuiScrollFlags_ {
	ImGuiScrollFlags_None = 0,
	ImGuiScrollFlags_KeepVisibleEdgeX = 1 << 0, // If item is not visible: scroll as little as possible on X axis to bring item back into view [default for X axis]
	ImGuiScrollFlags_KeepVisibleEdgeY = 1 << 1, // If item is not visible: scroll as little as possible on Y axis to bring item back into view [default for Y axis for windows that are already visible]
	ImGuiScrollFlags_KeepVisibleCenterX = 1 << 2, // If item is not visible: scroll to make the item centered on X axis [rarely used]
	ImGuiScrollFlags_KeepVisibleCenterY = 1 << 3, // If item is not visible: scroll to make the item centered on Y axis
	ImGuiScrollFlags_AlwaysCenterX = 1 << 4, // Always center the result item on X axis [rarely used]
	ImGuiScrollFlags_AlwaysCenterY = 1 << 5, // Always center the result item on Y axis [default for Y axis for appearing window)
	ImGuiScrollFlags_NoScrollParent = 1 << 6, // Disable forwarding scrolling to parent window if required to keep item/rect visible (only scroll window the function was applied to).
	ImGuiScrollFlags_MaskX_ = ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleCenterX | ImGuiScrollFlags_AlwaysCenterX,
	ImGuiScrollFlags_MaskY_ = ImGuiScrollFlags_KeepVisibleEdgeY | ImGuiScrollFlags_KeepVisibleCenterY | ImGuiScrollFlags_AlwaysCenterY,
};

enum ImGuiNavHighlightFlags_ {
	ImGuiNavHighlightFlags_None = 0,
	ImGuiNavHighlightFlags_Compact = 1 << 1, // Compact highlight, no padding
	ImGuiNavHighlightFlags_AlwaysDraw = 1 << 2, // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.
	ImGuiNavHighlightFlags_NoRounding = 1 << 3,
};

enum ImGuiNavMoveFlags_ {
	ImGuiNavMoveFlags_None = 0,
	ImGuiNavMoveFlags_LoopX = 1 << 0, // On failed request, restart from opposite side
	ImGuiNavMoveFlags_LoopY = 1 << 1,
	ImGuiNavMoveFlags_WrapX = 1 << 2, // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
	ImGuiNavMoveFlags_WrapY = 1 << 3, // This is not super useful but provided for completeness
	ImGuiNavMoveFlags_WrapMask_ = ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_WrapY,
	ImGuiNavMoveFlags_AllowCurrentNavId = 1 << 4, // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
	ImGuiNavMoveFlags_AlsoScoreVisibleSet = 1 << 5, // Store alternate result in NavMoveResultLocalVisible that only comprise elements that are already fully visible (used by PageUp/PageDown)
	ImGuiNavMoveFlags_ScrollToEdgeY = 1 << 6, // Force scrolling to min/max (used by Home/End) // FIXME-NAV: Aim to remove or reword, probably unnecessary
	ImGuiNavMoveFlags_Forwarded = 1 << 7,
	ImGuiNavMoveFlags_DebugNoResult = 1 << 8, // Dummy scoring for debug purpose, don't apply result
	ImGuiNavMoveFlags_FocusApi = 1 << 9, // Requests from focus API can land/focus/activate items even if they are marked with _NoTabStop (see NavProcessItemForTabbingRequest() for details)
	ImGuiNavMoveFlags_IsTabbing = 1 << 10, // == Focus + Activate if item is Inputable + DontChangeNavHighlight
	ImGuiNavMoveFlags_IsPageMove = 1 << 11, // Identify a PageDown/PageUp request.
	ImGuiNavMoveFlags_Activate = 1 << 12, // Activate/select target item.
	ImGuiNavMoveFlags_NoSelect = 1 << 13, // Don't trigger selection by not setting g.NavJustMovedTo
	ImGuiNavMoveFlags_NoSetNavHighlight = 1 << 14, // Do not alter the visible state of keyboard vs mouse nav highlight
	ImGuiNavMoveFlags_NoClearActiveId = 1 << 15, // (Experimental) Do not clear active id when applying move result
};

enum ImGuiNavLayer {
	ImGuiNavLayer_Main = 0, // Main scrolling layer
	ImGuiNavLayer_Menu = 1, // Menu layer (access with Alt)
	ImGuiNavLayer_COUNT
};

// Storage for navigation query/results
struct ImGuiNavItemData {
	ImGuiWindow *Window; // Init,Move    // Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)
	ImGuiID ID; // Init,Move    // Best candidate item ID
	ImGuiID FocusScopeId; // Init,Move    // Best candidate focus scope ID
	ImRect RectRel; // Init,Move    // Best candidate bounding box in window relative space
	ImGuiItemFlags InFlags; // ????,Move    // Best candidate item flags
	float DistBox; //      Move    // Best candidate box distance to current NavId
	float DistCenter; //      Move    // Best candidate center distance to current NavId
	float DistAxial; //      Move    // Best candidate axial distance to current NavId
	ImGuiSelectionUserData SelectionUserData; //I+Mov    // Best candidate SetNextItemSelectionUserData() value. Valid if (InFlags & ImGuiItemFlags_HasSelectionUserData)

	ImGuiNavItemData() { Clear(); }
	void Clear() {
		Window = NULL;
		ID = FocusScopeId = 0;
		InFlags = 0;
		SelectionUserData = -1;
		DistBox = DistCenter = DistAxial = FLT_MAX;
	}
};

// Storage for PushFocusScope()
struct ImGuiFocusScopeData {
	ImGuiID ID;
	ImGuiID WindowID;
};

//-----------------------------------------------------------------------------
// [SECTION] Typing-select support
//-----------------------------------------------------------------------------

// Flags for GetTypingSelectRequest()
enum ImGuiTypingSelectFlags_ {
	ImGuiTypingSelectFlags_None = 0,
	ImGuiTypingSelectFlags_AllowBackspace = 1 << 0, // Backspace to delete character inputs. If using: ensure GetTypingSelectRequest() is not called more than once per frame (filter by e.g. focus state)
	ImGuiTypingSelectFlags_AllowSingleCharMode = 1 << 1, // Allow "single char" search mode which is activated when pressing the same character multiple times.
};

// Returned by GetTypingSelectRequest(), designed to eventually be public.
struct IMGUI_API ImGuiTypingSelectRequest {
	ImGuiTypingSelectFlags Flags; // Flags passed to GetTypingSelectRequest()
	int SearchBufferLen;
	const char *SearchBuffer; // Search buffer contents (use full string. unless SingleCharMode is set, in which case use SingleCharSize).
	bool SelectRequest; // Set when buffer was modified this frame, requesting a selection.
	bool SingleCharMode; // Notify when buffer contains same character repeated, to implement special mode. In this situation it preferred to not display any on-screen search indication.
	ImS8 SingleCharSize; // Length in bytes of first letter codepoint (1 for ascii, 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize) only 1 letter has been input.
};

// Storage for GetTypingSelectRequest()
struct IMGUI_API ImGuiTypingSelectState {
	ImGuiTypingSelectRequest Request; // User-facing data
	char SearchBuffer[64]; // Search buffer: no need to make dynamic as this search is very transient.
	ImGuiID FocusScope;
	int LastRequestFrame = 0;
	float LastRequestTime = 0.0f;
	bool SingleCharModeLock = false; // After a certain single char repeat count we lock into SingleCharMode. Two benefits: 1) buffer never fill, 2) we can provide an immediate SingleChar mode without timer elapsing.

	ImGuiTypingSelectState() { memset(this, 0, sizeof(*this)); }
	void Clear() {
		SearchBuffer[0] = 0;
		SingleCharModeLock = false;
	} // We preserve remaining data for easier debugging
};

//-----------------------------------------------------------------------------
// [SECTION] Columns support
//-----------------------------------------------------------------------------

// Flags for internal's BeginColumns(). This is an obsolete API. Prefer using BeginTable() nowadays!
enum ImGuiOldColumnFlags_ {
	ImGuiOldColumnFlags_None = 0,
	ImGuiOldColumnFlags_NoBorder = 1 << 0, // Disable column dividers
	ImGuiOldColumnFlags_NoResize = 1 << 1, // Disable resizing columns when clicking on the dividers
	ImGuiOldColumnFlags_NoPreserveWidths = 1 << 2, // Disable column width preservation when adjusting columns
	ImGuiOldColumnFlags_NoForceWithinWindow = 1 << 3, // Disable forcing columns to fit within window
	ImGuiOldColumnFlags_GrowParentContentsSize = 1 << 4, // Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.

// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
//ImGuiColumnsFlags_None                    = ImGuiOldColumnFlags_None,
//ImGuiColumnsFlags_NoBorder                = ImGuiOldColumnFlags_NoBorder,
//ImGuiColumnsFlags_NoResize                = ImGuiOldColumnFlags_NoResize,
//ImGuiColumnsFlags_NoPreserveWidths        = ImGuiOldColumnFlags_NoPreserveWidths,
//ImGuiColumnsFlags_NoForceWithinWindow     = ImGuiOldColumnFlags_NoForceWithinWindow,
//ImGuiColumnsFlags_GrowParentContentsSize  = ImGuiOldColumnFlags_GrowParentContentsSize,
#endif
};

struct ImGuiOldColumnData {
	float OffsetNorm; // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
	float OffsetNormBeforeResize;
	ImGuiOldColumnFlags Flags; // Not exposed
	ImRect ClipRect;

	ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }
};

struct ImGuiOldColumns {
	ImGuiID ID;
	ImGuiOldColumnFlags Flags;
	bool IsFirstFrame;
	bool IsBeingResized;
	int Current;
	int Count;
	float OffMinX, OffMaxX; // Offsets from HostWorkRect.Min.x
	float LineMinY, LineMaxY;
	float HostCursorPosY; // Backup of CursorPos at the time of BeginColumns()
	float HostCursorMaxPosX; // Backup of CursorMaxPos at the time of BeginColumns()
	ImRect HostInitialClipRect; // Backup of ClipRect at the time of BeginColumns()
	ImRect HostBackupClipRect; // Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()
	ImRect HostBackupParentWorkRect; //Backup of WorkRect at the time of BeginColumns()
	ImVector<ImGuiOldColumnData> Columns;
	ImDrawListSplitter Splitter;

	ImGuiOldColumns() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Box-select support
//-----------------------------------------------------------------------------

struct ImGuiBoxSelectState {
	// Active box-selection data (persistent, 1 active at a time)
	ImGuiID ID;
	bool IsActive;
	bool IsStarting;
	bool IsStartedFromVoid; // Starting click was not from an item.
	bool IsStartedSetNavIdOnce;
	bool RequestClear;
	ImGuiKeyChord KeyMods : 16; // Latched key-mods for box-select logic.
	ImVec2 StartPosRel; // Start position in window-contents relative space (to support scrolling)
	ImVec2 EndPosRel; // End position in window-contents relative space
	ImVec2 ScrollAccum; // Scrolling accumulator (to behave at high-frame spaces)
	ImGuiWindow *Window;

	// Temporary/Transient data
	bool UnclipMode; // (Temp/Transient, here in hot area). Set/cleared by the BeginMultiSelect()/EndMultiSelect() owning active box-select.
	ImRect UnclipRect; // Rectangle where ItemAdd() clipping may be temporarily disabled. Need support by multi-select supporting widgets.
	ImRect BoxSelectRectPrev; // Selection rectangle in absolute coordinates (derived every frame from BoxSelectStartPosRel and MousePos)
	ImRect BoxSelectRectCurr;

	ImGuiBoxSelectState() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Multi-select support
//-----------------------------------------------------------------------------

// We always assume that -1 is an invalid value (which works for indices and pointers)
#define ImGuiSelectionUserData_Invalid ((ImGuiSelectionUserData) - 1)

// Temporary storage for multi-select
struct IMGUI_API ImGuiMultiSelectTempData {
	ImGuiMultiSelectIO IO; // MUST BE FIRST FIELD. Requests are set and returned by BeginMultiSelect()/EndMultiSelect() + written to by user during the loop.
	ImGuiMultiSelectState *Storage;
	ImGuiID FocusScopeId; // Copied from g.CurrentFocusScopeId (unless another selection scope was pushed manually)
	ImGuiMultiSelectFlags Flags;
	ImVec2 ScopeRectMin;
	ImVec2 BackupCursorMaxPos;
	ImGuiSelectionUserData LastSubmittedItem; // Copy of last submitted item data, used to merge output ranges.
	ImGuiID BoxSelectId;
	ImGuiKeyChord KeyMods;
	ImS8 LoopRequestSetAll; // -1: no operation, 0: clear all, 1: select all.
	bool IsEndIO; // Set when switching IO from BeginMultiSelect() to EndMultiSelect() state.
	bool IsFocused; // Set if currently focusing the selection scope (any item of the selection). May be used if you have custom shortcut associated to selection.
	bool IsKeyboardSetRange; // Set by BeginMultiSelect() when using Shift+Navigation. Because scrolling may be affected we can't afford a frame of lag with Shift+Navigation.
	bool NavIdPassedBy;
	bool RangeSrcPassedBy; // Set by the item that matches RangeSrcItem.
	bool RangeDstPassedBy; // Set by the item that matches NavJustMovedToId when IsSetRange is set.

	ImGuiMultiSelectTempData() { Clear(); }
	void Clear() {
		size_t io_sz = sizeof(IO);
		ClearIO();
		memset((void *)(&IO + 1), 0, sizeof(*this) - io_sz);
	} // Zero-clear except IO as we preserve IO.Requests[] buffer allocation.
	void ClearIO() {
		IO.Requests.resize(0);
		IO.RangeSrcItem = IO.NavIdItem = ImGuiSelectionUserData_Invalid;
		IO.NavIdSelected = IO.RangeSrcReset = false;
	}
};

// Persistent storage for multi-select (as long as selection is alive)
struct IMGUI_API ImGuiMultiSelectState {
	ImGuiWindow *Window;
	ImGuiID ID;
	int LastFrameActive; // Last used frame-count, for GC.
	int LastSelectionSize; // Set by BeginMultiSelect() based on optional info provided by user. May be -1 if unknown.
	ImS8 RangeSelected; // -1 (don't have) or true/false
	ImS8 NavIdSelected; // -1 (don't have) or true/false
	ImGuiSelectionUserData RangeSrcItem; //
	ImGuiSelectionUserData NavIdItem; // SetNextItemSelectionUserData() value for NavId (if part of submitted items)

	ImGuiMultiSelectState() {
		Window = NULL;
		ID = 0;
		LastFrameActive = LastSelectionSize = 0;
		RangeSelected = NavIdSelected = -1;
		RangeSrcItem = NavIdItem = ImGuiSelectionUserData_Invalid;
	}
};

//-----------------------------------------------------------------------------
// [SECTION] Docking support
//-----------------------------------------------------------------------------

#ifdef IMGUI_HAS_DOCK
// <this is filled in 'docking' branch>
#endif // #ifdef IMGUI_HAS_DOCK

//-----------------------------------------------------------------------------
// [SECTION] Viewport support
//-----------------------------------------------------------------------------

// ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)
// Every instance of ImGuiViewport is in fact a ImGuiViewportP.
struct ImGuiViewportP : public ImGuiViewport {
	int BgFgDrawListsLastFrame[2]; // Last frame number the background (0) and foreground (1) draw lists were used
	ImDrawList *BgFgDrawLists[2]; // Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.
	ImDrawData DrawDataP;
	ImDrawDataBuilder DrawDataBuilder; // Temporary data while building final ImDrawData

	// Per-viewport work area
	// - Insets are >= 0.0f values, distance from viewport corners to work area.
	// - BeginMainMenuBar() and DockspaceOverViewport() tend to use work area to avoid stepping over existing contents.
	// - Generally 'safeAreaInsets' in iOS land, 'DisplayCutout' in Android land.
	ImVec2 WorkInsetMin; // Work Area inset locked for the frame. GetWorkRect() always fits within GetMainRect().
	ImVec2 WorkInsetMax; // "
	ImVec2 BuildWorkInsetMin; // Work Area inset accumulator for current frame, to become next frame's WorkInset
	ImVec2 BuildWorkInsetMax; // "

	ImGuiViewportP() {
		BgFgDrawListsLastFrame[0] = BgFgDrawListsLastFrame[1] = -1;
		BgFgDrawLists[0] = BgFgDrawLists[1] = NULL;
	}
	~ImGuiViewportP() {
		if (BgFgDrawLists[0])
			IM_DELETE(BgFgDrawLists[0]);
		if (BgFgDrawLists[1])
			IM_DELETE(BgFgDrawLists[1]);
	}

	// Calculate work rect pos/size given a set of offset (we have 1 pair of offset for rect locked from last frame data, and 1 pair for currently building rect)
	ImVec2 CalcWorkRectPos(const ImVec2 &inset_min) const { return ImVec2(Pos.x + inset_min.x, Pos.y + inset_min.y); }
	ImVec2 CalcWorkRectSize(const ImVec2 &inset_min, const ImVec2 &inset_max) const { return ImVec2(ImMax(0.0f, Size.x - inset_min.x - inset_max.x), ImMax(0.0f, Size.y - inset_min.y - inset_max.y)); }
	void UpdateWorkRect() {
		WorkPos = CalcWorkRectPos(WorkInsetMin);
		WorkSize = CalcWorkRectSize(WorkInsetMin, WorkInsetMax);
	} // Update public fields

	// Helpers to retrieve ImRect (we don't need to store BuildWorkRect as every access tend to change it, hence the code asymmetry)
	ImRect GetMainRect() const { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
	ImRect GetWorkRect() const { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }
	ImRect GetBuildWorkRect() const {
		ImVec2 pos = CalcWorkRectPos(BuildWorkInsetMin);
		ImVec2 size = CalcWorkRectSize(BuildWorkInsetMin, BuildWorkInsetMax);
		return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y);
	}
};

//-----------------------------------------------------------------------------
// [SECTION] Settings support
//-----------------------------------------------------------------------------

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
struct ImGuiWindowSettings {
	ImGuiID ID;
	ImVec2ih Pos;
	ImVec2ih Size;
	bool Collapsed;
	bool IsChild;
	bool WantApply; // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
	bool WantDelete; // Set to invalidate/delete the settings entry

	ImGuiWindowSettings() { memset(this, 0, sizeof(*this)); }
	char *GetName() { return (char *)(this + 1); }
};

struct ImGuiSettingsHandler {
	const char *TypeName; // Short description stored in .ini file. Disallowed characters: '[' ']'
	ImGuiID TypeHash; // == ImHashStr(TypeName)
	void (*ClearAllFn)(ImGuiContext *ctx, ImGuiSettingsHandler *handler); // Clear all settings data
	void (*ReadInitFn)(ImGuiContext *ctx, ImGuiSettingsHandler *handler); // Read: Called before reading (in registration order)
	void *(*ReadOpenFn)(ImGuiContext *ctx, ImGuiSettingsHandler *handler, const char *name); // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
	void (*ReadLineFn)(ImGuiContext *ctx, ImGuiSettingsHandler *handler, void *entry, const char *line); // Read: Called for every line of text within an ini entry
	void (*ApplyAllFn)(ImGuiContext *ctx, ImGuiSettingsHandler *handler); // Read: Called after reading (in registration order)
	void (*WriteAllFn)(ImGuiContext *ctx, ImGuiSettingsHandler *handler, ImGuiTextBuffer *out_buf); // Write: Output every entries into 'out_buf'
	void *UserData;

	ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Localization support
//-----------------------------------------------------------------------------

// This is experimental and not officially supported, it'll probably fall short of features, if/when it does we may backtrack.
enum ImGuiLocKey : int {
	ImGuiLocKey_VersionStr,
	ImGuiLocKey_TableSizeOne,
	ImGuiLocKey_TableSizeAllFit,
	ImGuiLocKey_TableSizeAllDefault,
	ImGuiLocKey_TableResetOrder,
	ImGuiLocKey_WindowingMainMenuBar,
	ImGuiLocKey_WindowingPopup,
	ImGuiLocKey_WindowingUntitled,
	ImGuiLocKey_CopyLink,
	ImGuiLocKey_COUNT
};

struct ImGuiLocEntry {
	ImGuiLocKey Key;
	const char *Text;
};

//-----------------------------------------------------------------------------
// [SECTION] Metrics, Debug Tools
//-----------------------------------------------------------------------------

enum ImGuiDebugLogFlags_ {
	// Event types
	ImGuiDebugLogFlags_None = 0,
	ImGuiDebugLogFlags_EventActiveId = 1 << 0,
	ImGuiDebugLogFlags_EventFocus = 1 << 1,
	ImGuiDebugLogFlags_EventPopup = 1 << 2,
	ImGuiDebugLogFlags_EventNav = 1 << 3,
	ImGuiDebugLogFlags_EventClipper = 1 << 4,
	ImGuiDebugLogFlags_EventSelection = 1 << 5,
	ImGuiDebugLogFlags_EventIO = 1 << 6,
	ImGuiDebugLogFlags_EventInputRouting = 1 << 7,

	ImGuiDebugLogFlags_EventMask_ = ImGuiDebugLogFlags_EventActiveId | ImGuiDebugLogFlags_EventFocus | ImGuiDebugLogFlags_EventPopup | ImGuiDebugLogFlags_EventNav | ImGuiDebugLogFlags_EventClipper | ImGuiDebugLogFlags_EventSelection | ImGuiDebugLogFlags_EventIO | ImGuiDebugLogFlags_EventInputRouting,
	ImGuiDebugLogFlags_OutputToTTY = 1 << 20, // Also send output to TTY
	ImGuiDebugLogFlags_OutputToTestEngine = 1 << 21, // Also send output to Test Engine
};

struct ImGuiDebugAllocEntry {
	int FrameCount;
	ImS16 AllocCount;
	ImS16 FreeCount;
};

struct ImGuiDebugAllocInfo {
	int TotalAllocCount; // Number of call to MemAlloc().
	int TotalFreeCount;
	ImS16 LastEntriesIdx; // Current index in buffer
	ImGuiDebugAllocEntry LastEntriesBuf[6]; // Track last 6 frames that had allocations

	ImGuiDebugAllocInfo() { memset(this, 0, sizeof(*this)); }
};

struct ImGuiMetricsConfig {
	bool ShowDebugLog = false;
	bool ShowIDStackTool = false;
	bool ShowWindowsRects = false;
	bool ShowWindowsBeginOrder = false;
	bool ShowTablesRects = false;
	bool ShowDrawCmdMesh = true;
	bool ShowDrawCmdBoundingBoxes = true;
	bool ShowTextEncodingViewer = false;
	bool ShowAtlasTintedWithTextColor = false;
	int ShowWindowsRectsType = -1;
	int ShowTablesRectsType = -1;
	int HighlightMonitorIdx = -1;
	ImGuiID HighlightViewportID = 0;
};

struct ImGuiStackLevelInfo {
	ImGuiID ID;
	ImS8 QueryFrameCount; // >= 1: Query in progress
	bool QuerySuccess; // Obtained result from DebugHookIdInfo()
	ImGuiDataType DataType : 8;
	char Desc[57]; // Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.

	ImGuiStackLevelInfo() { memset(this, 0, sizeof(*this)); }
};

// State for ID Stack tool queries
struct ImGuiIDStackTool {
	int LastActiveFrame;
	int StackLevel; // -1: query stack and resize Results, >= 0: individual stack level
	ImGuiID QueryId; // ID to query details for
	ImVector<ImGuiStackLevelInfo> Results;
	bool CopyToClipboardOnCtrlC;
	float CopyToClipboardLastTime;

	ImGuiIDStackTool() {
		memset(this, 0, sizeof(*this));
		CopyToClipboardLastTime = -FLT_MAX;
	}
};

//-----------------------------------------------------------------------------
// [SECTION] Generic context hooks
//-----------------------------------------------------------------------------

typedef void (*ImGuiContextHookCallback)(ImGuiContext *ctx, ImGuiContextHook *hook);
enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre,
	ImGuiContextHookType_NewFramePost,
	ImGuiContextHookType_EndFramePre,
	ImGuiContextHookType_EndFramePost,
	ImGuiContextHookType_RenderPre,
	ImGuiContextHookType_RenderPost,
	ImGuiContextHookType_Shutdown,
	ImGuiContextHookType_PendingRemoval_ };

struct ImGuiContextHook {
	ImGuiID HookId; // A unique ID assigned by AddContextHook()
	ImGuiContextHookType Type;
	ImGuiID Owner;
	ImGuiContextHookCallback Callback;
	void *UserData;

	ImGuiContextHook() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] ImGuiContext (main Dear ImGui context)
//-----------------------------------------------------------------------------

struct ImGuiContext {
	bool Initialized;
	bool FontAtlasOwnedByContext; // IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
	ImGuiIO IO;
	ImGuiPlatformIO PlatformIO;
	ImGuiStyle Style;
	ImFont *Font; // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
	float FontSize; // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
	float FontBaseSize; // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
	float FontScale; // == FontSize / Font->FontSize
	float CurrentDpiScale; // Current window/viewport DpiScale
	ImDrawListSharedData DrawListSharedData;
	double Time;
	int FrameCount;
	int FrameCountEnded;
	int FrameCountRendered;
	bool WithinFrameScope; // Set by NewFrame(), cleared by EndFrame()
	bool WithinFrameScopeWithImplicitWindow; // Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
	bool WithinEndChild; // Set within EndChild()
	bool GcCompactAll; // Request full GC
	bool TestEngineHookItems; // Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()
	void *TestEngine; // Test engine user data
	char ContextName[16]; // Storage for a context name (to facilitate debugging multi-context setups)

	// Inputs
	ImVector<ImGuiInputEvent> InputEventsQueue; // Input events which will be trickled/written into IO structure.
	ImVector<ImGuiInputEvent> InputEventsTrail; // Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mouse/pen trail.
	ImGuiMouseSource InputEventsNextMouseSource;
	ImU32 InputEventsNextEventId;

	// Windows state
	ImVector<ImGuiWindow *> Windows; // Windows, sorted in display order, back to front
	ImVector<ImGuiWindow *> WindowsFocusOrder; // Root windows, sorted in focus order, back to front.
	ImVector<ImGuiWindow *> WindowsTempSortBuffer; // Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child
	ImVector<ImGuiWindowStackData> CurrentWindowStack;
	ImGuiStorage WindowsById; // Map window's ImGuiID to ImGuiWindow*
	int WindowsActiveCount; // Number of unique windows submitted by frame
	ImVec2 WindowsHoverPadding; // Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING).
	ImGuiID DebugBreakInWindow; // Set to break in Begin() call.
	ImGuiWindow *CurrentWindow; // Window being drawn into
	ImGuiWindow *HoveredWindow; // Window the mouse is hovering. Will typically catch mouse inputs.
	ImGuiWindow *HoveredWindowUnderMovingWindow; // Hovered window ignoring MovingWindow. Only set if MovingWindow is set.
	ImGuiWindow *HoveredWindowBeforeClear; // Window the mouse is hovering. Filled even with _NoMouse. This is currently useful for multi-context compositors.
	ImGuiWindow *MovingWindow; // Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindow.
	ImGuiWindow *WheelingWindow; // Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
	ImVec2 WheelingWindowRefMousePos;
	int WheelingWindowStartFrame; // This may be set one frame before WheelingWindow is != NULL
	int WheelingWindowScrolledFrame;
	float WheelingWindowReleaseTimer;
	ImVec2 WheelingWindowWheelRemainder;
	ImVec2 WheelingAxisAvg;

	// Item/widgets state and tracking information
	ImGuiID DebugHookIdInfo; // Will call core hooks: DebugHookIdInfo() from GetID functions, used by ID Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]
	ImGuiID HoveredId; // Hovered widget, filled during the frame
	ImGuiID HoveredIdPreviousFrame;
	float HoveredIdTimer; // Measure contiguous hovering time
	float HoveredIdNotActiveTimer; // Measure contiguous hovering time where the item has not been active
	bool HoveredIdAllowOverlap;
	bool HoveredIdIsDisabled; // At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.
	bool ItemUnclipByLog; // Disable ItemAdd() clipping, essentially a memory-locality friendly copy of LogEnabled
	ImGuiID ActiveId; // Active widget
	ImGuiID ActiveIdIsAlive; // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
	float ActiveIdTimer;
	bool ActiveIdIsJustActivated; // Set at the time of activation for one frame
	bool ActiveIdAllowOverlap; // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
	bool ActiveIdNoClearOnFocusLoss; // Disable losing active id if the active id window gets unfocused.
	bool ActiveIdHasBeenPressedBefore; // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
	bool ActiveIdHasBeenEditedBefore; // Was the value associated to the widget Edited over the course of the Active state.
	bool ActiveIdHasBeenEditedThisFrame;
	bool ActiveIdFromShortcut;
	int ActiveIdMouseButton : 8;
	ImVec2 ActiveIdClickOffset; // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
	ImGuiWindow *ActiveIdWindow;
	ImGuiInputSource ActiveIdSource; // Activating source: ImGuiInputSource_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad
	ImGuiID ActiveIdPreviousFrame;
	bool ActiveIdPreviousFrameIsAlive;
	bool ActiveIdPreviousFrameHasBeenEditedBefore;
	ImGuiWindow *ActiveIdPreviousFrameWindow;
	ImGuiID LastActiveId; // Store the last non-zero ActiveId, useful for animation.
	float LastActiveIdTimer; // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.

	// Key/Input Ownership + Shortcut Routing system
	// - The idea is that instead of "eating" a given key, we can link to an owner.
	// - Input query can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.
	// - Routing is requested ahead of time for a given chord (Key + Mods) and granted in NewFrame().
	double LastKeyModsChangeTime; // Record the last time key mods changed (affect repeat delay when using shortcut logic)
	double LastKeyModsChangeFromNoneTime; // Record the last time key mods changed away from being 0 (affect repeat delay when using shortcut logic)
	double LastKeyboardKeyPressTime; // Record the last time a keyboard key (ignore mouse/gamepad ones) was pressed.
	ImBitArrayForNamedKeys KeysMayBeCharInput; // Lookup to tell if a key can emit char input, see IsKeyChordPotentiallyCharInput(). sizeof() = 20 bytes
	ImGuiKeyOwnerData KeysOwnerData[ImGuiKey_NamedKey_COUNT];
	ImGuiKeyRoutingTable KeysRoutingTable;
	ImU32 ActiveIdUsingNavDirMask; // Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)
	bool ActiveIdUsingAllKeyboardKeys; // Active widget will want to read all keyboard keys inputs. (this is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations)
	ImGuiKeyChord DebugBreakInShortcutRouting; // Set to break in SetShortcutRouting()/Shortcut() calls.
	//ImU32                 ActiveIdUsingNavInputMask;          // [OBSOLETE] Since (IMGUI_VERSION_NUM >= 18804) : 'g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel);' becomes --> 'SetKeyOwner(ImGuiKey_Escape, g.ActiveId) and/or SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId);'

	// Next window/item data
	ImGuiID CurrentFocusScopeId; // Value for currently appending items == g.FocusScopeStack.back(). Not to be mistaken with g.NavFocusScopeId.
	ImGuiItemFlags CurrentItemFlags; // Value for currently appending items == g.ItemFlagsStack.back()
	ImGuiID DebugLocateId; // Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hot/cached location
	ImGuiNextItemData NextItemData; // Storage for SetNextItem** functions
	ImGuiLastItemData LastItemData; // Storage for last submitted item (setup by ItemAdd)
	ImGuiNextWindowData NextWindowData; // Storage for SetNextWindow** functions
	bool DebugShowGroupRects;

	// Shared stacks
	ImGuiCol DebugFlashStyleColorIdx; // (Keep close to ColorStack to share cache line)
	ImVector<ImGuiColorMod> ColorStack; // Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()
	ImVector<ImGuiStyleMod> StyleVarStack; // Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()
	ImVector<ImFont *> FontStack; // Stack for PushFont()/PopFont() - inherited by Begin()
	ImVector<ImGuiFocusScopeData> FocusScopeStack; // Stack for PushFocusScope()/PopFocusScope() - inherited by BeginChild(), pushed into by Begin()
	ImVector<ImGuiItemFlags> ItemFlagsStack; // Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()
	ImVector<ImGuiGroupData> GroupStack; // Stack for BeginGroup()/EndGroup() - not inherited by Begin()
	ImVector<ImGuiPopupData> OpenPopupStack; // Which popups are open (persistent)
	ImVector<ImGuiPopupData> BeginPopupStack; // Which level of BeginPopup() we are in (reset every frame)
	ImVector<ImGuiTreeNodeStackData> TreeNodeStack; // Stack for TreeNode()

	// Viewports
	ImVector<ImGuiViewportP *> Viewports; // Active viewports (Size==1 in 'master' branch). Each viewports hold their copy of ImDrawData.

	// Gamepad/keyboard Navigation
	ImGuiWindow *NavWindow; // Focused window for navigation. Could be called 'FocusedWindow'
	ImGuiID NavId; // Focused item for navigation
	ImGuiID NavFocusScopeId; // Focused focus scope (e.g. selection code often wants to "clear other items" when landing on an item of the same scope)
	ImGuiNavLayer NavLayer; // Focused layer (main scrolling layer, or menu/title bar layer)
	ImGuiID NavActivateId; // ~~ (g.ActiveId == 0) && (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()
	ImGuiID NavActivateDownId; // ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0
	ImGuiID NavActivatePressedId; // ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)
	ImGuiActivateFlags NavActivateFlags;
	ImVector<ImGuiFocusScopeData> NavFocusRoute; // Reversed copy focus scope stack for NavId (should contains NavFocusScopeId). This essentially follow the window->ParentWindowForFocusRoute chain.
	ImGuiID NavHighlightActivatedId;
	float NavHighlightActivatedTimer;
	ImGuiID NavNextActivateId; // Set by ActivateItem(), queued until next frame.
	ImGuiActivateFlags NavNextActivateFlags;
	ImGuiInputSource NavInputSource; // Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputSource_Mouse
	ImGuiSelectionUserData NavLastValidSelectionUserData; // Last valid data passed to SetNextItemSelectionUser(), or -1. For current window. Not reset when focusing an item that doesn't have selection data.
	bool NavIdIsAlive; // Nav widget has been seen this frame ~~ NavRectRel is valid
	bool NavMousePosDirty; // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
	bool NavDisableHighlight; // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
	bool NavDisableMouseHover; // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.

	// Navigation: Init & Move Requests
	bool NavAnyRequest; // ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()
	bool NavInitRequest; // Init request for appearing window to select first item
	bool NavInitRequestFromMove;
	ImGuiNavItemData NavInitResult; // Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)
	bool NavMoveSubmitted; // Move request submitted, will process result on next NewFrame()
	bool NavMoveScoringItems; // Move request submitted, still scoring incoming items
	bool NavMoveForwardToNextFrame;
	ImGuiNavMoveFlags NavMoveFlags;
	ImGuiScrollFlags NavMoveScrollFlags;
	ImGuiKeyChord NavMoveKeyMods;
	ImGuiDir NavMoveDir; // Direction of the move request (left/right/up/down)
	ImGuiDir NavMoveDirForDebug;
	ImGuiDir NavMoveClipDir; // FIXME-NAV: Describe the purpose of this better. Might want to rename?
	ImRect NavScoringRect; // Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.
	ImRect NavScoringNoClipRect; // Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted
	int NavScoringDebugCount; // Metrics for debugging
	int NavTabbingDir; // Generally -1 or +1, 0 when tabbing without a nav id
	int NavTabbingCounter; // >0 when counting items for tabbing
	ImGuiNavItemData NavMoveResultLocal; // Best move request candidate within NavWindow
	ImGuiNavItemData NavMoveResultLocalVisible; // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
	ImGuiNavItemData NavMoveResultOther; // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)
	ImGuiNavItemData NavTabbingResultFirst; // First tabbing request candidate within NavWindow and flattened hierarchy

	// Navigation: record of last move request
	ImGuiID NavJustMovedFromFocusScopeId; // Just navigated from this focus scope id (result of a successfully MoveRequest).
	ImGuiID NavJustMovedToId; // Just navigated to this id (result of a successfully MoveRequest).
	ImGuiID NavJustMovedToFocusScopeId; // Just navigated to this focus scope id (result of a successfully MoveRequest).
	ImGuiKeyChord NavJustMovedToKeyMods;
	bool NavJustMovedToIsTabbing; // Copy of ImGuiNavMoveFlags_IsTabbing. Maybe we should store whole flags.
	bool NavJustMovedToHasSelectionData; // Copy of move result's InFlags & ImGuiItemFlags_HasSelectionUserData). Maybe we should just store ImGuiNavItemData.

	// Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to move/resize)
	ImGuiKeyChord ConfigNavWindowingKeyNext; // = ImGuiMod_Ctrl | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiKey_Tab on OS X). For reconfiguration (see #4828)
	ImGuiKeyChord ConfigNavWindowingKeyPrev; // = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab on OS X)
	ImGuiWindow *NavWindowingTarget; // Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!
	ImGuiWindow *NavWindowingTargetAnim; // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.
	ImGuiWindow *NavWindowingListWindow; // Internal window actually listing the CTRL+Tab contents
	float NavWindowingTimer;
	float NavWindowingHighlightAlpha;
	bool NavWindowingToggleLayer;
	ImGuiKey NavWindowingToggleKey;
	ImVec2 NavWindowingAccumDeltaPos;
	ImVec2 NavWindowingAccumDeltaSize;

	// Render
	float DimBgRatio; // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)

	// Drag and Drop
	bool DragDropActive;
	bool DragDropWithinSource; // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.
	bool DragDropWithinTarget; // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.
	ImGuiDragDropFlags DragDropSourceFlags;
	int DragDropSourceFrameCount;
	int DragDropMouseButton;
	ImGuiPayload DragDropPayload;
	ImRect DragDropTargetRect; // Store rectangle of current target candidate (we favor small targets when overlapping)
	ImRect DragDropTargetClipRect; // Store ClipRect at the time of item's drawing
	ImGuiID DragDropTargetId;
	ImGuiDragDropFlags DragDropAcceptFlags;
	float DragDropAcceptIdCurrRectSurface; // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
	ImGuiID DragDropAcceptIdCurr; // Target item id (set at the time of accepting the payload)
	ImGuiID DragDropAcceptIdPrev; // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
	int DragDropAcceptFrameCount; // Last time a target expressed a desire to accept the source
	ImGuiID DragDropHoldJustPressedId; // Set when holding a payload just made ButtonBehavior() return a press.
	ImVector<unsigned char> DragDropPayloadBufHeap; // We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size
	unsigned char DragDropPayloadBufLocal[16]; // Local buffer for small payloads

	// Clipper
	int ClipperTempDataStacked;
	ImVector<ImGuiListClipperData> ClipperTempData;

	// Tables
	ImGuiTable *CurrentTable;
	ImGuiID DebugBreakInTable; // Set to break in BeginTable() call.
	int TablesTempDataStacked; // Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)
	ImVector<ImGuiTableTempData> TablesTempData; // Temporary table data (buffers reused/shared across instances, support nesting)
	ImPool<ImGuiTable> Tables; // Persistent table data
	ImVector<float> TablesLastTimeActive; // Last used timestamp of each tables (SOA, for efficient GC)
	ImVector<ImDrawChannel> DrawChannelsTempMergeBuffer;

	// Tab bars
	ImGuiTabBar *CurrentTabBar;
	ImPool<ImGuiTabBar> TabBars;
	ImVector<ImGuiPtrOrIndex> CurrentTabBarStack;
	ImVector<ImGuiShrinkWidthItem> ShrinkWidthBuffer;

	// Multi-Select state
	ImGuiBoxSelectState BoxSelectState;
	ImGuiMultiSelectTempData *CurrentMultiSelect;
	int MultiSelectTempDataStacked; // Temporary multi-select data size (because we leave previous instances undestructed, we generally don't use MultiSelectTempData.Size)
	ImVector<ImGuiMultiSelectTempData> MultiSelectTempData;
	ImPool<ImGuiMultiSelectState> MultiSelectStorage;

	// Hover Delay system
	ImGuiID HoverItemDelayId;
	ImGuiID HoverItemDelayIdPreviousFrame;
	float HoverItemDelayTimer; // Currently used by IsItemHovered()
	float HoverItemDelayClearTimer; // Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.
	ImGuiID HoverItemUnlockedStationaryId; // Mouse has once been stationary on this item. Only reset after departing the item.
	ImGuiID HoverWindowUnlockedStationaryId; // Mouse has once been stationary on this window. Only reset after departing the window.

	// Mouse state
	ImGuiMouseCursor MouseCursor;
	float MouseStationaryTimer; // Time the mouse has been stationary (with some loose heuristic)
	ImVec2 MouseLastValidPos;

	// Widget state
	ImGuiInputTextState InputTextState;
	ImGuiInputTextDeactivatedState InputTextDeactivatedState;
	ImFont InputTextPasswordFont;
	ImGuiID TempInputId; // Temporary text input when CTRL+clicking on a slider, etc.
	ImGuiDataTypeStorage DataTypeZeroValue; // 0 for all data types
	int BeginMenuDepth;
	int BeginComboDepth;
	ImGuiColorEditFlags ColorEditOptions; // Store user options for color edit widgets
	ImGuiID ColorEditCurrentID; // Set temporarily while inside of the parent-most ColorEdit4/ColorPicker4 (because they call each others).
	ImGuiID ColorEditSavedID; // ID we are saving/restoring HS for
	float ColorEditSavedHue; // Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips
	float ColorEditSavedSat; // Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips
	ImU32 ColorEditSavedColor; // RGB value with alpha set to 0.
	ImVec4 ColorPickerRef; // Initial/reference color at the time of opening the color picker.
	ImGuiComboPreviewData ComboPreviewData;
	ImRect WindowResizeBorderExpectedRect; // Expected border rect, switch to relative edit if moving
	bool WindowResizeRelativeMode;
	short ScrollbarSeekMode; // 0: relative, -1/+1: prev/next page.
	float ScrollbarClickDeltaToGrabCenter; // Distance between mouse and center of grab box, normalized in parent space. Use storage?
	float SliderGrabClickOffset;
	float SliderCurrentAccum; // Accumulated slider delta when using navigation controls.
	bool SliderCurrentAccumDirty; // Has the accumulated slider delta changed since last time we tried to apply it?
	bool DragCurrentAccumDirty;
	float DragCurrentAccum; // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
	float DragSpeedDefaultRatio; // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
	float DisabledAlphaBackup; // Backup for style.Alpha for BeginDisabled()
	short DisabledStackSize;
	short LockMarkEdited;
	short TooltipOverrideCount;
	ImVector<char> ClipboardHandlerData; // If no custom clipboard handler is defined
	ImVector<ImGuiID> MenusIdSubmittedThisFrame; // A list of menu IDs that were rendered at least once
	ImGuiTypingSelectState TypingSelectState; // State for GetTypingSelectRequest()

	// Platform support
	ImGuiPlatformImeData PlatformImeData; // Data updated by current frame
	ImGuiPlatformImeData PlatformImeDataPrev; // Previous frame data. When changed we call the platform_io.Platform_SetImeDataFn() handler.

	// Settings
	bool SettingsLoaded;
	float SettingsDirtyTimer; // Save .ini Settings to memory when time reaches zero
	ImGuiTextBuffer SettingsIniData; // In memory .ini settings
	ImVector<ImGuiSettingsHandler> SettingsHandlers; // List of .ini settings handlers
	ImChunkStream<ImGuiWindowSettings> SettingsWindows; // ImGuiWindow .ini settings entries
	ImChunkStream<ImGuiTableSettings> SettingsTables; // ImGuiTable .ini settings entries
	ImVector<ImGuiContextHook> Hooks; // Hooks for extensions (e.g. test engine)
	ImGuiID HookIdNext; // Next available HookId

	// Localization
	const char *LocalizationTable[ImGuiLocKey_COUNT];

	// Capture/Logging
	bool LogEnabled; // Currently capturing
	ImGuiLogType LogType; // Capture target
	ImFileHandle LogFile; // If != NULL log to stdout/ file
	ImGuiTextBuffer LogBuffer; // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
	const char *LogNextPrefix;
	const char *LogNextSuffix;
	float LogLinePosY;
	bool LogLineFirstItem;
	int LogDepthRef;
	int LogDepthToExpand;
	int LogDepthToExpandDefault; // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.

	// Debug Tools
	// (some of the highly frequently used data are interleaved in other structures above: DebugBreakXXX fields, DebugHookIdInfo, DebugLocateId etc.)
	ImGuiDebugLogFlags DebugLogFlags;
	ImGuiTextBuffer DebugLogBuf;
	ImGuiTextIndex DebugLogIndex;
	ImGuiDebugLogFlags DebugLogAutoDisableFlags;
	ImU8 DebugLogAutoDisableFrames;
	ImU8 DebugLocateFrames; // For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hot/cached spot above.
	bool DebugBreakInLocateId; // Debug break in ItemAdd() call for g.DebugLocateId.
	ImGuiKeyChord DebugBreakKeyChord; // = ImGuiKey_Pause
	ImS8 DebugBeginReturnValueCullDepth; // Cycle between 0..9 then wrap around.
	bool DebugItemPickerActive; // Item picker is active (started with DebugStartItemPicker())
	ImU8 DebugItemPickerMouseButton;
	ImGuiID DebugItemPickerBreakId; // Will call IM_DEBUG_BREAK() when encountering this ID
	float DebugFlashStyleColorTime;
	ImVec4 DebugFlashStyleColorBackup;
	ImGuiMetricsConfig DebugMetricsConfig;
	ImGuiIDStackTool DebugIDStackTool;
	ImGuiDebugAllocInfo DebugAllocInfo;

	// Misc
	float FramerateSecPerFrame[60]; // Calculate estimate of framerate for user over the last 60 frames..
	int FramerateSecPerFrameIdx;
	int FramerateSecPerFrameCount;
	float FramerateSecPerFrameAccum;
	int WantCaptureMouseNextFrame; // Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.
	int WantCaptureKeyboardNextFrame; // "
	int WantTextInputNextFrame;
	ImVector<char> TempBuffer; // Temporary text buffer
	char TempKeychordName[64];

	ImGuiContext(ImFontAtlas *shared_font_atlas) {
		IO.Ctx = this;
		InputTextState.Ctx = this;

		Initialized = false;
		FontAtlasOwnedByContext = shared_font_atlas ? false : true;
		Font = NULL;
		FontSize = FontBaseSize = FontScale = CurrentDpiScale = 0.0f;
		IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();
		Time = 0.0f;
		FrameCount = 0;
		FrameCountEnded = FrameCountRendered = -1;
		WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
		GcCompactAll = false;
		TestEngineHookItems = false;
		TestEngine = NULL;
		memset(ContextName, 0, sizeof(ContextName));

		InputEventsNextMouseSource = ImGuiMouseSource_Mouse;
		InputEventsNextEventId = 1;

		WindowsActiveCount = 0;
		CurrentWindow = NULL;
		HoveredWindow = NULL;
		HoveredWindowUnderMovingWindow = NULL;
		HoveredWindowBeforeClear = NULL;
		MovingWindow = NULL;
		WheelingWindow = NULL;
		WheelingWindowStartFrame = WheelingWindowScrolledFrame = -1;
		WheelingWindowReleaseTimer = 0.0f;

		DebugHookIdInfo = 0;
		HoveredId = HoveredIdPreviousFrame = 0;
		HoveredIdAllowOverlap = false;
		HoveredIdIsDisabled = false;
		HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
		ItemUnclipByLog = false;
		ActiveId = 0;
		ActiveIdIsAlive = 0;
		ActiveIdTimer = 0.0f;
		ActiveIdIsJustActivated = false;
		ActiveIdAllowOverlap = false;
		ActiveIdNoClearOnFocusLoss = false;
		ActiveIdHasBeenPressedBefore = false;
		ActiveIdHasBeenEditedBefore = false;
		ActiveIdHasBeenEditedThisFrame = false;
		ActiveIdFromShortcut = false;
		ActiveIdClickOffset = ImVec2(-1, -1);
		ActiveIdWindow = NULL;
		ActiveIdSource = ImGuiInputSource_None;
		ActiveIdMouseButton = -1;
		ActiveIdPreviousFrame = 0;
		ActiveIdPreviousFrameIsAlive = false;
		ActiveIdPreviousFrameHasBeenEditedBefore = false;
		ActiveIdPreviousFrameWindow = NULL;
		LastActiveId = 0;
		LastActiveIdTimer = 0.0f;

		LastKeyboardKeyPressTime = LastKeyModsChangeTime = LastKeyModsChangeFromNoneTime = -1.0;

		ActiveIdUsingNavDirMask = 0x00;
		ActiveIdUsingAllKeyboardKeys = false;

		CurrentFocusScopeId = 0;
		CurrentItemFlags = ImGuiItemFlags_None;
		DebugShowGroupRects = false;

		NavWindow = NULL;
		NavId = NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = 0;
		NavLayer = ImGuiNavLayer_Main;
		NavNextActivateId = 0;
		NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;
		NavHighlightActivatedId = 0;
		NavHighlightActivatedTimer = 0.0f;
		NavInputSource = ImGuiInputSource_Keyboard;
		NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
		NavIdIsAlive = false;
		NavMousePosDirty = false;
		NavDisableHighlight = true;
		NavDisableMouseHover = false;

		NavAnyRequest = false;
		NavInitRequest = false;
		NavInitRequestFromMove = false;
		NavMoveSubmitted = false;
		NavMoveScoringItems = false;
		NavMoveForwardToNextFrame = false;
		NavMoveFlags = ImGuiNavMoveFlags_None;
		NavMoveScrollFlags = ImGuiScrollFlags_None;
		NavMoveKeyMods = ImGuiMod_None;
		NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;
		NavScoringDebugCount = 0;
		NavTabbingDir = 0;
		NavTabbingCounter = 0;

		NavJustMovedFromFocusScopeId = NavJustMovedToId = NavJustMovedToFocusScopeId = 0;
		NavJustMovedToKeyMods = ImGuiMod_None;
		NavJustMovedToIsTabbing = false;
		NavJustMovedToHasSelectionData = false;

		// All platforms use Ctrl+Tab but Ctrl<>Super are swapped on Mac...
		// FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..
		ConfigNavWindowingKeyNext = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiKey_Tab);
		ConfigNavWindowingKeyPrev = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab);
		NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;
		NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
		NavWindowingToggleLayer = false;
		NavWindowingToggleKey = ImGuiKey_None;

		DimBgRatio = 0.0f;

		DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
		DragDropSourceFlags = ImGuiDragDropFlags_None;
		DragDropSourceFrameCount = -1;
		DragDropMouseButton = -1;
		DragDropTargetId = 0;
		DragDropAcceptFlags = ImGuiDragDropFlags_None;
		DragDropAcceptIdCurrRectSurface = 0.0f;
		DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
		DragDropAcceptFrameCount = -1;
		DragDropHoldJustPressedId = 0;
		memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

		ClipperTempDataStacked = 0;

		CurrentTable = NULL;
		TablesTempDataStacked = 0;
		CurrentTabBar = NULL;
		CurrentMultiSelect = NULL;
		MultiSelectTempDataStacked = 0;

		HoverItemDelayId = HoverItemDelayIdPreviousFrame = HoverItemUnlockedStationaryId = HoverWindowUnlockedStationaryId = 0;
		HoverItemDelayTimer = HoverItemDelayClearTimer = 0.0f;

		MouseCursor = ImGuiMouseCursor_Arrow;
		MouseStationaryTimer = 0.0f;

		TempInputId = 0;
		memset(&DataTypeZeroValue, 0, sizeof(DataTypeZeroValue));
		BeginMenuDepth = BeginComboDepth = 0;
		ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
		ColorEditCurrentID = ColorEditSavedID = 0;
		ColorEditSavedHue = ColorEditSavedSat = 0.0f;
		ColorEditSavedColor = 0;
		WindowResizeRelativeMode = false;
		ScrollbarSeekMode = 0;
		ScrollbarClickDeltaToGrabCenter = 0.0f;
		SliderGrabClickOffset = 0.0f;
		SliderCurrentAccum = 0.0f;
		SliderCurrentAccumDirty = false;
		DragCurrentAccumDirty = false;
		DragCurrentAccum = 0.0f;
		DragSpeedDefaultRatio = 1.0f / 100.0f;
		DisabledAlphaBackup = 0.0f;
		DisabledStackSize = 0;
		LockMarkEdited = 0;
		TooltipOverrideCount = 0;

		PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);
		PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f); // Different to ensure initial submission

		SettingsLoaded = false;
		SettingsDirtyTimer = 0.0f;
		HookIdNext = 0;

		memset(LocalizationTable, 0, sizeof(LocalizationTable));

		LogEnabled = false;
		LogType = ImGuiLogType_None;
		LogNextPrefix = LogNextSuffix = NULL;
		LogFile = NULL;
		LogLinePosY = FLT_MAX;
		LogLineFirstItem = false;
		LogDepthRef = 0;
		LogDepthToExpand = LogDepthToExpandDefault = 2;

		DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;
		DebugLocateId = 0;
		DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;
		DebugLogAutoDisableFrames = 0;
		DebugLocateFrames = 0;
		DebugBeginReturnValueCullDepth = -1;
		DebugItemPickerActive = false;
		DebugItemPickerMouseButton = ImGuiMouseButton_Left;
		DebugItemPickerBreakId = 0;
		DebugFlashStyleColorTime = 0.0f;
		DebugFlashStyleColorIdx = ImGuiCol_COUNT;

		// Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations
		DebugBreakInWindow = 0;
		DebugBreakInTable = 0;
		DebugBreakInLocateId = false;
		DebugBreakKeyChord = ImGuiKey_Pause;
		DebugBreakInShortcutRouting = ImGuiKey_None;

		memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
		FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
		FramerateSecPerFrameAccum = 0.0f;
		WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
		memset(TempKeychordName, 0, sizeof(TempKeychordName));
	}
};

//-----------------------------------------------------------------------------
// [SECTION] ImGuiWindowTempData, ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)
// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)
struct IMGUI_API ImGuiWindowTempData {
	// Layout
	ImVec2 CursorPos; // Current emitting position, in absolute coordinates.
	ImVec2 CursorPosPrevLine;
	ImVec2 CursorStartPos; // Initial position after Begin(), generally ~ window position + WindowPadding.
	ImVec2 CursorMaxPos; // Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.
	ImVec2 IdealMaxPos; // Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.
	ImVec2 CurrLineSize;
	ImVec2 PrevLineSize;
	float CurrLineTextBaseOffset; // Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
	float PrevLineTextBaseOffset;
	bool IsSameLine;
	bool IsSetPos;
	ImVec1 Indent; // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
	ImVec1 ColumnsOffset; // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
	ImVec1 GroupOffset;
	ImVec2 CursorStartPosLossyness; // Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensate and fix the most common use case of large scroll area.

	// Keyboard/Gamepad navigation
	ImGuiNavLayer NavLayerCurrent; // Current layer, 0..31 (we currently only use 0..1)
	short NavLayersActiveMask; // Which layers have been written to (result from previous frame)
	short NavLayersActiveMaskNext; // Which layers have been written to (accumulator for current frame)
	bool NavIsScrollPushableX; // Set when current work location may be scrolled horizontally when moving left / right. This is generally always true UNLESS within a column.
	bool NavHideHighlightOneFrame;
	bool NavWindowHasScrollY; // Set per window when scrolling can be used (== ScrollMax.y > 0.0f)

	// Miscellaneous
	bool MenuBarAppending; // FIXME: Remove this
	ImVec2 MenuBarOffset; // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
	ImGuiMenuColumns MenuColumns; // Simplified columns storage for menu items measurement
	int TreeDepth; // Current tree depth.
	ImU32 TreeHasStackDataDepthMask; // Store whether given depth has ImGuiTreeNodeStackData data. Could be turned into a ImU64 if necessary.
	ImVector<ImGuiWindow *> ChildWindows;
	ImGuiStorage *StateStorage; // Current persistent per-window storage (store e.g. tree node open/close state)
	ImGuiOldColumns *CurrentColumns; // Current columns set
	int CurrentTableIdx; // Current table index (into g.Tables)
	ImGuiLayoutType LayoutType;
	ImGuiLayoutType ParentLayoutType; // Layout type of parent window at the time of Begin()
	ImU32 ModalDimBgColor;

	// Local parameters stacks
	// We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
	float ItemWidth; // Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).
	float TextWrapPos; // Current text wrap pos.
	ImVector<float> ItemWidthStack; // Store item widths to restore (attention: .back() is not == ItemWidth)
	ImVector<float> TextWrapPosStack; // Store text wrap pos to restore (attention: .back() is not == TextWrapPos)
};

// Storage for one window
struct IMGUI_API ImGuiWindow {
	ImGuiContext *Ctx; // Parent UI context (needs to be set explicitly by parent).
	char *Name; // Window name, owned by the window.
	ImGuiID ID; // == ImHashStr(Name)
	ImGuiWindowFlags Flags; // See enum ImGuiWindowFlags_
	ImGuiChildFlags ChildFlags; // Set when window is a child window. See enum ImGuiChildFlags_
	ImGuiViewportP *Viewport; // Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.
	ImVec2 Pos; // Position (always rounded-up to nearest pixel)
	ImVec2 Size; // Current size (==SizeFull or collapsed title bar size)
	ImVec2 SizeFull; // Size when non collapsed
	ImVec2 ContentSize; // Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
	ImVec2 ContentSizeIdeal;
	ImVec2 ContentSizeExplicit; // Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
	ImVec2 WindowPadding; // Window padding at the time of Begin().
	float WindowRounding; // Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.
	float WindowBorderSize; // Window border size at the time of Begin().
	float TitleBarHeight, MenuBarHeight; // Note that those used to be function before 2024/05/28. If you have old code calling TitleBarHeight() you can change it to TitleBarHeight.
	float DecoOuterSizeX1, DecoOuterSizeY1; // Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().
	float DecoOuterSizeX2, DecoOuterSizeY2; // Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).
	float DecoInnerSizeX1, DecoInnerSizeY1; // Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).
	int NameBufLen; // Size of buffer storing Name. May be larger than strlen(Name)!
	ImGuiID MoveId; // == window->GetID("#MOVE")
	ImGuiID ChildId; // ID of corresponding item in parent window (for navigation to return from child window to parent window)
	ImGuiID PopupId; // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
	ImVec2 Scroll;
	ImVec2 ScrollMax;
	ImVec2 ScrollTarget; // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
	ImVec2 ScrollTargetCenterRatio; // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
	ImVec2 ScrollTargetEdgeSnapDist; // 0.0f = no snapping, >0.0f snapping threshold
	ImVec2 ScrollbarSizes; // Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.
	bool ScrollbarX, ScrollbarY; // Are scrollbars visible?
	bool Active; // Set to true on Begin(), unless Collapsed
	bool WasActive;
	bool WriteAccessed; // Set to true when any widget access the current window
	bool Collapsed; // Set when collapsing window to become only title-bar
	bool WantCollapseToggle;
	bool SkipItems; // Set when items can safely be all clipped (e.g. window not visible or collapsed)
	bool SkipRefresh; // [EXPERIMENTAL] Reuse previous frame drawn contents, Begin() returns false.
	bool Appearing; // Set during the frame where the window is appearing (or re-appearing)
	bool Hidden; // Do not display (== HiddenFrames*** > 0)
	bool IsFallbackWindow; // Set on the "Debug##Default" window.
	bool IsExplicitChild; // Set when passed _ChildWindow, left to false by BeginDocked()
	bool HasCloseButton; // Set when the window has a close button (p_open != NULL)
	signed char ResizeBorderHovered; // Current border being hovered for resize (-1: none, otherwise 0-3)
	signed char ResizeBorderHeld; // Current border being held for resize (-1: none, otherwise 0-3)
	short BeginCount; // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
	short BeginCountPreviousFrame; // Number of Begin() during the previous frame
	short BeginOrderWithinParent; // Begin() order within immediate parent window, if we are a child window. Otherwise 0.
	short BeginOrderWithinContext; // Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.
	short FocusOrder; // Order within WindowsFocusOrder[], altered when windows are focused.
	ImS8 AutoFitFramesX, AutoFitFramesY;
	bool AutoFitOnlyGrows;
	ImGuiDir AutoPosLastDirection;
	ImS8 HiddenFramesCanSkipItems; // Hide the window for N frames
	ImS8 HiddenFramesCannotSkipItems; // Hide the window for N frames while allowing items to be submitted so we can measure their size
	ImS8 HiddenFramesForRenderOnly; // Hide the window until frame N at Render() time only
	ImS8 DisableInputsFrames; // Disable window interactions for N frames
	ImGuiCond SetWindowPosAllowFlags : 8; // store acceptable condition flags for SetNextWindowPos() use.
	ImGuiCond SetWindowSizeAllowFlags : 8; // store acceptable condition flags for SetNextWindowSize() use.
	ImGuiCond SetWindowCollapsedAllowFlags : 8; // store acceptable condition flags for SetNextWindowCollapsed() use.
	ImVec2 SetWindowPosVal; // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
	ImVec2 SetWindowPosPivot; // store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.

	ImVector<ImGuiID> IDStack; // ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
	ImGuiWindowTempData DC; // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.

	// The best way to understand what those rectangles are is to use the 'Metrics->Tools->Show Windows Rectangles' viewer.
	// The main 'OuterRect', omitted as a field, is window->Rect().
	ImRect OuterRectClipped; // == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
	ImRect InnerRect; // Inner rectangle (omit title bar, menu bar, scroll bar)
	ImRect InnerClipRect; // == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
	ImRect WorkRect; // Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
	ImRect ParentWorkRect; // Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?
	ImRect ClipRect; // Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
	ImRect ContentRegionRect; // FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.
	ImVec2ih HitTestHoleSize; // Define an optional rectangular hole where mouse will pass-through the window.
	ImVec2ih HitTestHoleOffset;

	int LastFrameActive; // Last frame number the window was Active.
	float LastTimeActive; // Last timestamp the window was Active (using float as we don't need high precision there)
	float ItemWidthDefault;
	ImGuiStorage StateStorage;
	ImVector<ImGuiOldColumns> ColumnsStorage;
	float FontWindowScale; // User scale multiplier per-window, via SetWindowFontScale()
	int SettingsOffset; // Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)

	ImDrawList *DrawList; // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
	ImDrawList DrawListInst;
	ImGuiWindow *ParentWindow; // If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.
	ImGuiWindow *ParentWindowInBeginStack;
	ImGuiWindow *RootWindow; // Point to ourself or first ancestor that is not a child window. Doesn't cross through popups/dock nodes.
	ImGuiWindow *RootWindowPopupTree; // Point to ourself or first ancestor that is not a child window. Cross through popups parent<>child.
	ImGuiWindow *RootWindowForTitleBarHighlight; // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
	ImGuiWindow *RootWindowForNav; // Point to ourself or first ancestor which doesn't have the NavFlattened flag.
	ImGuiWindow *ParentWindowForFocusRoute; // Set to manual link a window to its logical parent so that Shortcut() chain are honoerd (e.g. Tool linked to Document)

	ImGuiWindow *NavLastChildNavWindow; // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
	ImGuiID NavLastIds[ImGuiNavLayer_COUNT]; // Last known NavId for this window, per layer (0/1)
	ImRect NavRectRel[ImGuiNavLayer_COUNT]; // Reference rectangle, in window relative space
	ImVec2 NavPreferredScoringPosRel[ImGuiNavLayer_COUNT]; // Preferred X/Y position updated when moving on a given axis, reset to FLT_MAX.
	ImGuiID NavRootFocusScopeId; // Focus Scope ID at the time of Begin()

	int MemoryDrawListIdxCapacity; // Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy
	int MemoryDrawListVtxCapacity;
	bool MemoryCompacted; // Set when window extraneous data have been garbage collected

public:
	ImGuiWindow(ImGuiContext *context, const char *name);
	~ImGuiWindow();

	ImGuiID GetID(const char *str, const char *str_end = NULL);
	ImGuiID GetID(const void *ptr);
	ImGuiID GetID(int n);
	ImGuiID GetIDFromPos(const ImVec2 &p_abs);
	ImGuiID GetIDFromRectangle(const ImRect &r_abs);

	// We don't use g.FontSize because the window may be != g.CurrentWindow.
	ImRect Rect() const { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
	float CalcFontSize() const {
		ImGuiContext &g = *Ctx;
		float scale = g.FontBaseSize * FontWindowScale;
		if (ParentWindow)
			scale *= ParentWindow->FontWindowScale;
		return scale;
	}
	ImRect TitleBarRect() const { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight)); }
	ImRect MenuBarRect() const {
		float y1 = Pos.y + TitleBarHeight;
		return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight);
	}
};

//-----------------------------------------------------------------------------
// [SECTION] Tab bar, Tab item support
//-----------------------------------------------------------------------------

// Extend ImGuiTabBarFlags_
enum ImGuiTabBarFlagsPrivate_ {
	ImGuiTabBarFlags_DockNode = 1 << 20, // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
	ImGuiTabBarFlags_IsFocused = 1 << 21,
	ImGuiTabBarFlags_SaveSettings = 1 << 22, // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
};

// Extend ImGuiTabItemFlags_
enum ImGuiTabItemFlagsPrivate_ {
	ImGuiTabItemFlags_SectionMask_ = ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing,
	ImGuiTabItemFlags_NoCloseButton = 1 << 20, // Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)
	ImGuiTabItemFlags_Button = 1 << 21, // Used by TabItemButton, change the tab item behavior to mimic a button
};

// Storage for one active tab item (sizeof() 40 bytes)
struct ImGuiTabItem {
	ImGuiID ID;
	ImGuiTabItemFlags Flags;
	int LastFrameVisible;
	int LastFrameSelected; // This allows us to infer an ordered list of the last activated tabs with little maintenance
	float Offset; // Position relative to beginning of tab
	float Width; // Width currently displayed
	float ContentWidth; // Width of label, stored during BeginTabItem() call
	float RequestedWidth; // Width optionally requested by caller, -1.0f is unused
	ImS32 NameOffset; // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
	ImS16 BeginOrder; // BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable
	ImS16 IndexDuringLayout; // Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.
	bool WantClose; // Marked as closed by SetTabItemClosed()

	ImGuiTabItem() {
		memset(this, 0, sizeof(*this));
		LastFrameVisible = LastFrameSelected = -1;
		RequestedWidth = -1.0f;
		NameOffset = -1;
		BeginOrder = IndexDuringLayout = -1;
	}
};

// Storage for a tab bar (sizeof() 152 bytes)
struct IMGUI_API ImGuiTabBar {
	ImVector<ImGuiTabItem> Tabs;
	ImGuiTabBarFlags Flags;
	ImGuiID ID; // Zero for tab-bars used by docking
	ImGuiID SelectedTabId; // Selected tab/window
	ImGuiID NextSelectedTabId; // Next selected tab/window. Will also trigger a scrolling animation
	ImGuiID VisibleTabId; // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
	int CurrFrameVisible;
	int PrevFrameVisible;
	ImRect BarRect;
	float CurrTabsContentsHeight;
	float PrevTabsContentsHeight; // Record the height of contents submitted below the tab bar
	float WidthAllTabs; // Actual width of all tabs (locked during layout)
	float WidthAllTabsIdeal; // Ideal width if all tabs were visible and not clipped
	float ScrollingAnim;
	float ScrollingTarget;
	float ScrollingTargetDistToVisibility;
	float ScrollingSpeed;
	float ScrollingRectMinX;
	float ScrollingRectMaxX;
	float SeparatorMinX;
	float SeparatorMaxX;
	ImGuiID ReorderRequestTabId;
	ImS16 ReorderRequestOffset;
	ImS8 BeginCount;
	bool WantLayout;
	bool VisibleTabWasSubmitted;
	bool TabsAddedNew; // Set to true when a new tab item or button has been added to the tab bar during last frame
	ImS16 TabsActiveCount; // Number of tabs submitted this frame.
	ImS16 LastTabItemIdx; // Index of last BeginTabItem() tab for use by EndTabItem()
	float ItemSpacingY;
	ImVec2 FramePadding; // style.FramePadding locked at the time of BeginTabBar()
	ImVec2 BackupCursorPos;
	ImGuiTextBuffer TabsNames; // For non-docking tab bar we re-append names in a contiguous buffer.

	ImGuiTabBar();
};

//-----------------------------------------------------------------------------
// [SECTION] Table support
//-----------------------------------------------------------------------------

#define IM_COL32_DISABLE IM_COL32(0, 0, 0, 1) // Special sentinel code which cannot be used as a regular color.
#define IMGUI_TABLE_MAX_COLUMNS 512 // May be further lifted

// Our current column maximum is 64 but we may raise that in the future.
typedef ImS16 ImGuiTableColumnIdx;
typedef ImU16 ImGuiTableDrawChannelIdx;

// [Internal] sizeof() ~ 112
// We use the terminology "Enabled" to refer to a column that is not Hidden by user/api.
// We use the terminology "Clipped" to refer to a column that is out of sight because of scrolling/clipping.
// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible" to mean "not clipped".
struct ImGuiTableColumn {
	ImGuiTableColumnFlags Flags; // Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_
	float WidthGiven; // Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.
	float MinX; // Absolute positions
	float MaxX;
	float WidthRequest; // Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()
	float WidthAuto; // Automatic width
	float WidthMax; // Maximum width (FIXME: overwritten by each instance)
	float StretchWeight; // Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.
	float InitStretchWeightOrWidth; // Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).
	ImRect ClipRect; // Clipping rectangle for the column
	ImGuiID UserID; // Optional, value passed to TableSetupColumn()
	float WorkMinX; // Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column
	float WorkMaxX; // Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)
	float ItemWidth; // Current item width for the column, preserved across rows
	float ContentMaxXFrozen; // Contents maximum position for frozen rows (apart from headers), from which we can infer content width.
	float ContentMaxXUnfrozen;
	float ContentMaxXHeadersUsed; // Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls
	float ContentMaxXHeadersIdeal;
	ImS16 NameOffset; // Offset into parent ColumnsNames[]
	ImGuiTableColumnIdx DisplayOrder; // Index within Table's IndexToDisplayOrder[] (column may be reordered by users)
	ImGuiTableColumnIdx IndexWithinEnabledSet; // Index within enabled/visible set (<= IndexToDisplayOrder)
	ImGuiTableColumnIdx PrevEnabledColumn; // Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column
	ImGuiTableColumnIdx NextEnabledColumn; // Index of next enabled/visible column within Columns[], -1 if last enabled/visible column
	ImGuiTableColumnIdx SortOrder; // Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort
	ImGuiTableDrawChannelIdx DrawChannelCurrent; // Index within DrawSplitter.Channels[]
	ImGuiTableDrawChannelIdx DrawChannelFrozen; // Draw channels for frozen rows (often headers)
	ImGuiTableDrawChannelIdx DrawChannelUnfrozen; // Draw channels for unfrozen rows
	bool IsEnabled; // IsUserEnabled && (Flags & ImGuiTableColumnFlags_Disabled) == 0
	bool IsUserEnabled; // Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).
	bool IsUserEnabledNextFrame;
	bool IsVisibleX; // Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).
	bool IsVisibleY;
	bool IsRequestOutput; // Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.
	bool IsSkipItems; // Do we want item submissions to this column to be completely ignored (no layout will happen).
	bool IsPreserveWidthAuto;
	ImS8 NavLayerCurrent; // ImGuiNavLayer in 1 byte
	ImU8 AutoFitQueue; // Queue of 8 values for the next 8 frames to request auto-fit
	ImU8 CannotSkipItemsQueue; // Queue of 8 values for the next 8 frames to disable Clipped/SkipItem
	ImU8 SortDirection : 2; // ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
	ImU8 SortDirectionsAvailCount : 2; // Number of available sort directions (0 to 3)
	ImU8 SortDirectionsAvailMask : 4; // Mask of available sort directions (1-bit each)
	ImU8 SortDirectionsAvailList; // Ordered list of available sort directions (2-bits each, total 8-bits)

	ImGuiTableColumn() {
		memset(this, 0, sizeof(*this));
		StretchWeight = WidthRequest = -1.0f;
		NameOffset = -1;
		DisplayOrder = IndexWithinEnabledSet = -1;
		PrevEnabledColumn = NextEnabledColumn = -1;
		SortOrder = -1;
		SortDirection = ImGuiSortDirection_None;
		DrawChannelCurrent = DrawChannelFrozen = DrawChannelUnfrozen = (ImU8)-1;
	}
};

// Transient cell data stored per row.
// sizeof() ~ 6 bytes
struct ImGuiTableCellData {
	ImU32 BgColor; // Actual color
	ImGuiTableColumnIdx Column; // Column number
};

// Parameters for TableAngledHeadersRowEx()
// This may end up being refactored for more general purpose.
// sizeof() ~ 12 bytes
struct ImGuiTableHeaderData {
	ImGuiTableColumnIdx Index; // Column index
	ImU32 TextColor;
	ImU32 BgColor0;
	ImU32 BgColor1;
};

// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)
// sizeof() ~ 24 bytes
struct ImGuiTableInstanceData {
	ImGuiID TableInstanceID;
	float LastOuterHeight; // Outer height from last frame
	float LastTopHeadersRowHeight; // Height of first consecutive header rows from last frame (FIXME: this is used assuming consecutive headers are in same frozen set)
	float LastFrozenHeight; // Height of frozen section from last frame
	int HoveredRowLast; // Index of row which was hovered last frame.
	int HoveredRowNext; // Index of row hovered this frame, set after encountering it.

	ImGuiTableInstanceData() {
		TableInstanceID = 0;
		LastOuterHeight = LastTopHeadersRowHeight = LastFrozenHeight = 0.0f;
		HoveredRowLast = HoveredRowNext = -1;
	}
};

// sizeof() ~ 592 bytes + heap allocs described in TableBeginInitMemory()
struct IMGUI_API ImGuiTable {
	ImGuiID ID;
	ImGuiTableFlags Flags;
	void *RawData; // Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]
	ImGuiTableTempData *TempData; // Transient data while table is active. Point within g.CurrentTableStack[]
	ImSpan<ImGuiTableColumn> Columns; // Point within RawData[]
	ImSpan<ImGuiTableColumnIdx> DisplayOrderToIndex; // Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)
	ImSpan<ImGuiTableCellData> RowCellData; // Point within RawData[]. Store cells background requests for current row.
	ImBitArrayPtr EnabledMaskByDisplayOrder; // Column DisplayOrder -> IsEnabled map
	ImBitArrayPtr EnabledMaskByIndex; // Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data
	ImBitArrayPtr VisibleMaskByIndex; // Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)
	ImGuiTableFlags SettingsLoadedFlags; // Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)
	int SettingsOffset; // Offset in g.SettingsTables
	int LastFrameActive;
	int ColumnsCount; // Number of columns declared in BeginTable()
	int CurrentRow;
	int CurrentColumn;
	ImS16 InstanceCurrent; // Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.
	ImS16 InstanceInteracted; // Mark which instance (generally 0) of the same ID is being interacted with
	float RowPosY1;
	float RowPosY2;
	float RowMinHeight; // Height submitted to TableNextRow()
	float RowCellPaddingY; // Top and bottom padding. Reloaded during row change.
	float RowTextBaseline;
	float RowIndentOffsetX;
	ImGuiTableRowFlags RowFlags : 16; // Current row flags, see ImGuiTableRowFlags_
	ImGuiTableRowFlags LastRowFlags : 16;
	int RowBgColorCounter; // Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.
	ImU32 RowBgColor[2]; // Background color override for current row.
	ImU32 BorderColorStrong;
	ImU32 BorderColorLight;
	float BorderX1;
	float BorderX2;
	float HostIndentX;
	float MinColumnWidth;
	float OuterPaddingX;
	float CellPaddingX; // Padding from each borders. Locked in BeginTable()/Layout.
	float CellSpacingX1; // Spacing between non-bordered cells. Locked in BeginTable()/Layout.
	float CellSpacingX2;
	float InnerWidth; // User value passed to BeginTable(), see comments at the top of BeginTable() for details.
	float ColumnsGivenWidth; // Sum of current column width
	float ColumnsAutoFitWidth; // Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window
	float ColumnsStretchSumWeights; // Sum of weight of all enabled stretching columns
	float ResizedColumnNextWidth;
	float ResizeLockMinContentsX2; // Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.
	float RefScale; // Reference scale to be able to rescale columns on font/dpi changes.
	float AngledHeadersHeight; // Set by TableAngledHeadersRow(), used in TableUpdateLayout()
	float AngledHeadersSlope; // Set by TableAngledHeadersRow(), used in TableUpdateLayout()
	ImRect OuterRect; // Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().
	ImRect InnerRect; // InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is
	ImRect WorkRect;
	ImRect InnerClipRect;
	ImRect BgClipRect; // We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries
	ImRect Bg0ClipRectForDrawCmd; // Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped
	ImRect Bg2ClipRectForDrawCmd; // Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.
	ImRect HostClipRect; // This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.
	ImRect HostBackupInnerClipRect; // Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()
	ImGuiWindow *OuterWindow; // Parent window for the table
	ImGuiWindow *InnerWindow; // Window holding the table data (== OuterWindow or a child window)
	ImGuiTextBuffer ColumnsNames; // Contiguous buffer holding columns names
	ImDrawListSplitter *DrawSplitter; // Shortcut to TempData->DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly
	ImGuiTableInstanceData InstanceDataFirst;
	ImVector<ImGuiTableInstanceData> InstanceDataExtra; // FIXME-OPT: Using a small-vector pattern would be good.
	ImGuiTableColumnSortSpecs SortSpecsSingle;
	ImVector<ImGuiTableColumnSortSpecs> SortSpecsMulti; // FIXME-OPT: Using a small-vector pattern would be good.
	ImGuiTableSortSpecs SortSpecs; // Public facing sorts specs, this is what we return in TableGetSortSpecs()
	ImGuiTableColumnIdx SortSpecsCount;
	ImGuiTableColumnIdx ColumnsEnabledCount; // Number of enabled columns (<= ColumnsCount)
	ImGuiTableColumnIdx ColumnsEnabledFixedCount; // Number of enabled columns using fixed width (<= ColumnsCount)
	ImGuiTableColumnIdx DeclColumnsCount; // Count calls to TableSetupColumn()
	ImGuiTableColumnIdx AngledHeadersCount; // Count columns with angled headers
	ImGuiTableColumnIdx HoveredColumnBody; // Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!
	ImGuiTableColumnIdx HoveredColumnBorder; // Index of column whose right-border is being hovered (for resizing).
	ImGuiTableColumnIdx HighlightColumnHeader; // Index of column which should be highlighted.
	ImGuiTableColumnIdx AutoFitSingleColumn; // Index of single column requesting auto-fit.
	ImGuiTableColumnIdx ResizedColumn; // Index of column being resized. Reset when InstanceCurrent==0.
	ImGuiTableColumnIdx LastResizedColumn; // Index of column being resized from previous frame.
	ImGuiTableColumnIdx HeldHeaderColumn; // Index of column header being held.
	ImGuiTableColumnIdx ReorderColumn; // Index of column being reordered. (not cleared)
	ImGuiTableColumnIdx ReorderColumnDir; // -1 or +1
	ImGuiTableColumnIdx LeftMostEnabledColumn; // Index of left-most non-hidden column.
	ImGuiTableColumnIdx RightMostEnabledColumn; // Index of right-most non-hidden column.
	ImGuiTableColumnIdx LeftMostStretchedColumn; // Index of left-most stretched column.
	ImGuiTableColumnIdx RightMostStretchedColumn; // Index of right-most stretched column.
	ImGuiTableColumnIdx ContextPopupColumn; // Column right-clicked on, of -1 if opening context menu from a neutral/empty spot
	ImGuiTableColumnIdx FreezeRowsRequest; // Requested frozen rows count
	ImGuiTableColumnIdx FreezeRowsCount; // Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)
	ImGuiTableColumnIdx FreezeColumnsRequest; // Requested frozen columns count
	ImGuiTableColumnIdx FreezeColumnsCount; // Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)
	ImGuiTableColumnIdx RowCellDataCurrent; // Index of current RowCellData[] entry in current row
	ImGuiTableDrawChannelIdx DummyDrawChannel; // Redirect non-visible columns here.
	ImGuiTableDrawChannelIdx Bg2DrawChannelCurrent; // For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]
	ImGuiTableDrawChannelIdx Bg2DrawChannelUnfrozen;
	bool IsLayoutLocked; // Set by TableUpdateLayout() which is called when beginning the first row.
	bool IsInsideRow; // Set when inside TableBeginRow()/TableEndRow().
	bool IsInitializing;
	bool IsSortSpecsDirty;
	bool IsUsingHeaders; // Set when the first row had the ImGuiTableRowFlags_Headers flag.
	bool IsContextPopupOpen; // Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).
	bool DisableDefaultContextMenu; // Disable default context menu contents. You may submit your own using TableBeginContextMenuPopup()/EndPopup()
	bool IsSettingsRequestLoad;
	bool IsSettingsDirty; // Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.
	bool IsDefaultDisplayOrder; // Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)
	bool IsResetAllRequest;
	bool IsResetDisplayOrderRequest;
	bool IsUnfrozenRows; // Set when we got past the frozen row.
	bool IsDefaultSizingPolicy; // Set if user didn't explicitly set a sizing policy in BeginTable()
	bool IsActiveIdAliveBeforeTable;
	bool IsActiveIdInTable;
	bool HasScrollbarYCurr; // Whether ANY instance of this table had a vertical scrollbar during the current frame.
	bool HasScrollbarYPrev; // Whether ANY instance of this table had a vertical scrollbar during the previous.
	bool MemoryCompacted;
	bool HostSkipItems; // Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis

	ImGuiTable() {
		memset(this, 0, sizeof(*this));
		LastFrameActive = -1;
	}
	~ImGuiTable() { IM_FREE(RawData); }
};

// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).
// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.
// - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.
// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs.
// sizeof() ~ 136 bytes.
struct IMGUI_API ImGuiTableTempData {
	int TableIndex; // Index in g.Tables.Buf[] pool
	float LastTimeActive; // Last timestamp this structure was used
	float AngledHeadersExtraWidth; // Used in EndTable()
	ImVector<ImGuiTableHeaderData> AngledHeadersRequests; // Used in TableAngledHeadersRow()

	ImVec2 UserOuterSize; // outer_size.x passed to BeginTable()
	ImDrawListSplitter DrawSplitter;

	ImRect HostBackupWorkRect; // Backup of InnerWindow->WorkRect at the end of BeginTable()
	ImRect HostBackupParentWorkRect; // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
	ImVec2 HostBackupPrevLineSize; // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
	ImVec2 HostBackupCurrLineSize; // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
	ImVec2 HostBackupCursorMaxPos; // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
	ImVec1 HostBackupColumnsOffset; // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
	float HostBackupItemWidth; // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
	int HostBackupItemWidthStackSize; //Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()

	ImGuiTableTempData() {
		memset(this, 0, sizeof(*this));
		LastTimeActive = -1.0f;
	}
};

// sizeof() ~ 12
struct ImGuiTableColumnSettings {
	float WidthOrWeight;
	ImGuiID UserID;
	ImGuiTableColumnIdx Index;
	ImGuiTableColumnIdx DisplayOrder;
	ImGuiTableColumnIdx SortOrder;
	ImU8 SortDirection : 2;
	ImU8 IsEnabled : 1; // "Visible" in ini file
	ImU8 IsStretch : 1;

	ImGuiTableColumnSettings() {
		WidthOrWeight = 0.0f;
		UserID = 0;
		Index = -1;
		DisplayOrder = SortOrder = -1;
		SortDirection = ImGuiSortDirection_None;
		IsEnabled = 1;
		IsStretch = 0;
	}
};

// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)
struct ImGuiTableSettings {
	ImGuiID ID; // Set to 0 to invalidate/delete the setting
	ImGuiTableFlags SaveFlags; // Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)
	float RefScale; // Reference scale to be able to rescale columns on font/dpi changes.
	ImGuiTableColumnIdx ColumnsCount;
	ImGuiTableColumnIdx ColumnsCountMax; // Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher
	bool WantApply; // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)

	ImGuiTableSettings() { memset(this, 0, sizeof(*this)); }
	ImGuiTableColumnSettings *GetColumnSettings() { return (ImGuiTableColumnSettings *)(this + 1); }
};

//-----------------------------------------------------------------------------
// [SECTION] ImGui internal API
// No guarantee of forward compatibility here!
//-----------------------------------------------------------------------------

namespace ImGui {
// Windows
// We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
// If this ever crashes because g.CurrentWindow is NULL, it means that either:
// - ImGui::NewFrame() has never been called, which is illegal.
// - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
inline ImGuiWindow *GetCurrentWindowRead() {
	ImGuiContext &g = *GImGui;
	return g.CurrentWindow;
}
inline ImGuiWindow *GetCurrentWindow() {
	ImGuiContext &g = *GImGui;
	g.CurrentWindow->WriteAccessed = true;
	return g.CurrentWindow;
}
IMGUI_API ImGuiWindow *FindWindowByID(ImGuiID id);
IMGUI_API ImGuiWindow *FindWindowByName(const char *name);
IMGUI_API void UpdateWindowParentAndRootLinks(ImGuiWindow *window, ImGuiWindowFlags flags, ImGuiWindow *parent_window);
IMGUI_API void UpdateWindowSkipRefresh(ImGuiWindow *window);
IMGUI_API ImVec2 CalcWindowNextAutoFitSize(ImGuiWindow *window);
IMGUI_API bool IsWindowChildOf(ImGuiWindow *window, ImGuiWindow *potential_parent, bool popup_hierarchy);
IMGUI_API bool IsWindowWithinBeginStackOf(ImGuiWindow *window, ImGuiWindow *potential_parent);
IMGUI_API bool IsWindowAbove(ImGuiWindow *potential_above, ImGuiWindow *potential_below);
IMGUI_API bool IsWindowNavFocusable(ImGuiWindow *window);
IMGUI_API void SetWindowPos(ImGuiWindow *window, const ImVec2 &pos, ImGuiCond cond = 0);
IMGUI_API void SetWindowSize(ImGuiWindow *window, const ImVec2 &size, ImGuiCond cond = 0);
IMGUI_API void SetWindowCollapsed(ImGuiWindow *window, bool collapsed, ImGuiCond cond = 0);
IMGUI_API void SetWindowHitTestHole(ImGuiWindow *window, const ImVec2 &pos, const ImVec2 &size);
IMGUI_API void SetWindowHiddenAndSkipItemsForCurrentFrame(ImGuiWindow *window);
inline void SetWindowParentWindowForFocusRoute(ImGuiWindow *window, ImGuiWindow *parent_window) {
	window->ParentWindowForFocusRoute = parent_window;
}
inline ImRect WindowRectAbsToRel(ImGuiWindow *window, const ImRect &r) {
	ImVec2 off = window->DC.CursorStartPos;
	return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y);
}
inline ImRect WindowRectRelToAbs(ImGuiWindow *window, const ImRect &r) {
	ImVec2 off = window->DC.CursorStartPos;
	return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y);
}
inline ImVec2 WindowPosAbsToRel(ImGuiWindow *window, const ImVec2 &p) {
	ImVec2 off = window->DC.CursorStartPos;
	return ImVec2(p.x - off.x, p.y - off.y);
}
inline ImVec2 WindowPosRelToAbs(ImGuiWindow *window, const ImVec2 &p) {
	ImVec2 off = window->DC.CursorStartPos;
	return ImVec2(p.x + off.x, p.y + off.y);
}

// Windows: Display Order and Focus Order
IMGUI_API void FocusWindow(ImGuiWindow *window, ImGuiFocusRequestFlags flags = 0);
IMGUI_API void FocusTopMostWindowUnderOne(ImGuiWindow *under_this_window, ImGuiWindow *ignore_window, ImGuiViewport *filter_viewport, ImGuiFocusRequestFlags flags);
IMGUI_API void BringWindowToFocusFront(ImGuiWindow *window);
IMGUI_API void BringWindowToDisplayFront(ImGuiWindow *window);
IMGUI_API void BringWindowToDisplayBack(ImGuiWindow *window);
IMGUI_API void BringWindowToDisplayBehind(ImGuiWindow *window, ImGuiWindow *above_window);
IMGUI_API int FindWindowDisplayIndex(ImGuiWindow *window);
IMGUI_API ImGuiWindow *FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow *window);

// Windows: Idle, Refresh Policies [EXPERIMENTAL]
IMGUI_API void SetNextWindowRefreshPolicy(ImGuiWindowRefreshFlags flags);

// Fonts, drawing
IMGUI_API void SetCurrentFont(ImFont *font);
inline ImFont *GetDefaultFont() {
	ImGuiContext &g = *GImGui;
	return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0];
}
inline ImDrawList *GetForegroundDrawList(ImGuiWindow *window) {
	IM_UNUSED(window);
	return GetForegroundDrawList();
} // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.
IMGUI_API ImDrawList *GetBackgroundDrawList(ImGuiViewport *viewport); // get background draw list for the given viewport. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
IMGUI_API ImDrawList *GetForegroundDrawList(ImGuiViewport *viewport); // get foreground draw list for the given viewport. this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
IMGUI_API void AddDrawListToDrawDataEx(ImDrawData *draw_data, ImVector<ImDrawList *> *out_list, ImDrawList *draw_list);

// Init
IMGUI_API void Initialize();
IMGUI_API void Shutdown(); // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

// NewFrame
IMGUI_API void UpdateInputEvents(bool trickle_fast_inputs);
IMGUI_API void UpdateHoveredWindowAndCaptureFlags();
IMGUI_API void FindHoveredWindowEx(const ImVec2 &pos, bool find_first_and_in_any_viewport, ImGuiWindow **out_hovered_window, ImGuiWindow **out_hovered_window_under_moving_window);
IMGUI_API void StartMouseMovingWindow(ImGuiWindow *window);
IMGUI_API void UpdateMouseMovingWindowNewFrame();
IMGUI_API void UpdateMouseMovingWindowEndFrame();

// Generic context hooks
IMGUI_API ImGuiID AddContextHook(ImGuiContext *context, const ImGuiContextHook *hook);
IMGUI_API void RemoveContextHook(ImGuiContext *context, ImGuiID hook_to_remove);
IMGUI_API void CallContextHooks(ImGuiContext *context, ImGuiContextHookType type);

// Viewports
IMGUI_API void SetWindowViewport(ImGuiWindow *window, ImGuiViewportP *viewport);

// Settings
IMGUI_API void MarkIniSettingsDirty();
IMGUI_API void MarkIniSettingsDirty(ImGuiWindow *window);
IMGUI_API void ClearIniSettings();
IMGUI_API void AddSettingsHandler(const ImGuiSettingsHandler *handler);
IMGUI_API void RemoveSettingsHandler(const char *type_name);
IMGUI_API ImGuiSettingsHandler *FindSettingsHandler(const char *type_name);

// Settings - Windows
IMGUI_API ImGuiWindowSettings *CreateNewWindowSettings(const char *name);
IMGUI_API ImGuiWindowSettings *FindWindowSettingsByID(ImGuiID id);
IMGUI_API ImGuiWindowSettings *FindWindowSettingsByWindow(ImGuiWindow *window);
IMGUI_API void ClearWindowSettings(const char *name);

// Localization
IMGUI_API void LocalizeRegisterEntries(const ImGuiLocEntry *entries, int count);
inline const char *LocalizeGetMsg(ImGuiLocKey key) {
	ImGuiContext &g = *GImGui;
	const char *msg = g.LocalizationTable[key];
	return msg ? msg : "*Missing Text*";
}

// Scrolling
IMGUI_API void SetScrollX(ImGuiWindow *window, float scroll_x);
IMGUI_API void SetScrollY(ImGuiWindow *window, float scroll_y);
IMGUI_API void SetScrollFromPosX(ImGuiWindow *window, float local_x, float center_x_ratio);
IMGUI_API void SetScrollFromPosY(ImGuiWindow *window, float local_y, float center_y_ratio);

// Early work-in-progress API (ScrollToItem() will become public)
IMGUI_API void ScrollToItem(ImGuiScrollFlags flags = 0);
IMGUI_API void ScrollToRect(ImGuiWindow *window, const ImRect &rect, ImGuiScrollFlags flags = 0);
IMGUI_API ImVec2 ScrollToRectEx(ImGuiWindow *window, const ImRect &rect, ImGuiScrollFlags flags = 0);
//#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
inline void ScrollToBringRectIntoView(ImGuiWindow *window, const ImRect &rect) {
	ScrollToRect(window, rect, ImGuiScrollFlags_KeepVisibleEdgeY);
}
//#endif

// Basic Accessors
inline ImGuiItemStatusFlags GetItemStatusFlags() {
	ImGuiContext &g = *GImGui;
	return g.LastItemData.StatusFlags;
}
inline ImGuiItemFlags GetItemFlags() {
	ImGuiContext &g = *GImGui;
	return g.LastItemData.InFlags;
}
inline ImGuiID GetActiveID() {
	ImGuiContext &g = *GImGui;
	return g.ActiveId;
}
inline ImGuiID GetFocusID() {
	ImGuiContext &g = *GImGui;
	return g.NavId;
}
IMGUI_API void SetActiveID(ImGuiID id, ImGuiWindow *window);
IMGUI_API void SetFocusID(ImGuiID id, ImGuiWindow *window);
IMGUI_API void ClearActiveID();
IMGUI_API ImGuiID GetHoveredID();
IMGUI_API void SetHoveredID(ImGuiID id);
IMGUI_API void KeepAliveID(ImGuiID id);
IMGUI_API void MarkItemEdited(ImGuiID id); // Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
IMGUI_API void PushOverrideID(ImGuiID id); // Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)
IMGUI_API ImGuiID GetIDWithSeed(const char *str_id_begin, const char *str_id_end, ImGuiID seed);
IMGUI_API ImGuiID GetIDWithSeed(int n, ImGuiID seed);

// Basic Helpers for widget code
IMGUI_API void ItemSize(const ImVec2 &size, float text_baseline_y = -1.0f);
inline void ItemSize(const ImRect &bb, float text_baseline_y = -1.0f) {
	ItemSize(bb.GetSize(), text_baseline_y);
} // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
IMGUI_API bool ItemAdd(const ImRect &bb, ImGuiID id, const ImRect *nav_bb = NULL, ImGuiItemFlags extra_flags = 0);
IMGUI_API bool ItemHoverable(const ImRect &bb, ImGuiID id, ImGuiItemFlags item_flags);
IMGUI_API bool IsWindowContentHoverable(ImGuiWindow *window, ImGuiHoveredFlags flags = 0);
IMGUI_API bool IsClippedEx(const ImRect &bb, ImGuiID id);
IMGUI_API void SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags status_flags, const ImRect &item_rect);
IMGUI_API ImVec2 CalcItemSize(ImVec2 size, float default_w, float default_h);
IMGUI_API float CalcWrapWidthForPos(const ImVec2 &pos, float wrap_pos_x);
IMGUI_API void PushMultiItemsWidths(int components, float width_full);
IMGUI_API void ShrinkWidths(ImGuiShrinkWidthItem *items, int count, float width_excess);

// Parameter stacks (shared)
IMGUI_API const ImGuiDataVarInfo *GetStyleVarInfo(ImGuiStyleVar idx);
IMGUI_API void BeginDisabledOverrideReenable();
IMGUI_API void EndDisabledOverrideReenable();

// Logging/Capture
IMGUI_API void LogBegin(ImGuiLogType type, int auto_open_depth); // -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
IMGUI_API void LogToBuffer(int auto_open_depth = -1); // Start logging/capturing to internal buffer
IMGUI_API void LogRenderedText(const ImVec2 *ref_pos, const char *text, const char *text_end = NULL);
IMGUI_API void LogSetNextTextDecoration(const char *prefix, const char *suffix);

// Childs
IMGUI_API bool BeginChildEx(const char *name, ImGuiID id, const ImVec2 &size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags);

// Popups, Modals
IMGUI_API bool BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_window_flags);
IMGUI_API void OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags_None);
IMGUI_API void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);
IMGUI_API void ClosePopupsOverWindow(ImGuiWindow *ref_window, bool restore_focus_to_window_under_popup);
IMGUI_API void ClosePopupsExceptModals();
IMGUI_API bool IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags);
IMGUI_API ImRect GetPopupAllowedExtentRect(ImGuiWindow *window);
IMGUI_API ImGuiWindow *GetTopMostPopupModal();
IMGUI_API ImGuiWindow *GetTopMostAndVisiblePopupModal();
IMGUI_API ImGuiWindow *FindBlockingModal(ImGuiWindow *window);
IMGUI_API ImVec2 FindBestWindowPosForPopup(ImGuiWindow *window);
IMGUI_API ImVec2 FindBestWindowPosForPopupEx(const ImVec2 &ref_pos, const ImVec2 &size, ImGuiDir *last_dir, const ImRect &r_outer, const ImRect &r_avoid, ImGuiPopupPositionPolicy policy);

// Tooltips
IMGUI_API bool BeginTooltipEx(ImGuiTooltipFlags tooltip_flags, ImGuiWindowFlags extra_window_flags);
IMGUI_API bool BeginTooltipHidden();

// Menus
IMGUI_API bool BeginViewportSideBar(const char *name, ImGuiViewport *viewport, ImGuiDir dir, float size, ImGuiWindowFlags window_flags);
IMGUI_API bool BeginMenuEx(const char *label, const char *icon, bool enabled = true);
IMGUI_API bool MenuItemEx(const char *label, const char *icon, const char *shortcut = NULL, bool selected = false, bool enabled = true);

// Combos
IMGUI_API bool BeginComboPopup(ImGuiID popup_id, const ImRect &bb, ImGuiComboFlags flags);
IMGUI_API bool BeginComboPreview();
IMGUI_API void EndComboPreview();

// Gamepad/Keyboard Navigation
IMGUI_API void NavInitWindow(ImGuiWindow *window, bool force_reinit);
IMGUI_API void NavInitRequestApplyResult();
IMGUI_API bool NavMoveRequestButNoResultYet();
IMGUI_API void NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);
IMGUI_API void NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);
IMGUI_API void NavMoveRequestResolveWithLastItem(ImGuiNavItemData *result);
IMGUI_API void NavMoveRequestResolveWithPastTreeNode(ImGuiNavItemData *result, ImGuiTreeNodeStackData *tree_node_data);
IMGUI_API void NavMoveRequestCancel();
IMGUI_API void NavMoveRequestApplyResult();
IMGUI_API void NavMoveRequestTryWrapping(ImGuiWindow *window, ImGuiNavMoveFlags move_flags);
IMGUI_API void NavHighlightActivated(ImGuiID id);
IMGUI_API void NavClearPreferredPosForAxis(ImGuiAxis axis);
IMGUI_API void NavRestoreHighlightAfterMove();
IMGUI_API void NavUpdateCurrentWindowIsScrollPushableX();
IMGUI_API void SetNavWindow(ImGuiWindow *window);
IMGUI_API void SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect &rect_rel);
IMGUI_API void SetNavFocusScope(ImGuiID focus_scope_id);

// Focus/Activation
// This should be part of a larger set of API: FocusItem(offset = -1), FocusItemByID(id), ActivateItem(offset = -1), ActivateItemByID(id) etc. which are
// much harder to design and implement than expected. I have a couple of private branches on this matter but it's not simple. For now implementing the easy ones.
IMGUI_API void FocusItem(); // Focus last item (no selection/activation).
IMGUI_API void ActivateItemByID(ImGuiID id); // Activate an item by ID (button, checkbox, tree node etc.). Activation is queued and processed on the next frame when the item is encountered again.

// Inputs
// FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into IsKeyXXX functions.
inline bool IsNamedKey(ImGuiKey key) {
	return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END;
}
inline bool IsNamedKeyOrMod(ImGuiKey key) {
	return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super;
}
inline bool IsLegacyKey(ImGuiKey key) {
	return key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_LegacyNativeKey_END;
}
inline bool IsKeyboardKey(ImGuiKey key) {
	return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END;
}
inline bool IsGamepadKey(ImGuiKey key) {
	return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END;
}
inline bool IsMouseKey(ImGuiKey key) {
	return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END;
}
inline bool IsAliasKey(ImGuiKey key) {
	return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END;
}
inline bool IsLRModKey(ImGuiKey key) {
	return key >= ImGuiKey_LeftCtrl && key <= ImGuiKey_RightSuper;
}
ImGuiKeyChord FixupKeyChord(ImGuiKeyChord key_chord);
inline ImGuiKey ConvertSingleModFlagToKey(ImGuiKey key) {
	if (key == ImGuiMod_Ctrl)
		return ImGuiKey_ReservedForModCtrl;
	if (key == ImGuiMod_Shift)
		return ImGuiKey_ReservedForModShift;
	if (key == ImGuiMod_Alt)
		return ImGuiKey_ReservedForModAlt;
	if (key == ImGuiMod_Super)
		return ImGuiKey_ReservedForModSuper;
	return key;
}

IMGUI_API ImGuiKeyData *GetKeyData(ImGuiContext *ctx, ImGuiKey key);
inline ImGuiKeyData *GetKeyData(ImGuiKey key) {
	ImGuiContext &g = *GImGui;
	return GetKeyData(&g, key);
}
IMGUI_API const char *GetKeyChordName(ImGuiKeyChord key_chord);
inline ImGuiKey MouseButtonToKey(ImGuiMouseButton button) {
	IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
	return (ImGuiKey)(ImGuiKey_MouseLeft + button);
}
IMGUI_API bool IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold = -1.0f);
IMGUI_API ImVec2 GetKeyMagnitude2d(ImGuiKey key_left, ImGuiKey key_right, ImGuiKey key_up, ImGuiKey key_down);
IMGUI_API float GetNavTweakPressedAmount(ImGuiAxis axis);
IMGUI_API int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);
IMGUI_API void GetTypematicRepeatRate(ImGuiInputFlags flags, float *repeat_delay, float *repeat_rate);
IMGUI_API void TeleportMousePos(const ImVec2 &pos);
IMGUI_API void SetActiveIdUsingAllKeyboardKeys();
inline bool IsActiveIdUsingNavDir(ImGuiDir dir) {
	ImGuiContext &g = *GImGui;
	return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0;
}

// [EXPERIMENTAL] Low-Level: Key/Input Ownership
// - The idea is that instead of "eating" a given input, we can link to an owner id.
// - Ownership is most often claimed as a result of reacting to a press/down event (but occasionally may be claimed ahead).
// - Input queries can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.
// - Legacy input queries (without specifying an owner or _Any or _None) are equivalent to using ImGuiKeyOwner_Any (== 0).
// - Input ownership is automatically released on the frame after a key is released. Therefore:
//   - for ownership registration happening as a result of a down/press event, the SetKeyOwner() call may be done once (common case).
//   - for ownership registration happening ahead of a down/press event, the SetKeyOwner() call needs to be made every frame (happens if e.g. claiming ownership on hover).
// - SetItemKeyOwner() is a shortcut for common simple case. A custom widget will probably want to call SetKeyOwner() multiple times directly based on its interaction state.
// - This is marked experimental because not all widgets are fully honoring the Set/Test idioms. We will need to move forward step by step.
//   Please open a GitHub Issue to submit your usage scenario or if there's a use case you need solved.
IMGUI_API ImGuiID GetKeyOwner(ImGuiKey key);
IMGUI_API void SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
IMGUI_API void SetKeyOwnersForKeyChord(ImGuiKeyChord key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
IMGUI_API void SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags); // Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
IMGUI_API bool TestKeyOwner(ImGuiKey key, ImGuiID owner_id); // Test that key is either not owned, either owned by 'owner_id'
inline ImGuiKeyOwnerData *GetKeyOwnerData(ImGuiContext *ctx, ImGuiKey key) {
	if (key & ImGuiMod_Mask_)
		key = ConvertSingleModFlagToKey(key);
	IM_ASSERT(IsNamedKey(key));
	return &ctx->KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
}

// [EXPERIMENTAL] High-Level: Input Access functions w/ support for Key/Input Ownership
// - Important: legacy IsKeyPressed(ImGuiKey, bool repeat=true) _DEFAULTS_ to repeat, new IsKeyPressed() requires _EXPLICIT_ ImGuiInputFlags_Repeat flag.
// - Expected to be later promoted to public API, the prototypes are designed to replace existing ones (since owner_id can default to Any == 0)
// - Specifying a value for 'ImGuiID owner' will test that EITHER the key is NOT owned (UNLESS locked), EITHER the key is owned by 'owner'.
//   Legacy functions use ImGuiKeyOwner_Any meaning that they typically ignore ownership, unless a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
// - Binding generators may want to ignore those for now, or suffix them with Ex() until we decide if this gets moved into public API.
IMGUI_API bool IsKeyDown(ImGuiKey key, ImGuiID owner_id);
IMGUI_API bool IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id = 0); // Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
IMGUI_API bool IsKeyReleased(ImGuiKey key, ImGuiID owner_id);
IMGUI_API bool IsKeyChordPressed(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id = 0);
IMGUI_API bool IsMouseDown(ImGuiMouseButton button, ImGuiID owner_id);
IMGUI_API bool IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id = 0);
IMGUI_API bool IsMouseReleased(ImGuiMouseButton button, ImGuiID owner_id);
IMGUI_API bool IsMouseDoubleClicked(ImGuiMouseButton button, ImGuiID owner_id);

// Shortcut Testing & Routing
// - Set Shortcut() and SetNextItemShortcut() in imgui.h
// - When a policy (except for ImGuiInputFlags_RouteAlways *) is set, Shortcut() will register itself with SetShortcutRouting(),
//   allowing the system to decide where to route the input among other route-aware calls.
//   (* using ImGuiInputFlags_RouteAlways is roughly equivalent to calling IsKeyChordPressed(key) and bypassing route registration and check)
// - When using one of the routing option:
//   - The default route is ImGuiInputFlags_RouteFocused (accept inputs if window is in focus stack. Deep-most focused window takes inputs. ActiveId takes inputs over deep-most focused window.)
//   - Routes are requested given a chord (key + modifiers) and a routing policy.
//   - Routes are resolved during NewFrame(): if keyboard modifiers are matching current ones: SetKeyOwner() is called + route is granted for the frame.
//   - Each route may be granted to a single owner. When multiple requests are made we have policies to select the winning route (e.g. deep most window).
//   - Multiple read sites may use the same owner id can all access the granted route.
//   - When owner_id is 0 we use the current Focus Scope ID as a owner ID in order to identify our location.
// - You can chain two unrelated windows in the focus stack using SetWindowParentWindowForFocusRoute()
//   e.g. if you have a tool window associated to a document, and you want document shortcuts to run when the tool is focused.
IMGUI_API bool Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id);
IMGUI_API bool SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id); // owner_id needs to be explicit and cannot be 0
IMGUI_API bool TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id);
IMGUI_API ImGuiKeyRoutingData *GetShortcutRoutingData(ImGuiKeyChord key_chord);

// [EXPERIMENTAL] Focus Scope
// This is generally used to identify a unique input location (for e.g. a selection set)
// There is one per window (automatically set in Begin), but:
// - Selection patterns generally need to react (e.g. clear a selection) when landing on one item of the set.
//   So in order to identify a set multiple lists in same window may each need a focus scope.
//   If you imagine an hypothetical BeginSelectionGroup()/EndSelectionGroup() api, it would likely call PushFocusScope()/EndFocusScope()
// - Shortcut routing also use focus scope as a default location identifier if an owner is not provided.
// We don't use the ID Stack for this as it is common to want them separate.
IMGUI_API void PushFocusScope(ImGuiID id);
IMGUI_API void PopFocusScope();
inline ImGuiID GetCurrentFocusScope() {
	ImGuiContext &g = *GImGui;
	return g.CurrentFocusScopeId;
} // Focus scope we are outputting into, set by PushFocusScope()

// Drag and Drop
IMGUI_API bool IsDragDropActive();
IMGUI_API bool BeginDragDropTargetCustom(const ImRect &bb, ImGuiID id);
IMGUI_API void ClearDragDrop();
IMGUI_API bool IsDragDropPayloadBeingAccepted();
IMGUI_API void RenderDragDropTargetRect(const ImRect &bb, const ImRect &item_clip_rect);

// Typing-Select API
IMGUI_API ImGuiTypingSelectRequest *GetTypingSelectRequest(ImGuiTypingSelectFlags flags = ImGuiTypingSelectFlags_None);
IMGUI_API int TypingSelectFindMatch(ImGuiTypingSelectRequest *req, int items_count, const char *(*get_item_name_func)(void *, int), void *user_data, int nav_item_idx);
IMGUI_API int TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequest *req, int items_count, const char *(*get_item_name_func)(void *, int), void *user_data, int nav_item_idx);
IMGUI_API int TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequest *req, int items_count, const char *(*get_item_name_func)(void *, int), void *user_data);

// Box-Select API
IMGUI_API bool BeginBoxSelect(const ImRect &scope_rect, ImGuiWindow *window, ImGuiID box_select_id, ImGuiMultiSelectFlags ms_flags);
IMGUI_API void EndBoxSelect(const ImRect &scope_rect, ImGuiMultiSelectFlags ms_flags);

// Multi-Select API
IMGUI_API void MultiSelectItemHeader(ImGuiID id, bool *p_selected, ImGuiButtonFlags *p_button_flags);
IMGUI_API void MultiSelectItemFooter(ImGuiID id, bool *p_selected, bool *p_pressed);
IMGUI_API void MultiSelectAddSetAll(ImGuiMultiSelectTempData *ms, bool selected);
IMGUI_API void MultiSelectAddSetRange(ImGuiMultiSelectTempData *ms, bool selected, int range_dir, ImGuiSelectionUserData first_item, ImGuiSelectionUserData last_item);
inline ImGuiBoxSelectState *GetBoxSelectState(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	return (id != 0 && g.BoxSelectState.ID == id && g.BoxSelectState.IsActive) ? &g.BoxSelectState : NULL;
}
inline ImGuiMultiSelectState *GetMultiSelectState(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	return g.MultiSelectStorage.GetByKey(id);
}

// Internal Columns API (this is not exposed because we will encourage transitioning to the Tables API)
IMGUI_API void SetWindowClipRectBeforeSetChannel(ImGuiWindow *window, const ImRect &clip_rect);
IMGUI_API void BeginColumns(const char *str_id, int count, ImGuiOldColumnFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
IMGUI_API void EndColumns(); // close columns
IMGUI_API void PushColumnClipRect(int column_index);
IMGUI_API void PushColumnsBackground();
IMGUI_API void PopColumnsBackground();
IMGUI_API ImGuiID GetColumnsID(const char *str_id, int count);
IMGUI_API ImGuiOldColumns *FindOrCreateColumns(ImGuiWindow *window, ImGuiID id);
IMGUI_API float GetColumnOffsetFromNorm(const ImGuiOldColumns *columns, float offset_norm);
IMGUI_API float GetColumnNormFromOffset(const ImGuiOldColumns *columns, float offset);

// Tables: Candidates for public API
IMGUI_API void TableOpenContextMenu(int column_n = -1);
IMGUI_API void TableSetColumnWidth(int column_n, float width);
IMGUI_API void TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs);
IMGUI_API int TableGetHoveredRow(); // Retrieve *PREVIOUS FRAME* hovered row. This difference with TableGetHoveredColumn() is the reason why this is not public yet.
IMGUI_API float TableGetHeaderRowHeight();
IMGUI_API float TableGetHeaderAngledMaxLabelWidth();
IMGUI_API void TablePushBackgroundChannel();
IMGUI_API void TablePopBackgroundChannel();
IMGUI_API void TableAngledHeadersRowEx(ImGuiID row_id, float angle, float max_label_width, const ImGuiTableHeaderData *data, int data_count);

// Tables: Internals
inline ImGuiTable *GetCurrentTable() {
	ImGuiContext &g = *GImGui;
	return g.CurrentTable;
}
IMGUI_API ImGuiTable *TableFindByID(ImGuiID id);
IMGUI_API bool BeginTableEx(const char *name, ImGuiID id, int columns_count, ImGuiTableFlags flags = 0, const ImVec2 &outer_size = ImVec2(0, 0), float inner_width = 0.0f);
IMGUI_API void TableBeginInitMemory(ImGuiTable *table, int columns_count);
IMGUI_API void TableBeginApplyRequests(ImGuiTable *table);
IMGUI_API void TableSetupDrawChannels(ImGuiTable *table);
IMGUI_API void TableUpdateLayout(ImGuiTable *table);
IMGUI_API void TableUpdateBorders(ImGuiTable *table);
IMGUI_API void TableUpdateColumnsWeightFromWidth(ImGuiTable *table);
IMGUI_API void TableDrawBorders(ImGuiTable *table);
IMGUI_API void TableDrawDefaultContextMenu(ImGuiTable *table, ImGuiTableFlags flags_for_section_to_display);
IMGUI_API bool TableBeginContextMenuPopup(ImGuiTable *table);
IMGUI_API void TableMergeDrawChannels(ImGuiTable *table);
inline ImGuiTableInstanceData *TableGetInstanceData(ImGuiTable *table, int instance_no) {
	if (instance_no == 0)
		return &table->InstanceDataFirst;
	return &table->InstanceDataExtra[instance_no - 1];
}
inline ImGuiID TableGetInstanceID(ImGuiTable *table, int instance_no) {
	return TableGetInstanceData(table, instance_no)->TableInstanceID;
}
IMGUI_API void TableSortSpecsSanitize(ImGuiTable *table);
IMGUI_API void TableSortSpecsBuild(ImGuiTable *table);
IMGUI_API ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumn *column);
IMGUI_API void TableFixColumnSortDirection(ImGuiTable *table, ImGuiTableColumn *column);
IMGUI_API float TableGetColumnWidthAuto(ImGuiTable *table, ImGuiTableColumn *column);
IMGUI_API void TableBeginRow(ImGuiTable *table);
IMGUI_API void TableEndRow(ImGuiTable *table);
IMGUI_API void TableBeginCell(ImGuiTable *table, int column_n);
IMGUI_API void TableEndCell(ImGuiTable *table);
IMGUI_API ImRect TableGetCellBgRect(const ImGuiTable *table, int column_n);
IMGUI_API const char *TableGetColumnName(const ImGuiTable *table, int column_n);
IMGUI_API ImGuiID TableGetColumnResizeID(ImGuiTable *table, int column_n, int instance_no = 0);
IMGUI_API float TableCalcMaxColumnWidth(const ImGuiTable *table, int column_n);
IMGUI_API void TableSetColumnWidthAutoSingle(ImGuiTable *table, int column_n);
IMGUI_API void TableSetColumnWidthAutoAll(ImGuiTable *table);
IMGUI_API void TableRemove(ImGuiTable *table);
IMGUI_API void TableGcCompactTransientBuffers(ImGuiTable *table);
IMGUI_API void TableGcCompactTransientBuffers(ImGuiTableTempData *table);
IMGUI_API void TableGcCompactSettings();

// Tables: Settings
IMGUI_API void TableLoadSettings(ImGuiTable *table);
IMGUI_API void TableSaveSettings(ImGuiTable *table);
IMGUI_API void TableResetSettings(ImGuiTable *table);
IMGUI_API ImGuiTableSettings *TableGetBoundSettings(ImGuiTable *table);
IMGUI_API void TableSettingsAddSettingsHandler();
IMGUI_API ImGuiTableSettings *TableSettingsCreate(ImGuiID id, int columns_count);
IMGUI_API ImGuiTableSettings *TableSettingsFindByID(ImGuiID id);

// Tab Bars
inline ImGuiTabBar *GetCurrentTabBar() {
	ImGuiContext &g = *GImGui;
	return g.CurrentTabBar;
}
IMGUI_API bool BeginTabBarEx(ImGuiTabBar *tab_bar, const ImRect &bb, ImGuiTabBarFlags flags);
IMGUI_API ImGuiTabItem *TabBarFindTabByID(ImGuiTabBar *tab_bar, ImGuiID tab_id);
IMGUI_API ImGuiTabItem *TabBarFindTabByOrder(ImGuiTabBar *tab_bar, int order);
IMGUI_API ImGuiTabItem *TabBarGetCurrentTab(ImGuiTabBar *tab_bar);
inline int TabBarGetTabOrder(ImGuiTabBar *tab_bar, ImGuiTabItem *tab) {
	return tab_bar->Tabs.index_from_ptr(tab);
}
IMGUI_API const char *TabBarGetTabName(ImGuiTabBar *tab_bar, ImGuiTabItem *tab);
IMGUI_API void TabBarRemoveTab(ImGuiTabBar *tab_bar, ImGuiID tab_id);
IMGUI_API void TabBarCloseTab(ImGuiTabBar *tab_bar, ImGuiTabItem *tab);
IMGUI_API void TabBarQueueFocus(ImGuiTabBar *tab_bar, ImGuiTabItem *tab);
IMGUI_API void TabBarQueueReorder(ImGuiTabBar *tab_bar, ImGuiTabItem *tab, int offset);
IMGUI_API void TabBarQueueReorderFromMousePos(ImGuiTabBar *tab_bar, ImGuiTabItem *tab, ImVec2 mouse_pos);
IMGUI_API bool TabBarProcessReorder(ImGuiTabBar *tab_bar);
IMGUI_API bool TabItemEx(ImGuiTabBar *tab_bar, const char *label, bool *p_open, ImGuiTabItemFlags flags, ImGuiWindow *docked_window);
IMGUI_API ImVec2 TabItemCalcSize(const char *label, bool has_close_button_or_unsaved_marker);
IMGUI_API ImVec2 TabItemCalcSize(ImGuiWindow *window);
IMGUI_API void TabItemBackground(ImDrawList *draw_list, const ImRect &bb, ImGuiTabItemFlags flags, ImU32 col);
IMGUI_API void TabItemLabelAndCloseButton(ImDrawList *draw_list, const ImRect &bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char *label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool *out_just_closed, bool *out_text_clipped);

// Render helpers
// AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
// NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
IMGUI_API void RenderText(ImVec2 pos, const char *text, const char *text_end = NULL, bool hide_text_after_hash = true);
IMGUI_API void RenderTextWrapped(ImVec2 pos, const char *text, const char *text_end, float wrap_width);
IMGUI_API void RenderTextClipped(const ImVec2 &pos_min, const ImVec2 &pos_max, const char *text, const char *text_end, const ImVec2 *text_size_if_known, const ImVec2 &align = ImVec2(0, 0), const ImRect *clip_rect = NULL);
IMGUI_API void RenderTextClippedEx(ImDrawList *draw_list, const ImVec2 &pos_min, const ImVec2 &pos_max, const char *text, const char *text_end, const ImVec2 *text_size_if_known, const ImVec2 &align = ImVec2(0, 0), const ImRect *clip_rect = NULL);
IMGUI_API void RenderTextEllipsis(ImDrawList *draw_list, const ImVec2 &pos_min, const ImVec2 &pos_max, float clip_max_x, float ellipsis_max_x, const char *text, const char *text_end, const ImVec2 *text_size_if_known);
IMGUI_API void RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool borders = true, float rounding = 0.0f);
IMGUI_API void RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);
IMGUI_API void RenderColorRectWithAlphaCheckerboard(ImDrawList *draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, ImDrawFlags flags = 0);
IMGUI_API void RenderNavHighlight(const ImRect &bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_None); // Navigation highlight
IMGUI_API const char *FindRenderedTextEnd(const char *text, const char *text_end = NULL); // Find the optional ## from which we stop displaying text.
IMGUI_API void RenderMouseCursor(ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow);

// Render helpers (those functions don't access any ImGui state!)
IMGUI_API void RenderArrow(ImDrawList *draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale = 1.0f);
IMGUI_API void RenderBullet(ImDrawList *draw_list, ImVec2 pos, ImU32 col);
IMGUI_API void RenderCheckMark(ImDrawList *draw_list, ImVec2 pos, ImU32 col, float sz);
IMGUI_API void RenderArrowPointingAt(ImDrawList *draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);
IMGUI_API void RenderRectFilledRangeH(ImDrawList *draw_list, const ImRect &rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);
IMGUI_API void RenderRectFilledWithHole(ImDrawList *draw_list, const ImRect &outer, const ImRect &inner, ImU32 col, float rounding);

// Widgets
IMGUI_API void TextEx(const char *text, const char *text_end = NULL, ImGuiTextFlags flags = 0);
IMGUI_API bool ButtonEx(const char *label, const ImVec2 &size_arg = ImVec2(0, 0), ImGuiButtonFlags flags = 0);
IMGUI_API bool ArrowButtonEx(const char *str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags = 0);
IMGUI_API bool ImageButtonEx(ImGuiID id, ImTextureID texture_id, const ImVec2 &image_size, const ImVec2 &uv0, const ImVec2 &uv1, const ImVec4 &bg_col, const ImVec4 &tint_col, ImGuiButtonFlags flags = 0);
IMGUI_API void SeparatorEx(ImGuiSeparatorFlags flags, float thickness = 1.0f);
IMGUI_API void SeparatorTextEx(ImGuiID id, const char *label, const char *label_end, float extra_width);
IMGUI_API bool CheckboxFlags(const char *label, ImS64 *flags, ImS64 flags_value);
IMGUI_API bool CheckboxFlags(const char *label, ImU64 *flags, ImU64 flags_value);

// Widgets: Window Decorations
IMGUI_API bool CloseButton(ImGuiID id, const ImVec2 &pos);
IMGUI_API bool CollapseButton(ImGuiID id, const ImVec2 &pos);
IMGUI_API void Scrollbar(ImGuiAxis axis);
IMGUI_API bool ScrollbarEx(const ImRect &bb, ImGuiID id, ImGuiAxis axis, ImS64 *p_scroll_v, ImS64 avail_v, ImS64 contents_v, ImDrawFlags flags);
IMGUI_API ImRect GetWindowScrollbarRect(ImGuiWindow *window, ImGuiAxis axis);
IMGUI_API ImGuiID GetWindowScrollbarID(ImGuiWindow *window, ImGuiAxis axis);
IMGUI_API ImGuiID GetWindowResizeCornerID(ImGuiWindow *window, int n); // 0..3: corners
IMGUI_API ImGuiID GetWindowResizeBorderID(ImGuiWindow *window, ImGuiDir dir);

// Widgets low-level behaviors
IMGUI_API bool ButtonBehavior(const ImRect &bb, ImGuiID id, bool *out_hovered, bool *out_held, ImGuiButtonFlags flags = 0);
IMGUI_API bool DragBehavior(ImGuiID id, ImGuiDataType data_type, void *p_v, float v_speed, const void *p_min, const void *p_max, const char *format, ImGuiSliderFlags flags);
IMGUI_API bool SliderBehavior(const ImRect &bb, ImGuiID id, ImGuiDataType data_type, void *p_v, const void *p_min, const void *p_max, const char *format, ImGuiSliderFlags flags, ImRect *out_grab_bb);
IMGUI_API bool SplitterBehavior(const ImRect &bb, ImGuiID id, ImGuiAxis axis, float *size1, float *size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f, ImU32 bg_col = 0);

// Widgets: Tree Nodes
IMGUI_API bool TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char *label, const char *label_end = NULL);
IMGUI_API void TreePushOverrideID(ImGuiID id);
IMGUI_API bool TreeNodeGetOpen(ImGuiID storage_id);
IMGUI_API void TreeNodeSetOpen(ImGuiID storage_id, bool open);
IMGUI_API bool TreeNodeUpdateNextOpen(ImGuiID storage_id, ImGuiTreeNodeFlags flags); // Return open state. Consume previous SetNextItemOpen() data, if any. May return true when logging.

// Template functions are instantiated in imgui_widgets.cpp for a finite number of types.
// To use them externally (for custom widget) you may need an "extern template" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).
// e.g. " extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); "
template <typename T, typename SIGNED_T, typename FLOAT_T>
IMGUI_API float ScaleRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_size);
template <typename T, typename SIGNED_T, typename FLOAT_T>
IMGUI_API T ScaleValueFromRatioT(ImGuiDataType data_type, float t, T v_min, T v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_size);
template <typename T, typename SIGNED_T, typename FLOAT_T>
IMGUI_API bool DragBehaviorT(ImGuiDataType data_type, T *v, float v_speed, T v_min, T v_max, const char *format, ImGuiSliderFlags flags);
template <typename T, typename SIGNED_T, typename FLOAT_T>
IMGUI_API bool SliderBehaviorT(const ImRect &bb, ImGuiID id, ImGuiDataType data_type, T *v, T v_min, T v_max, const char *format, ImGuiSliderFlags flags, ImRect *out_grab_bb);
template <typename T>
IMGUI_API T RoundScalarWithFormatT(const char *format, ImGuiDataType data_type, T v);
template <typename T>
IMGUI_API bool CheckboxFlagsT(const char *label, T *flags, T flags_value);

// Data type helpers
IMGUI_API const ImGuiDataTypeInfo *DataTypeGetInfo(ImGuiDataType data_type);
IMGUI_API int DataTypeFormatString(char *buf, int buf_size, ImGuiDataType data_type, const void *p_data, const char *format);
IMGUI_API void DataTypeApplyOp(ImGuiDataType data_type, int op, void *output, const void *arg_1, const void *arg_2);
IMGUI_API bool DataTypeApplyFromText(const char *buf, ImGuiDataType data_type, void *p_data, const char *format, void *p_data_when_empty = NULL);
IMGUI_API int DataTypeCompare(ImGuiDataType data_type, const void *arg_1, const void *arg_2);
IMGUI_API bool DataTypeClamp(ImGuiDataType data_type, void *p_data, const void *p_min, const void *p_max);

// InputText
IMGUI_API bool InputTextEx(const char *label, const char *hint, char *buf, int buf_size, const ImVec2 &size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void *user_data = NULL);
IMGUI_API void InputTextDeactivateHook(ImGuiID id);
IMGUI_API bool TempInputText(const ImRect &bb, ImGuiID id, const char *label, char *buf, int buf_size, ImGuiInputTextFlags flags);
IMGUI_API bool TempInputScalar(const ImRect &bb, ImGuiID id, const char *label, ImGuiDataType data_type, void *p_data, const char *format, const void *p_clamp_min = NULL, const void *p_clamp_max = NULL);
inline bool TempInputIsActive(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	return (g.ActiveId == id && g.TempInputId == id);
}
inline ImGuiInputTextState *GetInputTextState(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : NULL;
} // Get input text state if active
IMGUI_API void SetNextItemRefVal(ImGuiDataType data_type, void *p_data);

// Color
IMGUI_API void ColorTooltip(const char *text, const float *col, ImGuiColorEditFlags flags);
IMGUI_API void ColorEditOptionsPopup(const float *col, ImGuiColorEditFlags flags);
IMGUI_API void ColorPickerOptionsPopup(const float *ref_col, ImGuiColorEditFlags flags);

// Plot
IMGUI_API int PlotEx(ImGuiPlotType plot_type, const char *label, float (*values_getter)(void *data, int idx), void *data, int values_count, int values_offset, const char *overlay_text, float scale_min, float scale_max, const ImVec2 &size_arg);

// Shade functions (write over already created vertices)
IMGUI_API void ShadeVertsLinearColorGradientKeepAlpha(ImDrawList *draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
IMGUI_API void ShadeVertsLinearUV(ImDrawList *draw_list, int vert_start_idx, int vert_end_idx, const ImVec2 &a, const ImVec2 &b, const ImVec2 &uv_a, const ImVec2 &uv_b, bool clamp);
IMGUI_API void ShadeVertsTransformPos(ImDrawList *draw_list, int vert_start_idx, int vert_end_idx, const ImVec2 &pivot_in, float cos_a, float sin_a, const ImVec2 &pivot_out);

// Garbage collection
IMGUI_API void GcCompactTransientMiscBuffers();
IMGUI_API void GcCompactTransientWindowBuffers(ImGuiWindow *window);
IMGUI_API void GcAwakeTransientWindowBuffers(ImGuiWindow *window);

// Debug Tools
IMGUI_API void DebugAllocHook(ImGuiDebugAllocInfo *info, int frame_count, void *ptr, size_t size); // size >= 0 : alloc, size = -1 : free
IMGUI_API void ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void *user_data = NULL);
IMGUI_API void ErrorCheckEndWindowRecover(ImGuiErrorLogCallback log_callback, void *user_data = NULL);
IMGUI_API void ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
IMGUI_API void DebugDrawCursorPos(ImU32 col = IM_COL32(255, 0, 0, 255));
IMGUI_API void DebugDrawLineExtents(ImU32 col = IM_COL32(255, 0, 0, 255));
IMGUI_API void DebugDrawItemRect(ImU32 col = IM_COL32(255, 0, 0, 255));
IMGUI_API void DebugTextUnformattedWithLocateItem(const char *line_begin, const char *line_end);
IMGUI_API void DebugLocateItem(ImGuiID target_id); // Call sparingly: only 1 at the same time!
IMGUI_API void DebugLocateItemOnHover(ImGuiID target_id); // Only call on reaction to a mouse Hover: because only 1 at the same time!
IMGUI_API void DebugLocateItemResolveWithLastItem();
IMGUI_API void DebugBreakClearData();
IMGUI_API bool DebugBreakButton(const char *label, const char *description_of_location);
IMGUI_API void DebugBreakButtonTooltip(bool keyboard_only, const char *description_of_location);
IMGUI_API void ShowFontAtlas(ImFontAtlas *atlas);
IMGUI_API void DebugHookIdInfo(ImGuiID id, ImGuiDataType data_type, const void *data_id, const void *data_id_end);
IMGUI_API void DebugNodeColumns(ImGuiOldColumns *columns);
IMGUI_API void DebugNodeDrawList(ImGuiWindow *window, ImGuiViewportP *viewport, const ImDrawList *draw_list, const char *label);
IMGUI_API void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList *out_draw_list, const ImDrawList *draw_list, const ImDrawCmd *draw_cmd, bool show_mesh, bool show_aabb);
IMGUI_API void DebugNodeFont(ImFont *font);
IMGUI_API void DebugNodeFontGlyph(ImFont *font, const ImFontGlyph *glyph);
IMGUI_API void DebugNodeStorage(ImGuiStorage *storage, const char *label);
IMGUI_API void DebugNodeTabBar(ImGuiTabBar *tab_bar, const char *label);
IMGUI_API void DebugNodeTable(ImGuiTable *table);
IMGUI_API void DebugNodeTableSettings(ImGuiTableSettings *settings);
IMGUI_API void DebugNodeInputTextState(ImGuiInputTextState *state);
IMGUI_API void DebugNodeTypingSelectState(ImGuiTypingSelectState *state);
IMGUI_API void DebugNodeMultiSelectState(ImGuiMultiSelectState *state);
IMGUI_API void DebugNodeWindow(ImGuiWindow *window, const char *label);
IMGUI_API void DebugNodeWindowSettings(ImGuiWindowSettings *settings);
IMGUI_API void DebugNodeWindowsList(ImVector<ImGuiWindow *> *windows, const char *label);
IMGUI_API void DebugNodeWindowsListByBeginStackParent(ImGuiWindow **windows, int windows_size, ImGuiWindow *parent_in_begin_stack);
IMGUI_API void DebugNodeViewport(ImGuiViewportP *viewport);
IMGUI_API void DebugRenderKeyboardPreview(ImDrawList *draw_list);
IMGUI_API void DebugRenderViewportThumbnail(ImDrawList *draw_list, ImGuiViewportP *viewport, const ImRect &bb);

// Obsolete functions
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
inline void SetItemUsingMouseWheel() {
	SetItemKeyOwner(ImGuiKey_MouseWheelY);
} // Changed in 1.89
inline bool TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0) {
	return TreeNodeUpdateNextOpen(id, flags);
} // Renamed in 1.89

//inline bool   IsKeyPressedMap(ImGuiKey key, bool repeat = true)                   { IM_ASSERT(IsNamedKey(key)); return IsKeyPressed(key, repeat); } // Removed in 1.87: Mapping from named key is always identity!

// Refactored focus/nav/tabbing system in 1.82 and 1.84. If you have old/custom copy-and-pasted widgets which used FocusableItemRegister():
//  (Old) IMGUI_VERSION_NUM  < 18209: using 'ItemAdd(....)'                              and 'bool tab_focused = FocusableItemRegister(...)'
//  (Old) IMGUI_VERSION_NUM >= 18209: using 'ItemAdd(..., ImGuiItemAddFlags_Focusable)'  and 'bool tab_focused = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Focused) != 0'
//  (New) IMGUI_VERSION_NUM >= 18413: using 'ItemAdd(..., ImGuiItemFlags_Inputable)'     and 'bool tab_focused = (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput))'
//inline bool   FocusableItemRegister(ImGuiWindow* window, ImGuiID id)              // -> pass ImGuiItemAddFlags_Inputable flag to ItemAdd()
//inline void   FocusableItemUnregister(ImGuiWindow* window)                        // -> unnecessary: TempInputText() uses ImGuiInputTextFlags_MergedItem
#endif

} // namespace ImGui

//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas internal API
//-----------------------------------------------------------------------------

// This structure is likely to evolve as we add support for incremental atlas updates
struct ImFontBuilderIO {
	bool (*FontBuilder_Build)(ImFontAtlas *atlas);
};

// Helper for font builder
#ifdef IMGUI_ENABLE_STB_TRUETYPE
IMGUI_API const ImFontBuilderIO *ImFontAtlasGetBuilderForStbTruetype();
#endif
IMGUI_API void ImFontAtlasUpdateConfigDataPointers(ImFontAtlas *atlas);
IMGUI_API void ImFontAtlasBuildInit(ImFontAtlas *atlas);
IMGUI_API void ImFontAtlasBuildSetupFont(ImFontAtlas *atlas, ImFont *font, ImFontConfig *font_config, float ascent, float descent);
IMGUI_API void ImFontAtlasBuildPackCustomRects(ImFontAtlas *atlas, void *stbrp_context_opaque);
IMGUI_API void ImFontAtlasBuildFinish(ImFontAtlas *atlas);
IMGUI_API void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas *atlas, int x, int y, int w, int h, const char *in_str, char in_marker_char, unsigned char in_marker_pixel_value);
IMGUI_API void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas *atlas, int x, int y, int w, int h, const char *in_str, char in_marker_char, unsigned int in_marker_pixel_value);
IMGUI_API void ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
IMGUI_API void ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char *pixels, int x, int y, int w, int h, int stride);

//-----------------------------------------------------------------------------
// [SECTION] Test Engine specific hooks (imgui_test_engine)
//-----------------------------------------------------------------------------

#ifdef IMGUI_ENABLE_TEST_ENGINE
extern void ImGuiTestEngineHook_ItemAdd(ImGuiContext *ctx, ImGuiID id, const ImRect &bb, const ImGuiLastItemData *item_data); // item_data may be NULL
extern void ImGuiTestEngineHook_ItemInfo(ImGuiContext *ctx, ImGuiID id, const char *label, ImGuiItemStatusFlags flags);
extern void ImGuiTestEngineHook_Log(ImGuiContext *ctx, const char *fmt, ...);
extern const char *ImGuiTestEngine_FindItemDebugLabel(ImGuiContext *ctx, ImGuiID id);

// In IMGUI_VERSION_NUM >= 18934: changed IMGUI_TEST_ENGINE_ITEM_ADD(bb,id) to IMGUI_TEST_ENGINE_ITEM_ADD(id,bb,item_data);
#define IMGUI_TEST_ENGINE_ITEM_ADD(_ID, _BB, _ITEM_DATA) \
	if (g.TestEngineHookItems)                           \
	ImGuiTestEngineHook_ItemAdd(&g, _ID, _BB, _ITEM_DATA) // Register item bounding box
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS) \
	if (g.TestEngineHookItems)                           \
	ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS) // Register item label and status flags (optional)
#define IMGUI_TEST_ENGINE_LOG(_FMT, ...) \
	if (g.TestEngineHookItems)           \
	ImGuiTestEngineHook_Log(&g, _FMT, __VA_ARGS__) // Custom log entry from user land into test log
#else
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB, _ID) ((void)0)
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS) ((void)g)
#endif

//-----------------------------------------------------------------------------

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif // #ifndef IMGUI_DISABLE
#line 0

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
namespace ImStb {

static int STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState *obj) {
	return obj->CurLenW;
}
static ImWchar STB_TEXTEDIT_GETCHAR(const ImGuiInputTextState *obj, int idx) {
	IM_ASSERT(idx <= obj->CurLenW);
	return obj->TextW[idx];
}
static float STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState *obj, int line_start_idx, int char_idx) {
	ImWchar c = obj->TextW[line_start_idx + char_idx];
	if (c == '\n')
		return IMSTB_TEXTEDIT_GETWIDTH_NEWLINE;
	ImGuiContext &g = *obj->Ctx;
	return g.Font->GetCharAdvance(c) * g.FontScale;
}
static int STB_TEXTEDIT_KEYTOTEXT(int key) {
	return key >= 0x200000 ? 0 : key;
}
static ImWchar STB_TEXTEDIT_NEWLINE = '\n';
static void STB_TEXTEDIT_LAYOUTROW(StbTexteditRow *r, ImGuiInputTextState *obj, int line_start_idx) {
	const ImWchar *text = obj->TextW.Data;
	const ImWchar *text_remaining = NULL;
	const ImVec2 size = InputTextCalcTextSizeW(obj->Ctx, text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);
	r->x0 = 0.0f;
	r->x1 = size.x;
	r->baseline_y_delta = size.y;
	r->ymin = 0.0f;
	r->ymax = size.y;
	r->num_chars = (int)(text_remaining - (text + line_start_idx));
}

static bool is_separator(unsigned int c) {
	return c == ',' || c == ';' || c == '(' || c == ')' || c == '{' || c == '}' || c == '[' || c == ']' || c == '|' || c == '\n' || c == '\r' || c == '.' || c == '!' || c == '\\' || c == '/';
}

static int is_word_boundary_from_right(ImGuiInputTextState *obj, int idx) {
	// When ImGuiInputTextFlags_Password is set, we don't want actions such as CTRL+Arrow to leak the fact that underlying data are blanks or separators.
	if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)
		return 0;

	bool prev_white = ImCharIsBlankW(obj->TextW[idx - 1]);
	bool prev_separ = is_separator(obj->TextW[idx - 1]);
	bool curr_white = ImCharIsBlankW(obj->TextW[idx]);
	bool curr_separ = is_separator(obj->TextW[idx]);
	return ((prev_white || prev_separ) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);
}
static int is_word_boundary_from_left(ImGuiInputTextState *obj, int idx) {
	if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)
		return 0;

	bool prev_white = ImCharIsBlankW(obj->TextW[idx]);
	bool prev_separ = is_separator(obj->TextW[idx]);
	bool curr_white = ImCharIsBlankW(obj->TextW[idx - 1]);
	bool curr_separ = is_separator(obj->TextW[idx - 1]);
	return ((prev_white) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);
}
static int STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiInputTextState *obj, int idx) {
	idx--;
	while (idx >= 0 && !is_word_boundary_from_right(obj, idx))
		idx--;
	return idx < 0 ? 0 : idx;
}
static int STB_TEXTEDIT_MOVEWORDRIGHT_MAC(ImGuiInputTextState *obj, int idx) {
	idx++;
	int len = obj->CurLenW;
	while (idx < len && !is_word_boundary_from_left(obj, idx))
		idx++;
	return idx > len ? len : idx;
}
static int STB_TEXTEDIT_MOVEWORDRIGHT_WIN(ImGuiInputTextState *obj, int idx) {
	idx++;
	int len = obj->CurLenW;
	while (idx < len && !is_word_boundary_from_right(obj, idx))
		idx++;
	return idx > len ? len : idx;
}
static int STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(ImGuiInputTextState *obj, int idx) {
	ImGuiContext &g = *obj->Ctx;
	if (g.IO.ConfigMacOSXBehaviors)
		return STB_TEXTEDIT_MOVEWORDRIGHT_MAC(obj, idx);
	else
		return STB_TEXTEDIT_MOVEWORDRIGHT_WIN(obj, idx);
}
#define STB_TEXTEDIT_MOVEWORDLEFT STB_TEXTEDIT_MOVEWORDLEFT_IMPL // They need to be #define for stb_textedit.h
#define STB_TEXTEDIT_MOVEWORDRIGHT STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

static void STB_TEXTEDIT_DELETECHARS(ImGuiInputTextState *obj, int pos, int n) {
	ImWchar *dst = obj->TextW.Data + pos;

	// We maintain our buffer length in both UTF-8 and wchar formats
	obj->Edited = true;
	obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);
	obj->CurLenW -= n;

	// Offset remaining text (FIXME-OPT: Use memmove)
	const ImWchar *src = obj->TextW.Data + pos + n;
	while (ImWchar c = *src++)
		*dst++ = c;
	*dst = '\0';
}

static bool STB_TEXTEDIT_INSERTCHARS(ImGuiInputTextState *obj, int pos, const ImWchar *new_text, int new_text_len) {
	const bool is_resizable = (obj->Flags & ImGuiInputTextFlags_CallbackResize) != 0;
	const int text_len = obj->CurLenW;
	IM_ASSERT(pos <= text_len);

	const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);
	if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))
		return false;

	// Grow internal buffer if needed
	if (new_text_len + text_len + 1 > obj->TextW.Size) {
		if (!is_resizable)
			return false;
		IM_ASSERT(text_len < obj->TextW.Size);
		obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);
	}

	ImWchar *text = obj->TextW.Data;
	if (pos != text_len)
		memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));
	memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

	obj->Edited = true;
	obj->CurLenW += new_text_len;
	obj->CurLenA += new_text_len_utf8;
	obj->TextW[obj->CurLenW] = '\0';

	return true;
}

// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT 0x200000 // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT 0x200001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP 0x200002 // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN 0x200003 // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART 0x200004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND 0x200005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART 0x200006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND 0x200007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE 0x200008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE 0x200009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO 0x20000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO 0x20000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT 0x20000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT 0x20000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_PGUP 0x20000E // keyboard input to move cursor up a page
#define STB_TEXTEDIT_K_PGDOWN 0x20000F // keyboard input to move cursor down a page
#define STB_TEXTEDIT_K_SHIFT 0x400000

#undef IMSTB_TEXTEDIT_STRING
#undef IMSTB_TEXTEDIT_CHARTYPE
#define IMSTB_TEXTEDIT_STRING ImGuiInputTextState
#define IMSTB_TEXTEDIT_CHARTYPE ImWchar
#define IMSTB_TEXTEDIT_GETWIDTH_NEWLINE (-1.0f)
#define IMSTB_TEXTEDIT_UNDOSTATECOUNT 99
#define IMSTB_TEXTEDIT_UNDOCHARCOUNT 999

#define IMSTB_TEXTEDIT_IMPLEMENTATION
#define IMSTB_TEXTEDIT_memmove memmove

#line 1 "sfw/render_gui/imstb_textedit.h"
// [DEAR IMGUI]
// This is a slightly modified version of stb_textedit.h 1.14.
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// - Fix in stb_textedit_find_charpos to handle last line (see https://github.com/ocornut/imgui/issues/6000 + #6783)
// Grep for [DEAR IMGUI] to find the changes.
// - Also renamed macros used or defined outside of IMSTB_TEXTEDIT_IMPLEMENTATION block from STB_TEXTEDIT_* to IMSTB_TEXTEDIT_*

// stb_textedit.h - v1.14  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
//
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining IMSTB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.14 (2021-07-11) page up/down, various fixes
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//   Louis Schnellbach: page up/down in 1.14
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATECOUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHARCOUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTEDIT_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_IMSTB_TEXTEDIT_H
#define INCLUDE_IMSTB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef IMSTB_TEXTEDIT_UNDOSTATECOUNT
#define IMSTB_TEXTEDIT_UNDOSTATECOUNT 99
#endif
#ifndef IMSTB_TEXTEDIT_UNDOCHARCOUNT
#define IMSTB_TEXTEDIT_UNDOCHARCOUNT 999
#endif
#ifndef IMSTB_TEXTEDIT_CHARTYPE
#define IMSTB_TEXTEDIT_CHARTYPE int
#endif
#ifndef IMSTB_TEXTEDIT_POSITIONTYPE
#define IMSTB_TEXTEDIT_POSITIONTYPE int
#endif

typedef struct
{
	// private data
	IMSTB_TEXTEDIT_POSITIONTYPE where;
	IMSTB_TEXTEDIT_POSITIONTYPE insert_length;
	IMSTB_TEXTEDIT_POSITIONTYPE delete_length;
	int char_storage;
} StbUndoRecord;

typedef struct
{
	// private data
	StbUndoRecord undo_rec[IMSTB_TEXTEDIT_UNDOSTATECOUNT];
	IMSTB_TEXTEDIT_CHARTYPE undo_char[IMSTB_TEXTEDIT_UNDOCHARCOUNT];
	short undo_point, redo_point;
	int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
	/////////////////////
	//
	// public data
	//

	int cursor;
	// position of the text cursor within the string

	int select_start; // selection start point
	int select_end;
	// selection start and end point in characters; if equal, no selection.
	// note that start may be less than or greater than end (e.g. when
	// dragging the mouse, start is where the initial click was, and you
	// can drag in either direction)

	unsigned char insert_mode;
	// each textfield keeps its own insert mode state. to keep an app-wide
	// insert mode, copy this value in/out of the app state

	int row_count_per_page;
	// page size in number of row.
	// this value MUST be set to >0 for pageup or pagedown in multilines documents.

	/////////////////////
	//
	// private data
	//
	unsigned char cursor_at_end_of_line; // not implemented yet
	unsigned char initialized;
	unsigned char has_preferred_x;
	unsigned char single_line;
	unsigned char padding1, padding2, padding3;
	float preferred_x; // this determines where the cursor up/down tries to seek to along x
	StbUndoState undostate;
} STB_TexteditState;

////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
	float x0, x1; // starting x location, end x location (allows for align=right, etc)
	float baseline_y_delta; // position of baseline relative to previous row's baseline
	float ymin, ymax; // height of row above and below baseline
	int num_chars;
} StbTexteditRow;
#endif //INCLUDE_IMSTB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////

// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef IMSTB_TEXTEDIT_IMPLEMENTATION

#ifndef IMSTB_TEXTEDIT_memmove
#include <string.h>
#define IMSTB_TEXTEDIT_memmove memmove
#endif

/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(IMSTB_TEXTEDIT_STRING *str, float x, float y) {
	StbTexteditRow r;
	int n = STB_TEXTEDIT_STRINGLEN(str);
	float base_y = 0, prev_x;
	int i = 0, k;

	r.x0 = r.x1 = 0;
	r.ymin = r.ymax = 0;
	r.num_chars = 0;

	// search rows to find one that straddles 'y'
	while (i < n) {
		STB_TEXTEDIT_LAYOUTROW(&r, str, i);
		if (r.num_chars <= 0)
			return n;

		if (i == 0 && y < base_y + r.ymin)
			return 0;

		if (y < base_y + r.ymax)
			break;

		i += r.num_chars;
		base_y += r.baseline_y_delta;
	}

	// below all text, return 'after' last character
	if (i >= n)
		return n;

	// check if it's before the beginning of the line
	if (x < r.x0)
		return i;

	// check if it's before the end of the line
	if (x < r.x1) {
		// search characters in row for one that straddles 'x'
		prev_x = r.x0;
		for (k = 0; k < r.num_chars; ++k) {
			float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
			if (x < prev_x + w) {
				if (x < prev_x + w / 2)
					return k + i;
				else
					return k + i + 1;
			}
			prev_x += w;
		}
		// shouldn't happen, but if it does, fall through to end-of-line case
	}

	// if the last character is a newline, return that. otherwise return 'after' the last character
	if (STB_TEXTEDIT_GETCHAR(str, i + r.num_chars - 1) == STB_TEXTEDIT_NEWLINE)
		return i + r.num_chars - 1;
	else
		return i + r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y) {
	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
	// goes off the top or bottom of the text
	if (state->single_line) {
		StbTexteditRow r;
		STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
		y = r.ymin;
	}

	state->cursor = stb_text_locate_coord(str, x, y);
	state->select_start = state->cursor;
	state->select_end = state->cursor;
	state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y) {
	int p = 0;

	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
	// goes off the top or bottom of the text
	if (state->single_line) {
		StbTexteditRow r;
		STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
		y = r.ymin;
	}

	if (state->select_start == state->select_end)
		state->select_start = state->cursor;

	p = stb_text_locate_coord(str, x, y);
	state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
	float x, y; // position of n'th character
	float height; // height of line
	int first_char, length; // first char of row, and length
	int prev_first; // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, IMSTB_TEXTEDIT_STRING *str, int n, int single_line) {
	StbTexteditRow r;
	int prev_start = 0;
	int z = STB_TEXTEDIT_STRINGLEN(str);
	int i = 0, first;

	if (n == z && single_line) {
		// special case if it's at the end (may not be needed?)
		STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
		find->y = 0;
		find->first_char = 0;
		find->length = z;
		find->height = r.ymax - r.ymin;
		find->x = r.x1;
		return;
	}

	// search rows to find the one that straddles character n
	find->y = 0;

	for (;;) {
		STB_TEXTEDIT_LAYOUTROW(&r, str, i);
		if (n < i + r.num_chars)
			break;
		if (i + r.num_chars == z && z > 0 && STB_TEXTEDIT_GETCHAR(str, z - 1) != STB_TEXTEDIT_NEWLINE) // [DEAR IMGUI] special handling for last line
			break; // [DEAR IMGUI]
		prev_start = i;
		i += r.num_chars;
		find->y += r.baseline_y_delta;
		if (i == z) // [DEAR IMGUI]
		{
			r.num_chars = 0; // [DEAR IMGUI]
			break; // [DEAR IMGUI]
		}
	}

	find->first_char = first = i;
	find->length = r.num_chars;
	find->height = r.ymax - r.ymin;
	find->prev_first = prev_start;

	// now scan to find xpos
	find->x = r.x0;
	for (i = 0; first + i < n; ++i)
		find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s) ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	int n = STB_TEXTEDIT_STRINGLEN(str);
	if (STB_TEXT_HAS_SELECTION(state)) {
		if (state->select_start > n)
			state->select_start = n;
		if (state->select_end > n)
			state->select_end = n;
		// if clamping forced them to be equal, move the cursor to match
		if (state->select_start == state->select_end)
			state->cursor = state->select_start;
	}
	if (state->cursor > n)
		state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len) {
	stb_text_makeundo_delete(str, state, where, len);
	STB_TEXTEDIT_DELETECHARS(str, where, len);
	state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	stb_textedit_clamp(str, state);
	if (STB_TEXT_HAS_SELECTION(state)) {
		if (state->select_start < state->select_end) {
			stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
			state->select_end = state->cursor = state->select_start;
		} else {
			stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
			state->select_start = state->cursor = state->select_end;
		}
		state->has_preferred_x = 0;
	}
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state) {
	if (state->select_end < state->select_start) {
		int temp = state->select_end;
		state->select_end = state->select_start;
		state->select_start = temp;
	}
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state) {
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_sortselection(state);
		state->cursor = state->select_start;
		state->select_end = state->select_start;
		state->has_preferred_x = 0;
	}
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_sortselection(state);
		stb_textedit_clamp(str, state);
		state->cursor = state->select_end;
		state->select_start = state->select_end;
		state->has_preferred_x = 0;
	}
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary(IMSTB_TEXTEDIT_STRING *str, int idx) {
	return idx > 0 ? (STB_TEXTEDIT_IS_SPACE(STB_TEXTEDIT_GETCHAR(str, idx - 1)) && !STB_TEXTEDIT_IS_SPACE(STB_TEXTEDIT_GETCHAR(str, idx))) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous(IMSTB_TEXTEDIT_STRING *str, int c) {
	--c; // always move at least one character
	while (c >= 0 && !is_word_boundary(str, c))
		--c;

	if (c < 0)
		c = 0;

	return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next(IMSTB_TEXTEDIT_STRING *str, int c) {
	const int len = STB_TEXTEDIT_STRINGLEN(str);
	++c; // always move at least one character
	while (c < len && !is_word_boundary(str, c))
		++c;

	if (c > len)
		c = len;

	return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state) {
	if (!STB_TEXT_HAS_SELECTION(state))
		state->select_start = state->select_end = state->cursor;
	else
		state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_delete_selection(str, state); // implicitly clamps
		state->has_preferred_x = 0;
		return 1;
	}
	return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE *text, int len) {
	// if there's a selection, the paste should delete it
	stb_textedit_clamp(str, state);
	stb_textedit_delete_selection(str, state);
	// try to insert the characters
	if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
		stb_text_makeundo_insert(state, state->cursor, len);
		state->cursor += len;
		state->has_preferred_x = 0;
		return 1;
	}
	// note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)
	return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key) {
retry:
	switch (key) {
		default: {
			int c = STB_TEXTEDIT_KEYTOTEXT(key);
			if (c > 0) {
				IMSTB_TEXTEDIT_CHARTYPE ch = (IMSTB_TEXTEDIT_CHARTYPE)c;

				// can't add newline in single-line mode
				if (c == '\n' && state->single_line)
					break;

				if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
					stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
					STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
					if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
						++state->cursor;
						state->has_preferred_x = 0;
					}
				} else {
					stb_textedit_delete_selection(str, state); // implicitly clamps
					if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
						stb_text_makeundo_insert(state, state->cursor, 1);
						++state->cursor;
						state->has_preferred_x = 0;
					}
				}
			}
			break;
		}

#ifdef STB_TEXTEDIT_K_INSERT
		case STB_TEXTEDIT_K_INSERT:
			state->insert_mode = !state->insert_mode;
			break;
#endif

		case STB_TEXTEDIT_K_UNDO:
			stb_text_undo(str, state);
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_REDO:
			stb_text_redo(str, state);
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_LEFT:
			// if currently there's a selection, move cursor to start of selection
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_first(state);
			else if (state->cursor > 0)
				--state->cursor;
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_RIGHT:
			// if currently there's a selection, move cursor to end of selection
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_last(str, state);
			else
				++state->cursor;
			stb_textedit_clamp(str, state);
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_clamp(str, state);
			stb_textedit_prep_selection_at_cursor(state);
			// move selection left
			if (state->select_end > 0)
				--state->select_end;
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
		case STB_TEXTEDIT_K_WORDLEFT:
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_first(state);
			else {
				state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
				stb_textedit_clamp(str, state);
			}
			break;

		case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
			if (!STB_TEXT_HAS_SELECTION(state))
				stb_textedit_prep_selection_at_cursor(state);

			state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
			state->select_end = state->cursor;

			stb_textedit_clamp(str, state);
			break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
		case STB_TEXTEDIT_K_WORDRIGHT:
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_last(str, state);
			else {
				state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
				stb_textedit_clamp(str, state);
			}
			break;

		case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
			if (!STB_TEXT_HAS_SELECTION(state))
				stb_textedit_prep_selection_at_cursor(state);

			state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
			state->select_end = state->cursor;

			stb_textedit_clamp(str, state);
			break;
#endif

		case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor(state);
			// move selection right
			++state->select_end;
			stb_textedit_clamp(str, state);
			state->cursor = state->select_end;
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_DOWN:
		case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:
		case STB_TEXTEDIT_K_PGDOWN:
		case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT: {
			StbFindState find;
			StbTexteditRow row;
			int i, j, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
			int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN;
			int row_count = is_page ? state->row_count_per_page : 1;

			if (!is_page && state->single_line) {
				// on windows, up&down in single-line behave like left&right
				key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
				goto retry;
			}

			if (sel)
				stb_textedit_prep_selection_at_cursor(state);
			else if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_last(str, state);

			// compute current position of cursor point
			stb_textedit_clamp(str, state);
			stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

			for (j = 0; j < row_count; ++j) {
				float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;
				int start = find.first_char + find.length;

				if (find.length == 0)
					break;

				// [DEAR IMGUI]
				// going down while being on the last line shouldn't bring us to that line end
				if (STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE)
					break;

				// now find character position down a row
				state->cursor = start;
				STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
				x = row.x0;
				for (i = 0; i < row.num_chars; ++i) {
					float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
#ifdef IMSTB_TEXTEDIT_GETWIDTH_NEWLINE
					if (dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE)
						break;
#endif
					x += dx;
					if (x > goal_x)
						break;
					++state->cursor;
				}
				stb_textedit_clamp(str, state);

				state->has_preferred_x = 1;
				state->preferred_x = goal_x;

				if (sel)
					state->select_end = state->cursor;

				// go to next line
				find.first_char = find.first_char + find.length;
				find.length = row.num_chars;
			}
			break;
		}

		case STB_TEXTEDIT_K_UP:
		case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:
		case STB_TEXTEDIT_K_PGUP:
		case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT: {
			StbFindState find;
			StbTexteditRow row;
			int i, j, prev_scan, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
			int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP;
			int row_count = is_page ? state->row_count_per_page : 1;

			if (!is_page && state->single_line) {
				// on windows, up&down become left&right
				key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
				goto retry;
			}

			if (sel)
				stb_textedit_prep_selection_at_cursor(state);
			else if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_move_to_first(state);

			// compute current position of cursor point
			stb_textedit_clamp(str, state);
			stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

			for (j = 0; j < row_count; ++j) {
				float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

				// can only go up if there's a previous row
				if (find.prev_first == find.first_char)
					break;

				// now find character position up a row
				state->cursor = find.prev_first;
				STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
				x = row.x0;
				for (i = 0; i < row.num_chars; ++i) {
					float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
#ifdef IMSTB_TEXTEDIT_GETWIDTH_NEWLINE
					if (dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE)
						break;
#endif
					x += dx;
					if (x > goal_x)
						break;
					++state->cursor;
				}
				stb_textedit_clamp(str, state);

				state->has_preferred_x = 1;
				state->preferred_x = goal_x;

				if (sel)
					state->select_end = state->cursor;

				// go to previous line
				// (we need to scan previous line the hard way. maybe we could expose this as a new API function?)
				prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;
				while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)
					--prev_scan;
				find.first_char = find.prev_first;
				find.prev_first = prev_scan;
			}
			break;
		}

		case STB_TEXTEDIT_K_DELETE:
		case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_delete_selection(str, state);
			else {
				int n = STB_TEXTEDIT_STRINGLEN(str);
				if (state->cursor < n)
					stb_textedit_delete(str, state, state->cursor, 1);
			}
			state->has_preferred_x = 0;
			break;

		case STB_TEXTEDIT_K_BACKSPACE:
		case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
			if (STB_TEXT_HAS_SELECTION(state))
				stb_textedit_delete_selection(str, state);
			else {
				stb_textedit_clamp(str, state);
				if (state->cursor > 0) {
					stb_textedit_delete(str, state, state->cursor - 1, 1);
					--state->cursor;
				}
			}
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
		case STB_TEXTEDIT_K_TEXTSTART2:
#endif
		case STB_TEXTEDIT_K_TEXTSTART:
			state->cursor = state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
		case STB_TEXTEDIT_K_TEXTEND2:
#endif
		case STB_TEXTEDIT_K_TEXTEND:
			state->cursor = STB_TEXTEDIT_STRINGLEN(str);
			state->select_start = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
		case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor(state);
			state->cursor = state->select_end = 0;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
		case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_prep_selection_at_cursor(state);
			state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_LINESTART2
		case STB_TEXTEDIT_K_LINESTART2:
#endif
		case STB_TEXTEDIT_K_LINESTART:
			stb_textedit_clamp(str, state);
			stb_textedit_move_to_first(state);
			if (state->single_line)
				state->cursor = 0;
			else
				while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor - 1) != STB_TEXTEDIT_NEWLINE)
					--state->cursor;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_LINEEND2
		case STB_TEXTEDIT_K_LINEEND2:
#endif
		case STB_TEXTEDIT_K_LINEEND: {
			int n = STB_TEXTEDIT_STRINGLEN(str);
			stb_textedit_clamp(str, state);
			stb_textedit_move_to_first(state);
			if (state->single_line)
				state->cursor = n;
			else
				while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
					++state->cursor;
			state->has_preferred_x = 0;
			break;
		}

#ifdef STB_TEXTEDIT_K_LINESTART2
		case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
			stb_textedit_clamp(str, state);
			stb_textedit_prep_selection_at_cursor(state);
			if (state->single_line)
				state->cursor = 0;
			else
				while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor - 1) != STB_TEXTEDIT_NEWLINE)
					--state->cursor;
			state->select_end = state->cursor;
			state->has_preferred_x = 0;
			break;

#ifdef STB_TEXTEDIT_K_LINEEND2
		case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
		case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
			int n = STB_TEXTEDIT_STRINGLEN(str);
			stb_textedit_clamp(str, state);
			stb_textedit_prep_selection_at_cursor(state);
			if (state->single_line)
				state->cursor = n;
			else
				while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
					++state->cursor;
			state->select_end = state->cursor;
			state->has_preferred_x = 0;
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state) {
	state->redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT;
	state->redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state) {
	if (state->undo_point > 0) {
		// if the 0th undo state has characters, clean those up
		if (state->undo_rec[0].char_storage >= 0) {
			int n = state->undo_rec[0].insert_length, i;
			// delete n characters from all other records
			state->undo_char_point -= n;
			IMSTB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t)(state->undo_char_point * sizeof(IMSTB_TEXTEDIT_CHARTYPE)));
			for (i = 0; i < state->undo_point; ++i)
				if (state->undo_rec[i].char_storage >= 0)
					state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
		}
		--state->undo_point;
		IMSTB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec + 1, (size_t)(state->undo_point * sizeof(state->undo_rec[0])));
	}
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state) {
	int k = IMSTB_TEXTEDIT_UNDOSTATECOUNT - 1;

	if (state->redo_point <= k) {
		// if the k'th undo state has characters, clean those up
		if (state->undo_rec[k].char_storage >= 0) {
			int n = state->undo_rec[k].insert_length, i;
			// move the remaining redo character data to the end of the buffer
			state->redo_char_point += n;
			IMSTB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point - n, (size_t)((IMSTB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point) * sizeof(IMSTB_TEXTEDIT_CHARTYPE)));
			// adjust the position of all the other records to account for above memmove
			for (i = state->redo_point; i < k; ++i)
				if (state->undo_rec[i].char_storage >= 0)
					state->undo_rec[i].char_storage += n;
		}
		// now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
		// [DEAR IMGUI]
		size_t move_size = (size_t)((IMSTB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));
		const char *buf_begin = (char *)state->undo_rec;
		(void)buf_begin;
		const char *buf_end = (char *)state->undo_rec + sizeof(state->undo_rec);
		(void)buf_end;
		IM_ASSERT(((char *)(state->undo_rec + state->redo_point)) >= buf_begin);
		IM_ASSERT(((char *)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
		IMSTB_TEXTEDIT_memmove(state->undo_rec + state->redo_point + 1, state->undo_rec + state->redo_point, move_size);

		// now move redo_point to point to the new one
		++state->redo_point;
	}
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars) {
	// any time we create a new undo record, we discard redo
	stb_textedit_flush_redo(state);

	// if we have no free records, we have to make room, by sliding the
	// existing records down
	if (state->undo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
		stb_textedit_discard_undo(state);

	// if the characters to store won't possibly fit in the buffer, we can't undo
	if (numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT) {
		state->undo_point = 0;
		state->undo_char_point = 0;
		return NULL;
	}

	// if we don't have enough free characters in the buffer, we have to make room
	while (state->undo_char_point + numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT)
		stb_textedit_discard_undo(state);

	return &state->undo_rec[state->undo_point++];
}

static IMSTB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len) {
	StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
	if (r == NULL)
		return NULL;

	r->where = pos;
	r->insert_length = (IMSTB_TEXTEDIT_POSITIONTYPE)insert_len;
	r->delete_length = (IMSTB_TEXTEDIT_POSITIONTYPE)delete_len;

	if (insert_len == 0) {
		r->char_storage = -1;
		return NULL;
	} else {
		r->char_storage = state->undo_char_point;
		state->undo_char_point += insert_len;
		return &state->undo_char[r->char_storage];
	}
}

static void stb_text_undo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	StbUndoState *s = &state->undostate;
	StbUndoRecord u, *r;
	if (s->undo_point == 0)
		return;

	// we need to do two things: apply the undo record, and create a redo record
	u = s->undo_rec[s->undo_point - 1];
	r = &s->undo_rec[s->redo_point - 1];
	r->char_storage = -1;

	r->insert_length = u.delete_length;
	r->delete_length = u.insert_length;
	r->where = u.where;

	if (u.delete_length) {
		// if the undo record says to delete characters, then the redo record will
		// need to re-insert the characters that get deleted, so we need to store
		// them.

		// there are three cases:
		//    there's enough room to store the characters
		//    characters stored for *redoing* don't leave room for redo
		//    characters stored for *undoing* don't leave room for redo
		// if the last is true, we have to bail

		if (s->undo_char_point + u.delete_length >= IMSTB_TEXTEDIT_UNDOCHARCOUNT) {
			// the undo records take up too much character space; there's no space to store the redo characters
			r->insert_length = 0;
		} else {
			int i;

			// there's definitely room to store the characters eventually
			while (s->undo_char_point + u.delete_length > s->redo_char_point) {
				// should never happen:
				if (s->redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
					return;
				// there's currently not enough room, so discard a redo record
				stb_textedit_discard_redo(s);
			}
			r = &s->undo_rec[s->redo_point - 1];

			r->char_storage = s->redo_char_point - u.delete_length;
			s->redo_char_point = s->redo_char_point - u.delete_length;

			// now save the characters
			for (i = 0; i < u.delete_length; ++i)
				s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
		}

		// now we can carry out the deletion
		STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
	}

	// check type of recorded action:
	if (u.insert_length) {
		// easy case: was a deletion, so we need to insert n characters
		STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
		s->undo_char_point -= u.insert_length;
	}

	state->cursor = u.where + u.insert_length;

	s->undo_point--;
	s->redo_point--;
}

static void stb_text_redo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state) {
	StbUndoState *s = &state->undostate;
	StbUndoRecord *u, r;
	if (s->redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
		return;

	// we need to do two things: apply the redo record, and create an undo record
	u = &s->undo_rec[s->undo_point];
	r = s->undo_rec[s->redo_point];

	// we KNOW there must be room for the undo record, because the redo record
	// was derived from an undo record

	u->delete_length = r.insert_length;
	u->insert_length = r.delete_length;
	u->where = r.where;
	u->char_storage = -1;

	if (r.delete_length) {
		// the redo record requires us to delete characters, so the undo record
		// needs to store the characters

		if (s->undo_char_point + u->insert_length > s->redo_char_point) {
			u->insert_length = 0;
			u->delete_length = 0;
		} else {
			int i;
			u->char_storage = s->undo_char_point;
			s->undo_char_point = s->undo_char_point + u->insert_length;

			// now save the characters
			for (i = 0; i < u->insert_length; ++i)
				s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
		}

		STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
	}

	if (r.insert_length) {
		// easy case: need to insert n characters
		STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
		s->redo_char_point += r.insert_length;
	}

	state->cursor = r.where + r.insert_length;

	s->undo_point++;
	s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length) {
	stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length) {
	int i;
	IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
	if (p) {
		for (i = 0; i < length; ++i)
			p[i] = STB_TEXTEDIT_GETCHAR(str, where + i);
	}
}

static void stb_text_makeundo_replace(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length) {
	int i;
	IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
	if (p) {
		for (i = 0; i < old_length; ++i)
			p[i] = STB_TEXTEDIT_GETCHAR(str, where + i);
	}
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line) {
	state->undostate.undo_point = 0;
	state->undostate.undo_char_point = 0;
	state->undostate.redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT;
	state->undostate.redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT;
	state->select_end = state->select_start = 0;
	state->cursor = 0;
	state->has_preferred_x = 0;
	state->preferred_x = 0;
	state->cursor_at_end_of_line = 0;
	state->initialized = 1;
	state->single_line = (unsigned char)is_single_line;
	state->insert_mode = 0;
	state->row_count_per_page = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line) {
	stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE const *ctext, int len) {
	return stb_textedit_paste_internal(str, state, (IMSTB_TEXTEDIT_CHARTYPE *)ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif //IMSTB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
#line 0

// stb_textedit internally allows for a single undo record to do addition and deletion, but somehow, calling
// the stb_textedit_paste() function creates two separate records, so we perform it manually. (FIXME: Report to nothings/stb?)
static void stb_textedit_replace(ImGuiInputTextState *str, STB_TexteditState *state, const IMSTB_TEXTEDIT_CHARTYPE *text, int text_len) {
	stb_text_makeundo_replace(str, state, 0, str->CurLenW, text_len);
	ImStb::STB_TEXTEDIT_DELETECHARS(str, 0, str->CurLenW);
	state->cursor = state->select_start = state->select_end = 0;
	if (text_len <= 0)
		return;
	if (ImStb::STB_TEXTEDIT_INSERTCHARS(str, 0, text, text_len)) {
		state->cursor = state->select_start = state->select_end = text_len;
		state->has_preferred_x = 0;
		return;
	}
	IM_ASSERT(0); // Failed to insert character, normally shouldn't happen because of how we currently use stb_textedit_replace()
}

} // namespace ImStb

#line 1 "sfw/render_gui/imgui_widgets.cpp"
// dear imgui, v1.91.1
// (widgets code)

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Widgets: Text, etc.
// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)
// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)
// [SECTION] Widgets: ComboBox
// [SECTION] Data Type and Data Formatting Helpers
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
// [SECTION] Widgets: InputText, InputTextMultiline
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
// [SECTION] Widgets: Selectable
// [SECTION] Widgets: Typing-Select support
// [SECTION] Widgets: Box-Select support
// [SECTION] Widgets: Multi-Select support
// [SECTION] Widgets: Multi-Select helpers
// [SECTION] Widgets: ListBox
// [SECTION] Widgets: PlotLines, PlotHistogram
// [SECTION] Widgets: Value helpers
// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif

#ifndef IMGUI_DISABLE

// System includes
#include <stdint.h> // intptr_t

//-------------------------------------------------------------------------
// Warnings
//-------------------------------------------------------------------------

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(disable : 4127) // condition expression is constant
#pragma warning(disable : 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning(disable : 5054) // operator '|': deprecated between enumerations of different types
#endif
#pragma warning(disable : 26451) // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning(disable : 26812) // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option" // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast" // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral" // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wunused-macros" // warning: macro is not used                                // we define snprintf/vsnprintf on Windows so they are available, but not always used.
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant" // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion" // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wenum-enum-conversion" // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')
#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage" // warning: 'xxx' is an unsafe pointer used for buffer access
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wformat-nonliteral" // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#pragma GCC diagnostic ignored "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#endif

//-------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------

// Widgets
static const float DRAGDROP_HOLD_TO_OPEN_TIMER = 0.70f; // Time for drag-hold to activate items accepting the ImGuiButtonFlags_PressedOnDragDropHold button behavior.
static const float DRAG_MOUSE_THRESHOLD_FACTOR = 0.50f; // Multiplier for the default value of io.MouseDragThreshold to make DragFloat/DragInt react faster to mouse drags.

// Those MIN/MAX values are not define because we need to point to them
static const signed char IM_S8_MIN = -128;
static const signed char IM_S8_MAX = 127;
static const unsigned char IM_U8_MIN = 0;
static const unsigned char IM_U8_MAX = 0xFF;
static const signed short IM_S16_MIN = -32768;
static const signed short IM_S16_MAX = 32767;
static const unsigned short IM_U16_MIN = 0;
static const unsigned short IM_U16_MAX = 0xFFFF;
static const ImS32 IM_S32_MIN = INT_MIN; // (-2147483647 - 1), (0x80000000);
static const ImS32 IM_S32_MAX = INT_MAX; // (2147483647), (0x7FFFFFFF)
static const ImU32 IM_U32_MIN = 0;
static const ImU32 IM_U32_MAX = UINT_MAX; // (0xFFFFFFFF)
#ifdef LLONG_MIN
static const ImS64 IM_S64_MIN = LLONG_MIN; // (-9223372036854775807ll - 1ll);
static const ImS64 IM_S64_MAX = LLONG_MAX; // (9223372036854775807ll);
#else
static const ImS64 IM_S64_MIN = -9223372036854775807LL - 1;
static const ImS64 IM_S64_MAX = 9223372036854775807LL;
#endif
static const ImU64 IM_U64_MIN = 0;
#ifdef ULLONG_MAX
static const ImU64 IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
#else
static const ImU64 IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);
#endif

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextEx() [Internal]
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

void ImGui::TextEx(const char *text, const char *text_end, ImGuiTextFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;
	ImGuiContext &g = *GImGui;

	// Accept null ranges
	if (text == text_end)
		text = text_end = "";

	// Calculate length
	const char *text_begin = text;
	if (text_end == NULL)
		text_end = text + strlen(text); // FIXME-OPT

	const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
	const float wrap_pos_x = window->DC.TextWrapPos;
	const bool wrap_enabled = (wrap_pos_x >= 0.0f);
	if (text_end - text <= 2000 || wrap_enabled) {
		// Common case
		const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;
		const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

		ImRect bb(text_pos, text_pos + text_size);
		ItemSize(text_size, 0.0f);
		if (!ItemAdd(bb, 0))
			return;

		// Render (we don't hide text after ## in this end-user function)
		RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
	} else {
		// Long text!
		// Perform manual coarse clipping to optimize for long multi-line text
		// - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
		// - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
		// - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
		const char *line = text;
		const float line_height = GetTextLineHeight();
		ImVec2 text_size(0, 0);

		// Lines to skip (can't skip when logging text)
		ImVec2 pos = text_pos;
		if (!g.LogEnabled) {
			int lines_skippable = (int)((window->ClipRect.Min.y - text_pos.y) / line_height);
			if (lines_skippable > 0) {
				int lines_skipped = 0;
				while (line < text_end && lines_skipped < lines_skippable) {
					const char *line_end = (const char *)memchr(line, '\n', text_end - line);
					if (!line_end)
						line_end = text_end;
					if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
						text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
					line = line_end + 1;
					lines_skipped++;
				}
				pos.y += lines_skipped * line_height;
			}
		}

		// Lines to render
		if (line < text_end) {
			ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
			while (line < text_end) {
				if (IsClippedEx(line_rect, 0))
					break;

				const char *line_end = (const char *)memchr(line, '\n', text_end - line);
				if (!line_end)
					line_end = text_end;
				text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
				RenderText(pos, line, line_end, false);
				line = line_end + 1;
				line_rect.Min.y += line_height;
				line_rect.Max.y += line_height;
				pos.y += line_height;
			}

			// Count remaining lines
			int lines_skipped = 0;
			while (line < text_end) {
				const char *line_end = (const char *)memchr(line, '\n', text_end - line);
				if (!line_end)
					line_end = text_end;
				if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
					text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
				line = line_end + 1;
				lines_skipped++;
			}
			pos.y += lines_skipped * line_height;
		}
		text_size.y = (pos - text_pos).y;

		ImRect bb(text_pos, text_pos + text_size);
		ItemSize(text_size, 0.0f);
		ItemAdd(bb, 0);
	}
}

void ImGui::TextUnformatted(const char *text, const char *text_end) {
	TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
}

void ImGui::Text(const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	TextV(fmt, args);
	va_end(args);
}

void ImGui::TextV(const char *fmt, va_list args) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	const char *text, *text_end;
	ImFormatStringToTempBufferV(&text, &text_end, fmt, args);
	TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
}

void ImGui::TextColored(const ImVec4 &col, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	TextColoredV(col, fmt, args);
	va_end(args);
}

void ImGui::TextColoredV(const ImVec4 &col, const char *fmt, va_list args) {
	PushStyleColor(ImGuiCol_Text, col);
	TextV(fmt, args);
	PopStyleColor();
}

void ImGui::TextDisabled(const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	TextDisabledV(fmt, args);
	va_end(args);
}

void ImGui::TextDisabledV(const char *fmt, va_list args) {
	ImGuiContext &g = *GImGui;
	PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
	TextV(fmt, args);
	PopStyleColor();
}

void ImGui::TextWrapped(const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	TextWrappedV(fmt, args);
	va_end(args);
}

void ImGui::TextWrappedV(const char *fmt, va_list args) {
	ImGuiContext &g = *GImGui;
	const bool need_backup = (g.CurrentWindow->DC.TextWrapPos < 0.0f); // Keep existing wrap position if one is already set
	if (need_backup)
		PushTextWrapPos(0.0f);
	TextV(fmt, args);
	if (need_backup)
		PopTextWrapPos();
}

void ImGui::LabelText(const char *label, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	LabelTextV(label, fmt, args);
	va_end(args);
}

// Add a label+text combo aligned to other label+value widgets
void ImGui::LabelTextV(const char *label, const char *fmt, va_list args) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const float w = CalcItemWidth();

	const char *value_text_begin, *value_text_end;
	ImFormatStringToTempBufferV(&value_text_begin, &value_text_end, fmt, args);
	const ImVec2 value_size = CalcTextSize(value_text_begin, value_text_end, false);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	const ImVec2 pos = window->DC.CursorPos;
	const ImRect value_bb(pos, pos + ImVec2(w, value_size.y + style.FramePadding.y * 2));
	const ImRect total_bb(pos, pos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), ImMax(value_size.y, label_size.y) + style.FramePadding.y * 2));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, 0))
		return;

	// Render
	RenderTextClipped(value_bb.Min + style.FramePadding, value_bb.Max, value_text_begin, value_text_end, &value_size, ImVec2(0.0f, 0.0f));
	if (label_size.x > 0.0f)
		RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);
}

void ImGui::BulletText(const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	BulletTextV(fmt, args);
	va_end(args);
}

// Text with a little bullet aligned to the typical tree node.
void ImGui::BulletTextV(const char *fmt, va_list args) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;

	const char *text_begin, *text_end;
	ImFormatStringToTempBufferV(&text_begin, &text_end, fmt, args);
	const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);
	const ImVec2 total_size = ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x * 2) : 0.0f), label_size.y); // Empty text doesn't add padding
	ImVec2 pos = window->DC.CursorPos;
	pos.y += window->DC.CurrLineTextBaseOffset;
	ItemSize(total_size, 0.0f);
	const ImRect bb(pos, pos + total_size);
	if (!ItemAdd(bb, 0))
		return;

	// Render
	ImU32 text_col = GetColorU32(ImGuiCol_Text);
	RenderBullet(window->DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, g.FontSize * 0.5f), text_col);
	RenderText(bb.Min + ImVec2(g.FontSize + style.FramePadding.x * 2, 0.0f), text_begin, text_end, false);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - GetWindowScrollbarID() [Internal]
// - GetWindowScrollbarRect() [Internal]
// - Scrollbar() [Internal]
// - ScrollbarEx() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlagsT() [Internal]
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()
// - Hyperlink()
//-------------------------------------------------------------------------

// The ButtonBehavior() function is key to many interactions and used by many/most widgets.
// Because we handle so many cases (keyboard/gamepad navigation, drag and drop) and many specific behavior (via ImGuiButtonFlags_),
// this code is a little complex.
// By far the most common path is interacting with the Mouse using the default ImGuiButtonFlags_PressedOnClickRelease button behavior.
// See the series of events below and the corresponding state reported by dear imgui:
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClickRelease:             return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse is outside bb)        -             -                -               -                  -                    -
//   Frame N+1 (mouse moves inside bb)      -             true             -               -                  -                    -
//   Frame N+2 (mouse button is down)       -             true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+4 (mouse moves outside bb)     -             -                true            -                  -                    -
//   Frame N+5 (mouse moves inside bb)      -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+8 (mouse moves outside bb)     -             -                -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClick:                    return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnRelease:                  return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+3 (mouse button is down)       -             true             -               -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  -                    -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnDoubleClick:              return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+1 (mouse button is down)       -             true             -               -                  -                    -
//   Frame N+2 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+3 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+4 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+5 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// Note that some combinations are supported,
// - PressedOnDragDropHold can generally be associated with any flag.
// - PressedOnDoubleClick can be associated by PressedOnClickRelease/PressedOnRelease, in which case the second release event won't be reported.
//------------------------------------------------------------------------------------------------------------------------------------------------
// The behavior of the return-value changes when ImGuiButtonFlags_Repeat is set:
//                                         Repeat+                  Repeat+           Repeat+             Repeat+
//                                         PressedOnClickRelease    PressedOnClick    PressedOnRelease    PressedOnDoubleClick
//-------------------------------------------------------------------------------------------------------------------------------------------------
//   Frame N+0 (mouse button is down)       -                        true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay                  true                     true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay + RepeatRate*N   true                     true              -                   true
//-------------------------------------------------------------------------------------------------------------------------------------------------

// FIXME: For refactor we could output flags, incl mouse hovered vs nav keyboard vs nav triggered etc.
// And better standardize how widgets use 'GetColor32((held && hovered) ? ... : hovered ? ...)' vs 'GetColor32(held ? ... : hovered ? ...);'
// For mouse feedback we typically prefer the 'held && hovered' test, but for nav feedback not always. Outputting hovered=true on Activation may be misleading.
bool ImGui::ButtonBehavior(const ImRect &bb, ImGuiID id, bool *out_hovered, bool *out_held, ImGuiButtonFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();

	// Default only reacts to left mouse button
	if ((flags & ImGuiButtonFlags_MouseButtonMask_) == 0)
		flags |= ImGuiButtonFlags_MouseButtonLeft;

	// Default behavior requires click + release inside bounding box
	if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)
		flags |= ImGuiButtonFlags_PressedOnDefault_;

	// Default behavior inherited from item flags
	// Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one into the item_flags and only check that.
	ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);
	if (flags & ImGuiButtonFlags_AllowOverlap)
		item_flags |= ImGuiItemFlags_AllowOverlap;
	if (flags & ImGuiButtonFlags_Repeat)
		item_flags |= ImGuiItemFlags_ButtonRepeat;

	ImGuiWindow *backup_hovered_window = g.HoveredWindow;
	const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindow == window;
	if (flatten_hovered_children)
		g.HoveredWindow = window;

#ifdef IMGUI_ENABLE_TEST_ENGINE
	// Alternate registration spot, for when caller didn't use ItemAdd()
	if (g.LastItemData.ID != id)
		IMGUI_TEST_ENGINE_ITEM_ADD(id, bb, NULL);
#endif

	bool pressed = false;
	bool hovered = ItemHoverable(bb, id, item_flags);

	// Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
	if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
		if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {
			hovered = true;
			SetHoveredID(id);
			if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER) {
				pressed = true;
				g.DragDropHoldJustPressedId = id;
				FocusWindow(window);
			}
		}

	if (flatten_hovered_children)
		g.HoveredWindow = backup_hovered_window;

	// Mouse handling
	const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;
	if (hovered) {
		IM_ASSERT(id != 0); // Lazily check inside rare path.

		// Poll mouse buttons
		// - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
		// - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.
		int mouse_button_clicked = -1;
		int mouse_button_released = -1;
		for (int button = 0; button < 3; button++)
			if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.
			{
				if (IsMouseClicked(button, ImGuiInputFlags_None, test_owner_id) && mouse_button_clicked == -1) {
					mouse_button_clicked = button;
				}
				if (IsMouseReleased(button, test_owner_id) && mouse_button_released == -1) {
					mouse_button_released = button;
				}
			}

		// Process initial action
		if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt)) {
			if (mouse_button_clicked != -1 && g.ActiveId != id) {
				if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))
					SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);
				if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere)) {
					SetActiveID(id, window);
					g.ActiveIdMouseButton = mouse_button_clicked;
					if (!(flags & ImGuiButtonFlags_NoNavFocus)) {
						SetFocusID(id, window);
						FocusWindow(window);
					} else {
						FocusWindow(window, ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to front, but try to avoid losing NavId when navigating a child
					}
				}
				if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseClickedCount[mouse_button_clicked] == 2)) {
					pressed = true;
					if (flags & ImGuiButtonFlags_NoHoldingActiveId)
						ClearActiveID();
					else
						SetActiveID(id, window); // Hold on ID
					g.ActiveIdMouseButton = mouse_button_clicked;
					if (!(flags & ImGuiButtonFlags_NoNavFocus)) {
						SetFocusID(id, window);
						FocusWindow(window);
					} else {
						FocusWindow(window, ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to front, but try to avoid losing NavId when navigating a child
					}
				}
			}
			if (flags & ImGuiButtonFlags_PressedOnRelease) {
				if (mouse_button_released != -1) {
					const bool has_repeated_at_least_once = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
					if (!has_repeated_at_least_once)
						pressed = true;
					if (!(flags & ImGuiButtonFlags_NoNavFocus))
						SetFocusID(id, window);
					ClearActiveID();
				}
			}

			// 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
			// Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
			if (g.ActiveId == id && (item_flags & ImGuiItemFlags_ButtonRepeat))
				if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f && IsMouseClicked(g.ActiveIdMouseButton, ImGuiInputFlags_Repeat, test_owner_id))
					pressed = true;
		}

		if (pressed)
			g.NavDisableHighlight = true;
	}

	// Gamepad/Keyboard handling
	// We report navigated and navigation-activated items as hovered but we don't set g.HoveredId to not interfere with mouse.
	if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover)
		if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))
			hovered = true;
	if (g.NavActivateDownId == id) {
		bool nav_activated_by_code = (g.NavActivateId == id);
		bool nav_activated_by_inputs = (g.NavActivatePressedId == id);
		if (!nav_activated_by_inputs && (item_flags & ImGuiItemFlags_ButtonRepeat)) {
			// Avoid pressing multiple keys from triggering excessive amount of repeat events
			const ImGuiKeyData *key1 = GetKeyData(ImGuiKey_Space);
			const ImGuiKeyData *key2 = GetKeyData(ImGuiKey_Enter);
			const ImGuiKeyData *key3 = GetKeyData(ImGuiKey_NavGamepadActivate);
			const float t1 = ImMax(ImMax(key1->DownDuration, key2->DownDuration), key3->DownDuration);
			nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
		}
		if (nav_activated_by_code || nav_activated_by_inputs) {
			// Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
			pressed = true;
			SetActiveID(id, window);
			g.ActiveIdSource = g.NavInputSource;
			if (!(flags & ImGuiButtonFlags_NoNavFocus) && !(g.NavActivateFlags & ImGuiActivateFlags_FromShortcut))
				SetFocusID(id, window);
			if (g.NavActivateFlags & ImGuiActivateFlags_FromShortcut)
				g.ActiveIdFromShortcut = true;
		}
	}

	// Process while held
	bool held = false;
	if (g.ActiveId == id) {
		if (g.ActiveIdSource == ImGuiInputSource_Mouse) {
			if (g.ActiveIdIsJustActivated)
				g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

			const int mouse_button = g.ActiveIdMouseButton;
			if (mouse_button == -1) {
				// Fallback for the rare situation were g.ActiveId was set programmatically or from another widget (e.g. #6304).
				ClearActiveID();
			} else if (IsMouseDown(mouse_button, test_owner_id)) {
				held = true;
			} else {
				bool release_in = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;
				bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;
				if ((release_in || release_anywhere) && !g.DragDropActive) {
					// Report as pressed when releasing the mouse (this is the most common path)
					bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2;
					bool is_repeating_already = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
					bool is_button_avail_or_owned = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);
					if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)
						pressed = true;
				}
				ClearActiveID();
			}
			if (!(flags & ImGuiButtonFlags_NoNavFocus))
				g.NavDisableHighlight = true;
		} else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad) {
			// When activated using Nav, we hold on the ActiveID until activation button is released
			if (g.NavActivateDownId == id)
				held = true; // hovered == true not true as we are already likely hovered on direct activation.
			else
				ClearActiveID();
		}
		if (pressed)
			g.ActiveIdHasBeenPressedBefore = true;
	}

	// Activation highlight (this may be a remote activation)
	if (g.NavHighlightActivatedId == id)
		hovered = true;

	if (out_hovered)
		*out_hovered = hovered;
	if (out_held)
		*out_held = held;

	return pressed;
}

bool ImGui::ButtonEx(const char *label, const ImVec2 &size_arg, ImGuiButtonFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	ImVec2 pos = window->DC.CursorPos;
	if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
		pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;
	ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	const ImRect bb(pos, pos + size);
	ItemSize(size, style.FramePadding.y);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	// Render
	const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered
																					  : ImGuiCol_Button);
	RenderNavHighlight(bb, id);
	RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);

	if (g.LogEnabled)
		LogSetNextTextDecoration("[", "]");
	RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	// Automatically close popups
	//if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
	//    CloseCurrentPopup();

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	return pressed;
}

bool ImGui::Button(const char *label, const ImVec2 &size_arg) {
	return ButtonEx(label, size_arg, ImGuiButtonFlags_None);
}

// Small buttons fits within text without additional vertical spacing.
bool ImGui::SmallButton(const char *label) {
	ImGuiContext &g = *GImGui;
	float backup_padding_y = g.Style.FramePadding.y;
	g.Style.FramePadding.y = 0.0f;
	bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);
	g.Style.FramePadding.y = backup_padding_y;
	return pressed;
}

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
bool ImGui::InvisibleButton(const char *str_id, const ImVec2 &size_arg, ImGuiButtonFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	// Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
	IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);

	const ImGuiID id = window->GetID(str_id);
	ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	ItemSize(size);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);
	return pressed;
}

bool ImGui::ArrowButtonEx(const char *str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	const ImGuiID id = window->GetID(str_id);
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	const float default_size = GetFrameHeight();
	ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : -1.0f);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	// Render
	const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered
																						 : ImGuiCol_Button);
	const ImU32 text_col = GetColorU32(ImGuiCol_Text);
	RenderNavHighlight(bb, id);
	RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding);
	RenderArrow(window->DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);
	return pressed;
}

bool ImGui::ArrowButton(const char *str_id, ImGuiDir dir) {
	float sz = GetFrameHeight();
	return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), ImGuiButtonFlags_None);
}

// Button to close a window
bool ImGui::CloseButton(ImGuiID id, const ImVec2 &pos) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	// Tweak 1: Shrink hit-testing area if button covers an abnormally large proportion of the visible region. That's in order to facilitate moving the window away. (#3825)
	// This may better be applied as a general hit-rect reduction mechanism for all widgets to ensure the area to move window is always accessible?
	const ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize));
	ImRect bb_interact = bb;
	const float area_to_visible_ratio = window->OuterRectClipped.GetArea() / bb.GetArea();
	if (area_to_visible_ratio < 1.5f)
		bb_interact.Expand(ImTrunc(bb_interact.GetSize() * -0.25f));

	// Tweak 2: We intentionally allow interaction when clipped so that a mechanical Alt,Right,Activate sequence can always close a window.
	// (this isn't the common behavior of buttons, but it doesn't affect the user because navigation tends to keep items visible in scrolling layer).
	bool is_clipped = !ItemAdd(bb_interact, id);

	bool hovered, held;
	bool pressed = ButtonBehavior(bb_interact, id, &hovered, &held);
	if (is_clipped)
		return pressed;

	// Render
	ImU32 bg_col = GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered);
	if (hovered)
		window->DrawList->AddRectFilled(bb.Min, bb.Max, bg_col);
	RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_Compact);
	ImU32 cross_col = GetColorU32(ImGuiCol_Text);
	ImVec2 cross_center = bb.GetCenter() - ImVec2(0.5f, 0.5f);
	float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;
	window->DrawList->AddLine(cross_center + ImVec2(+cross_extent, +cross_extent), cross_center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);
	window->DrawList->AddLine(cross_center + ImVec2(+cross_extent, -cross_extent), cross_center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);

	return pressed;
}

bool ImGui::CollapseButton(ImGuiID id, const ImVec2 &pos) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize));
	bool is_clipped = !ItemAdd(bb, id);
	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);
	if (is_clipped)
		return pressed;

	// Render
	ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered
																				   : ImGuiCol_Button);
	ImU32 text_col = GetColorU32(ImGuiCol_Text);
	if (hovered || held)
		window->DrawList->AddRectFilled(bb.Min, bb.Max, bg_col);
	RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_Compact);
	RenderArrow(window->DrawList, bb.Min, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);

	// Switch to moving the window after mouse is moved beyond the initial drag threshold
	if (IsItemActive() && IsMouseDragging(0))
		StartMouseMovingWindow(window);

	return pressed;
}

ImGuiID ImGui::GetWindowScrollbarID(ImGuiWindow *window, ImGuiAxis axis) {
	return window->GetID(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
}

// Return scrollbar rectangle, must only be called for corresponding axis if window->ScrollbarX/Y is set.
ImRect ImGui::GetWindowScrollbarRect(ImGuiWindow *window, ImGuiAxis axis) {
	const ImRect outer_rect = window->Rect();
	const ImRect inner_rect = window->InnerRect;
	const float border_size = window->WindowBorderSize;
	const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
	IM_ASSERT(scrollbar_size > 0.0f);
	if (axis == ImGuiAxis_X)
		return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);
	else
		return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);
}

void ImGui::Scrollbar(ImGuiAxis axis) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	const ImGuiID id = GetWindowScrollbarID(window, axis);

	// Calculate scrollbar bounding box
	ImRect bb = GetWindowScrollbarRect(window, axis);
	ImDrawFlags rounding_corners = ImDrawFlags_RoundCornersNone;
	if (axis == ImGuiAxis_X) {
		rounding_corners |= ImDrawFlags_RoundCornersBottomLeft;
		if (!window->ScrollbarY)
			rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
	} else {
		if ((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar))
			rounding_corners |= ImDrawFlags_RoundCornersTopRight;
		if (!window->ScrollbarX)
			rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
	}
	float size_visible = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];
	float size_contents = window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;
	ImS64 scroll = (ImS64)window->Scroll[axis];
	ScrollbarEx(bb, id, axis, &scroll, (ImS64)size_visible, (ImS64)size_contents, rounding_corners);
	window->Scroll[axis] = (float)scroll;
}

// Vertical/Horizontal scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
// Still, the code should probably be made simpler..
bool ImGui::ScrollbarEx(const ImRect &bb_frame, ImGuiID id, ImGuiAxis axis, ImS64 *p_scroll_v, ImS64 size_visible_v, ImS64 size_contents_v, ImDrawFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return false;

	const float bb_frame_width = bb_frame.GetWidth();
	const float bb_frame_height = bb_frame.GetHeight();
	if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)
		return false;

	// When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
	float alpha = 1.0f;
	if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
		alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));
	if (alpha <= 0.0f)
		return false;

	const ImGuiStyle &style = g.Style;
	const bool allow_interaction = (alpha >= 1.0f);

	ImRect bb = bb_frame;
	bb.Expand(ImVec2(-ImClamp(IM_TRUNC((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_TRUNC((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));

	// V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
	const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();

	// Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
	// But we maintain a minimum size in pixel to allow for the user to still aim inside.
	IM_ASSERT(ImMax(size_contents_v, size_visible_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
	const ImS64 win_size_v = ImMax(ImMax(size_contents_v, size_visible_v), (ImS64)1);
	const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_visible_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);
	const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

	// Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
	bool held = false;
	bool hovered = false;
	ItemAdd(bb_frame, id, NULL, ImGuiItemFlags_NoNav);
	ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

	const ImS64 scroll_max = ImMax((ImS64)1, size_contents_v - size_visible_v);
	float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
	float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space
	if (held && allow_interaction && grab_h_norm < 1.0f) {
		const float scrollbar_pos_v = bb.Min[axis];
		const float mouse_pos_v = g.IO.MousePos[axis];

		// Click position in scrollbar normalized space (0.0f->1.0f)
		const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);

		const int held_dir = (clicked_v_norm < grab_v_norm) ? -1 : (clicked_v_norm > grab_v_norm + grab_h_norm) ? +1
																												: 0;
		if (g.ActiveIdIsJustActivated) {
			// On initial click calculate the distance between mouse and the center of the grab
			g.ScrollbarSeekMode = (short)held_dir;
			g.ScrollbarClickDeltaToGrabCenter = (g.ScrollbarSeekMode == 0.0f) ? clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f : 0.0f;
		}

		// Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
		// It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
		if (g.ScrollbarSeekMode == 0) {
			// Absolute seeking
			const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));
			*p_scroll_v = (ImS64)(scroll_v_norm * scroll_max);
		} else {
			// Page by page
			if (IsMouseClicked(ImGuiMouseButton_Left, ImGuiInputFlags_Repeat) && held_dir == g.ScrollbarSeekMode) {
				float page_dir = (g.ScrollbarSeekMode > 0.0f) ? +1.0f : -1.0f;
				*p_scroll_v = ImClamp(*p_scroll_v + (ImS64)(page_dir * size_visible_v), (ImS64)0, scroll_max);
			}
		}

		// Update values for rendering
		scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
		grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

		// Update distance to grab now that we have seek'ed and saturated
		//if (seek_absolute)
		//    g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
	}

	// Render
	const ImU32 bg_col = GetColorU32(ImGuiCol_ScrollbarBg);
	const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered
																					 : ImGuiCol_ScrollbarGrab,
			alpha);
	window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, flags);
	ImRect grab_rect;
	if (axis == ImGuiAxis_X)
		grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);
	else
		grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);
	window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);

	return held;
}

// - Read about ImTextureID here: https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples
// - 'uv0' and 'uv1' are texture coordinates. Read about them from the same link above.
void ImGui::Image(ImTextureID user_texture_id, const ImVec2 &image_size, const ImVec2 &uv0, const ImVec2 &uv1, const ImVec4 &tint_col, const ImVec4 &border_col) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	const float border_size = (border_col.w > 0.0f) ? 1.0f : 0.0f;
	const ImVec2 padding(border_size, border_size);
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + image_size + padding * 2.0f);
	ItemSize(bb);
	if (!ItemAdd(bb, 0))
		return;

	// Render
	if (border_size > 0.0f)
		window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f, ImDrawFlags_None, border_size);
	window->DrawList->AddImage(user_texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col));
}

// ImageButton() is flawed as 'id' is always derived from 'texture_id' (see #2464 #1390)
// We provide this internal helper to write your own variant while we figure out how to redesign the public ImageButton() API.
bool ImGui::ImageButtonEx(ImGuiID id, ImTextureID texture_id, const ImVec2 &image_size, const ImVec2 &uv0, const ImVec2 &uv1, const ImVec4 &bg_col, const ImVec4 &tint_col, ImGuiButtonFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	const ImVec2 padding = g.Style.FramePadding;
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + image_size + padding * 2.0f);
	ItemSize(bb);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	// Render
	const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered
																					  : ImGuiCol_Button);
	RenderNavHighlight(bb, id);
	RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, g.Style.FrameRounding));
	if (bg_col.w > 0.0f)
		window->DrawList->AddRectFilled(bb.Min + padding, bb.Max - padding, GetColorU32(bg_col));
	window->DrawList->AddImage(texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col));

	return pressed;
}

// Note that ImageButton() adds style.FramePadding*2.0f to provided size. This is in order to facilitate fitting an image in a button.
bool ImGui::ImageButton(const char *str_id, ImTextureID user_texture_id, const ImVec2 &image_size, const ImVec2 &uv0, const ImVec2 &uv1, const ImVec4 &bg_col, const ImVec4 &tint_col) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return false;

	return ImageButtonEx(window->GetID(str_id), user_texture_id, image_size, uv0, uv1, bg_col, tint_col);
}

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
// Legacy API obsoleted in 1.89. Two differences with new ImageButton()
// - old ImageButton() used ImTextureId as item id (created issue with multiple buttons with same image, transient texture id values, opaque computation of ID)
// - new ImageButton() requires an explicit 'const char* str_id'
// - old ImageButton() had frame_padding' override argument.
// - new ImageButton() always use style.FramePadding.
/*
bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
{
	// Default to using texture ID as ID. User can still push string/integer prefixes.
	PushID((void*)(intptr_t)user_texture_id);
	if (frame_padding >= 0)
		PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2((float)frame_padding, (float)frame_padding));
	bool ret = ImageButton("", user_texture_id, size, uv0, uv1, bg_col, tint_col);
	if (frame_padding >= 0)
		PopStyleVar();
	PopID();
	return ret;
}
*/
#endif // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS

bool ImGui::Checkbox(const char *label, bool *v) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	const float square_sz = GetFrameHeight();
	const ImVec2 pos = window->DC.CursorPos;
	const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
	ItemSize(total_bb, style.FramePadding.y);
	const bool is_visible = ItemAdd(total_bb, id);
	const bool is_multi_select = (g.LastItemData.InFlags & ImGuiItemFlags_IsMultiSelect) != 0;
	if (!is_visible)
		if (!is_multi_select || !g.BoxSelectState.UnclipMode || !g.BoxSelectState.UnclipRect.Overlaps(total_bb)) // Extra layer of "no logic clip" for box-select support
		{
			IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
			return false;
		}

	// Range-Selection/Multi-selection support (header)
	bool checked = *v;
	if (is_multi_select)
		MultiSelectItemHeader(id, &checked, NULL);

	bool hovered, held;
	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	// Range-Selection/Multi-selection support (footer)
	if (is_multi_select)
		MultiSelectItemFooter(id, &checked, &pressed);
	else if (pressed)
		checked = !checked;

	if (*v != checked) {
		*v = checked;
		pressed = true; // return value
		MarkItemEdited(id);
	}

	const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
	const bool mixed_value = (g.LastItemData.InFlags & ImGuiItemFlags_MixedValue) != 0;
	if (is_visible) {
		RenderNavHighlight(total_bb, id);
		RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered
																												 : ImGuiCol_FrameBg),
				true, style.FrameRounding);
		ImU32 check_col = GetColorU32(ImGuiCol_CheckMark);
		if (mixed_value) {
			// Undocumented tristate/mixed/indeterminate checkbox (#2644)
			// This may seem awkwardly designed because the aim is to make ImGuiItemFlags_MixedValue supported by all widgets (not just checkbox)
			ImVec2 pad(ImMax(1.0f, IM_TRUNC(square_sz / 3.6f)), ImMax(1.0f, IM_TRUNC(square_sz / 3.6f)));
			window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);
		} else if (*v) {
			const float pad = ImMax(1.0f, IM_TRUNC(square_sz / 6.0f));
			RenderCheckMark(window->DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f);
		}
	}
	const ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);
	if (g.LogEnabled)
		LogRenderedText(&label_pos, mixed_value ? "[~]" : *v ? "[x]"
															 : "[ ]");
	if (is_visible && label_size.x > 0.0f)
		RenderText(label_pos, label);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
	return pressed;
}

template <typename T>
bool ImGui::CheckboxFlagsT(const char *label, T *flags, T flags_value) {
	bool all_on = (*flags & flags_value) == flags_value;
	bool any_on = (*flags & flags_value) != 0;
	bool pressed;
	if (!all_on && any_on) {
		ImGuiContext &g = *GImGui;
		g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
		pressed = Checkbox(label, &all_on);
	} else {
		pressed = Checkbox(label, &all_on);
	}
	if (pressed) {
		if (all_on)
			*flags |= flags_value;
		else
			*flags &= ~flags_value;
	}
	return pressed;
}

bool ImGui::CheckboxFlags(const char *label, int *flags, int flags_value) {
	return CheckboxFlagsT(label, flags, flags_value);
}

bool ImGui::CheckboxFlags(const char *label, unsigned int *flags, unsigned int flags_value) {
	return CheckboxFlagsT(label, flags, flags_value);
}

bool ImGui::CheckboxFlags(const char *label, ImS64 *flags, ImS64 flags_value) {
	return CheckboxFlagsT(label, flags, flags_value);
}

bool ImGui::CheckboxFlags(const char *label, ImU64 *flags, ImU64 flags_value) {
	return CheckboxFlagsT(label, flags, flags_value);
}

bool ImGui::RadioButton(const char *label, bool active) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	const float square_sz = GetFrameHeight();
	const ImVec2 pos = window->DC.CursorPos;
	const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
	const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id))
		return false;

	ImVec2 center = check_bb.GetCenter();
	center.x = IM_ROUND(center.x);
	center.y = IM_ROUND(center.y);
	const float radius = (square_sz - 1.0f) * 0.5f;

	bool hovered, held;
	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
	if (pressed)
		MarkItemEdited(id);

	RenderNavHighlight(total_bb, id);
	const int num_segment = window->DrawList->_CalcCircleAutoSegmentCount(radius);
	window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered
																													   : ImGuiCol_FrameBg),
			num_segment);
	if (active) {
		const float pad = ImMax(1.0f, IM_TRUNC(square_sz / 6.0f));
		window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark));
	}

	if (style.FrameBorderSize > 0.0f) {
		window->DrawList->AddCircle(center + ImVec2(1, 1), radius, GetColorU32(ImGuiCol_BorderShadow), num_segment, style.FrameBorderSize);
		window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), num_segment, style.FrameBorderSize);
	}

	ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);
	if (g.LogEnabled)
		LogRenderedText(&label_pos, active ? "(x)" : "( )");
	if (label_size.x > 0.0f)
		RenderText(label_pos, label);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	return pressed;
}

// FIXME: This would work nicely if it was a public template, e.g. 'template<T> RadioButton(const char* label, T* v, T v_button)', but I'm not sure how we would expose it..
bool ImGui::RadioButton(const char *label, int *v, int v_button) {
	const bool pressed = RadioButton(label, *v == v_button);
	if (pressed)
		*v = v_button;
	return pressed;
}

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
void ImGui::ProgressBar(float fraction, const ImVec2 &size_arg, const char *overlay) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;

	ImVec2 pos = window->DC.CursorPos;
	ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y * 2.0f);
	ImRect bb(pos, pos + size);
	ItemSize(size, style.FramePadding.y);
	if (!ItemAdd(bb, 0))
		return;

	// Fraction < 0.0f will display an indeterminate progress bar animation
	// The value must be animated along with time, so e.g. passing '-1.0f * ImGui::GetTime()' as fraction works.
	const bool is_indeterminate = (fraction < 0.0f);
	if (!is_indeterminate)
		fraction = ImSaturate(fraction);

	// Out of courtesy we accept a NaN fraction without crashing
	float fill_n0 = 0.0f;
	float fill_n1 = (fraction == fraction) ? fraction : 0.0f;

	if (is_indeterminate) {
		const float fill_width_n = 0.2f;
		fill_n0 = ImFmod(-fraction, 1.0f) * (1.0f + fill_width_n) - fill_width_n;
		fill_n1 = ImSaturate(fill_n0 + fill_width_n);
		fill_n0 = ImSaturate(fill_n0);
	}

	// Render
	RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
	bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));
	RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), fill_n0, fill_n1, style.FrameRounding);

	// Default displaying the fraction as percentage string, but user can override it
	// Don't display text for indeterminate bars by default
	char overlay_buf[32];
	if (!is_indeterminate || overlay != NULL) {
		if (!overlay) {
			ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction * 100 + 0.01f);
			overlay = overlay_buf;
		}

		ImVec2 overlay_size = CalcTextSize(overlay, NULL);
		if (overlay_size.x > 0.0f) {
			float text_x = is_indeterminate ? (bb.Min.x + bb.Max.x - overlay_size.x) * 0.5f : ImLerp(bb.Min.x, bb.Max.x, fill_n1) + style.ItemSpacing.x;
			RenderTextClipped(ImVec2(ImClamp(text_x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f, 0.5f), &bb);
		}
	}
}

void ImGui::Bullet() {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const float line_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), g.FontSize);
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));
	ItemSize(bb);
	if (!ItemAdd(bb, 0)) {
		SameLine(0, style.FramePadding.x * 2);
		return;
	}

	// Render and stay on same line
	ImU32 text_col = GetColorU32(ImGuiCol_Text);
	RenderBullet(window->DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f), text_col);
	SameLine(0, style.FramePadding.x * 2.0f);
}

// This is provided as a convenience for being an often requested feature.
// FIXME-STYLE: we delayed adding as there is a larger plan to revamp the styling system.
// Because of this we currently don't provide many styling options for this widget
// (e.g. hovered/active colors are automatically inferred from a single color).
bool ImGui::TextLink(const char *label) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiID id = window->GetID(label);
	const char *label_end = FindRenderedTextEnd(label);

	ImVec2 pos = window->DC.CursorPos;
	ImVec2 size = CalcTextSize(label, label_end, true);
	ImRect bb(pos, pos + size);
	ItemSize(size, 0.0f);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);
	RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_None);

	if (hovered)
		SetMouseCursor(ImGuiMouseCursor_Hand);

	ImVec4 text_colf = g.Style.Colors[ImGuiCol_TextLink];
	ImVec4 line_colf = text_colf;
	{
		// FIXME-STYLE: Read comments above. This widget is NOT written in the same style as some earlier widgets,
		// as we are currently experimenting/planning a different styling system.
		float h, s, v;
		ColorConvertRGBtoHSV(text_colf.x, text_colf.y, text_colf.z, h, s, v);
		if (held || hovered) {
			v = ImSaturate(v + (held ? 0.4f : 0.3f));
			h = ImFmod(h + 0.02f, 1.0f);
		}
		ColorConvertHSVtoRGB(h, s, v, text_colf.x, text_colf.y, text_colf.z);
		v = ImSaturate(v - 0.20f);
		ColorConvertHSVtoRGB(h, s, v, line_colf.x, line_colf.y, line_colf.z);
	}

	float line_y = bb.Max.y + ImFloor(g.Font->Descent * g.FontScale * 0.20f);
	window->DrawList->AddLine(ImVec2(bb.Min.x, line_y), ImVec2(bb.Max.x, line_y), GetColorU32(line_colf)); // FIXME-TEXT: Underline mode.

	PushStyleColor(ImGuiCol_Text, GetColorU32(text_colf));
	RenderText(bb.Min, label, label_end);
	PopStyleColor();

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	return pressed;
}

void ImGui::TextLinkOpenURL(const char *label, const char *url) {
	ImGuiContext &g = *GImGui;
	if (url == NULL)
		url = label;
	if (TextLink(label))
		if (g.PlatformIO.Platform_OpenInShellFn != NULL)
			g.PlatformIO.Platform_OpenInShellFn(&g, url);
	SetItemTooltip("%s", url); // It is more reassuring for user to _always_ display URL when we same as label
	if (BeginPopupContextItem()) {
		if (MenuItem(LocalizeGetMsg(ImGuiLocKey_CopyLink)))
			SetClipboardText(url);
		EndPopup();
	}
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - SeparatorEx() [Internal]
// - Separator()
// - SplitterBehavior() [Internal]
// - ShrinkWidths() [Internal]
//-------------------------------------------------------------------------

void ImGui::Spacing() {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;
	ItemSize(ImVec2(0, 0));
}

void ImGui::Dummy(const ImVec2 &size) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	ItemSize(size);
	ItemAdd(bb, 0);
}

void ImGui::NewLine() {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext &g = *GImGui;
	const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
	window->DC.LayoutType = ImGuiLayoutType_Vertical;
	window->DC.IsSameLine = false;
	if (window->DC.CurrLineSize.y > 0.0f) // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
		ItemSize(ImVec2(0, 0));
	else
		ItemSize(ImVec2(0.0f, g.FontSize));
	window->DC.LayoutType = backup_layout_type;
}

void ImGui::AlignTextToFramePadding() {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext &g = *GImGui;
	window->DC.CurrLineSize.y = ImMax(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);
	window->DC.CurrLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, g.Style.FramePadding.y);
}

// Horizontal/vertical separating line
// FIXME: Surprisingly, this seemingly trivial widget is a victim of many different legacy/tricky layout issues.
// Note how thickness == 1.0f is handled specifically as not moving CursorPos by 'thickness', but other values are.
void ImGui::SeparatorEx(ImGuiSeparatorFlags flags, float thickness) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext &g = *GImGui;
	IM_ASSERT(ImIsPowerOfTwo(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical))); // Check that only 1 option is selected
	IM_ASSERT(thickness > 0.0f);

	if (flags & ImGuiSeparatorFlags_Vertical) {
		// Vertical separator, for menu bars (use current line height).
		float y1 = window->DC.CursorPos.y;
		float y2 = window->DC.CursorPos.y + window->DC.CurrLineSize.y;
		const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + thickness, y2));
		ItemSize(ImVec2(thickness, 0.0f));
		if (!ItemAdd(bb, 0))
			return;

		// Draw
		window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));
		if (g.LogEnabled)
			LogText(" |");
	} else if (flags & ImGuiSeparatorFlags_Horizontal) {
		// Horizontal Separator
		float x1 = window->DC.CursorPos.x;
		float x2 = window->WorkRect.Max.x;

		// Preserve legacy behavior inside Columns()
		// Before Tables API happened, we relied on Separator() to span all columns of a Columns() set.
		// We currently don't need to provide the same feature for tables because tables naturally have border features.
		ImGuiOldColumns *columns = (flags & ImGuiSeparatorFlags_SpanAllColumns) ? window->DC.CurrentColumns : NULL;
		if (columns) {
			x1 = window->Pos.x + window->DC.Indent.x; // Used to be Pos.x before 2023/10/03
			x2 = window->Pos.x + window->Size.x;
			PushColumnsBackground();
		}

		// We don't provide our width to the layout so that it doesn't get feed back into AutoFit
		// FIXME: This prevents ->CursorMaxPos based bounding box evaluation from working (e.g. TableEndCell)
		const float thickness_for_layout = (thickness == 1.0f) ? 0.0f : thickness; // FIXME: See 1.70/1.71 Separator() change: makes legacy 1-px separator not affect layout yet. Should change.
		const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + thickness));
		ItemSize(ImVec2(0.0f, thickness_for_layout));

		if (ItemAdd(bb, 0)) {
			// Draw
			window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));
			if (g.LogEnabled)
				LogRenderedText(&bb.Min, "--------------------------------\n");
		}
		if (columns) {
			PopColumnsBackground();
			columns->LineMinY = window->DC.CursorPos.y;
		}
	}
}

void ImGui::Separator() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return;

	// Those flags should eventually be configurable by the user
	// FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
	ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;

	// Only applies to legacy Columns() api as they relied on Separator() a lot.
	if (window->DC.CurrentColumns)
		flags |= ImGuiSeparatorFlags_SpanAllColumns;

	SeparatorEx(flags, 1.0f);
}

void ImGui::SeparatorTextEx(ImGuiID id, const char *label, const char *label_end, float extra_w) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiStyle &style = g.Style;

	const ImVec2 label_size = CalcTextSize(label, label_end, false);
	const ImVec2 pos = window->DC.CursorPos;
	const ImVec2 padding = style.SeparatorTextPadding;

	const float separator_thickness = style.SeparatorTextBorderSize;
	const ImVec2 min_size(label_size.x + extra_w + padding.x * 2.0f, ImMax(label_size.y + padding.y * 2.0f, separator_thickness));
	const ImRect bb(pos, ImVec2(window->WorkRect.Max.x, pos.y + min_size.y));
	const float text_baseline_y = ImTrunc((bb.GetHeight() - label_size.y) * style.SeparatorTextAlign.y + 0.99999f); //ImMax(padding.y, ImFloor((style.SeparatorTextSize - label_size.y) * 0.5f));
	ItemSize(min_size, text_baseline_y);
	if (!ItemAdd(bb, id))
		return;

	const float sep1_x1 = pos.x;
	const float sep2_x2 = bb.Max.x;
	const float seps_y = ImTrunc((bb.Min.y + bb.Max.y) * 0.5f + 0.99999f);

	const float label_avail_w = ImMax(0.0f, sep2_x2 - sep1_x1 - padding.x * 2.0f);
	const ImVec2 label_pos(pos.x + padding.x + ImMax(0.0f, (label_avail_w - label_size.x - extra_w) * style.SeparatorTextAlign.x), pos.y + text_baseline_y); // FIXME-ALIGN

	// This allows using SameLine() to position something in the 'extra_w'
	window->DC.CursorPosPrevLine.x = label_pos.x + label_size.x;

	const ImU32 separator_col = GetColorU32(ImGuiCol_Separator);
	if (label_size.x > 0.0f) {
		const float sep1_x2 = label_pos.x - style.ItemSpacing.x;
		const float sep2_x1 = label_pos.x + label_size.x + extra_w + style.ItemSpacing.x;
		if (sep1_x2 > sep1_x1 && separator_thickness > 0.0f)
			window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep1_x2, seps_y), separator_col, separator_thickness);
		if (sep2_x2 > sep2_x1 && separator_thickness > 0.0f)
			window->DrawList->AddLine(ImVec2(sep2_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);
		if (g.LogEnabled)
			LogSetNextTextDecoration("---", NULL);
		RenderTextEllipsis(window->DrawList, label_pos, ImVec2(bb.Max.x, bb.Max.y + style.ItemSpacing.y), bb.Max.x, bb.Max.x, label, label_end, &label_size);
	} else {
		if (g.LogEnabled)
			LogText("---");
		if (separator_thickness > 0.0f)
			window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);
	}
}

void ImGui::SeparatorText(const char *label) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	// The SeparatorText() vs SeparatorTextEx() distinction is designed to be considerate that we may want:
	// - allow separator-text to be draggable items (would require a stable ID + a noticeable highlight)
	// - this high-level entry point to allow formatting? (which in turns may require ID separate from formatted string)
	// - because of this we probably can't turn 'const char* label' into 'const char* fmt, ...'
	// Otherwise, we can decide that users wanting to drag this would layout a dedicated drag-item,
	// and then we can turn this into a format function.
	SeparatorTextEx(0, label, FindRenderedTextEnd(label), 0.0f);
}

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
bool ImGui::SplitterBehavior(const ImRect &bb, ImGuiID id, ImGuiAxis axis, float *size1, float *size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay, ImU32 bg_col) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	if (!ItemAdd(bb, id, NULL, ImGuiItemFlags_NoNav))
		return false;

	// FIXME: AFAIK the only leftover reason for passing ImGuiButtonFlags_AllowOverlap here is
	// to allow caller of SplitterBehavior() to call SetItemAllowOverlap() after the item.
	// Nowadays we would instead want to use SetNextItemAllowOverlap() before the item.
	ImGuiButtonFlags button_flags = ImGuiButtonFlags_FlattenChildren;
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	button_flags |= ImGuiButtonFlags_AllowOverlap;
#endif

	bool hovered, held;
	ImRect bb_interact = bb;
	bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));
	ButtonBehavior(bb_interact, id, &hovered, &held, button_flags);
	if (hovered)
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect; // for IsItemHovered(), because bb_interact is larger than bb

	if (held || (hovered && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))
		SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

	ImRect bb_render = bb;
	if (held) {
		float mouse_delta = (g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min)[axis];

		// Minimum pane size
		float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);
		float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);
		if (mouse_delta < -size_1_maximum_delta)
			mouse_delta = -size_1_maximum_delta;
		if (mouse_delta > size_2_maximum_delta)
			mouse_delta = size_2_maximum_delta;

		// Apply resize
		if (mouse_delta != 0.0f) {
			*size1 = ImMax(*size1 + mouse_delta, min_size1);
			*size2 = ImMax(*size2 - mouse_delta, min_size2);
			bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));
			MarkItemEdited(id);
		}
	}

	// Render at new position
	if (bg_col & IM_COL32_A_MASK)
		window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, bg_col, 0.0f);
	const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered
																															: ImGuiCol_Separator);
	window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, 0.0f);

	return held;
}

static int IMGUI_CDECL ShrinkWidthItemComparer(const void *lhs, const void *rhs) {
	const ImGuiShrinkWidthItem *a = (const ImGuiShrinkWidthItem *)lhs;
	const ImGuiShrinkWidthItem *b = (const ImGuiShrinkWidthItem *)rhs;
	if (int d = (int)(b->Width - a->Width))
		return d;
	return (b->Index - a->Index);
}

// Shrink excess width from a set of item, by removing width from the larger items first.
// Set items Width to -1.0f to disable shrinking this item.
void ImGui::ShrinkWidths(ImGuiShrinkWidthItem *items, int count, float width_excess) {
	if (count == 1) {
		if (items[0].Width >= 0.0f)
			items[0].Width = ImMax(items[0].Width - width_excess, 1.0f);
		return;
	}
	ImQsort(items, (size_t)count, sizeof(ImGuiShrinkWidthItem), ShrinkWidthItemComparer);
	int count_same_width = 1;
	while (width_excess > 0.0f && count_same_width < count) {
		while (count_same_width < count && items[0].Width <= items[count_same_width].Width)
			count_same_width++;
		float max_width_to_remove_per_item = (count_same_width < count && items[count_same_width].Width >= 0.0f) ? (items[0].Width - items[count_same_width].Width) : (items[0].Width - 1.0f);
		if (max_width_to_remove_per_item <= 0.0f)
			break;
		float width_to_remove_per_item = ImMin(width_excess / count_same_width, max_width_to_remove_per_item);
		for (int item_n = 0; item_n < count_same_width; item_n++)
			items[item_n].Width -= width_to_remove_per_item;
		width_excess -= width_to_remove_per_item * count_same_width;
	}

	// Round width and redistribute remainder
	// Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches exactly at the same distance from the right-most edge of the tab bar separator.
	width_excess = 0.0f;
	for (int n = 0; n < count; n++) {
		float width_rounded = ImTrunc(items[n].Width);
		width_excess += items[n].Width - width_rounded;
		items[n].Width = width_rounded;
	}
	while (width_excess > 0.0f)
		for (int n = 0; n < count && width_excess > 0.0f; n++) {
			float width_to_add = ImMin(items[n].InitialWidth - items[n].Width, 1.0f);
			items[n].Width += width_to_add;
			width_excess -= width_to_add;
		}
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ComboBox
//-------------------------------------------------------------------------
// - CalcMaxPopupHeightFromItemCount() [Internal]
// - BeginCombo()
// - BeginComboPopup() [Internal]
// - EndCombo()
// - BeginComboPreview() [Internal]
// - EndComboPreview() [Internal]
// - Combo()
//-------------------------------------------------------------------------

static float CalcMaxPopupHeightFromItemCount(int items_count) {
	ImGuiContext &g = *GImGui;
	if (items_count <= 0)
		return FLT_MAX;
	return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

bool ImGui::BeginCombo(const char *label, const char *preview_value, ImGuiComboFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();

	ImGuiNextWindowDataFlags backup_next_window_data_flags = g.NextWindowData.Flags;
	g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
	if (window->SkipItems)
		return false;

	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);
	IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together
	if (flags & ImGuiComboFlags_WidthFitPreview)
		IM_ASSERT((flags & (ImGuiComboFlags_NoPreview | (ImGuiComboFlags)ImGuiComboFlags_CustomPreview)) == 0);

	const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const float preview_width = ((flags & ImGuiComboFlags_WidthFitPreview) && (preview_value != NULL)) ? CalcTextSize(preview_value, NULL, true).x : 0.0f;
	const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : ((flags & ImGuiComboFlags_WidthFitPreview) ? (arrow_size + preview_width + style.FramePadding.x * 2.0f) : CalcItemWidth());
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(bb.Min, bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id, &bb))
		return false;

	// Open on click
	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);
	const ImGuiID popup_id = ImHashStr("##ComboPopup", 0, id);
	bool popup_open = IsPopupOpen(popup_id, ImGuiPopupFlags_None);
	if (pressed && !popup_open) {
		OpenPopupEx(popup_id, ImGuiPopupFlags_None);
		popup_open = true;
	}

	// Render shape
	const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
	const float value_x2 = ImMax(bb.Min.x, bb.Max.x - arrow_size);
	RenderNavHighlight(bb, id);
	if (!(flags & ImGuiComboFlags_NoPreview))
		window->DrawList->AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);
	if (!(flags & ImGuiComboFlags_NoArrowButton)) {
		ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
		ImU32 text_col = GetColorU32(ImGuiCol_Text);
		window->DrawList->AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);
		if (value_x2 + arrow_size - style.FramePadding.x <= bb.Max.x)
			RenderArrow(window->DrawList, ImVec2(value_x2 + style.FramePadding.y, bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, 1.0f);
	}
	RenderFrameBorder(bb.Min, bb.Max, style.FrameRounding);

	// Custom preview
	if (flags & ImGuiComboFlags_CustomPreview) {
		g.ComboPreviewData.PreviewRect = ImRect(bb.Min.x, bb.Min.y, value_x2, bb.Max.y);
		IM_ASSERT(preview_value == NULL || preview_value[0] == 0);
		preview_value = NULL;
	}

	// Render preview and label
	if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview)) {
		if (g.LogEnabled)
			LogSetNextTextDecoration("{", "}");
		RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);
	}
	if (label_size.x > 0)
		RenderText(ImVec2(bb.Max.x + style.ItemInnerSpacing.x, bb.Min.y + style.FramePadding.y), label);

	if (!popup_open)
		return false;

	g.NextWindowData.Flags = backup_next_window_data_flags;
	return BeginComboPopup(popup_id, bb, flags);
}

bool ImGui::BeginComboPopup(ImGuiID popup_id, const ImRect &bb, ImGuiComboFlags flags) {
	ImGuiContext &g = *GImGui;
	if (!IsPopupOpen(popup_id, ImGuiPopupFlags_None)) {
		g.NextWindowData.ClearFlags();
		return false;
	}

	// Set popup size
	float w = bb.GetWidth();
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint) {
		g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
	} else {
		if ((flags & ImGuiComboFlags_HeightMask_) == 0)
			flags |= ImGuiComboFlags_HeightRegular;
		IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_)); // Only one
		int popup_max_height_in_items = -1;
		if (flags & ImGuiComboFlags_HeightRegular)
			popup_max_height_in_items = 8;
		else if (flags & ImGuiComboFlags_HeightSmall)
			popup_max_height_in_items = 4;
		else if (flags & ImGuiComboFlags_HeightLarge)
			popup_max_height_in_items = 20;
		ImVec2 constraint_min(0.0f, 0.0f), constraint_max(FLT_MAX, FLT_MAX);
		if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0 || g.NextWindowData.SizeVal.x <= 0.0f) // Don't apply constraints if user specified a size
			constraint_min.x = w;
		if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0 || g.NextWindowData.SizeVal.y <= 0.0f)
			constraint_max.y = CalcMaxPopupHeightFromItemCount(popup_max_height_in_items);
		SetNextWindowSizeConstraints(constraint_min, constraint_max);
	}

	// This is essentially a specialized version of BeginPopupEx()
	char name[16];
	ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginComboDepth); // Recycle windows based on depth

	// Set position given a custom constraint (peak into expected window size so we can position it)
	// FIXME: This might be easier to express with an hypothetical SetNextWindowPosConstraints() function?
	// FIXME: This might be moved to Begin() or at least around the same spot where Tooltips and other Popups are calling FindBestWindowPosForPopupEx()?
	if (ImGuiWindow *popup_window = FindWindowByName(name))
		if (popup_window->WasActive) {
			// Always override 'AutoPosLastDirection' to not leave a chance for a past value to affect us.
			ImVec2 size_expected = CalcWindowNextAutoFitSize(popup_window);
			popup_window->AutoPosLastDirection = (flags & ImGuiComboFlags_PopupAlignLeft) ? ImGuiDir_Left : ImGuiDir_Down; // Left = "Below, Toward Left", Down = "Below, Toward Right (default)"
			ImRect r_outer = GetPopupAllowedExtentRect(popup_window);
			ImVec2 pos = FindBestWindowPosForPopupEx(bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy_ComboBox);
			SetNextWindowPos(pos);
		}

	// We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()
	ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove;
	PushStyleVarX(ImGuiStyleVar_WindowPadding, g.Style.FramePadding.x); // Horizontally align ourselves with the framed text
	bool ret = Begin(name, NULL, window_flags);
	PopStyleVar();
	if (!ret) {
		EndPopup();
		IM_ASSERT(0); // This should never happen as we tested for IsPopupOpen() above
		return false;
	}
	g.BeginComboDepth++;
	return true;
}

void ImGui::EndCombo() {
	ImGuiContext &g = *GImGui;
	EndPopup();
	g.BeginComboDepth--;
}

// Call directly after the BeginCombo/EndCombo block. The preview is designed to only host non-interactive elements
// (Experimental, see GitHub issues: #1658, #4168)
bool ImGui::BeginComboPreview() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiComboPreviewData *preview_data = &g.ComboPreviewData;

	if (window->SkipItems || !(g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible))
		return false;
	IM_ASSERT(g.LastItemData.Rect.Min.x == preview_data->PreviewRect.Min.x && g.LastItemData.Rect.Min.y == preview_data->PreviewRect.Min.y); // Didn't call after BeginCombo/EndCombo block or forgot to pass ImGuiComboFlags_CustomPreview flag?
	if (!window->ClipRect.Overlaps(preview_data->PreviewRect)) // Narrower test (optional)
		return false;

	// FIXME: This could be contained in a PushWorkRect() api
	preview_data->BackupCursorPos = window->DC.CursorPos;
	preview_data->BackupCursorMaxPos = window->DC.CursorMaxPos;
	preview_data->BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;
	preview_data->BackupPrevLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
	preview_data->BackupLayout = window->DC.LayoutType;
	window->DC.CursorPos = preview_data->PreviewRect.Min + g.Style.FramePadding;
	window->DC.CursorMaxPos = window->DC.CursorPos;
	window->DC.LayoutType = ImGuiLayoutType_Horizontal;
	window->DC.IsSameLine = false;
	PushClipRect(preview_data->PreviewRect.Min, preview_data->PreviewRect.Max, true);

	return true;
}

void ImGui::EndComboPreview() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiComboPreviewData *preview_data = &g.ComboPreviewData;

	// FIXME: Using CursorMaxPos approximation instead of correct AABB which we will store in ImDrawCmd in the future
	ImDrawList *draw_list = window->DrawList;
	if (window->DC.CursorMaxPos.x < preview_data->PreviewRect.Max.x && window->DC.CursorMaxPos.y < preview_data->PreviewRect.Max.y)
		if (draw_list->CmdBuffer.Size > 1) // Unlikely case that the PushClipRect() didn't create a command
		{
			draw_list->_CmdHeader.ClipRect = draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ClipRect = draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 2].ClipRect;
			draw_list->_TryMergeDrawCmds();
		}
	PopClipRect();
	window->DC.CursorPos = preview_data->BackupCursorPos;
	window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, preview_data->BackupCursorMaxPos);
	window->DC.CursorPosPrevLine = preview_data->BackupCursorPosPrevLine;
	window->DC.PrevLineTextBaseOffset = preview_data->BackupPrevLineTextBaseOffset;
	window->DC.LayoutType = preview_data->BackupLayout;
	window->DC.IsSameLine = false;
	preview_data->PreviewRect = ImRect();
}

// Getter for the old Combo() API: const char*[]
static const char *Items_ArrayGetter(void *data, int idx) {
	const char *const *items = (const char *const *)data;
	return items[idx];
}

// Getter for the old Combo() API: "item1\0item2\0item3\0"
static const char *Items_SingleStringGetter(void *data, int idx) {
	const char *items_separated_by_zeros = (const char *)data;
	int items_count = 0;
	const char *p = items_separated_by_zeros;
	while (*p) {
		if (idx == items_count)
			break;
		p += strlen(p) + 1;
		items_count++;
	}
	return *p ? p : NULL;
}

// Old API, prefer using BeginCombo() nowadays if you can.
bool ImGui::Combo(const char *label, int *current_item, const char *(*getter)(void *user_data, int idx), void *user_data, int items_count, int popup_max_height_in_items) {
	ImGuiContext &g = *GImGui;

	// Call the getter to obtain the preview string which is a parameter to BeginCombo()
	const char *preview_value = NULL;
	if (*current_item >= 0 && *current_item < items_count)
		preview_value = getter(user_data, *current_item);

	// The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
	if (popup_max_height_in_items != -1 && !(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint))
		SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

	if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
		return false;

	// Display items
	bool value_changed = false;
	ImGuiListClipper clipper;
	clipper.Begin(items_count);
	clipper.IncludeItemByIndex(*current_item);
	while (clipper.Step())
		for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++) {
			const char *item_text = getter(user_data, i);
			if (item_text == NULL)
				item_text = "*Unknown item*";

			PushID(i);
			const bool item_selected = (i == *current_item);
			if (Selectable(item_text, item_selected) && *current_item != i) {
				value_changed = true;
				*current_item = i;
			}
			if (item_selected)
				SetItemDefaultFocus();
			PopID();
		}

	EndCombo();
	if (value_changed)
		MarkItemEdited(g.LastItemData.ID);

	return value_changed;
}

// Combo box helper allowing to pass an array of strings.
bool ImGui::Combo(const char *label, int *current_item, const char *const items[], int items_count, int height_in_items) {
	const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void *)items, items_count, height_in_items);
	return value_changed;
}

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"
bool ImGui::Combo(const char *label, int *current_item, const char *items_separated_by_zeros, int height_in_items) {
	int items_count = 0;
	const char *p = items_separated_by_zeros; // FIXME-OPT: Avoid computing this, or at least only when combo is open
	while (*p) {
		p += strlen(p) + 1;
		items_count++;
	}
	bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void *)items_separated_by_zeros, items_count, height_in_items);
	return value_changed;
}

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS

struct ImGuiGetNameFromIndexOldToNewCallbackData {
	void *UserData;
	bool (*OldCallback)(void *, int, const char **);
};
static const char *ImGuiGetNameFromIndexOldToNewCallback(void *user_data, int idx) {
	ImGuiGetNameFromIndexOldToNewCallbackData *data = (ImGuiGetNameFromIndexOldToNewCallbackData *)user_data;
	const char *s = NULL;
	data->OldCallback(data->UserData, idx, &s);
	return s;
}

bool ImGui::ListBox(const char *label, int *current_item, bool (*old_getter)(void *, int, const char **), void *user_data, int items_count, int height_in_items) {
	ImGuiGetNameFromIndexOldToNewCallbackData old_to_new_data = { user_data, old_getter };
	return ListBox(label, current_item, ImGuiGetNameFromIndexOldToNewCallback, &old_to_new_data, items_count, height_in_items);
}
bool ImGui::Combo(const char *label, int *current_item, bool (*old_getter)(void *, int, const char **), void *user_data, int items_count, int popup_max_height_in_items) {
	ImGuiGetNameFromIndexOldToNewCallbackData old_to_new_data = { user_data, old_getter };
	return Combo(label, current_item, ImGuiGetNameFromIndexOldToNewCallback, &old_to_new_data, items_count, popup_max_height_in_items);
}

#endif

//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - DataTypeGetInfo()
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyFromText()
// - DataTypeCompare()
// - DataTypeClamp()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat<>()
//-------------------------------------------------------------------------

static const ImGuiDataTypeInfo GDataTypeInfo[] = {
	{ sizeof(char), "S8", "%d", "%d" }, // ImGuiDataType_S8
	{ sizeof(unsigned char), "U8", "%u", "%u" },
	{ sizeof(short), "S16", "%d", "%d" }, // ImGuiDataType_S16
	{ sizeof(unsigned short), "U16", "%u", "%u" },
	{ sizeof(int), "S32", "%d", "%d" }, // ImGuiDataType_S32
	{ sizeof(unsigned int), "U32", "%u", "%u" },
#ifdef _MSC_VER
	{ sizeof(ImS64), "S64", "%I64d", "%I64d" }, // ImGuiDataType_S64
	{ sizeof(ImU64), "U64", "%I64u", "%I64u" },
#else
	{ sizeof(ImS64), "S64", "%lld", "%lld" }, // ImGuiDataType_S64
	{ sizeof(ImU64), "U64", "%llu", "%llu" },
#endif
	{ sizeof(float), "float", "%.3f", "%f" }, // ImGuiDataType_Float (float are promoted to double in va_arg)
	{ sizeof(double), "double", "%f", "%lf" }, // ImGuiDataType_Double
	{ sizeof(bool), "bool", "%d", "%d" }, // ImGuiDataType_Bool
};
IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);

const ImGuiDataTypeInfo *ImGui::DataTypeGetInfo(ImGuiDataType data_type) {
	IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
	return &GDataTypeInfo[data_type];
}

int ImGui::DataTypeFormatString(char *buf, int buf_size, ImGuiDataType data_type, const void *p_data, const char *format) {
	// Signedness doesn't matter when pushing integer arguments
	if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)
		return ImFormatString(buf, buf_size, format, *(const ImU32 *)p_data);
	if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)
		return ImFormatString(buf, buf_size, format, *(const ImU64 *)p_data);
	if (data_type == ImGuiDataType_Float)
		return ImFormatString(buf, buf_size, format, *(const float *)p_data);
	if (data_type == ImGuiDataType_Double)
		return ImFormatString(buf, buf_size, format, *(const double *)p_data);
	if (data_type == ImGuiDataType_S8)
		return ImFormatString(buf, buf_size, format, *(const ImS8 *)p_data);
	if (data_type == ImGuiDataType_U8)
		return ImFormatString(buf, buf_size, format, *(const ImU8 *)p_data);
	if (data_type == ImGuiDataType_S16)
		return ImFormatString(buf, buf_size, format, *(const ImS16 *)p_data);
	if (data_type == ImGuiDataType_U16)
		return ImFormatString(buf, buf_size, format, *(const ImU16 *)p_data);
	IM_ASSERT(0);
	return 0;
}

void ImGui::DataTypeApplyOp(ImGuiDataType data_type, int op, void *output, const void *arg1, const void *arg2) {
	IM_ASSERT(op == '+' || op == '-');
	switch (data_type) {
		case ImGuiDataType_S8:
			if (op == '+') {
				*(ImS8 *)output = ImAddClampOverflow(*(const ImS8 *)arg1, *(const ImS8 *)arg2, IM_S8_MIN, IM_S8_MAX);
			}
			if (op == '-') {
				*(ImS8 *)output = ImSubClampOverflow(*(const ImS8 *)arg1, *(const ImS8 *)arg2, IM_S8_MIN, IM_S8_MAX);
			}
			return;
		case ImGuiDataType_U8:
			if (op == '+') {
				*(ImU8 *)output = ImAddClampOverflow(*(const ImU8 *)arg1, *(const ImU8 *)arg2, IM_U8_MIN, IM_U8_MAX);
			}
			if (op == '-') {
				*(ImU8 *)output = ImSubClampOverflow(*(const ImU8 *)arg1, *(const ImU8 *)arg2, IM_U8_MIN, IM_U8_MAX);
			}
			return;
		case ImGuiDataType_S16:
			if (op == '+') {
				*(ImS16 *)output = ImAddClampOverflow(*(const ImS16 *)arg1, *(const ImS16 *)arg2, IM_S16_MIN, IM_S16_MAX);
			}
			if (op == '-') {
				*(ImS16 *)output = ImSubClampOverflow(*(const ImS16 *)arg1, *(const ImS16 *)arg2, IM_S16_MIN, IM_S16_MAX);
			}
			return;
		case ImGuiDataType_U16:
			if (op == '+') {
				*(ImU16 *)output = ImAddClampOverflow(*(const ImU16 *)arg1, *(const ImU16 *)arg2, IM_U16_MIN, IM_U16_MAX);
			}
			if (op == '-') {
				*(ImU16 *)output = ImSubClampOverflow(*(const ImU16 *)arg1, *(const ImU16 *)arg2, IM_U16_MIN, IM_U16_MAX);
			}
			return;
		case ImGuiDataType_S32:
			if (op == '+') {
				*(ImS32 *)output = ImAddClampOverflow(*(const ImS32 *)arg1, *(const ImS32 *)arg2, IM_S32_MIN, IM_S32_MAX);
			}
			if (op == '-') {
				*(ImS32 *)output = ImSubClampOverflow(*(const ImS32 *)arg1, *(const ImS32 *)arg2, IM_S32_MIN, IM_S32_MAX);
			}
			return;
		case ImGuiDataType_U32:
			if (op == '+') {
				*(ImU32 *)output = ImAddClampOverflow(*(const ImU32 *)arg1, *(const ImU32 *)arg2, IM_U32_MIN, IM_U32_MAX);
			}
			if (op == '-') {
				*(ImU32 *)output = ImSubClampOverflow(*(const ImU32 *)arg1, *(const ImU32 *)arg2, IM_U32_MIN, IM_U32_MAX);
			}
			return;
		case ImGuiDataType_S64:
			if (op == '+') {
				*(ImS64 *)output = ImAddClampOverflow(*(const ImS64 *)arg1, *(const ImS64 *)arg2, IM_S64_MIN, IM_S64_MAX);
			}
			if (op == '-') {
				*(ImS64 *)output = ImSubClampOverflow(*(const ImS64 *)arg1, *(const ImS64 *)arg2, IM_S64_MIN, IM_S64_MAX);
			}
			return;
		case ImGuiDataType_U64:
			if (op == '+') {
				*(ImU64 *)output = ImAddClampOverflow(*(const ImU64 *)arg1, *(const ImU64 *)arg2, IM_U64_MIN, IM_U64_MAX);
			}
			if (op == '-') {
				*(ImU64 *)output = ImSubClampOverflow(*(const ImU64 *)arg1, *(const ImU64 *)arg2, IM_U64_MIN, IM_U64_MAX);
			}
			return;
		case ImGuiDataType_Float:
			if (op == '+') {
				*(float *)output = *(const float *)arg1 + *(const float *)arg2;
			}
			if (op == '-') {
				*(float *)output = *(const float *)arg1 - *(const float *)arg2;
			}
			return;
		case ImGuiDataType_Double:
			if (op == '+') {
				*(double *)output = *(const double *)arg1 + *(const double *)arg2;
			}
			if (op == '-') {
				*(double *)output = *(const double *)arg1 - *(const double *)arg2;
			}
			return;
		case ImGuiDataType_COUNT:
			break;
	}
	IM_ASSERT(0);
}

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
bool ImGui::DataTypeApplyFromText(const char *buf, ImGuiDataType data_type, void *p_data, const char *format, void *p_data_when_empty) {
	// Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
	const ImGuiDataTypeInfo *type_info = DataTypeGetInfo(data_type);
	ImGuiDataTypeStorage data_backup;
	memcpy(&data_backup, p_data, type_info->Size);

	while (ImCharIsBlankA(*buf))
		buf++;
	if (!buf[0]) {
		if (p_data_when_empty != NULL) {
			memcpy(p_data, p_data_when_empty, type_info->Size);
			return memcmp(&data_backup, p_data, type_info->Size) != 0;
		}
		return false;
	}

	// Sanitize format
	// - For float/double we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in, so force them into %f and %lf
	// - In theory could treat empty format as using default, but this would only cover rare/bizarre case of using InputScalar() + integer + format string without %.
	char format_sanitized[32];
	if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)
		format = type_info->ScanFmt;
	else
		format = ImParseFormatSanitizeForScanning(format, format_sanitized, IM_ARRAYSIZE(format_sanitized));

	// Small types need a 32-bit buffer to receive the result from scanf()
	int v32 = 0;
	if (sscanf(buf, format, type_info->Size >= 4 ? p_data : &v32) < 1)
		return false;
	if (type_info->Size < 4) {
		if (data_type == ImGuiDataType_S8)
			*(ImS8 *)p_data = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);
		else if (data_type == ImGuiDataType_U8)
			*(ImU8 *)p_data = (ImU8)ImClamp(v32, (int)IM_U8_MIN, (int)IM_U8_MAX);
		else if (data_type == ImGuiDataType_S16)
			*(ImS16 *)p_data = (ImS16)ImClamp(v32, (int)IM_S16_MIN, (int)IM_S16_MAX);
		else if (data_type == ImGuiDataType_U16)
			*(ImU16 *)p_data = (ImU16)ImClamp(v32, (int)IM_U16_MIN, (int)IM_U16_MAX);
		else
			IM_ASSERT(0);
	}

	return memcmp(&data_backup, p_data, type_info->Size) != 0;
}

template <typename T>
static int DataTypeCompareT(const T *lhs, const T *rhs) {
	if (*lhs < *rhs)
		return -1;
	if (*lhs > *rhs)
		return +1;
	return 0;
}

int ImGui::DataTypeCompare(ImGuiDataType data_type, const void *arg_1, const void *arg_2) {
	switch (data_type) {
		case ImGuiDataType_S8:
			return DataTypeCompareT<ImS8>((const ImS8 *)arg_1, (const ImS8 *)arg_2);
		case ImGuiDataType_U8:
			return DataTypeCompareT<ImU8>((const ImU8 *)arg_1, (const ImU8 *)arg_2);
		case ImGuiDataType_S16:
			return DataTypeCompareT<ImS16>((const ImS16 *)arg_1, (const ImS16 *)arg_2);
		case ImGuiDataType_U16:
			return DataTypeCompareT<ImU16>((const ImU16 *)arg_1, (const ImU16 *)arg_2);
		case ImGuiDataType_S32:
			return DataTypeCompareT<ImS32>((const ImS32 *)arg_1, (const ImS32 *)arg_2);
		case ImGuiDataType_U32:
			return DataTypeCompareT<ImU32>((const ImU32 *)arg_1, (const ImU32 *)arg_2);
		case ImGuiDataType_S64:
			return DataTypeCompareT<ImS64>((const ImS64 *)arg_1, (const ImS64 *)arg_2);
		case ImGuiDataType_U64:
			return DataTypeCompareT<ImU64>((const ImU64 *)arg_1, (const ImU64 *)arg_2);
		case ImGuiDataType_Float:
			return DataTypeCompareT<float>((const float *)arg_1, (const float *)arg_2);
		case ImGuiDataType_Double:
			return DataTypeCompareT<double>((const double *)arg_1, (const double *)arg_2);
		case ImGuiDataType_COUNT:
			break;
	}
	IM_ASSERT(0);
	return 0;
}

template <typename T>
static bool DataTypeClampT(T *v, const T *v_min, const T *v_max) {
	// Clamp, both sides are optional, return true if modified
	if (v_min && *v < *v_min) {
		*v = *v_min;
		return true;
	}
	if (v_max && *v > *v_max) {
		*v = *v_max;
		return true;
	}
	return false;
}

bool ImGui::DataTypeClamp(ImGuiDataType data_type, void *p_data, const void *p_min, const void *p_max) {
	switch (data_type) {
		case ImGuiDataType_S8:
			return DataTypeClampT<ImS8>((ImS8 *)p_data, (const ImS8 *)p_min, (const ImS8 *)p_max);
		case ImGuiDataType_U8:
			return DataTypeClampT<ImU8>((ImU8 *)p_data, (const ImU8 *)p_min, (const ImU8 *)p_max);
		case ImGuiDataType_S16:
			return DataTypeClampT<ImS16>((ImS16 *)p_data, (const ImS16 *)p_min, (const ImS16 *)p_max);
		case ImGuiDataType_U16:
			return DataTypeClampT<ImU16>((ImU16 *)p_data, (const ImU16 *)p_min, (const ImU16 *)p_max);
		case ImGuiDataType_S32:
			return DataTypeClampT<ImS32>((ImS32 *)p_data, (const ImS32 *)p_min, (const ImS32 *)p_max);
		case ImGuiDataType_U32:
			return DataTypeClampT<ImU32>((ImU32 *)p_data, (const ImU32 *)p_min, (const ImU32 *)p_max);
		case ImGuiDataType_S64:
			return DataTypeClampT<ImS64>((ImS64 *)p_data, (const ImS64 *)p_min, (const ImS64 *)p_max);
		case ImGuiDataType_U64:
			return DataTypeClampT<ImU64>((ImU64 *)p_data, (const ImU64 *)p_min, (const ImU64 *)p_max);
		case ImGuiDataType_Float:
			return DataTypeClampT<float>((float *)p_data, (const float *)p_min, (const float *)p_max);
		case ImGuiDataType_Double:
			return DataTypeClampT<double>((double *)p_data, (const double *)p_min, (const double *)p_max);
		case ImGuiDataType_COUNT:
			break;
	}
	IM_ASSERT(0);
	return false;
}

static float GetMinimumStepAtDecimalPrecision(int decimal_precision) {
	static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
	if (decimal_precision < 0)
		return FLT_MIN;
	return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);
}

template <typename TYPE>
TYPE ImGui::RoundScalarWithFormatT(const char *format, ImGuiDataType data_type, TYPE v) {
	IM_UNUSED(data_type);
	IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
	const char *fmt_start = ImParseFormatFindStart(format);
	if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
		return v;

	// Sanitize format
	char fmt_sanitized[32];
	ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
	fmt_start = fmt_sanitized;

	// Format value with our rounding, and read back
	char v_str[64];
	ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
	const char *p = v_str;
	while (*p == ' ')
		p++;
	v = (TYPE)ImAtof(p);

	return v;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
//-------------------------------------------------------------------------
// - DragBehaviorT<>() [Internal]
// - DragBehavior() [Internal]
// - DragScalar()
// - DragScalarN()
// - DragFloat()
// - DragFloat2()
// - DragFloat3()
// - DragFloat4()
// - DragFloatRange2()
// - DragInt()
// - DragInt2()
// - DragInt3()
// - DragInt4()
// - DragIntRange2()
//-------------------------------------------------------------------------

// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
template <typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE *v, float v_speed, const TYPE v_min, const TYPE v_max, const char *format, ImGuiSliderFlags flags) {
	ImGuiContext &g = *GImGui;
	const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
	const bool is_bounded = (v_min < v_max);
	const bool is_wrapped = is_bounded && (flags & ImGuiSliderFlags_WrapAround);
	const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
	const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	// Default tweak speed
	if (v_speed == 0.0f && is_bounded && (v_max - v_min < FLT_MAX))
		v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
	float adjust_delta = 0.0f;
	if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR)) {
		adjust_delta = g.IO.MouseDelta[axis];
		if (g.IO.KeyAlt)
			adjust_delta *= 1.0f / 100.0f;
		if (g.IO.KeyShift)
			adjust_delta *= 10.0f;
	} else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad) {
		const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
		const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
		const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
		const float tweak_factor = tweak_slow ? 1.0f / 10.0f : tweak_fast ? 10.0f
																		  : 1.0f;
		adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;
		v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
	}
	adjust_delta *= v_speed;

	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
	if (axis == ImGuiAxis_Y)
		adjust_delta = -adjust_delta;

	// For logarithmic use our range is effectively 0..1 so scale the delta into that range
	if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
		adjust_delta /= (float)(v_max - v_min);

	// Clear current value on activation
	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
	const bool is_just_activated = g.ActiveIdIsJustActivated;
	const bool is_already_past_limits_and_pushing_outward = is_bounded && !is_wrapped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
	if (is_just_activated || is_already_past_limits_and_pushing_outward) {
		g.DragCurrentAccum = 0.0f;
		g.DragCurrentAccumDirty = false;
	} else if (adjust_delta != 0.0f) {
		g.DragCurrentAccum += adjust_delta;
		g.DragCurrentAccumDirty = true;
	}

	if (!g.DragCurrentAccumDirty)
		return false;

	TYPE v_cur = *v;
	FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

	float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
	const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
	if (is_logarithmic) {
		// When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
		const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
		logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);

		// Convert to parametric space, apply delta, convert back
		float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
		float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
		v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
		v_old_ref_for_accum_remainder = v_old_parametric;
	} else {
		v_cur += (SIGNEDTYPE)g.DragCurrentAccum;
	}

	// Round to user desired precision based on format string
	if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
		v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);

	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
	g.DragCurrentAccumDirty = false;
	if (is_logarithmic) {
		// Convert to parametric space, apply delta, convert back
		float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
		g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
	} else {
		g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
	}

	// Lose zero sign for float/double
	if (v_cur == (TYPE)-0)
		v_cur = (TYPE)0;

	if (*v != v_cur && is_bounded) {
		if (is_wrapped) {
			// Wrap values
			if (v_cur < v_min)
				v_cur += v_max - v_min + (is_floating_point ? 0 : 1);
			if (v_cur > v_max)
				v_cur -= v_max - v_min + (is_floating_point ? 0 : 1);
		} else {
			// Clamp values + handle overflow/wrap-around for integer types.
			if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))
				v_cur = v_min;
			if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))
				v_cur = v_max;
		}
	}

	// Apply result
	if (*v == v_cur)
		return false;
	*v = v_cur;
	return true;
}

bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void *p_v, float v_speed, const void *p_min, const void *p_max, const char *format, ImGuiSliderFlags flags) {
	// Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
	IM_ASSERT((flags == 1 || (flags & ImGuiSliderFlags_InvalidMask_) == 0) && "Invalid ImGuiSliderFlags flags! Has the legacy 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.");

	ImGuiContext &g = *GImGui;
	if (g.ActiveId == id) {
		// Those are the things we can do easily outside the DragBehaviorT<> template, saves code generation.
		if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])
			ClearActiveID();
		else if ((g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad) && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
			ClearActiveID();
	}
	if (g.ActiveId != id)
		return false;
	if ((g.LastItemData.InFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
		return false;

	switch (data_type) {
		case ImGuiDataType_S8: {
			ImS32 v32 = (ImS32) * (ImS8 *)p_v;
			bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS8 *)p_min : IM_S8_MIN, p_max ? *(const ImS8 *)p_max : IM_S8_MAX, format, flags);
			if (r)
				*(ImS8 *)p_v = (ImS8)v32;
			return r;
		}
		case ImGuiDataType_U8: {
			ImU32 v32 = (ImU32) * (ImU8 *)p_v;
			bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU8 *)p_min : IM_U8_MIN, p_max ? *(const ImU8 *)p_max : IM_U8_MAX, format, flags);
			if (r)
				*(ImU8 *)p_v = (ImU8)v32;
			return r;
		}
		case ImGuiDataType_S16: {
			ImS32 v32 = (ImS32) * (ImS16 *)p_v;
			bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS16 *)p_min : IM_S16_MIN, p_max ? *(const ImS16 *)p_max : IM_S16_MAX, format, flags);
			if (r)
				*(ImS16 *)p_v = (ImS16)v32;
			return r;
		}
		case ImGuiDataType_U16: {
			ImU32 v32 = (ImU32) * (ImU16 *)p_v;
			bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU16 *)p_min : IM_U16_MIN, p_max ? *(const ImU16 *)p_max : IM_U16_MAX, format, flags);
			if (r)
				*(ImU16 *)p_v = (ImU16)v32;
			return r;
		}
		case ImGuiDataType_S32:
			return DragBehaviorT<ImS32, ImS32, float>(data_type, (ImS32 *)p_v, v_speed, p_min ? *(const ImS32 *)p_min : IM_S32_MIN, p_max ? *(const ImS32 *)p_max : IM_S32_MAX, format, flags);
		case ImGuiDataType_U32:
			return DragBehaviorT<ImU32, ImS32, float>(data_type, (ImU32 *)p_v, v_speed, p_min ? *(const ImU32 *)p_min : IM_U32_MIN, p_max ? *(const ImU32 *)p_max : IM_U32_MAX, format, flags);
		case ImGuiDataType_S64:
			return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64 *)p_v, v_speed, p_min ? *(const ImS64 *)p_min : IM_S64_MIN, p_max ? *(const ImS64 *)p_max : IM_S64_MAX, format, flags);
		case ImGuiDataType_U64:
			return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64 *)p_v, v_speed, p_min ? *(const ImU64 *)p_min : IM_U64_MIN, p_max ? *(const ImU64 *)p_max : IM_U64_MAX, format, flags);
		case ImGuiDataType_Float:
			return DragBehaviorT<float, float, float>(data_type, (float *)p_v, v_speed, p_min ? *(const float *)p_min : -FLT_MAX, p_max ? *(const float *)p_max : FLT_MAX, format, flags);
		case ImGuiDataType_Double:
			return DragBehaviorT<double, double, double>(data_type, (double *)p_v, v_speed, p_min ? *(const double *)p_min : -DBL_MAX, p_max ? *(const double *)p_max : DBL_MAX, format, flags);
		case ImGuiDataType_COUNT:
			break;
	}
	IM_ASSERT(0);
	return false;
}

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a Drag widget, p_min and p_max are optional.
// Read code of e.g. DragFloat(), DragInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
bool ImGui::DragScalar(const char *label, ImGuiDataType data_type, void *p_data, float v_speed, const void *p_min, const void *p_max, const char *format, ImGuiSliderFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	const bool temp_input_allowed = (flags & ImGuiSliderFlags_NoInput) == 0;
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))
		return false;

	// Default format string when passing NULL
	if (format == NULL)
		format = DataTypeGetInfo(data_type)->PrintFmt;

	const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);
	bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);
	if (!temp_input_is_active) {
		// Tabbing or CTRL-clicking on Drag turns it into an InputText
		const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);
		const bool double_clicked = (hovered && g.IO.MouseClickedCount[0] == 2 && TestKeyOwner(ImGuiKey_MouseLeft, id));
		const bool make_active = (clicked || double_clicked || g.NavActivateId == id);
		if (make_active && (clicked || double_clicked))
			SetKeyOwner(ImGuiKey_MouseLeft, id);
		if (make_active && temp_input_allowed)
			if ((clicked && g.IO.KeyCtrl) || double_clicked || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput)))
				temp_input_is_active = true;

		// (Optional) simple click (without moving) turns Drag into an InputText
		if (g.IO.ConfigDragClickToInputText && temp_input_allowed && !temp_input_is_active)
			if (g.ActiveId == id && hovered && g.IO.MouseReleased[0] && !IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR)) {
				g.NavActivateId = id;
				g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
				temp_input_is_active = true;
			}

		if (make_active && !temp_input_is_active) {
			SetActiveID(id, window);
			SetFocusID(id, window);
			FocusWindow(window);
			g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
		}
	}

	if (temp_input_is_active) {
		// Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
		const bool is_clamp_input = (flags & ImGuiSliderFlags_AlwaysClamp) != 0 && (p_min == NULL || p_max == NULL || DataTypeCompare(data_type, p_min, p_max) < 0);
		return TempInputScalar(frame_bb, id, label, data_type, p_data, format, is_clamp_input ? p_min : NULL, is_clamp_input ? p_max : NULL);
	}

	// Draw frame
	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered
																							: ImGuiCol_FrameBg);
	RenderNavHighlight(frame_bb, id);
	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

	// Drag behavior
	const bool value_changed = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags);
	if (value_changed)
		MarkItemEdited(id);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[64];
	const char *value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
	if (g.LogEnabled)
		LogSetNextTextDecoration("{", "}");
	RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_Inputable : 0));
	return value_changed;
}

bool ImGui::DragScalarN(const char *label, ImGuiDataType data_type, void *p_data, int components, float v_speed, const void *p_min, const void *p_max, const char *format, ImGuiSliderFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components, CalcItemWidth());
	size_t type_size = GDataTypeInfo[data_type].Size;
	for (int i = 0; i < components; i++) {
		PushID(i);
		if (i > 0)
			SameLine(0, g.Style.ItemInnerSpacing.x);
		value_changed |= DragScalar("", data_type, p_data, v_speed, p_min, p_max, format, flags);
		PopID();
		PopItemWidth();
		p_data = (void *)((char *)p_data + type_size);
	}
	PopID();

	const char *label_end = FindRenderedTextEnd(label);
	if (label != label_end) {
		SameLine(0, g.Style.ItemInnerSpacing.x);
		TextEx(label, label_end);
	}

	EndGroup();
	return value_changed;
}

bool ImGui::DragFloat(const char *label, float *v, float v_speed, float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, flags);
}

bool ImGui::DragFloat2(const char *label, float v[2], float v_speed, float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, flags);
}

bool ImGui::DragFloat3(const char *label, float v[3], float v_speed, float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, flags);
}

bool ImGui::DragFloat4(const char *label, float v[4], float v_speed, float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, flags);
}

// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.
bool ImGui::DragFloatRange2(const char *label, float *v_current_min, float *v_current_max, float v_speed, float v_min, float v_max, const char *format, const char *format_max, ImGuiSliderFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	PushID(label);
	BeginGroup();
	PushMultiItemsWidths(2, CalcItemWidth());

	float min_min = (v_min >= v_max) ? -FLT_MAX : v_min;
	float min_max = (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max);
	ImGuiSliderFlags min_flags = flags | ((min_min == min_max) ? ImGuiSliderFlags_ReadOnly : 0);
	bool value_changed = DragScalar("##min", ImGuiDataType_Float, v_current_min, v_speed, &min_min, &min_max, format, min_flags);
	PopItemWidth();
	SameLine(0, g.Style.ItemInnerSpacing.x);

	float max_min = (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min);
	float max_max = (v_min >= v_max) ? FLT_MAX : v_max;
	ImGuiSliderFlags max_flags = flags | ((max_min == max_max) ? ImGuiSliderFlags_ReadOnly : 0);
	value_changed |= DragScalar("##max", ImGuiDataType_Float, v_current_max, v_speed, &max_min, &max_max, format_max ? format_max : format, max_flags);
	PopItemWidth();
	SameLine(0, g.Style.ItemInnerSpacing.x);

	TextEx(label, FindRenderedTextEnd(label));
	EndGroup();
	PopID();

	return value_changed;
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
bool ImGui::DragInt(const char *label, int *v, float v_speed, int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format, flags);
}

bool ImGui::DragInt2(const char *label, int v[2], float v_speed, int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format, flags);
}

bool ImGui::DragInt3(const char *label, int v[3], float v_speed, int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format, flags);
}

bool ImGui::DragInt4(const char *label, int v[4], float v_speed, int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format, flags);
}

// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.
bool ImGui::DragIntRange2(const char *label, int *v_current_min, int *v_current_max, float v_speed, int v_min, int v_max, const char *format, const char *format_max, ImGuiSliderFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	PushID(label);
	BeginGroup();
	PushMultiItemsWidths(2, CalcItemWidth());

	int min_min = (v_min >= v_max) ? INT_MIN : v_min;
	int min_max = (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max);
	ImGuiSliderFlags min_flags = flags | ((min_min == min_max) ? ImGuiSliderFlags_ReadOnly : 0);
	bool value_changed = DragInt("##min", v_current_min, v_speed, min_min, min_max, format, min_flags);
	PopItemWidth();
	SameLine(0, g.Style.ItemInnerSpacing.x);

	int max_min = (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min);
	int max_max = (v_min >= v_max) ? INT_MAX : v_max;
	ImGuiSliderFlags max_flags = flags | ((max_min == max_max) ? ImGuiSliderFlags_ReadOnly : 0);
	value_changed |= DragInt("##max", v_current_max, v_speed, max_min, max_max, format_max ? format_max : format, max_flags);
	PopItemWidth();
	SameLine(0, g.Style.ItemInnerSpacing.x);

	TextEx(label, FindRenderedTextEnd(label));
	EndGroup();
	PopID();

	return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - ScaleRatioFromValueT<> [Internal]
// - ScaleValueFromRatioT<> [Internal]
// - SliderBehaviorT<>() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()
//-------------------------------------------------------------------------

// Convert a value v in the output space of a slider into a parametric position on the slider itself (the logical opposite of ScaleValueFromRatioT)
template <typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize) {
	if (v_min == v_max)
		return 0.0f;
	IM_UNUSED(data_type);

	const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
	if (is_logarithmic) {
		bool flipped = v_max < v_min;

		if (flipped) // Handle the case where the range is backwards
			ImSwap(v_min, v_max);

		// Fudge min/max to avoid getting close to log(0)
		FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
		FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;

		// Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
		if ((v_min == 0.0f) && (v_max < 0.0f))
			v_min_fudged = -logarithmic_zero_epsilon;
		else if ((v_max == 0.0f) && (v_min < 0.0f))
			v_max_fudged = -logarithmic_zero_epsilon;

		float result;
		if (v_clamped <= v_min_fudged)
			result = 0.0f; // Workaround for values that are in-range but below our fudge
		else if (v_clamped >= v_max_fudged)
			result = 1.0f; // Workaround for values that are in-range but above our fudge
		else if ((v_min * v_max) < 0.0f) // Range crosses zero, so split into two portions
		{
			float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
			float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
			float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
			if (v == 0.0f)
				result = zero_point_center; // Special case for exactly zero
			else if (v < 0.0f)
				result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;
			else
				result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
		} else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
			result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));
		else
			result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));

		return flipped ? (1.0f - result) : result;
	} else {
		// Linear slider
		return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
	}
}

// Convert a parametric position on a slider into a value v in the output space (the logical opposite of ScaleRatioFromValueT)
template <typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize) {
	// We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
	// but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
	if (t <= 0.0f || v_min == v_max)
		return v_min;
	if (t >= 1.0f)
		return v_max;

	TYPE result = (TYPE)0;
	if (is_logarithmic) {
		// Fudge min/max to avoid getting silly results close to zero
		FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
		FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;

		const bool flipped = v_max < v_min; // Check if range is "backwards"
		if (flipped)
			ImSwap(v_min_fudged, v_max_fudged);

		// Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
		if ((v_max == 0.0f) && (v_min < 0.0f))
			v_max_fudged = -logarithmic_zero_epsilon;

		float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range

		if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
		{
			float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
			float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
			float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
			if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
				result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
			else if (t_with_flip < zero_point_center)
				result = (TYPE) - (logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
			else
				result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
		} else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
			result = (TYPE) - (-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
		else
			result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
	} else {
		// Linear slider
		const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
		if (is_floating_point) {
			result = ImLerp(v_min, v_max, t);
		} else if (t < 1.0) {
			// - For integer values we want the clicking position to match the grab box so we round above
			//   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
			// - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
			//   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
			FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
			result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));
		}
	}

	return result;
}

// FIXME: Try to move more of the code into shared SliderBehavior()
template <typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::SliderBehaviorT(const ImRect &bb, ImGuiID id, ImGuiDataType data_type, TYPE *v, const TYPE v_min, const TYPE v_max, const char *format, ImGuiSliderFlags flags, ImRect *out_grab_bb) {
	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;

	const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
	const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
	const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
	const float v_range_f = (float)(v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.

	// Calculate bounds
	const float grab_padding = 2.0f; // FIXME: Should be part of style.
	const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
	float grab_sz = style.GrabMinSize;
	if (!is_floating_point && v_range_f >= 0.0f) // v_range_f < 0 may happen on integer overflows
		grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize); // For integer sliders: if possible have the grab size represent 1 unit
	grab_sz = ImMin(grab_sz, slider_sz);
	const float slider_usable_sz = slider_sz - grab_sz;
	const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
	const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

	float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
	float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
	if (is_logarithmic) {
		// When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
		const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
		logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
		zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);
	}

	// Process interacting with the slider
	bool value_changed = false;
	if (g.ActiveId == id) {
		bool set_new_value = false;
		float clicked_t = 0.0f;
		if (g.ActiveIdSource == ImGuiInputSource_Mouse) {
			if (!g.IO.MouseDown[0]) {
				ClearActiveID();
			} else {
				const float mouse_abs_pos = g.IO.MousePos[axis];
				if (g.ActiveIdIsJustActivated) {
					float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
					if (axis == ImGuiAxis_Y)
						grab_t = 1.0f - grab_t;
					const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
					const bool clicked_around_grab = (mouse_abs_pos >= grab_pos - grab_sz * 0.5f - 1.0f) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5f + 1.0f); // No harm being extra generous here.
					g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0f;
				}
				if (slider_usable_sz > 0.0f)
					clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz);
				if (axis == ImGuiAxis_Y)
					clicked_t = 1.0f - clicked_t;
				set_new_value = true;
			}
		} else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad) {
			if (g.ActiveIdIsJustActivated) {
				g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
				g.SliderCurrentAccumDirty = false;
			}

			float input_delta = (axis == ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis);
			if (input_delta != 0.0f) {
				const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
				const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);
				const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
				if (decimal_precision > 0) {
					input_delta /= 100.0f; // Gamepad/keyboard tweak speeds in % of slider bounds
					if (tweak_slow)
						input_delta /= 10.0f;
				} else {
					if ((v_range_f >= -100.0f && v_range_f <= 100.0f && v_range_f != 0.0f) || tweak_slow)
						input_delta = ((input_delta < 0.0f) ? -1.0f : +1.0f) / v_range_f; // Gamepad/keyboard tweak speeds in integer steps
					else
						input_delta /= 100.0f;
				}
				if (tweak_fast)
					input_delta *= 10.0f;

				g.SliderCurrentAccum += input_delta;
				g.SliderCurrentAccumDirty = true;
			}

			float delta = g.SliderCurrentAccum;
			if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated) {
				ClearActiveID();
			} else if (g.SliderCurrentAccumDirty) {
				clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);

				if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
				{
					set_new_value = false;
					g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
				} else {
					set_new_value = true;
					float old_clicked_t = clicked_t;
					clicked_t = ImSaturate(clicked_t + delta);

					// Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
					TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
					if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
						v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);
					float new_clicked_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);

					if (delta > 0)
						g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);
					else
						g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);
				}

				g.SliderCurrentAccumDirty = false;
			}
		}

		if (set_new_value)
			if ((g.LastItemData.InFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))
				set_new_value = false;

		if (set_new_value) {
			TYPE v_new = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);

			// Round to user desired precision based on format string
			if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))
				v_new = RoundScalarWithFormatT<TYPE>(format, data_type, v_new);

			// Apply result
			if (*v != v_new) {
				*v = v_new;
				value_changed = true;
			}
		}
	}

	if (slider_sz < 1.0f) {
		*out_grab_bb = ImRect(bb.Min, bb.Min);
	} else {
		// Output grab position so it can be displayed by the caller
		float grab_t = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
		if (axis == ImGuiAxis_Y)
			grab_t = 1.0f - grab_t;
		const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
		if (axis == ImGuiAxis_X)
			*out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
		else
			*out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
	}

	return value_changed;
}

// For 32-bit and larger types, slider bounds are limited to half the natural type range.
// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
bool ImGui::SliderBehavior(const ImRect &bb, ImGuiID id, ImGuiDataType data_type, void *p_v, const void *p_min, const void *p_max, const char *format, ImGuiSliderFlags flags, ImRect *out_grab_bb) {
	// Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
	IM_ASSERT((flags == 1 || (flags & ImGuiSliderFlags_InvalidMask_) == 0) && "Invalid ImGuiSliderFlags flags! Has the legacy 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.");
	IM_ASSERT((flags & ImGuiSliderFlags_WrapAround) == 0); // Not supported by SliderXXX(), only by DragXXX()

	switch (data_type) {
		case ImGuiDataType_S8: {
			ImS32 v32 = (ImS32) * (ImS8 *)p_v;
			bool r = SliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS8 *)p_min, *(const ImS8 *)p_max, format, flags, out_grab_bb);
			if (r)
				*(ImS8 *)p_v = (ImS8)v32;
			return r;
		}
		case ImGuiDataType_U8: {
			ImU32 v32 = (ImU32) * (ImU8 *)p_v;
			bool r = SliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU8 *)p_min, *(const ImU8 *)p_max, format, flags, out_grab_bb);
			if (r)
				*(ImU8 *)p_v = (ImU8)v32;
			return r;
		}
		case ImGuiDataType_S16: {
			ImS32 v32 = (ImS32) * (ImS16 *)p_v;
			bool r = SliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS16 *)p_min, *(const ImS16 *)p_max, format, flags, out_grab_bb);
			if (r)
				*(ImS16 *)p_v = (ImS16)v32;
			return r;
		}
		case ImGuiDataType_U16: {
			ImU32 v32 = (ImU32) * (ImU16 *)p_v;
			bool r = SliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU16 *)p_min, *(const ImU16 *)p_max, format, flags, out_grab_bb);
			if (r)
				*(ImU16 *)p_v = (ImU16)v32;
			return r;
		}
		case ImGuiDataType_S32:
			IM_ASSERT(*(const ImS32 *)p_min >= IM_S32_MIN / 2 && *(const ImS32 *)p_max <= IM_S32_MAX / 2);
			return SliderBehaviorT<ImS32, ImS32, float>(bb, id, data_type, (ImS32 *)p_v, *(const ImS32 *)p_min, *(const ImS32 *)p_max, format, flags, out_grab_bb);
		case ImGuiDataType_U32:
			IM_ASSERT(*(const ImU32 *)p_max <= IM_U32_MAX / 2);
			return SliderBehaviorT<ImU32, ImS32, float>(bb, id, data_type, (ImU32 *)p_v, *(const ImU32 *)p_min, *(const ImU32 *)p_max, format, flags, out_grab_bb);
		case ImGuiDataType_S64:
			IM_ASSERT(*(const ImS64 *)p_min >= IM_S64_MIN / 2 && *(const ImS64 *)p_max <= IM_S64_MAX / 2);
			return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64 *)p_v, *(const ImS64 *)p_min, *(const ImS64 *)p_max, format, flags, out_grab_bb);
		case ImGuiDataType_U64:
			IM_ASSERT(*(const ImU64 *)p_max <= IM_U64_MAX / 2);
			return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64 *)p_v, *(const ImU64 *)p_min, *(const ImU64 *)p_max, format, flags, out_grab_bb);
		case ImGuiDataType_Float:
			IM_ASSERT(*(const float *)p_min >= -FLT_MAX / 2.0f && *(const float *)p_max <= FLT_MAX / 2.0f);
			return SliderBehaviorT<float, float, float>(bb, id, data_type, (float *)p_v, *(const float *)p_min, *(const float *)p_max, format, flags, out_grab_bb);
		case ImGuiDataType_Double:
			IM_ASSERT(*(const double *)p_min >= -DBL_MAX / 2.0f && *(const double *)p_max <= DBL_MAX / 2.0f);
			return SliderBehaviorT<double, double, double>(bb, id, data_type, (double *)p_v, *(const double *)p_min, *(const double *)p_max, format, flags, out_grab_bb);
		case ImGuiDataType_COUNT:
			break;
	}
	IM_ASSERT(0);
	return false;
}

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a slider, they are all required.
// Read code of e.g. SliderFloat(), SliderInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
bool ImGui::SliderScalar(const char *label, ImGuiDataType data_type, void *p_data, const void *p_min, const void *p_max, const char *format, ImGuiSliderFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	const bool temp_input_allowed = (flags & ImGuiSliderFlags_NoInput) == 0;
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))
		return false;

	// Default format string when passing NULL
	if (format == NULL)
		format = DataTypeGetInfo(data_type)->PrintFmt;

	const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);
	bool temp_input_is_active = temp_input_allowed && TempInputIsActive(id);
	if (!temp_input_is_active) {
		// Tabbing or CTRL-clicking on Slider turns it into an input box
		const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);
		const bool make_active = (clicked || g.NavActivateId == id);
		if (make_active && clicked)
			SetKeyOwner(ImGuiKey_MouseLeft, id);
		if (make_active && temp_input_allowed)
			if ((clicked && g.IO.KeyCtrl) || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput)))
				temp_input_is_active = true;

		if (make_active && !temp_input_is_active) {
			SetActiveID(id, window);
			SetFocusID(id, window);
			FocusWindow(window);
			g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
		}
	}

	if (temp_input_is_active) {
		// Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
		const bool is_clamp_input = (flags & ImGuiSliderFlags_AlwaysClamp) != 0;
		return TempInputScalar(frame_bb, id, label, data_type, p_data, format, is_clamp_input ? p_min : NULL, is_clamp_input ? p_max : NULL);
	}

	// Draw frame
	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered
																							: ImGuiCol_FrameBg);
	RenderNavHighlight(frame_bb, id);
	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

	// Slider behavior
	ImRect grab_bb;
	const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags, &grab_bb);
	if (value_changed)
		MarkItemEdited(id);

	// Render grab
	if (grab_bb.Max.x > grab_bb.Min.x)
		window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[64];
	const char *value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
	if (g.LogEnabled)
		LogSetNextTextDecoration("{", "}");
	RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_Inputable : 0));
	return value_changed;
}

// Add multiple sliders on 1 line for compact edition of multiple components
bool ImGui::SliderScalarN(const char *label, ImGuiDataType data_type, void *v, int components, const void *v_min, const void *v_max, const char *format, ImGuiSliderFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components, CalcItemWidth());
	size_t type_size = GDataTypeInfo[data_type].Size;
	for (int i = 0; i < components; i++) {
		PushID(i);
		if (i > 0)
			SameLine(0, g.Style.ItemInnerSpacing.x);
		value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, flags);
		PopID();
		PopItemWidth();
		v = (void *)((char *)v + type_size);
	}
	PopID();

	const char *label_end = FindRenderedTextEnd(label);
	if (label != label_end) {
		SameLine(0, g.Style.ItemInnerSpacing.x);
		TextEx(label, label_end);
	}

	EndGroup();
	return value_changed;
}

bool ImGui::SliderFloat(const char *label, float *v, float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, flags);
}

bool ImGui::SliderFloat2(const char *label, float v[2], float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, flags);
}

bool ImGui::SliderFloat3(const char *label, float v[3], float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, flags);
}

bool ImGui::SliderFloat4(const char *label, float v[4], float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, flags);
}

bool ImGui::SliderAngle(const char *label, float *v_rad, float v_degrees_min, float v_degrees_max, const char *format, ImGuiSliderFlags flags) {
	if (format == NULL)
		format = "%.0f deg";
	float v_deg = (*v_rad) * 360.0f / (2 * IM_PI);
	bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, flags);
	*v_rad = v_deg * (2 * IM_PI) / 360.0f;
	return value_changed;
}

bool ImGui::SliderInt(const char *label, int *v, int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format, flags);
}

bool ImGui::SliderInt2(const char *label, int v[2], int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format, flags);
}

bool ImGui::SliderInt3(const char *label, int v[3], int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format, flags);
}

bool ImGui::SliderInt4(const char *label, int v[4], int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format, flags);
}

bool ImGui::VSliderScalar(const char *label, const ImVec2 &size, ImGuiDataType data_type, void *p_data, const void *p_min, const void *p_max, const char *format, ImGuiSliderFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
	const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	ItemSize(bb, style.FramePadding.y);
	if (!ItemAdd(frame_bb, id))
		return false;

	// Default format string when passing NULL
	if (format == NULL)
		format = DataTypeGetInfo(data_type)->PrintFmt;

	const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);
	const bool clicked = hovered && IsMouseClicked(0, ImGuiInputFlags_None, id);
	if (clicked || g.NavActivateId == id) {
		if (clicked)
			SetKeyOwner(ImGuiKey_MouseLeft, id);
		SetActiveID(id, window);
		SetFocusID(id, window);
		FocusWindow(window);
		g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
	}

	// Draw frame
	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered
																							: ImGuiCol_FrameBg);
	RenderNavHighlight(frame_bb, id);
	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

	// Slider behavior
	ImRect grab_bb;
	const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags | ImGuiSliderFlags_Vertical, &grab_bb);
	if (value_changed)
		MarkItemEdited(id);

	// Render grab
	if (grab_bb.Max.y > grab_bb.Min.y)
		window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	// For the vertical slider we allow centered text to overlap the frame padding
	char value_buf[64];
	const char *value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
	RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.0f));
	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	return value_changed;
}

bool ImGui::VSliderFloat(const char *label, const ImVec2 &size, float *v, float v_min, float v_max, const char *format, ImGuiSliderFlags flags) {
	return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, flags);
}

bool ImGui::VSliderInt(const char *label, const ImVec2 &size, int *v, int v_min, int v_max, const char *format, ImGuiSliderFlags flags) {
	return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format, flags);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
//-------------------------------------------------------------------------
// - ImParseFormatFindStart() [Internal]
// - ImParseFormatFindEnd() [Internal]
// - ImParseFormatTrimDecorations() [Internal]
// - ImParseFormatSanitizeForPrinting() [Internal]
// - ImParseFormatSanitizeForScanning() [Internal]
// - ImParseFormatPrecision() [Internal]
// - TempInputTextScalar() [Internal]
// - InputScalar()
// - InputScalarN()
// - InputFloat()
// - InputFloat2()
// - InputFloat3()
// - InputFloat4()
// - InputInt()
// - InputInt2()
// - InputInt3()
// - InputInt4()
// - InputDouble()
//-------------------------------------------------------------------------

// We don't use strchr() because our strings are usually very short and often start with '%'
const char *ImParseFormatFindStart(const char *fmt) {
	while (char c = fmt[0]) {
		if (c == '%' && fmt[1] != '%')
			return fmt;
		else if (c == '%')
			fmt++;
		fmt++;
	}
	return fmt;
}

const char *ImParseFormatFindEnd(const char *fmt) {
	// Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
	if (fmt[0] != '%')
		return fmt;
	const unsigned int ignored_uppercase_mask = (1 << ('I' - 'A')) | (1 << ('L' - 'A'));
	const unsigned int ignored_lowercase_mask = (1 << ('h' - 'a')) | (1 << ('j' - 'a')) | (1 << ('l' - 'a')) | (1 << ('t' - 'a')) | (1 << ('w' - 'a')) | (1 << ('z' - 'a'));
	for (char c; (c = *fmt) != 0; fmt++) {
		if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)
			return fmt + 1;
		if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)
			return fmt + 1;
	}
	return fmt;
}

// Extract the format out of a format string with leading or trailing decorations
//  fmt = "blah blah"  -> return ""
//  fmt = "%.3f"       -> return fmt
//  fmt = "hello %.3f" -> return fmt + 6
//  fmt = "%.3f hello" -> return buf written with "%.3f"
const char *ImParseFormatTrimDecorations(const char *fmt, char *buf, size_t buf_size) {
	const char *fmt_start = ImParseFormatFindStart(fmt);
	if (fmt_start[0] != '%')
		return "";
	const char *fmt_end = ImParseFormatFindEnd(fmt_start);
	if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.
		return fmt_start;
	ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));
	return buf;
}

// Sanitize format
// - Zero terminate so extra characters after format (e.g. "%f123") don't confuse atof/atoi
// - stb_sprintf.h supports several new modifiers which format numbers in a way that also makes them incompatible atof/atoi.
void ImParseFormatSanitizeForPrinting(const char *fmt_in, char *fmt_out, size_t fmt_out_size) {
	const char *fmt_end = ImParseFormatFindEnd(fmt_in);
	IM_UNUSED(fmt_out_size);
	IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
	while (fmt_in < fmt_end) {
		char c = *fmt_in++;
		if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.
			*(fmt_out++) = c;
	}
	*fmt_out = 0; // Zero-terminate
}

// - For scanning we need to remove all width and precision fields and flags "%+3.7f" -> "%f". BUT don't strip types like "%I64d" which includes digits. ! "%07I64d" -> "%I64d"
const char *ImParseFormatSanitizeForScanning(const char *fmt_in, char *fmt_out, size_t fmt_out_size) {
	const char *fmt_end = ImParseFormatFindEnd(fmt_in);
	const char *fmt_out_begin = fmt_out;
	IM_UNUSED(fmt_out_size);
	IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
	bool has_type = false;
	while (fmt_in < fmt_end) {
		char c = *fmt_in++;
		if (!has_type && ((c >= '0' && c <= '9') || c == '.' || c == '+' || c == '#'))
			continue;
		has_type |= ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')); // Stop skipping digits
		if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.
			*(fmt_out++) = c;
	}
	*fmt_out = 0; // Zero-terminate
	return fmt_out_begin;
}

template <typename TYPE>
static const char *ImAtoi(const char *src, TYPE *output) {
	int negative = 0;
	if (*src == '-') {
		negative = 1;
		src++;
	}
	if (*src == '+') {
		src++;
	}
	TYPE v = 0;
	while (*src >= '0' && *src <= '9')
		v = (v * 10) + (*src++ - '0');
	*output = negative ? -v : v;
	return src;
}

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
int ImParseFormatPrecision(const char *fmt, int default_precision) {
	fmt = ImParseFormatFindStart(fmt);
	if (fmt[0] != '%')
		return default_precision;
	fmt++;
	while (*fmt >= '0' && *fmt <= '9')
		fmt++;
	int precision = INT_MAX;
	if (*fmt == '.') {
		fmt = ImAtoi<int>(fmt + 1, &precision);
		if (precision < 0 || precision > 99)
			precision = default_precision;
	}
	if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
		precision = -1;
	if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)
		precision = -1;
	return (precision == INT_MAX) ? default_precision : precision;
}

// Create text input in place of another active widget (e.g. used when doing a CTRL+Click on drag/slider widgets)
// FIXME: Facilitate using this in variety of other situations.
bool ImGui::TempInputText(const ImRect &bb, ImGuiID id, const char *label, char *buf, int buf_size, ImGuiInputTextFlags flags) {
	// On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.
	// We clear ActiveID on the first frame to allow the InputText() taking it back.
	ImGuiContext &g = *GImGui;
	const bool init = (g.TempInputId != id);
	if (init)
		ClearActiveID();

	g.CurrentWindow->DC.CursorPos = bb.Min;
	bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);
	if (init) {
		// First frame we started displaying the InputText widget, we expect it to take the active id.
		IM_ASSERT(g.ActiveId == id);
		g.TempInputId = g.ActiveId;
	}
	return value_changed;
}

// Note that Drag/Slider functions are only forwarding the min/max values clamping values if the ImGuiSliderFlags_AlwaysClamp flag is set!
// This is intended: this way we allow CTRL+Click manual input to set a value out of bounds, for maximum flexibility.
// However this may not be ideal for all uses, as some user code may break on out of bound values.
bool ImGui::TempInputScalar(const ImRect &bb, ImGuiID id, const char *label, ImGuiDataType data_type, void *p_data, const char *format, const void *p_clamp_min, const void *p_clamp_max) {
	// FIXME: May need to clarify display behavior if format doesn't contain %.
	// "%d" -> "%d" / "There are %d items" -> "%d" / "items" -> "%d" (fallback). Also see #6405
	const ImGuiDataTypeInfo *type_info = DataTypeGetInfo(data_type);
	char fmt_buf[32];
	char data_buf[32];
	format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));
	if (format[0] == 0)
		format = type_info->PrintFmt;
	DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, p_data, format);
	ImStrTrimBlanks(data_buf);

	ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | (ImGuiInputTextFlags)ImGuiInputTextFlags_NoMarkEdited | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint;

	bool value_changed = false;
	if (TempInputText(bb, id, label, data_buf, IM_ARRAYSIZE(data_buf), flags)) {
		// Backup old value
		size_t data_type_size = type_info->Size;
		ImGuiDataTypeStorage data_backup;
		memcpy(&data_backup, p_data, data_type_size);

		// Apply new value (or operations) then clamp
		DataTypeApplyFromText(data_buf, data_type, p_data, format, NULL);
		if (p_clamp_min || p_clamp_max) {
			if (p_clamp_min && p_clamp_max && DataTypeCompare(data_type, p_clamp_min, p_clamp_max) > 0)
				ImSwap(p_clamp_min, p_clamp_max);
			DataTypeClamp(data_type, p_data, p_clamp_min, p_clamp_max);
		}

		// Only mark as edited if new value is different
		value_changed = memcmp(&data_backup, p_data, data_type_size) != 0;
		if (value_changed)
			MarkItemEdited(id);
	}
	return value_changed;
}

void ImGui::SetNextItemRefVal(ImGuiDataType data_type, void *p_data) {
	ImGuiContext &g = *GImGui;
	g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasRefVal;
	memcpy(&g.NextItemData.RefVal, p_data, DataTypeGetInfo(data_type)->Size);
}

// Note: p_data, p_step, p_step_fast are _pointers_ to a memory address holding the data. For an Input widget, p_step and p_step_fast are optional.
// Read code of e.g. InputFloat(), InputInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
bool ImGui::InputScalar(const char *label, ImGuiDataType data_type, void *p_data, const void *p_step, const void *p_step_fast, const char *format, ImGuiInputTextFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	ImGuiStyle &style = g.Style;

	if (format == NULL)
		format = DataTypeGetInfo(data_type)->PrintFmt;

	void *p_data_default = (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasRefVal) ? &g.NextItemData.RefVal : &g.DataTypeZeroValue;

	char buf[64];
	if ((flags & ImGuiInputTextFlags_DisplayEmptyRefVal) && DataTypeCompare(data_type, p_data, p_data_default) == 0)
		buf[0] = 0;
	else
		DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, p_data, format);

	flags |= ImGuiInputTextFlags_AutoSelectAll | (ImGuiInputTextFlags)ImGuiInputTextFlags_NoMarkEdited; // We call MarkItemEdited() ourselves by comparing the actual data rather than the string.
	flags |= (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint;

	bool value_changed = false;
	if (p_step == NULL) {
		if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))
			value_changed = DataTypeApplyFromText(buf, data_type, p_data, format, (flags & ImGuiInputTextFlags_ParseEmptyRefVal) ? p_data_default : NULL);
	} else {
		const float button_size = GetFrameHeight();

		BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
		PushID(label);
		SetNextItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
		if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view
			value_changed = DataTypeApplyFromText(buf, data_type, p_data, format, (flags & ImGuiInputTextFlags_ParseEmptyRefVal) ? p_data_default : NULL);
		IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Inputable);

		// Step buttons
		const ImVec2 backup_frame_padding = style.FramePadding;
		style.FramePadding.x = style.FramePadding.y;
		ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;
		if (flags & ImGuiInputTextFlags_ReadOnly)
			BeginDisabled();
		SameLine(0, style.ItemInnerSpacing.x);
		if (ButtonEx("-", ImVec2(button_size, button_size), button_flags)) {
			DataTypeApplyOp(data_type, '-', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);
			value_changed = true;
		}
		SameLine(0, style.ItemInnerSpacing.x);
		if (ButtonEx("+", ImVec2(button_size, button_size), button_flags)) {
			DataTypeApplyOp(data_type, '+', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);
			value_changed = true;
		}
		if (flags & ImGuiInputTextFlags_ReadOnly)
			EndDisabled();

		const char *label_end = FindRenderedTextEnd(label);
		if (label != label_end) {
			SameLine(0, style.ItemInnerSpacing.x);
			TextEx(label, label_end);
		}
		style.FramePadding = backup_frame_padding;

		PopID();
		EndGroup();
	}
	if (value_changed)
		MarkItemEdited(g.LastItemData.ID);

	return value_changed;
}

bool ImGui::InputScalarN(const char *label, ImGuiDataType data_type, void *p_data, int components, const void *p_step, const void *p_step_fast, const char *format, ImGuiInputTextFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components, CalcItemWidth());
	size_t type_size = GDataTypeInfo[data_type].Size;
	for (int i = 0; i < components; i++) {
		PushID(i);
		if (i > 0)
			SameLine(0, g.Style.ItemInnerSpacing.x);
		value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);
		PopID();
		PopItemWidth();
		p_data = (void *)((char *)p_data + type_size);
	}
	PopID();

	const char *label_end = FindRenderedTextEnd(label);
	if (label != label_end) {
		SameLine(0.0f, g.Style.ItemInnerSpacing.x);
		TextEx(label, label_end);
	}

	EndGroup();
	return value_changed;
}

bool ImGui::InputFloat(const char *label, float *v, float step, float step_fast, const char *format, ImGuiInputTextFlags flags) {
	return InputScalar(label, ImGuiDataType_Float, (void *)v, (void *)(step > 0.0f ? &step : NULL), (void *)(step_fast > 0.0f ? &step_fast : NULL), format, flags);
}

bool ImGui::InputFloat2(const char *label, float v[2], const char *format, ImGuiInputTextFlags flags) {
	return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);
}

bool ImGui::InputFloat3(const char *label, float v[3], const char *format, ImGuiInputTextFlags flags) {
	return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);
}

bool ImGui::InputFloat4(const char *label, float v[4], const char *format, ImGuiInputTextFlags flags) {
	return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);
}

bool ImGui::InputInt(const char *label, int *v, int step, int step_fast, ImGuiInputTextFlags flags) {
	// Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
	const char *format = (flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
	return InputScalar(label, ImGuiDataType_S32, (void *)v, (void *)(step > 0 ? &step : NULL), (void *)(step_fast > 0 ? &step_fast : NULL), format, flags);
}

bool ImGui::InputInt2(const char *label, int v[2], ImGuiInputTextFlags flags) {
	return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", flags);
}

bool ImGui::InputInt3(const char *label, int v[3], ImGuiInputTextFlags flags) {
	return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", flags);
}

bool ImGui::InputInt4(const char *label, int v[4], ImGuiInputTextFlags flags) {
	return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", flags);
}

bool ImGui::InputDouble(const char *label, double *v, double step, double step_fast, const char *format, ImGuiInputTextFlags flags) {
	return InputScalar(label, ImGuiDataType_Double, (void *)v, (void *)(step > 0.0 ? &step : NULL), (void *)(step_fast > 0.0 ? &step_fast : NULL), format, flags);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint
//-------------------------------------------------------------------------
// - InputText()
// - InputTextWithHint()
// - InputTextMultiline()
// - InputTextGetCharInfo() [Internal]
// - InputTextReindexLines() [Internal]
// - InputTextReindexLinesRange() [Internal]
// - InputTextEx() [Internal]
// - DebugNodeInputTextState() [Internal]
//-------------------------------------------------------------------------

bool ImGui::InputText(const char *label, char *buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void *user_data) {
	IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
	return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);
}

bool ImGui::InputTextMultiline(const char *label, char *buf, size_t buf_size, const ImVec2 &size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void *user_data) {
	return InputTextEx(label, NULL, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);
}

bool ImGui::InputTextWithHint(const char *label, const char *hint, char *buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void *user_data) {
	IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline() or  InputTextEx() manually if you need multi-line + hint.
	return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);
}

static int InputTextCalcTextLenAndLineCount(const char *text_begin, const char **out_text_end) {
	int line_count = 0;
	const char *s = text_begin;
	while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding
		if (c == '\n')
			line_count++;
	s--;
	if (s[0] != '\n' && s[0] != '\r')
		line_count++;
	*out_text_end = s;
	return line_count;
}

static ImVec2 InputTextCalcTextSizeW(ImGuiContext *ctx, const ImWchar *text_begin, const ImWchar *text_end, const ImWchar **remaining, ImVec2 *out_offset, bool stop_on_new_line) {
	ImGuiContext &g = *ctx;
	ImFont *font = g.Font;
	const float line_height = g.FontSize;
	const float scale = line_height / font->FontSize;

	ImVec2 text_size = ImVec2(0, 0);
	float line_width = 0.0f;

	const ImWchar *s = text_begin;
	while (s < text_end) {
		unsigned int c = (unsigned int)(*s++);
		if (c == '\n') {
			text_size.x = ImMax(text_size.x, line_width);
			text_size.y += line_height;
			line_width = 0.0f;
			if (stop_on_new_line)
				break;
			continue;
		}
		if (c == '\r')
			continue;

		const float char_width = font->GetCharAdvance((ImWchar)c) * scale;
		line_width += char_width;
	}

	if (text_size.x < line_width)
		text_size.x = line_width;

	if (out_offset)
		*out_offset = ImVec2(line_width, text_size.y + line_height); // offset allow for the possibility of sitting after a trailing \n

	if (line_width > 0 || text_size.y == 0.0f) // whereas size.y will ignore the trailing \n
		text_size.y += line_height;

	if (remaining)
		*remaining = s;

	return text_size;
}

void ImGuiInputTextState::OnKeyPressed(int key) {
	stb_textedit_key(this, &Stb, key);
	CursorFollow = true;
	CursorAnimReset();
}

ImGuiInputTextCallbackData::ImGuiInputTextCallbackData() {
	memset(this, 0, sizeof(*this));
}

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count) {
	IM_ASSERT(pos + bytes_count <= BufTextLen);
	char *dst = Buf + pos;
	const char *src = Buf + pos + bytes_count;
	while (char c = *src++)
		*dst++ = c;
	*dst = '\0';

	if (CursorPos >= pos + bytes_count)
		CursorPos -= bytes_count;
	else if (CursorPos >= pos)
		CursorPos = pos;
	SelectionStart = SelectionEnd = CursorPos;
	BufDirty = true;
	BufTextLen -= bytes_count;
}

void ImGuiInputTextCallbackData::InsertChars(int pos, const char *new_text, const char *new_text_end) {
	// Accept null ranges
	if (new_text == new_text_end)
		return;

	const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;
	const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
	if (new_text_len + BufTextLen >= BufSize) {
		if (!is_resizable)
			return;

		// Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the mildly similar code (until we remove the U16 buffer altogether!)
		ImGuiContext &g = *Ctx;
		ImGuiInputTextState *edit_state = &g.InputTextState;
		IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);
		IM_ASSERT(Buf == edit_state->TextA.Data);
		int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;
		edit_state->TextA.reserve(new_buf_size + 1);
		Buf = edit_state->TextA.Data;
		BufSize = edit_state->BufCapacityA = new_buf_size;
	}

	if (BufTextLen != pos)
		memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
	memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
	Buf[BufTextLen + new_text_len] = '\0';

	if (CursorPos >= pos)
		CursorPos += new_text_len;
	SelectionStart = SelectionEnd = CursorPos;
	BufDirty = true;
	BufTextLen += new_text_len;
}

// Return false to discard a character.
static bool InputTextFilterCharacter(ImGuiContext *ctx, unsigned int *p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void *user_data, bool input_source_is_clipboard) {
	unsigned int c = *p_char;

	// Filter non-printable (NB: isprint is unreliable! see #2467)
	bool apply_named_filters = true;
	if (c < 0x20) {
		bool pass = false;
		pass |= (c == '\n') && (flags & ImGuiInputTextFlags_Multiline) != 0; // Note that an Enter KEY will emit \r and be ignored (we poll for KEY in InputText() code)
		pass |= (c == '\t') && (flags & ImGuiInputTextFlags_AllowTabInput) != 0;
		if (!pass)
			return false;
		apply_named_filters = false; // Override named filters below so newline and tabs can still be inserted.
	}

	if (input_source_is_clipboard == false) {
		// We ignore Ascii representation of delete (emitted from Backspace on OSX, see #2578, #2817)
		if (c == 127)
			return false;

		// Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)
		if (c >= 0xE000 && c <= 0xF8FF)
			return false;
	}

	// Filter Unicode ranges we are not handling in this build
	if (c > IM_UNICODE_CODEPOINT_MAX)
		return false;

	// Generic named filters
	if (apply_named_filters && (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint))) {
		// The libc allows overriding locale, with e.g. 'setlocale(LC_NUMERIC, "de_DE.UTF-8");' which affect the output/input of printf/scanf to use e.g. ',' instead of '.'.
		// The standard mandate that programs starts in the "C" locale where the decimal point is '.'.
		// We don't really intend to provide widespread support for it, but out of empathy for people stuck with using odd API, we support the bare minimum aka overriding the decimal point.
		// Change the default decimal_point with:
		//   ImGui::GetPlatformIO()->Platform_LocaleDecimalPoint = *localeconv()->decimal_point;
		// Users of non-default decimal point (in particular ',') may be affected by word-selection logic (is_word_boundary_from_right/is_word_boundary_from_left) functions.
		ImGuiContext &g = *ctx;
		const unsigned c_decimal_point = (unsigned int)g.PlatformIO.Platform_LocaleDecimalPoint;
		if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsScientific | (ImGuiInputTextFlags)ImGuiInputTextFlags_LocalizeDecimalPoint))
			if (c == '.' || c == ',')
				c = c_decimal_point;

		// Full-width -> half-width conversion for numeric fields (https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)
		// While this is mostly convenient, this has the side-effect for uninformed users accidentally inputting full-width characters that they may
		// scratch their head as to why it works in numerical fields vs in generic text fields it would require support in the font.
		if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsScientific | ImGuiInputTextFlags_CharsHexadecimal))
			if (c >= 0xFF01 && c <= 0xFF5E)
				c = c - 0xFF01 + 0x21;

		// Allow 0-9 . - + * /
		if (flags & ImGuiInputTextFlags_CharsDecimal)
			if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/'))
				return false;

		// Allow 0-9 . - + * / e E
		if (flags & ImGuiInputTextFlags_CharsScientific)
			if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))
				return false;

		// Allow 0-9 a-F A-F
		if (flags & ImGuiInputTextFlags_CharsHexadecimal)
			if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))
				return false;

		// Turn a-z into A-Z
		if (flags & ImGuiInputTextFlags_CharsUppercase)
			if (c >= 'a' && c <= 'z')
				c += (unsigned int)('A' - 'a');

		if (flags & ImGuiInputTextFlags_CharsNoBlank)
			if (ImCharIsBlankW(c))
				return false;

		*p_char = c;
	}

	// Custom callback filter
	if (flags & ImGuiInputTextFlags_CallbackCharFilter) {
		ImGuiContext &g = *GImGui;
		ImGuiInputTextCallbackData callback_data;
		callback_data.Ctx = &g;
		callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
		callback_data.EventChar = (ImWchar)c;
		callback_data.Flags = flags;
		callback_data.UserData = user_data;
		if (callback(&callback_data) != 0)
			return false;
		*p_char = callback_data.EventChar;
		if (!callback_data.EventChar)
			return false;
	}

	return true;
}

// Find the shortest single replacement we can make to get the new text from the old text.
// Important: needs to be run before TextW is rewritten with the new characters because calling STB_TEXTEDIT_GETCHAR() at the end.
// FIXME: Ideally we should transition toward (1) making InsertChars()/DeleteChars() update undo-stack (2) discourage (and keep reconcile) or obsolete (and remove reconcile) accessing buffer directly.
static void InputTextReconcileUndoStateAfterUserCallback(ImGuiInputTextState *state, const char *new_buf_a, int new_length_a) {
	ImGuiContext &g = *GImGui;
	const ImWchar *old_buf = state->TextW.Data;
	const int old_length = state->CurLenW;
	const int new_length = ImTextCountCharsFromUtf8(new_buf_a, new_buf_a + new_length_a);
	g.TempBuffer.reserve_discard((new_length + 1) * sizeof(ImWchar));
	ImWchar *new_buf = (ImWchar *)(void *)g.TempBuffer.Data;
	ImTextStrFromUtf8(new_buf, new_length + 1, new_buf_a, new_buf_a + new_length_a);

	const int shorter_length = ImMin(old_length, new_length);
	int first_diff;
	for (first_diff = 0; first_diff < shorter_length; first_diff++)
		if (old_buf[first_diff] != new_buf[first_diff])
			break;
	if (first_diff == old_length && first_diff == new_length)
		return;

	int old_last_diff = old_length - 1;
	int new_last_diff = new_length - 1;
	for (; old_last_diff >= first_diff && new_last_diff >= first_diff; old_last_diff--, new_last_diff--)
		if (old_buf[old_last_diff] != new_buf[new_last_diff])
			break;

	const int insert_len = new_last_diff - first_diff + 1;
	const int delete_len = old_last_diff - first_diff + 1;
	if (insert_len > 0 || delete_len > 0)
		if (IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->Stb.undostate, first_diff, delete_len, insert_len))
			for (int i = 0; i < delete_len; i++)
				p[i] = ImStb::STB_TEXTEDIT_GETCHAR(state, first_diff + i);
}

// As InputText() retain textual data and we currently provide a path for user to not retain it (via local variables)
// we need some form of hook to reapply data back to user buffer on deactivation frame. (#4714)
// It would be more desirable that we discourage users from taking advantage of the "user not retaining data" trick,
// but that more likely be attractive when we do have _NoLiveEdit flag available.
void ImGui::InputTextDeactivateHook(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	ImGuiInputTextState *state = &g.InputTextState;
	if (id == 0 || state->ID != id)
		return;
	g.InputTextDeactivatedState.ID = state->ID;
	if (state->Flags & ImGuiInputTextFlags_ReadOnly) {
		g.InputTextDeactivatedState.TextA.resize(0); // In theory this data won't be used, but clear to be neat.
	} else {
		IM_ASSERT(state->TextA.Data != 0);
		g.InputTextDeactivatedState.TextA.resize(state->CurLenA + 1);
		memcpy(g.InputTextDeactivatedState.TextA.Data, state->TextA.Data, state->CurLenA + 1);
	}
}

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match
//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h
// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are
//  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
bool ImGui::InputTextEx(const char *label, const char *hint, char *buf, int buf_size, const ImVec2 &size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void *callback_user_data) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	IM_ASSERT(buf != NULL && buf_size >= 0);
	IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline))); // Can't use both together (they both use up/down keys)
	IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)

	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;
	const ImGuiStyle &style = g.Style;

	const bool RENDER_SELECTION_WHEN_INACTIVE = false;
	const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;

	if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope (including the scrollbar)
		BeginGroup();
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? g.FontSize * 8.0f : label_size.y) + style.FramePadding.y * 2.0f); // Arbitrary default of 8 lines high for multi-line
	const ImVec2 total_size = ImVec2(frame_size.x + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), frame_size.y);

	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
	const ImRect total_bb(frame_bb.Min, frame_bb.Min + total_size);

	ImGuiWindow *draw_window = window;
	ImVec2 inner_size = frame_size;
	ImGuiLastItemData item_data_backup;
	if (is_multiline) {
		ImVec2 backup_pos = window->DC.CursorPos;
		ItemSize(total_bb, style.FramePadding.y);
		if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_Inputable)) {
			EndGroup();
			return false;
		}
		item_data_backup = g.LastItemData;
		window->DC.CursorPos = backup_pos;

		// Prevent NavActivation from Tabbing when our widget accepts Tab inputs: this allows cycling through widgets without stopping.
		if (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_FromTabbing) && (flags & ImGuiInputTextFlags_AllowTabInput))
			g.NavActivateId = 0;

		// Prevent NavActivate reactivating in BeginChild() when we are already active.
		const ImGuiID backup_activate_id = g.NavActivateId;
		if (g.ActiveId == id) // Prevent reactivation
			g.NavActivateId = 0;

		// We reproduce the contents of BeginChildFrame() in order to provide 'label' so our window internal data are easier to read/debug.
		PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
		PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
		PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
		PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0)); // Ensure no clip rect so mouse hover can reach FramePadding edges
		bool child_visible = BeginChildEx(label, id, frame_bb.GetSize(), ImGuiChildFlags_Borders, ImGuiWindowFlags_NoMove);
		g.NavActivateId = backup_activate_id;
		PopStyleVar(3);
		PopStyleColor();
		if (!child_visible) {
			EndChild();
			EndGroup();
			return false;
		}
		draw_window = g.CurrentWindow; // Child window
		draw_window->DC.NavLayersActiveMaskNext |= (1 << draw_window->DC.NavLayerCurrent); // This is to ensure that EndChild() will display a navigation highlight so we can "enter" into it.
		draw_window->DC.CursorPos += style.FramePadding;
		inner_size.x -= draw_window->ScrollbarSizes.x;
	} else {
		// Support for internal ImGuiInputTextFlags_MergedItem flag, which could be redesigned as an ItemFlags if needed (with test performed in ItemAdd)
		ItemSize(total_bb, style.FramePadding.y);
		if (!(flags & ImGuiInputTextFlags_MergedItem))
			if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_Inputable))
				return false;
	}
	const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);
	if (hovered)
		g.MouseCursor = ImGuiMouseCursor_TextInput;

	// We are only allowed to access the state if we are already the active widget.
	ImGuiInputTextState *state = GetInputTextState(id);

	if (g.LastItemData.InFlags & ImGuiItemFlags_ReadOnly)
		flags |= ImGuiInputTextFlags_ReadOnly;
	const bool is_readonly = (flags & ImGuiInputTextFlags_ReadOnly) != 0;
	const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;
	const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;
	const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;
	if (is_resizable)
		IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!

	const bool input_requested_by_nav = (g.ActiveId != id) && ((g.NavActivateId == id) && ((g.NavActivateFlags & ImGuiActivateFlags_PreferInput) || (g.NavInputSource == ImGuiInputSource_Keyboard)));

	const bool user_clicked = hovered && io.MouseClicked[0];
	const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);
	const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);
	bool clear_active_id = false;
	bool select_all = false;

	float scroll_y = is_multiline ? draw_window->Scroll.y : FLT_MAX;

	const bool init_reload_from_user_buf = (state != NULL && state->ReloadUserBuf);
	const bool init_changed_specs = (state != NULL && state->Stb.single_line != !is_multiline); // state != NULL means its our state.
	const bool init_make_active = (user_clicked || user_scroll_finish || input_requested_by_nav);
	const bool init_state = (init_make_active || user_scroll_active);
	if ((init_state && g.ActiveId != id) || init_changed_specs || init_reload_from_user_buf) {
		// Access state even if we don't own it yet.
		state = &g.InputTextState;
		state->CursorAnimReset();
		state->ReloadUserBuf = false;

		// Backup state of deactivating item so they'll have a chance to do a write to output buffer on the same frame they report IsItemDeactivatedAfterEdit (#4714)
		InputTextDeactivateHook(state->ID);

		// From the moment we focused we are normally ignoring the content of 'buf' (unless we are in read-only mode)
		const int buf_len = (int)strlen(buf);
		if (!init_reload_from_user_buf) {
			// Take a copy of the initial buffer value.
			state->InitialTextA.resize(buf_len + 1); // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.
			memcpy(state->InitialTextA.Data, buf, buf_len + 1);
		}

		// Preserve cursor position and undo/redo stack if we come back to same widget
		// FIXME: Since we reworked this on 2022/06, may want to differentiate recycle_cursor vs recycle_undostate?
		bool recycle_state = (state->ID == id && !init_changed_specs && !init_reload_from_user_buf);
		if (recycle_state && (state->CurLenA != buf_len || (state->TextAIsValid && strncmp(state->TextA.Data, buf, buf_len) != 0)))
			recycle_state = false;

		// Start edition
		const char *buf_end = NULL;
		state->ID = id;
		state->TextW.resize(buf_size + 1); // wchar count <= UTF-8 count. we use +1 to make sure that .Data is always pointing to at least an empty string.
		state->TextA.resize(0);
		state->TextAIsValid = false; // TextA is not valid yet (we will display buf until then)
		state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, buf_size, buf, NULL, &buf_end);
		state->CurLenA = (int)(buf_end - buf); // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.

		if (recycle_state) {
			// Recycle existing cursor/selection/undo stack but clamp position
			// Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
			state->CursorClamp();
		} else {
			state->Scroll = ImVec2(0.0f, 0.0f);
			stb_textedit_initialize_state(&state->Stb, !is_multiline);
		}

		if (init_reload_from_user_buf) {
			state->Stb.select_start = state->ReloadSelectionStart;
			state->Stb.cursor = state->Stb.select_end = state->ReloadSelectionEnd;
			state->CursorClamp();
		} else if (!is_multiline) {
			if (flags & ImGuiInputTextFlags_AutoSelectAll)
				select_all = true;
			if (input_requested_by_nav && (!recycle_state || !(g.NavActivateFlags & ImGuiActivateFlags_TryToPreserveState)))
				select_all = true;
			if (user_clicked && io.KeyCtrl)
				select_all = true;
		}

		if (flags & ImGuiInputTextFlags_AlwaysOverwrite)
			state->Stb.insert_mode = 1; // stb field name is indeed incorrect (see #2863)
	}

	const bool is_osx = io.ConfigMacOSXBehaviors;
	if (g.ActiveId != id && init_make_active) {
		IM_ASSERT(state && state->ID == id);
		SetActiveID(id, window);
		SetFocusID(id, window);
		FocusWindow(window);
	}
	if (g.ActiveId == id) {
		// Declare some inputs, the other are registered and polled via Shortcut() routing system.
		if (user_clicked)
			SetKeyOwner(ImGuiKey_MouseLeft, id);
		g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
		if (is_multiline || (flags & ImGuiInputTextFlags_CallbackHistory))
			g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
		SetKeyOwner(ImGuiKey_Enter, id);
		SetKeyOwner(ImGuiKey_KeypadEnter, id);
		SetKeyOwner(ImGuiKey_Home, id);
		SetKeyOwner(ImGuiKey_End, id);
		if (is_multiline) {
			SetKeyOwner(ImGuiKey_PageUp, id);
			SetKeyOwner(ImGuiKey_PageDown, id);
		}
		// FIXME: May be a problem to always steal Alt on OSX, would ideally still allow an uninterrupted Alt down-up to toggle menu
		if (is_osx)
			SetKeyOwner(ImGuiMod_Alt, id);

		// Expose scroll in a manner that is agnostic to us using a child window
		if (is_multiline && state != NULL)
			state->Scroll.y = draw_window->Scroll.y;
	}

	// We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)
	if (g.ActiveId == id && state == NULL)
		ClearActiveID();

	// Release focus when we click outside
	if (g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active) //-V560
		clear_active_id = true;

	// Lock the decision of whether we are going to take the path displaying the cursor or selection
	bool render_cursor = (g.ActiveId == id) || (state && user_scroll_active);
	bool render_selection = state && (state->HasSelection() || select_all) && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
	bool value_changed = false;
	bool validated = false;

	// When read-only we always use the live data passed to the function
	// FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :(
	if (is_readonly && state != NULL && (render_cursor || render_selection)) {
		const char *buf_end = NULL;
		state->TextW.resize(buf_size + 1);
		state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, buf, NULL, &buf_end);
		state->CurLenA = (int)(buf_end - buf);
		state->CursorClamp();
		render_selection &= state->HasSelection();
	}

	// Select the buffer to render.
	const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state && state->TextAIsValid;
	const bool is_displaying_hint = (hint != NULL && (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);

	// Password pushes a temporary font with only a fallback glyph
	if (is_password && !is_displaying_hint) {
		const ImFontGlyph *glyph = g.Font->FindGlyph('*');
		ImFont *password_font = &g.InputTextPasswordFont;
		password_font->FontSize = g.Font->FontSize;
		password_font->Scale = g.Font->Scale;
		password_font->Ascent = g.Font->Ascent;
		password_font->Descent = g.Font->Descent;
		password_font->ContainerAtlas = g.Font->ContainerAtlas;
		password_font->FallbackGlyph = glyph;
		password_font->FallbackAdvanceX = glyph->AdvanceX;
		IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
		PushFont(password_font);
	}

	// Process mouse inputs and character inputs
	int backup_current_text_length = 0;
	if (g.ActiveId == id) {
		IM_ASSERT(state != NULL);
		backup_current_text_length = state->CurLenA;
		state->Edited = false;
		state->BufCapacityA = buf_size;
		state->Flags = flags;

		// Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
		// Down the line we should have a cleaner library-wide concept of Selected vs Active.
		g.ActiveIdAllowOverlap = !io.MouseDown[0];

		// Edit in progress
		const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state->Scroll.x;
		const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y) : (g.FontSize * 0.5f));

		if (select_all) {
			state->SelectAll();
			state->SelectedAllMouseLock = true;
		} else if (hovered && io.MouseClickedCount[0] >= 2 && !io.KeyShift) {
			stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);
			const int multiclick_count = (io.MouseClickedCount[0] - 2);
			if ((multiclick_count % 2) == 0) {
				// Double-click: Select word
				// We always use the "Mac" word advance for double-click select vs CTRL+Right which use the platform dependent variant:
				// FIXME: There are likely many ways to improve this behavior, but there's no "right" behavior (depends on use-case, software, OS)
				const bool is_bol = (state->Stb.cursor == 0) || ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb.cursor - 1) == '\n';
				if (STB_TEXT_HAS_SELECTION(&state->Stb) || !is_bol)
					state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);
				//state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
				if (!STB_TEXT_HAS_SELECTION(&state->Stb))
					ImStb::stb_textedit_prep_selection_at_cursor(&state->Stb);
				state->Stb.cursor = ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC(state, state->Stb.cursor);
				state->Stb.select_end = state->Stb.cursor;
				ImStb::stb_textedit_clamp(state, &state->Stb);
			} else {
				// Triple-click: Select line
				const bool is_eol = ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb.cursor) == '\n';
				state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART);
				state->OnKeyPressed(STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT);
				state->OnKeyPressed(STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT);
				if (!is_eol && is_multiline) {
					ImSwap(state->Stb.select_start, state->Stb.select_end);
					state->Stb.cursor = state->Stb.select_end;
				}
				state->CursorFollow = false;
			}
			state->CursorAnimReset();
		} else if (io.MouseClicked[0] && !state->SelectedAllMouseLock) {
			if (hovered) {
				if (io.KeyShift)
					stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);
				else
					stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);
				state->CursorAnimReset();
			}
		} else if (io.MouseDown[0] && !state->SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)) {
			stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);
			state->CursorAnimReset();
			state->CursorFollow = true;
		}
		if (state->SelectedAllMouseLock && !io.MouseDown[0])
			state->SelectedAllMouseLock = false;

		// We expect backends to emit a Tab key but some also emit a Tab character which we ignore (#2467, #1336)
		// (For Tab and Enter: Win32/SFML/Allegro are sending both keys and chars, GLFW and SDL are only sending keys. For Space they all send all threes)
		if ((flags & ImGuiInputTextFlags_AllowTabInput) && !is_readonly) {
			if (Shortcut(ImGuiKey_Tab, ImGuiInputFlags_Repeat, id)) {
				unsigned int c = '\t'; // Insert TAB
				if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))
					state->OnKeyPressed((int)c);
			}
			// FIXME: Implement Shift+Tab
			/*
			if (Shortcut(ImGuiKey_Tab | ImGuiMod_Shift, ImGuiInputFlags_Repeat, id))
			{
			}
			*/
		}

		// Process regular text input (before we check for Return because using some IME will effectively send a Return?)
		// We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
		const bool ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeyCtrl);
		if (io.InputQueueCharacters.Size > 0) {
			if (!ignore_char_inputs && !is_readonly && !input_requested_by_nav)
				for (int n = 0; n < io.InputQueueCharacters.Size; n++) {
					// Insert character if they pass filtering
					unsigned int c = (unsigned int)io.InputQueueCharacters[n];
					if (c == '\t') // Skip Tab, see above.
						continue;
					if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))
						state->OnKeyPressed((int)c);
				}

			// Consume characters
			io.InputQueueCharacters.resize(0);
		}
	}

	// Process other shortcuts/key-presses
	bool revert_edit = false;
	if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id) {
		IM_ASSERT(state != NULL);

		const int row_count_per_page = ImMax((int)((inner_size.y - style.FramePadding.y) / g.FontSize), 1);
		state->Stb.row_count_per_page = row_count_per_page;

		const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
		const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl; // OS X style: Text editing cursor movement using Alt instead of Ctrl
		const bool is_startend_key_down = is_osx && io.KeyCtrl && !io.KeySuper && !io.KeyAlt; // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End

		// Using Shortcut() with ImGuiInputFlags_RouteFocused (default policy) to allow routing operations for other code (e.g. calling window trying to use CTRL+A and CTRL+B: formet would be handled by InputText)
		// Otherwise we could simply assume that we own the keys as we are active.
		const ImGuiInputFlags f_repeat = ImGuiInputFlags_Repeat;
		const bool is_cut = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_X, f_repeat, id) || Shortcut(ImGuiMod_Shift | ImGuiKey_Delete, f_repeat, id)) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());
		const bool is_copy = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_C, 0, id) || Shortcut(ImGuiMod_Ctrl | ImGuiKey_Insert, 0, id)) && !is_password && (!is_multiline || state->HasSelection());
		const bool is_paste = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_V, f_repeat, id) || Shortcut(ImGuiMod_Shift | ImGuiKey_Insert, f_repeat, id)) && !is_readonly;
		const bool is_undo = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_Z, f_repeat, id)) && !is_readonly && is_undoable;
		const bool is_redo = (Shortcut(ImGuiMod_Ctrl | ImGuiKey_Y, f_repeat, id) || (is_osx && Shortcut(ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Z, f_repeat, id))) && !is_readonly && is_undoable;
		const bool is_select_all = Shortcut(ImGuiMod_Ctrl | ImGuiKey_A, 0, id);

		// We allow validate/cancel with Nav source (gamepad) to makes it easier to undo an accidental NavInput press with no keyboard wired, but otherwise it isn't very useful.
		const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
		const bool is_enter_pressed = IsKeyPressed(ImGuiKey_Enter, true) || IsKeyPressed(ImGuiKey_KeypadEnter, true);
		const bool is_gamepad_validate = nav_gamepad_active && (IsKeyPressed(ImGuiKey_NavGamepadActivate, false) || IsKeyPressed(ImGuiKey_NavGamepadInput, false));
		const bool is_cancel = Shortcut(ImGuiKey_Escape, f_repeat, id) || (nav_gamepad_active && Shortcut(ImGuiKey_NavGamepadCancel, f_repeat, id));

		// FIXME: Should use more Shortcut() and reduce IsKeyPressed()+SetKeyOwner(), but requires modifiers combination to be taken account of.
		// FIXME-OSX: Missing support for Alt(option)+Right/Left = go to end of line, or next line if already in end of line.
		if (IsKeyPressed(ImGuiKey_LeftArrow)) {
			state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT
																										: STB_TEXTEDIT_K_LEFT) |
					k_mask);
		} else if (IsKeyPressed(ImGuiKey_RightArrow)) {
			state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT
																									  : STB_TEXTEDIT_K_RIGHT) |
					k_mask);
		} else if (IsKeyPressed(ImGuiKey_UpArrow) && is_multiline) {
			if (io.KeyCtrl)
				SetScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f));
			else
				state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask);
		} else if (IsKeyPressed(ImGuiKey_DownArrow) && is_multiline) {
			if (io.KeyCtrl)
				SetScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY()));
			else
				state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask);
		} else if (IsKeyPressed(ImGuiKey_PageUp) && is_multiline) {
			state->OnKeyPressed(STB_TEXTEDIT_K_PGUP | k_mask);
			scroll_y -= row_count_per_page * g.FontSize;
		} else if (IsKeyPressed(ImGuiKey_PageDown) && is_multiline) {
			state->OnKeyPressed(STB_TEXTEDIT_K_PGDOWN | k_mask);
			scroll_y += row_count_per_page * g.FontSize;
		} else if (IsKeyPressed(ImGuiKey_Home)) {
			state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask);
		} else if (IsKeyPressed(ImGuiKey_End)) {
			state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask);
		} else if (IsKeyPressed(ImGuiKey_Delete) && !is_readonly && !is_cut) {
			if (!state->HasSelection()) {
				// OSX doesn't seem to have Super+Delete to delete until end-of-line, so we don't emulate that (as opposed to Super+Backspace)
				if (is_wordmove_key_down)
					state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
			}
			state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask);
		} else if (IsKeyPressed(ImGuiKey_Backspace) && !is_readonly) {
			if (!state->HasSelection()) {
				if (is_wordmove_key_down)
					state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT);
				else if (is_osx && io.KeyCtrl && !io.KeyAlt && !io.KeySuper)
					state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT);
			}
			state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
		} else if (is_enter_pressed || is_gamepad_validate) {
			// Determine if we turn Enter into a \n character
			bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;
			if (!is_multiline || is_gamepad_validate || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl)) {
				validated = true;
				if (io.ConfigInputTextEnterKeepActive && !is_multiline)
					state->SelectAll(); // No need to scroll
				else
					clear_active_id = true;
			} else if (!is_readonly) {
				unsigned int c = '\n'; // Insert new line
				if (InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data))
					state->OnKeyPressed((int)c);
			}
		} else if (is_cancel) {
			if (flags & ImGuiInputTextFlags_EscapeClearsAll) {
				if (buf[0] != 0) {
					revert_edit = true;
				} else {
					render_cursor = render_selection = false;
					clear_active_id = true;
				}
			} else {
				clear_active_id = revert_edit = true;
				render_cursor = render_selection = false;
			}
		} else if (is_undo || is_redo) {
			state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);
			state->ClearSelection();
		} else if (is_select_all) {
			state->SelectAll();
			state->CursorFollow = true;
		} else if (is_cut || is_copy) {
			// Cut, Copy
			if (g.PlatformIO.Platform_SetClipboardTextFn != NULL) {
				const int ib = state->HasSelection() ? ImMin(state->Stb.select_start, state->Stb.select_end) : 0;
				const int ie = state->HasSelection() ? ImMax(state->Stb.select_start, state->Stb.select_end) : state->CurLenW;
				const int clipboard_data_len = ImTextCountUtf8BytesFromStr(state->TextW.Data + ib, state->TextW.Data + ie) + 1;
				char *clipboard_data = (char *)IM_ALLOC(clipboard_data_len * sizeof(char));
				ImTextStrToUtf8(clipboard_data, clipboard_data_len, state->TextW.Data + ib, state->TextW.Data + ie);
				SetClipboardText(clipboard_data);
				MemFree(clipboard_data);
			}
			if (is_cut) {
				if (!state->HasSelection())
					state->SelectAll();
				state->CursorFollow = true;
				stb_textedit_cut(state, &state->Stb);
			}
		} else if (is_paste) {
			if (const char *clipboard = GetClipboardText()) {
				// Filter pasted buffer
				const int clipboard_len = (int)strlen(clipboard);
				ImWchar *clipboard_filtered = (ImWchar *)IM_ALLOC((clipboard_len + 1) * sizeof(ImWchar));
				int clipboard_filtered_len = 0;
				for (const char *s = clipboard; *s != 0;) {
					unsigned int c;
					s += ImTextCharFromUtf8(&c, s, NULL);
					if (!InputTextFilterCharacter(&g, &c, flags, callback, callback_user_data, true))
						continue;
					clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;
				}
				clipboard_filtered[clipboard_filtered_len] = 0;
				if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation
				{
					stb_textedit_paste(state, &state->Stb, clipboard_filtered, clipboard_filtered_len);
					state->CursorFollow = true;
				}
				MemFree(clipboard_filtered);
			}
		}

		// Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.
		render_selection |= state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
	}

	// Process callbacks and apply result back to user's buffer.
	const char *apply_new_text = NULL;
	int apply_new_text_length = 0;
	if (g.ActiveId == id) {
		IM_ASSERT(state != NULL);
		if (revert_edit && !is_readonly) {
			if (flags & ImGuiInputTextFlags_EscapeClearsAll) {
				// Clear input
				IM_ASSERT(buf[0] != 0);
				apply_new_text = "";
				apply_new_text_length = 0;
				value_changed = true;
				IMSTB_TEXTEDIT_CHARTYPE empty_string;
				stb_textedit_replace(state, &state->Stb, &empty_string, 0);
			} else if (strcmp(buf, state->InitialTextA.Data) != 0) {
				// Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
				// Push records into the undo stack so we can CTRL+Z the revert operation itself
				apply_new_text = state->InitialTextA.Data;
				apply_new_text_length = state->InitialTextA.Size - 1;
				value_changed = true;
				ImVector<ImWchar> w_text;
				if (apply_new_text_length > 0) {
					w_text.resize(ImTextCountCharsFromUtf8(apply_new_text, apply_new_text + apply_new_text_length) + 1);
					ImTextStrFromUtf8(w_text.Data, w_text.Size, apply_new_text, apply_new_text + apply_new_text_length);
				}
				stb_textedit_replace(state, &state->Stb, w_text.Data, (apply_new_text_length > 0) ? (w_text.Size - 1) : 0);
			}
		}

		// Apply ASCII value
		if (!is_readonly) {
			state->TextAIsValid = true;
			state->TextA.resize(state->TextW.Size * 4 + 1);
			ImTextStrToUtf8(state->TextA.Data, state->TextA.Size, state->TextW.Data, NULL);
		}

		// When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer
		// before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
		// If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
		// This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage
		// (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object
		// unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).
		const bool apply_edit_back_to_user_buffer = !revert_edit || (validated && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);
		if (apply_edit_back_to_user_buffer) {
			// Apply new value immediately - copy modified buffer back
			// Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
			// FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
			// FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.

			// User callback
			if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_CallbackAlways)) != 0) {
				IM_ASSERT(callback != NULL);

				// The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
				ImGuiInputTextFlags event_flag = 0;
				ImGuiKey event_key = ImGuiKey_None;
				if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && Shortcut(ImGuiKey_Tab, 0, id)) {
					event_flag = ImGuiInputTextFlags_CallbackCompletion;
					event_key = ImGuiKey_Tab;
				} else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_UpArrow)) {
					event_flag = ImGuiInputTextFlags_CallbackHistory;
					event_key = ImGuiKey_UpArrow;
				} else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_DownArrow)) {
					event_flag = ImGuiInputTextFlags_CallbackHistory;
					event_key = ImGuiKey_DownArrow;
				} else if ((flags & ImGuiInputTextFlags_CallbackEdit) && state->Edited) {
					event_flag = ImGuiInputTextFlags_CallbackEdit;
				} else if (flags & ImGuiInputTextFlags_CallbackAlways) {
					event_flag = ImGuiInputTextFlags_CallbackAlways;
				}

				if (event_flag) {
					ImGuiInputTextCallbackData callback_data;
					callback_data.Ctx = &g;
					callback_data.EventFlag = event_flag;
					callback_data.Flags = flags;
					callback_data.UserData = callback_user_data;

					char *callback_buf = is_readonly ? buf : state->TextA.Data;
					callback_data.EventKey = event_key;
					callback_data.Buf = callback_buf;
					callback_data.BufTextLen = state->CurLenA;
					callback_data.BufSize = state->BufCapacityA;
					callback_data.BufDirty = false;

					// We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
					ImWchar *text = state->TextW.Data;
					const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + state->Stb.cursor);
					const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_start);
					const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_end);

					// Call user code
					callback(&callback_data);

					// Read back what user may have modified
					callback_buf = is_readonly ? buf : state->TextA.Data; // Pointer may have been invalidated by a resize callback
					IM_ASSERT(callback_data.Buf == callback_buf); // Invalid to modify those fields
					IM_ASSERT(callback_data.BufSize == state->BufCapacityA);
					IM_ASSERT(callback_data.Flags == flags);
					const bool buf_dirty = callback_data.BufDirty;
					if (callback_data.CursorPos != utf8_cursor_pos || buf_dirty) {
						state->Stb.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos);
						state->CursorFollow = true;
					}
					if (callback_data.SelectionStart != utf8_selection_start || buf_dirty) {
						state->Stb.select_start = (callback_data.SelectionStart == callback_data.CursorPos) ? state->Stb.cursor : ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart);
					}
					if (callback_data.SelectionEnd != utf8_selection_end || buf_dirty) {
						state->Stb.select_end = (callback_data.SelectionEnd == callback_data.SelectionStart) ? state->Stb.select_start : ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd);
					}
					if (buf_dirty) {
						// Callback may update buffer and thus set buf_dirty even in read-only mode.
						IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
						InputTextReconcileUndoStateAfterUserCallback(state, callback_data.Buf, callback_data.BufTextLen); // FIXME: Move the rest of this block inside function and rename to InputTextReconcileStateAfterUserCallback() ?
						if (callback_data.BufTextLen > backup_current_text_length && is_resizable)
							state->TextW.resize(state->TextW.Size + (callback_data.BufTextLen - backup_current_text_length)); // Worse case scenario resize
						state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, callback_data.Buf, NULL);
						state->CurLenA = callback_data.BufTextLen; // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
						state->CursorAnimReset();
					}
				}
			}

			// Will copy result string if modified
			if (!is_readonly && strcmp(state->TextA.Data, buf) != 0) {
				apply_new_text = state->TextA.Data;
				apply_new_text_length = state->CurLenA;
				value_changed = true;
			}
		}
	}

	// Handle reapplying final data on deactivation (see InputTextDeactivateHook() for details)
	if (g.InputTextDeactivatedState.ID == id) {
		if (g.ActiveId != id && IsItemDeactivatedAfterEdit() && !is_readonly && strcmp(g.InputTextDeactivatedState.TextA.Data, buf) != 0) {
			apply_new_text = g.InputTextDeactivatedState.TextA.Data;
			apply_new_text_length = g.InputTextDeactivatedState.TextA.Size - 1;
			value_changed = true;
			//IMGUI_DEBUG_LOG("InputText(): apply Deactivated data for 0x%08X: \"%.*s\".\n", id, apply_new_text_length, apply_new_text);
		}
		g.InputTextDeactivatedState.ID = 0;
	}

	// Copy result to user buffer. This can currently only happen when (g.ActiveId == id)
	if (apply_new_text != NULL) {
		// We cannot test for 'backup_current_text_length != apply_new_text_length' here because we have no guarantee that the size
		// of our owned buffer matches the size of the string object held by the user, and by design we allow InputText() to be used
		// without any storage on user's side.
		IM_ASSERT(apply_new_text_length >= 0);
		if (is_resizable) {
			ImGuiInputTextCallbackData callback_data;
			callback_data.Ctx = &g;
			callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;
			callback_data.Flags = flags;
			callback_data.Buf = buf;
			callback_data.BufTextLen = apply_new_text_length;
			callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);
			callback_data.UserData = callback_user_data;
			callback(&callback_data);
			buf = callback_data.Buf;
			buf_size = callback_data.BufSize;
			apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);
			IM_ASSERT(apply_new_text_length <= buf_size);
		}
		//IMGUI_DEBUG_PRINT("InputText(\"%s\"): apply_new_text length %d\n", label, apply_new_text_length);

		// If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
		ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));
	}

	// Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
	// Otherwise request text input ahead for next frame.
	if (g.ActiveId == id && clear_active_id)
		ClearActiveID();
	else if (g.ActiveId == id)
		g.WantTextInputNextFrame = 1;

	// Render frame
	if (!is_multiline) {
		RenderNavHighlight(frame_bb, id);
		RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
	}

	const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x, frame_bb.Min.y + inner_size.y); // Not using frame_bb.Max because we have adjusted size
	ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;
	ImVec2 text_size(0.0f, 0.0f);

	// Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
	// without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
	// Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
	const int buf_display_max_length = 2 * 1024 * 1024;
	const char *buf_display = buf_display_from_state ? state->TextA.Data : buf; //-V595
	const char *buf_display_end = NULL; // We have specialized paths below for setting the length
	if (is_displaying_hint) {
		buf_display = hint;
		buf_display_end = hint + strlen(hint);
	}

	// Render text. We currently only render selection when the widget is active or while scrolling.
	// FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.
	if (render_cursor || render_selection) {
		IM_ASSERT(state != NULL);
		if (!is_displaying_hint)
			buf_display_end = buf_display + state->CurLenA;

		// Render text (with cursor and selection)
		// This is going to be messy. We need to:
		// - Display the text (this alone can be more easily clipped)
		// - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
		// - Measure text height (for scrollbar)
		// We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
		// FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
		const ImWchar *text_begin = state->TextW.Data;
		ImVec2 cursor_offset, select_start_offset;

		{
			// Find lines numbers straddling 'cursor' (slot 0) and 'select_start' (slot 1) positions.
			const ImWchar *searches_input_ptr[2] = { NULL, NULL };
			int searches_result_line_no[2] = { -1000, -1000 };
			int searches_remaining = 0;
			if (render_cursor) {
				searches_input_ptr[0] = text_begin + state->Stb.cursor;
				searches_result_line_no[0] = -1;
				searches_remaining++;
			}
			if (render_selection) {
				searches_input_ptr[1] = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);
				searches_result_line_no[1] = -1;
				searches_remaining++;
			}

			// Iterate all lines to find our line numbers
			// In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
			searches_remaining += is_multiline ? 1 : 0;
			int line_count = 0;
			//for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bit
			for (const ImWchar *s = text_begin; *s != 0; s++)
				if (*s == '\n') {
					line_count++;
					if (searches_result_line_no[0] == -1 && s >= searches_input_ptr[0]) {
						searches_result_line_no[0] = line_count;
						if (--searches_remaining <= 0)
							break;
					}
					if (searches_result_line_no[1] == -1 && s >= searches_input_ptr[1]) {
						searches_result_line_no[1] = line_count;
						if (--searches_remaining <= 0)
							break;
					}
				}
			line_count++;
			if (searches_result_line_no[0] == -1)
				searches_result_line_no[0] = line_count;
			if (searches_result_line_no[1] == -1)
				searches_result_line_no[1] = line_count;

			// Calculate 2d position by finding the beginning of the line and measuring distance
			cursor_offset.x = InputTextCalcTextSizeW(&g, ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;
			cursor_offset.y = searches_result_line_no[0] * g.FontSize;
			if (searches_result_line_no[1] >= 0) {
				select_start_offset.x = InputTextCalcTextSizeW(&g, ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;
				select_start_offset.y = searches_result_line_no[1] * g.FontSize;
			}

			// Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
			if (is_multiline)
				text_size = ImVec2(inner_size.x, line_count * g.FontSize);
		}

		// Scroll
		if (render_cursor && state->CursorFollow) {
			// Horizontal scroll in chunks of quarter width
			if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll)) {
				const float scroll_increment_x = inner_size.x * 0.25f;
				const float visible_width = inner_size.x - style.FramePadding.x;
				if (cursor_offset.x < state->Scroll.x)
					state->Scroll.x = IM_TRUNC(ImMax(0.0f, cursor_offset.x - scroll_increment_x));
				else if (cursor_offset.x - visible_width >= state->Scroll.x)
					state->Scroll.x = IM_TRUNC(cursor_offset.x - visible_width + scroll_increment_x);
			} else {
				state->Scroll.y = 0.0f;
			}

			// Vertical scroll
			if (is_multiline) {
				// Test if cursor is vertically visible
				if (cursor_offset.y - g.FontSize < scroll_y)
					scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);
				else if (cursor_offset.y - (inner_size.y - style.FramePadding.y * 2.0f) >= scroll_y)
					scroll_y = cursor_offset.y - inner_size.y + style.FramePadding.y * 2.0f;
				const float scroll_max_y = ImMax((text_size.y + style.FramePadding.y * 2.0f) - inner_size.y, 0.0f);
				scroll_y = ImClamp(scroll_y, 0.0f, scroll_max_y);
				draw_pos.y += (draw_window->Scroll.y - scroll_y); // Manipulate cursor pos immediately avoid a frame of lag
				draw_window->Scroll.y = scroll_y;
			}

			state->CursorFollow = false;
		}

		// Draw selection
		const ImVec2 draw_scroll = ImVec2(state->Scroll.x, 0.0f);
		if (render_selection) {
			const ImWchar *text_selected_begin = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);
			const ImWchar *text_selected_end = text_begin + ImMax(state->Stb.select_start, state->Stb.select_end);

			ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.
			float bg_offy_up = is_multiline ? 0.0f : -1.0f; // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
			float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
			ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;
			for (const ImWchar *p = text_selected_begin; p < text_selected_end;) {
				if (rect_pos.y > clip_rect.w + g.FontSize)
					break;
				if (rect_pos.y < clip_rect.y) {
					//p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bit
					//p = p ? p + 1 : text_selected_end;
					while (p < text_selected_end)
						if (*p++ == '\n')
							break;
				} else {
					ImVec2 rect_size = InputTextCalcTextSizeW(&g, p, text_selected_end, &p, NULL, true);
					if (rect_size.x <= 0.0f)
						rect_size.x = IM_TRUNC(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines
					ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos + ImVec2(rect_size.x, bg_offy_dn));
					rect.ClipWith(clip_rect);
					if (rect.Overlaps(clip_rect))
						draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);
				}
				rect_pos.x = draw_pos.x - draw_scroll.x;
				rect_pos.y += g.FontSize;
			}
		}

		// We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
		if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length) {
			ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);
			draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);
		}

		// Draw blinking cursor
		if (render_cursor) {
			state->CursorAnim += io.DeltaTime;
			bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state->CursorAnim <= 0.0f) || ImFmod(state->CursorAnim, 1.20f) <= 0.80f;
			ImVec2 cursor_screen_pos = ImTrunc(draw_pos + cursor_offset - draw_scroll);
			ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);
			if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
				draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

			// Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
			if (!is_readonly) {
				g.PlatformImeData.WantVisible = true;
				g.PlatformImeData.InputPos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);
				g.PlatformImeData.InputLineHeight = g.FontSize;
			}
		}
	} else {
		// Render text only (no selection, no cursor)
		if (is_multiline)
			text_size = ImVec2(inner_size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_display_end) * g.FontSize); // We don't need width
		else if (!is_displaying_hint && g.ActiveId == id)
			buf_display_end = buf_display + state->CurLenA;
		else if (!is_displaying_hint)
			buf_display_end = buf_display + strlen(buf_display);

		if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length) {
			ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);
			draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);
		}
	}

	if (is_password && !is_displaying_hint)
		PopFont();

	if (is_multiline) {
		// For focus requests to work on our multiline we need to ensure our child ItemAdd() call specifies the ImGuiItemFlags_Inputable (see #4761, #7870)...
		Dummy(ImVec2(text_size.x, text_size.y + style.FramePadding.y));
		g.NextItemData.ItemFlags |= ImGuiItemFlags_Inputable | ImGuiItemFlags_NoTabStop;
		EndChild();
		item_data_backup.StatusFlags |= (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredWindow);

		// ...and then we need to undo the group overriding last item data, which gets a bit messy as EndGroup() tries to forward scrollbar being active...
		// FIXME: This quite messy/tricky, should attempt to get rid of the child window.
		EndGroup();
		if (g.LastItemData.ID == 0 || g.LastItemData.ID != GetWindowScrollbarID(draw_window, ImGuiAxis_Y)) {
			g.LastItemData.ID = id;
			g.LastItemData.InFlags = item_data_backup.InFlags;
			g.LastItemData.StatusFlags = item_data_backup.StatusFlags;
		}
	}

	// Log as text
	if (g.LogEnabled && (!is_password || is_displaying_hint)) {
		LogSetNextTextDecoration("{", "}");
		LogRenderedText(&draw_pos, buf_display, buf_display_end);
	}

	if (label_size.x > 0)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	if (value_changed && !(flags & ImGuiInputTextFlags_NoMarkEdited))
		MarkItemEdited(id);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Inputable);
	if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)
		return validated;
	else
		return value_changed;
}

void ImGui::DebugNodeInputTextState(ImGuiInputTextState *state) {
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	ImGuiContext &g = *GImGui;
	ImStb::STB_TexteditState *stb_state = &state->Stb;
	ImStb::StbUndoState *undo_state = &stb_state->undostate;
	Text("ID: 0x%08X, ActiveID: 0x%08X", state->ID, g.ActiveId);
	DebugLocateItemOnHover(state->ID);
	Text("CurLenW: %d, CurLenA: %d, Cursor: %d, Selection: %d..%d", state->CurLenW, state->CurLenA, stb_state->cursor, stb_state->select_start, stb_state->select_end);
	Text("has_preferred_x: %d (%.2f)", stb_state->has_preferred_x, stb_state->preferred_x);
	Text("undo_point: %d, redo_point: %d, undo_char_point: %d, redo_char_point: %d", undo_state->undo_point, undo_state->redo_point, undo_state->undo_char_point, undo_state->redo_char_point);
	if (BeginChild("undopoints", ImVec2(0.0f, GetTextLineHeight() * 10), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeY)) // Visualize undo state
	{
		PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
		for (int n = 0; n < IMSTB_TEXTEDIT_UNDOSTATECOUNT; n++) {
			ImStb::StbUndoRecord *undo_rec = &undo_state->undo_rec[n];
			const char undo_rec_type = (n < undo_state->undo_point) ? 'u' : (n >= undo_state->redo_point) ? 'r'
																										  : ' ';
			if (undo_rec_type == ' ')
				BeginDisabled();
			char buf[64] = "";
			if (undo_rec_type != ' ' && undo_rec->char_storage != -1)
				ImTextStrToUtf8(buf, IM_ARRAYSIZE(buf), undo_state->undo_char + undo_rec->char_storage, undo_state->undo_char + undo_rec->char_storage + undo_rec->insert_length);
			Text("%c [%02d] where %03d, insert %03d, delete %03d, char_storage %03d \"%s\"",
					undo_rec_type, n, undo_rec->where, undo_rec->insert_length, undo_rec->delete_length, undo_rec->char_storage, buf);
			if (undo_rec_type == ' ')
				EndDisabled();
		}
		PopStyleVar();
	}
	EndChild();
#else
	IM_UNUSED(state);
#endif
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorPicker3()
// - RenderColorRectWithAlphaCheckerboard() [Internal]
// - ColorPicker4()
// - ColorButton()
// - SetColorEditOptions()
// - ColorTooltip() [Internal]
// - ColorEditOptionsPopup() [Internal]
// - ColorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------

bool ImGui::ColorEdit3(const char *label, float col[3], ImGuiColorEditFlags flags) {
	return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);
}

static void ColorEditRestoreH(const float *col, float *H) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.ColorEditCurrentID != 0);
	if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))
		return;
	*H = g.ColorEditSavedHue;
}

// ColorEdit supports RGB and HSV inputs. In case of RGB input resulting color may have undefined hue and/or saturation.
// Since widget displays both RGB and HSV values we must preserve hue and saturation to prevent these values resetting.
static void ColorEditRestoreHS(const float *col, float *H, float *S, float *V) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.ColorEditCurrentID != 0);
	if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))
		return;

	// When S == 0, H is undefined.
	// When H == 1 it wraps around to 0.
	if (*S == 0.0f || (*H == 0.0f && g.ColorEditSavedHue == 1))
		*H = g.ColorEditSavedHue;

	// When V == 0, S is undefined.
	if (*V == 0.0f)
		*S = g.ColorEditSavedSat;
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on color square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
bool ImGui::ColorEdit4(const char *label, float col[4], ImGuiColorEditFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const float square_sz = GetFrameHeight();
	const char *label_display_end = FindRenderedTextEnd(label);
	float w_full = CalcItemWidth();
	g.NextItemData.ClearFlags();

	BeginGroup();
	PushID(label);
	const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);
	if (set_current_color_edit_id)
		g.ColorEditCurrentID = window->IDStack.back();

	// If we're not showing any slider there's no point in doing any HSV conversions
	const ImGuiColorEditFlags flags_untouched = flags;
	if (flags & ImGuiColorEditFlags_NoInputs)
		flags = (flags & (~ImGuiColorEditFlags_DisplayMask_)) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;

	// Context menu: display and modify options (before defaults are applied)
	if (!(flags & ImGuiColorEditFlags_NoOptions))
		ColorEditOptionsPopup(col, flags);

	// Read stored options
	if (!(flags & ImGuiColorEditFlags_DisplayMask_))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DisplayMask_);
	if (!(flags & ImGuiColorEditFlags_DataTypeMask_))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DataTypeMask_);
	if (!(flags & ImGuiColorEditFlags_PickerMask_))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags_PickerMask_);
	if (!(flags & ImGuiColorEditFlags_InputMask_))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags_InputMask_);
	flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_));
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DisplayMask_)); // Check that only 1 is selected
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_)); // Check that only 1 is selected

	const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;
	const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;
	const int components = alpha ? 4 : 3;
	const float w_button = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);
	const float w_inputs = ImMax(w_full - w_button, 1.0f);
	w_full = w_inputs + w_button;

	// Convert to the formats we need
	float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };
	if ((flags & ImGuiColorEditFlags_InputHSV) && (flags & ImGuiColorEditFlags_DisplayRGB))
		ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
	else if ((flags & ImGuiColorEditFlags_InputRGB) && (flags & ImGuiColorEditFlags_DisplayHSV)) {
		// Hue is lost when converting from grayscale rgb (saturation=0). Restore it.
		ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
		ColorEditRestoreHS(col, &f[0], &f[1], &f[2]);
	}
	int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

	bool value_changed = false;
	bool value_changed_as_float = false;

	const ImVec2 pos = window->DC.CursorPos;
	const float inputs_offset_x = (style.ColorButtonPosition == ImGuiDir_Left) ? w_button : 0.0f;
	window->DC.CursorPos.x = pos.x + inputs_offset_x;

	if ((flags & (ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0) {
		// RGB/HSV 0..255 Sliders
		const float w_items = w_inputs - style.ItemInnerSpacing.x * (components - 1);

		const bool hide_prefix = (IM_TRUNC(w_items / components) <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);
		static const char *ids[4] = { "##X", "##Y", "##Z", "##W" };
		static const char *fmt_table_int[3][4] = {
			{ "%3d", "%3d", "%3d", "%3d" }, // Short display
			{ "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
			{ "H:%3d", "S:%3d", "V:%3d", "A:%3d" } // Long display for HSVA
		};
		static const char *fmt_table_float[3][4] = {
			{ "%0.3f", "%0.3f", "%0.3f", "%0.3f" }, // Short display
			{ "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
			{ "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" } // Long display for HSVA
		};
		const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_DisplayHSV) ? 2
																					   : 1;

		float prev_split = 0.0f;
		for (int n = 0; n < components; n++) {
			if (n > 0)
				SameLine(0, style.ItemInnerSpacing.x);
			float next_split = IM_TRUNC(w_items * (n + 1) / components);
			SetNextItemWidth(ImMax(next_split - prev_split, 1.0f));
			prev_split = next_split;

			// FIXME: When ImGuiColorEditFlags_HDR flag is passed HS values snap in weird ways when SV values go below 0.
			if (flags & ImGuiColorEditFlags_Float) {
				value_changed |= DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);
				value_changed_as_float |= value_changed;
			} else {
				value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);
			}
			if (!(flags & ImGuiColorEditFlags_NoOptions))
				OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
		}
	} else if ((flags & ImGuiColorEditFlags_DisplayHex) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0) {
		// RGB Hexadecimal Input
		char buf[64];
		if (alpha)
			ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));
		else
			ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));
		SetNextItemWidth(w_inputs);
		if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsUppercase)) {
			value_changed = true;
			char *p = buf;
			while (*p == '#' || ImCharIsBlankA(*p))
				p++;
			i[0] = i[1] = i[2] = 0;
			i[3] = 0xFF; // alpha default to 255 is not parsed by scanf (e.g. inputting #FFFFFF omitting alpha)
			int r;
			if (alpha)
				r = sscanf(p, "%02X%02X%02X%02X", (unsigned int *)&i[0], (unsigned int *)&i[1], (unsigned int *)&i[2], (unsigned int *)&i[3]); // Treat at unsigned (%X is unsigned)
			else
				r = sscanf(p, "%02X%02X%02X", (unsigned int *)&i[0], (unsigned int *)&i[1], (unsigned int *)&i[2]);
			IM_UNUSED(r); // Fixes C6031: Return value ignored: 'sscanf'.
		}
		if (!(flags & ImGuiColorEditFlags_NoOptions))
			OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
	}

	ImGuiWindow *picker_active_window = NULL;
	if (!(flags & ImGuiColorEditFlags_NoSmallPreview)) {
		const float button_offset_x = ((flags & ImGuiColorEditFlags_NoInputs) || (style.ColorButtonPosition == ImGuiDir_Left)) ? 0.0f : w_inputs + style.ItemInnerSpacing.x;
		window->DC.CursorPos = ImVec2(pos.x + button_offset_x, pos.y);

		const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
		if (ColorButton("##ColorButton", col_v4, flags)) {
			if (!(flags & ImGuiColorEditFlags_NoPicker)) {
				// Store current color and open a picker
				g.ColorPickerRef = col_v4;
				OpenPopup("picker");
				SetNextWindowPos(g.LastItemData.Rect.GetBL() + ImVec2(0.0f, style.ItemSpacing.y));
			}
		}
		if (!(flags & ImGuiColorEditFlags_NoOptions))
			OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);

		if (BeginPopup("picker")) {
			if (g.CurrentWindow->BeginCount == 1) {
				picker_active_window = g.CurrentWindow;
				if (label != label_display_end) {
					TextEx(label, label_display_end);
					Spacing();
				}
				ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
				ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
				SetNextItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
				value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);
			}
			EndPopup();
		}
	}

	if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel)) {
		// Position not necessarily next to last submitted button (e.g. if style.ColorButtonPosition == ImGuiDir_Left),
		// but we need to use SameLine() to setup baseline correctly. Might want to refactor SameLine() to simplify this.
		SameLine(0.0f, style.ItemInnerSpacing.x);
		window->DC.CursorPos.x = pos.x + ((flags & ImGuiColorEditFlags_NoInputs) ? w_button : w_full + style.ItemInnerSpacing.x);
		TextEx(label, label_display_end);
	}

	// Convert back
	if (value_changed && picker_active_window == NULL) {
		if (!value_changed_as_float)
			for (int n = 0; n < 4; n++)
				f[n] = i[n] / 255.0f;
		if ((flags & ImGuiColorEditFlags_DisplayHSV) && (flags & ImGuiColorEditFlags_InputRGB)) {
			g.ColorEditSavedHue = f[0];
			g.ColorEditSavedSat = f[1];
			ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
			g.ColorEditSavedID = g.ColorEditCurrentID;
			g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(f[0], f[1], f[2], 0));
		}
		if ((flags & ImGuiColorEditFlags_DisplayRGB) && (flags & ImGuiColorEditFlags_InputHSV))
			ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

		col[0] = f[0];
		col[1] = f[1];
		col[2] = f[2];
		if (alpha)
			col[3] = f[3];
	}

	if (set_current_color_edit_id)
		g.ColorEditCurrentID = 0;
	PopID();
	EndGroup();

	// Drag and Drop Target
	// NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
	if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(g.LastItemData.InFlags & ImGuiItemFlags_ReadOnly) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget()) {
		bool accepted_drag_drop = false;
		if (const ImGuiPayload *payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F)) {
			memcpy((float *)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512 //-V1086
			value_changed = accepted_drag_drop = true;
		}
		if (const ImGuiPayload *payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F)) {
			memcpy((float *)col, payload->Data, sizeof(float) * components);
			value_changed = accepted_drag_drop = true;
		}

		// Drag-drop payloads are always RGB
		if (accepted_drag_drop && (flags & ImGuiColorEditFlags_InputHSV))
			ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);
		EndDragDropTarget();
	}

	// When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
	if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)
		g.LastItemData.ID = g.ActiveId;

	if (value_changed && g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup() won't catch g.ActiveId
		MarkItemEdited(g.LastItemData.ID);

	return value_changed;
}

bool ImGui::ColorPicker3(const char *label, float col[3], ImGuiColorEditFlags flags) {
	float col4[4] = { col[0], col[1], col[2], 1.0f };
	if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))
		return false;
	col[0] = col4[0];
	col[1] = col4[1];
	col[2] = col4[2];
	return true;
}

// Helper for ColorPicker4()
static void RenderArrowsForVerticalBar(ImDrawList *draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w, float alpha) {
	ImU32 alpha8 = IM_F32_TO_INT8_SAT(alpha);
	ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32(0, 0, 0, alpha8));
	ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x, pos.y), half_sz, ImGuiDir_Right, IM_COL32(255, 255, 255, alpha8));
	ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left, IM_COL32(0, 0, 0, alpha8));
	ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x, pos.y), half_sz, ImGuiDir_Left, IM_COL32(255, 255, 255, alpha8));
}

// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// (In C++ the 'float col[4]' notation for a function argument is equivalent to 'float* col', we only specify a size to facilitate understanding of the code.)
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
// FIXME: this is trying to be aware of style.Alpha but not fully correct. Also, the color wheel will have overlapping glitches with (style.Alpha < 1.0)
bool ImGui::ColorPicker4(const char *label, float col[4], ImGuiColorEditFlags flags, const float *ref_col) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImDrawList *draw_list = window->DrawList;
	ImGuiStyle &style = g.Style;
	ImGuiIO &io = g.IO;

	const float width = CalcItemWidth();
	const bool is_readonly = ((g.NextItemData.ItemFlags | g.CurrentItemFlags) & ImGuiItemFlags_ReadOnly) != 0;
	g.NextItemData.ClearFlags();

	PushID(label);
	const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);
	if (set_current_color_edit_id)
		g.ColorEditCurrentID = window->IDStack.back();
	BeginGroup();

	if (!(flags & ImGuiColorEditFlags_NoSidePreview))
		flags |= ImGuiColorEditFlags_NoSmallPreview;

	// Context menu: display and store options.
	if (!(flags & ImGuiColorEditFlags_NoOptions))
		ColorPickerOptionsPopup(col, flags);

	// Read stored options
	if (!(flags & ImGuiColorEditFlags_PickerMask_))
		flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_PickerMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_PickerMask_;
	if (!(flags & ImGuiColorEditFlags_InputMask_))
		flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_InputMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_InputMask_;
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_PickerMask_)); // Check that only 1 is selected
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_)); // Check that only 1 is selected
	if (!(flags & ImGuiColorEditFlags_NoOptions))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

	// Setup
	int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;
	bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);
	ImVec2 picker_pos = window->DC.CursorPos;
	float square_sz = GetFrameHeight();
	float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
	float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
	float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
	float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
	float bars_triangles_half_sz = IM_TRUNC(bars_width * 0.20f);

	float backup_initial_col[4];
	memcpy(backup_initial_col, col, components * sizeof(float));

	float wheel_thickness = sv_picker_size * 0.08f;
	float wheel_r_outer = sv_picker_size * 0.50f;
	float wheel_r_inner = wheel_r_outer - wheel_thickness;
	ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width) * 0.5f, picker_pos.y + sv_picker_size * 0.5f);

	// Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
	float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
	ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.
	ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
	ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

	float H = col[0], S = col[1], V = col[2];
	float R = col[0], G = col[1], B = col[2];
	if (flags & ImGuiColorEditFlags_InputRGB) {
		// Hue is lost when converting from grayscale rgb (saturation=0). Restore it.
		ColorConvertRGBtoHSV(R, G, B, H, S, V);
		ColorEditRestoreHS(col, &H, &S, &V);
	} else if (flags & ImGuiColorEditFlags_InputHSV) {
		ColorConvertHSVtoRGB(H, S, V, R, G, B);
	}

	bool value_changed = false, value_changed_h = false, value_changed_sv = false;

	PushItemFlag(ImGuiItemFlags_NoNav, true);
	if (flags & ImGuiColorEditFlags_PickerHueWheel) {
		// Hue wheel + SV triangle logic
		InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));
		if (IsItemActive() && !is_readonly) {
			ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;
			ImVec2 current_off = g.IO.MousePos - wheel_center;
			float initial_dist2 = ImLengthSqr(initial_off);
			if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1)) {
				// Interactive with Hue wheel
				H = ImAtan2(current_off.y, current_off.x) / IM_PI * 0.5f;
				if (H < 0.0f)
					H += 1.0f;
				value_changed = value_changed_h = true;
			}
			float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);
			float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);
			if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle))) {
				// Interacting with SV triangle
				ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);
				if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))
					current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);
				float uu, vv, ww;
				ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);
				V = ImClamp(1.0f - vv, 0.0001f, 1.0f);
				S = ImClamp(uu / V, 0.0001f, 1.0f);
				value_changed = value_changed_sv = true;
			}
		}
		if (!(flags & ImGuiColorEditFlags_NoOptions))
			OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
	} else if (flags & ImGuiColorEditFlags_PickerHueBar) {
		// SV rectangle logic
		InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));
		if (IsItemActive() && !is_readonly) {
			S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1));
			V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
			ColorEditRestoreH(col, &H); // Greatly reduces hue jitter and reset to 0 when hue == 255 and color is rapidly modified using SV square.
			value_changed = value_changed_sv = true;
		}
		if (!(flags & ImGuiColorEditFlags_NoOptions))
			OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);

		// Hue bar logic
		SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));
		InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));
		if (IsItemActive() && !is_readonly) {
			H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
			value_changed = value_changed_h = true;
		}
	}

	// Alpha bar logic
	if (alpha_bar) {
		SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));
		InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));
		if (IsItemActive()) {
			col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
			value_changed = true;
		}
	}
	PopItemFlag(); // ImGuiItemFlags_NoNav

	if (!(flags & ImGuiColorEditFlags_NoSidePreview)) {
		SameLine(0, style.ItemInnerSpacing.x);
		BeginGroup();
	}

	if (!(flags & ImGuiColorEditFlags_NoLabel)) {
		const char *label_display_end = FindRenderedTextEnd(label);
		if (label != label_display_end) {
			if ((flags & ImGuiColorEditFlags_NoSidePreview))
				SameLine(0, style.ItemInnerSpacing.x);
			TextEx(label, label_display_end);
		}
	}

	if (!(flags & ImGuiColorEditFlags_NoSidePreview)) {
		PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
		ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
		if ((flags & ImGuiColorEditFlags_NoLabel))
			Text("Current");

		ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip;
		ColorButton("##current", col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));
		if (ref_col != NULL) {
			Text("Original");
			ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
			if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2))) {
				memcpy(col, ref_col, components * sizeof(float));
				value_changed = true;
			}
		}
		PopItemFlag();
		EndGroup();
	}

	// Convert back color to RGB
	if (value_changed_h || value_changed_sv) {
		if (flags & ImGuiColorEditFlags_InputRGB) {
			ColorConvertHSVtoRGB(H, S, V, col[0], col[1], col[2]);
			g.ColorEditSavedHue = H;
			g.ColorEditSavedSat = S;
			g.ColorEditSavedID = g.ColorEditCurrentID;
			g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0));
		} else if (flags & ImGuiColorEditFlags_InputHSV) {
			col[0] = H;
			col[1] = S;
			col[2] = V;
		}
	}

	// R,G,B and H,S,V slider color editor
	bool value_changed_fix_hue_wrap = false;
	if ((flags & ImGuiColorEditFlags_NoInputs) == 0) {
		PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
		ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
		ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;
		if (flags & ImGuiColorEditFlags_DisplayRGB || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)
			if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_DisplayRGB)) {
				// FIXME: Hackily differentiating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
				// For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
				value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);
				value_changed = true;
			}
		if (flags & ImGuiColorEditFlags_DisplayHSV || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)
			value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_DisplayHSV);
		if (flags & ImGuiColorEditFlags_DisplayHex || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)
			value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_DisplayHex);
		PopItemWidth();
	}

	// Try to cancel hue wrap (after ColorEdit4 call), if any
	if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB)) {
		float new_H, new_S, new_V;
		ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
		if (new_H <= 0 && H > 0) {
			if (new_V <= 0 && V != new_V)
				ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);
			else if (new_S <= 0)
				ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);
		}
	}

	if (value_changed) {
		if (flags & ImGuiColorEditFlags_InputRGB) {
			R = col[0];
			G = col[1];
			B = col[2];
			ColorConvertRGBtoHSV(R, G, B, H, S, V);
			ColorEditRestoreHS(col, &H, &S, &V); // Fix local Hue as display below will use it immediately.
		} else if (flags & ImGuiColorEditFlags_InputHSV) {
			H = col[0];
			S = col[1];
			V = col[2];
			ColorConvertHSVtoRGB(H, S, V, R, G, B);
		}
	}

	const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);
	const ImU32 col_black = IM_COL32(0, 0, 0, style_alpha8);
	const ImU32 col_white = IM_COL32(255, 255, 255, style_alpha8);
	const ImU32 col_midgrey = IM_COL32(128, 128, 128, style_alpha8);
	const ImU32 col_hues[6 + 1] = { IM_COL32(255, 0, 0, style_alpha8), IM_COL32(255, 255, 0, style_alpha8), IM_COL32(0, 255, 0, style_alpha8), IM_COL32(0, 255, 255, style_alpha8), IM_COL32(0, 0, 255, style_alpha8), IM_COL32(255, 0, 255, style_alpha8), IM_COL32(255, 0, 0, style_alpha8) };

	ImVec4 hue_color_f(1, 1, 1, style.Alpha);
	ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
	ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
	ImU32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, style.Alpha)); // Important: this is still including the main rendering/style alpha!!

	ImVec2 sv_cursor_pos;

	if (flags & ImGuiColorEditFlags_PickerHueWheel) {
		// Render Hue Wheel
		const float aeps = 0.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
		const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);
		for (int n = 0; n < 6; n++) {
			const float a0 = (n) / 6.0f * 2.0f * IM_PI - aeps;
			const float a1 = (n + 1.0f) / 6.0f * 2.0f * IM_PI + aeps;
			const int vert_start_idx = draw_list->VtxBuffer.Size;
			draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer) * 0.5f, a0, a1, segment_per_arc);
			draw_list->PathStroke(col_white, 0, wheel_thickness);
			const int vert_end_idx = draw_list->VtxBuffer.Size;

			// Paint colors over existing vertices
			ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);
			ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);
			ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col_hues[n], col_hues[n + 1]);
		}

		// Render Cursor + preview on Hue Wheel
		float cos_hue_angle = ImCos(H * 2.0f * IM_PI);
		float sin_hue_angle = ImSin(H * 2.0f * IM_PI);
		ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f);
		float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
		int hue_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(hue_cursor_rad); // Lock segment count so the +1 one matches others.
		draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);
		draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad + 1, col_midgrey, hue_cursor_segments);
		draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, col_white, hue_cursor_segments);

		// Render SV triangle (rotated according to hue)
		ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);
		ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);
		ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);
		ImVec2 uv_white = GetFontTexUvWhitePixel();
		draw_list->PrimReserve(3, 3);
		draw_list->PrimVtx(tra, uv_white, hue_color32);
		draw_list->PrimVtx(trb, uv_white, col_black);
		draw_list->PrimVtx(trc, uv_white, col_white);
		draw_list->AddTriangle(tra, trb, trc, col_midgrey, 1.5f);
		sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));
	} else if (flags & ImGuiColorEditFlags_PickerHueBar) {
		// Render SV Square
		draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);
		draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0, 0, col_black, col_black);
		RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0.0f);
		sv_cursor_pos.x = ImClamp(IM_ROUND(picker_pos.x + ImSaturate(S) * sv_picker_size), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
		sv_cursor_pos.y = ImClamp(IM_ROUND(picker_pos.y + ImSaturate(1 - V) * sv_picker_size), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

		// Render Hue Bar
		for (int i = 0; i < 6; ++i)
			draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);
		float bar0_line_y = IM_ROUND(picker_pos.y + H * sv_picker_size);
		RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
		RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);
	}

	// Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
	float sv_cursor_rad = value_changed_sv ? wheel_thickness * 0.55f : wheel_thickness * 0.40f;
	int sv_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(sv_cursor_rad); // Lock segment count so the +1 one matches others.
	draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, user_col32_striped_of_alpha, sv_cursor_segments);
	draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, col_midgrey, sv_cursor_segments);
	draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, col_white, sv_cursor_segments);

	// Render alpha bar
	if (alpha_bar) {
		float alpha = ImSaturate(col[3]);
		ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);
		RenderColorRectWithAlphaCheckerboard(draw_list, bar1_bb.Min, bar1_bb.Max, 0, bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));
		draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha & ~IM_COL32_A_MASK, user_col32_striped_of_alpha & ~IM_COL32_A_MASK);
		float bar1_line_y = IM_ROUND(picker_pos.y + (1.0f - alpha) * sv_picker_size);
		RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
		RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);
	}

	EndGroup();

	if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)
		value_changed = false;
	if (value_changed && g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup() won't catch g.ActiveId
		MarkItemEdited(g.LastItemData.ID);

	if (set_current_color_edit_id)
		g.ColorEditCurrentID = 0;
	PopID();

	return value_changed;
}

// A little color square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
// Note that 'col' may be encoded in HSV if ImGuiColorEditFlags_InputHSV is set.
bool ImGui::ColorButton(const char *desc_id, const ImVec4 &col, ImGuiColorEditFlags flags, const ImVec2 &size_arg) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiID id = window->GetID(desc_id);
	const float default_size = GetFrameHeight();
	const ImVec2 size(size_arg.x == 0.0f ? default_size : size_arg.x, size_arg.y == 0.0f ? default_size : size_arg.y);
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	if (flags & ImGuiColorEditFlags_NoAlpha)
		flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

	ImVec4 col_rgb = col;
	if (flags & ImGuiColorEditFlags_InputHSV)
		ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);

	ImVec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);
	float grid_step = ImMin(size.x, size.y) / 2.99f;
	float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
	ImRect bb_inner = bb;
	float off = 0.0f;
	if ((flags & ImGuiColorEditFlags_NoBorder) == 0) {
		off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
		bb_inner.Expand(off);
	}
	if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f) {
		float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);
		RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);
		window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawFlags_RoundCornersLeft);
	} else {
		// Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
		ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;
		if (col_source.w < 1.0f)
			RenderColorRectWithAlphaCheckerboard(window->DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);
		else
			window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding);
	}
	RenderNavHighlight(bb, id);
	if ((flags & ImGuiColorEditFlags_NoBorder) == 0) {
		if (g.Style.FrameBorderSize > 0.0f)
			RenderFrameBorder(bb.Min, bb.Max, rounding);
		else
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border
	}

	// Drag and Drop Source
	// NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
	if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource()) {
		if (flags & ImGuiColorEditFlags_NoAlpha)
			SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3, ImGuiCond_Once);
		else
			SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof(float) * 4, ImGuiCond_Once);
		ColorButton(desc_id, col, flags);
		SameLine();
		TextEx("Color");
		EndDragDropSource();
	}

	// Tooltip
	if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered && IsItemHovered(ImGuiHoveredFlags_ForTooltip))
		ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

	return pressed;
}

// Initialize/override default color options
void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags) {
	ImGuiContext &g = *GImGui;
	if ((flags & ImGuiColorEditFlags_DisplayMask_) == 0)
		flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_DisplayMask_;
	if ((flags & ImGuiColorEditFlags_DataTypeMask_) == 0)
		flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_DataTypeMask_;
	if ((flags & ImGuiColorEditFlags_PickerMask_) == 0)
		flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_PickerMask_;
	if ((flags & ImGuiColorEditFlags_InputMask_) == 0)
		flags |= ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_InputMask_;
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DisplayMask_)); // Check only 1 option is selected
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DataTypeMask_)); // Check only 1 option is selected
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_PickerMask_)); // Check only 1 option is selected
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_)); // Check only 1 option is selected
	g.ColorEditOptions = flags;
}

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
void ImGui::ColorTooltip(const char *text, const float *col, ImGuiColorEditFlags flags) {
	ImGuiContext &g = *GImGui;

	if (!BeginTooltipEx(ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_None))
		return;
	const char *text_end = text ? FindRenderedTextEnd(text, NULL) : text;
	if (text_end > text) {
		TextEx(text, text_end);
		Separator();
	}

	ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);
	ImVec4 cf(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
	int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
	ColorButton("##preview", cf, (flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);
	SameLine();
	if ((flags & ImGuiColorEditFlags_InputRGB) || !(flags & ImGuiColorEditFlags_InputMask_)) {
		if (flags & ImGuiColorEditFlags_NoAlpha)
			Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);
		else
			Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
	} else if (flags & ImGuiColorEditFlags_InputHSV) {
		if (flags & ImGuiColorEditFlags_NoAlpha)
			Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]);
		else
			Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2], col[3]);
	}
	EndTooltip();
}

void ImGui::ColorEditOptionsPopup(const float *col, ImGuiColorEditFlags flags) {
	bool allow_opt_inputs = !(flags & ImGuiColorEditFlags_DisplayMask_);
	bool allow_opt_datatype = !(flags & ImGuiColorEditFlags_DataTypeMask_);
	if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))
		return;
	ImGuiContext &g = *GImGui;
	g.LockMarkEdited++;
	ImGuiColorEditFlags opts = g.ColorEditOptions;
	if (allow_opt_inputs) {
		if (RadioButton("RGB", (opts & ImGuiColorEditFlags_DisplayRGB) != 0))
			opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayRGB;
		if (RadioButton("HSV", (opts & ImGuiColorEditFlags_DisplayHSV) != 0))
			opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHSV;
		if (RadioButton("Hex", (opts & ImGuiColorEditFlags_DisplayHex) != 0))
			opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHex;
	}
	if (allow_opt_datatype) {
		if (allow_opt_inputs)
			Separator();
		if (RadioButton("0..255", (opts & ImGuiColorEditFlags_Uint8) != 0))
			opts = (opts & ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Uint8;
		if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) != 0))
			opts = (opts & ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Float;
	}

	if (allow_opt_inputs || allow_opt_datatype)
		Separator();
	if (Button("Copy as..", ImVec2(-1, 0)))
		OpenPopup("Copy");
	if (BeginPopup("Copy")) {
		int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
		char buf[64];
		ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
		if (Selectable(buf))
			SetClipboardText(buf);
		ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);
		if (Selectable(buf))
			SetClipboardText(buf);
		ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", cr, cg, cb);
		if (Selectable(buf))
			SetClipboardText(buf);
		if (!(flags & ImGuiColorEditFlags_NoAlpha)) {
			ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", cr, cg, cb, ca);
			if (Selectable(buf))
				SetClipboardText(buf);
		}
		EndPopup();
	}

	g.ColorEditOptions = opts;
	EndPopup();
	g.LockMarkEdited--;
}

void ImGui::ColorPickerOptionsPopup(const float *ref_col, ImGuiColorEditFlags flags) {
	bool allow_opt_picker = !(flags & ImGuiColorEditFlags_PickerMask_);
	bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);
	if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))
		return;
	ImGuiContext &g = *GImGui;
	g.LockMarkEdited++;
	if (allow_opt_picker) {
		ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function
		PushItemWidth(picker_size.x);
		for (int picker_type = 0; picker_type < 2; picker_type++) {
			// Draw small/thumbnail version of each picker type (over an invisible button for selection)
			if (picker_type > 0)
				Separator();
			PushID(picker_type);
			ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoSidePreview | (flags & ImGuiColorEditFlags_NoAlpha);
			if (picker_type == 0)
				picker_flags |= ImGuiColorEditFlags_PickerHueBar;
			if (picker_type == 1)
				picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
			ImVec2 backup_pos = GetCursorScreenPos();
			if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup
				g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags_PickerMask_) | (picker_flags & ImGuiColorEditFlags_PickerMask_);
			SetCursorScreenPos(backup_pos);
			ImVec4 previewing_ref_col;
			memcpy(&previewing_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));
			ColorPicker4("##previewing_picker", &previewing_ref_col.x, picker_flags);
			PopID();
		}
		PopItemWidth();
	}
	if (allow_opt_alpha_bar) {
		if (allow_opt_picker)
			Separator();
		CheckboxFlags("Alpha Bar", &g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);
	}
	EndPopup();
	g.LockMarkEdited--;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - TreeNodeBehavior() [Internal]
// - TreePush()
// - TreePop()
// - GetTreeNodeToLabelSpacing()
// - SetNextItemOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

bool ImGui::TreeNode(const char *str_id, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	bool is_open = TreeNodeExV(str_id, 0, fmt, args);
	va_end(args);
	return is_open;
}

bool ImGui::TreeNode(const void *ptr_id, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
	va_end(args);
	return is_open;
}

bool ImGui::TreeNode(const char *label) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;
	ImGuiID id = window->GetID(label);
	return TreeNodeBehavior(id, ImGuiTreeNodeFlags_None, label, NULL);
}

bool ImGui::TreeNodeV(const char *str_id, const char *fmt, va_list args) {
	return TreeNodeExV(str_id, 0, fmt, args);
}

bool ImGui::TreeNodeV(const void *ptr_id, const char *fmt, va_list args) {
	return TreeNodeExV(ptr_id, 0, fmt, args);
}

bool ImGui::TreeNodeEx(const char *label, ImGuiTreeNodeFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;
	ImGuiID id = window->GetID(label);
	return TreeNodeBehavior(id, flags, label, NULL);
}

bool ImGui::TreeNodeEx(const char *str_id, ImGuiTreeNodeFlags flags, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	bool is_open = TreeNodeExV(str_id, flags, fmt, args);
	va_end(args);
	return is_open;
}

bool ImGui::TreeNodeEx(const void *ptr_id, ImGuiTreeNodeFlags flags, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
	va_end(args);
	return is_open;
}

bool ImGui::TreeNodeExV(const char *str_id, ImGuiTreeNodeFlags flags, const char *fmt, va_list args) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiID id = window->GetID(str_id);
	const char *label, *label_end;
	ImFormatStringToTempBufferV(&label, &label_end, fmt, args);
	return TreeNodeBehavior(id, flags, label, label_end);
}

bool ImGui::TreeNodeExV(const void *ptr_id, ImGuiTreeNodeFlags flags, const char *fmt, va_list args) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiID id = window->GetID(ptr_id);
	const char *label, *label_end;
	ImFormatStringToTempBufferV(&label, &label_end, fmt, args);
	return TreeNodeBehavior(id, flags, label, label_end);
}

bool ImGui::TreeNodeGetOpen(ImGuiID storage_id) {
	ImGuiContext &g = *GImGui;
	ImGuiStorage *storage = g.CurrentWindow->DC.StateStorage;
	return storage->GetInt(storage_id, 0) != 0;
}

void ImGui::TreeNodeSetOpen(ImGuiID storage_id, bool open) {
	ImGuiContext &g = *GImGui;
	ImGuiStorage *storage = g.CurrentWindow->DC.StateStorage;
	storage->SetInt(storage_id, open ? 1 : 0);
}

bool ImGui::TreeNodeUpdateNextOpen(ImGuiID storage_id, ImGuiTreeNodeFlags flags) {
	if (flags & ImGuiTreeNodeFlags_Leaf)
		return true;

	// We only write to the tree storage if the user clicks, or explicitly use the SetNextItemOpen function
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiStorage *storage = window->DC.StateStorage;

	bool is_open;
	if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasOpen) {
		if (g.NextItemData.OpenCond & ImGuiCond_Always) {
			is_open = g.NextItemData.OpenVal;
			TreeNodeSetOpen(storage_id, is_open);
		} else {
			// We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
			const int stored_value = storage->GetInt(storage_id, -1);
			if (stored_value == -1) {
				is_open = g.NextItemData.OpenVal;
				TreeNodeSetOpen(storage_id, is_open);
			} else {
				is_open = stored_value != 0;
			}
		}
	} else {
		is_open = storage->GetInt(storage_id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;
	}

	// When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
	// NB- If we are above max depth we still allow manually opened nodes to be logged.
	if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)
		is_open = true;

	return is_open;
}

// Store ImGuiTreeNodeStackData for just submitted node.
// Currently only supports 32 level deep and we are fine with (1 << Depth) overflowing into a zero, easy to increase.
static void TreeNodeStoreStackData(ImGuiTreeNodeFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	g.TreeNodeStack.resize(g.TreeNodeStack.Size + 1);
	ImGuiTreeNodeStackData *tree_node_data = &g.TreeNodeStack.back();
	tree_node_data->ID = g.LastItemData.ID;
	tree_node_data->TreeFlags = flags;
	tree_node_data->InFlags = g.LastItemData.InFlags;
	tree_node_data->NavRect = g.LastItemData.NavRect;
	window->DC.TreeHasStackDataDepthMask |= (1 << window->DC.TreeDepth);
}

// When using public API, currently 'id == storage_id' is always true, but we separate the values to facilitate advanced user code doing storage queries outside of UI loop.
bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char *label, const char *label_end) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;
	const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));

	if (!label_end)
		label_end = FindRenderedTextEnd(label);
	const ImVec2 label_size = CalcTextSize(label, label_end, false);

	const float text_offset_x = g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2); // Collapsing arrow width + Spacing
	const float text_offset_y = ImMax(padding.y, window->DC.CurrLineTextBaseOffset); // Latch before ItemSize changes it
	const float text_width = g.FontSize + label_size.x + padding.x * 2; // Include collapsing arrow

	// We vertically grow up to current line height up the typical widget height.
	const float frame_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);
	const bool span_all_columns = (flags & ImGuiTreeNodeFlags_SpanAllColumns) != 0 && (g.CurrentTable != NULL);
	ImRect frame_bb;
	frame_bb.Min.x = span_all_columns ? window->ParentWorkRect.Min.x : (flags & ImGuiTreeNodeFlags_SpanFullWidth) ? window->WorkRect.Min.x
																												  : window->DC.CursorPos.x;
	frame_bb.Min.y = window->DC.CursorPos.y;
	frame_bb.Max.x = span_all_columns ? window->ParentWorkRect.Max.x : (flags & ImGuiTreeNodeFlags_SpanTextWidth) ? window->DC.CursorPos.x + text_width + padding.x
																												  : window->WorkRect.Max.x;
	frame_bb.Max.y = window->DC.CursorPos.y + frame_height;
	if (display_frame) {
		const float outer_extend = IM_TRUNC(window->WindowPadding.x * 0.5f); // Framed header expand a little outside of current limits
		frame_bb.Min.x -= outer_extend;
		frame_bb.Max.x += outer_extend;
	}

	ImVec2 text_pos(window->DC.CursorPos.x + text_offset_x, window->DC.CursorPos.y + text_offset_y);
	ItemSize(ImVec2(text_width, frame_height), padding.y);

	// For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
	ImRect interact_bb = frame_bb;
	if ((flags & (ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_SpanTextWidth | ImGuiTreeNodeFlags_SpanAllColumns)) == 0)
		interact_bb.Max.x = frame_bb.Min.x + text_width + (label_size.x > 0.0f ? style.ItemSpacing.x * 2.0f : 0.0f);

	// Compute open and multi-select states before ItemAdd() as it clear NextItem data.
	ImGuiID storage_id = (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasStorageID) ? g.NextItemData.StorageId : id;
	bool is_open = TreeNodeUpdateNextOpen(storage_id, flags);

	bool is_visible;
	if (span_all_columns) {
		// Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackgroundChannel for every Selectable..
		const float backup_clip_rect_min_x = window->ClipRect.Min.x;
		const float backup_clip_rect_max_x = window->ClipRect.Max.x;
		window->ClipRect.Min.x = window->ParentWorkRect.Min.x;
		window->ClipRect.Max.x = window->ParentWorkRect.Max.x;
		is_visible = ItemAdd(interact_bb, id);
		window->ClipRect.Min.x = backup_clip_rect_min_x;
		window->ClipRect.Max.x = backup_clip_rect_max_x;
	} else {
		is_visible = ItemAdd(interact_bb, id);
	}
	g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
	g.LastItemData.DisplayRect = frame_bb;

	// If a NavLeft request is happening and ImGuiTreeNodeFlags_NavLeftJumpsBackHere enabled:
	// Store data for the current depth to allow returning to this node from any child item.
	// For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
	// It will become tempting to enable ImGuiTreeNodeFlags_NavLeftJumpsBackHere by default or move it to ImGuiStyle.
	bool store_tree_node_stack_data = false;
	if (!(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen)) {
		if ((flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && is_open && !g.NavIdIsAlive)
			if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
				store_tree_node_stack_data = true;
	}

	const bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;
	if (!is_visible) {
		if (store_tree_node_stack_data && is_open)
			TreeNodeStoreStackData(flags); // Call before TreePushOverrideID()
		if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
			TreePushOverrideID(id);
		IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
		return is_open;
	}

	if (span_all_columns) {
		TablePushBackgroundChannel();
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasClipRect;
		g.LastItemData.ClipRect = window->ClipRect;
	}

	ImGuiButtonFlags button_flags = ImGuiTreeNodeFlags_None;
	if ((flags & ImGuiTreeNodeFlags_AllowOverlap) || (g.LastItemData.InFlags & ImGuiItemFlags_AllowOverlap))
		button_flags |= ImGuiButtonFlags_AllowOverlap;
	if (!is_leaf)
		button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

	// We allow clicking on the arrow section with keyboard modifiers held, in order to easily
	// allow browsing a tree while preserving selection with code implementing multi-selection patterns.
	// When clicking on the rest of the tree node we always disallow keyboard modifiers.
	const float arrow_hit_x1 = (text_pos.x - text_offset_x) - style.TouchExtraPadding.x;
	const float arrow_hit_x2 = (text_pos.x - text_offset_x) + (g.FontSize + padding.x * 2.0f) + style.TouchExtraPadding.x;
	const bool is_mouse_x_over_arrow = (g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2);

	const bool is_multi_select = (g.LastItemData.InFlags & ImGuiItemFlags_IsMultiSelect) != 0;
	if (is_multi_select) // We absolutely need to distinguish open vs select so _OpenOnArrow comes by default
		flags |= (flags & ImGuiTreeNodeFlags_OpenOnMask_) == 0 ? ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick : ImGuiTreeNodeFlags_OpenOnArrow;

	// Open behaviors can be altered with the _OpenOnArrow and _OnOnDoubleClick flags.
	// Some alteration have subtle effects (e.g. toggle on MouseUp vs MouseDown events) due to requirements for multi-selection and drag and drop support.
	// - Single-click on label = Toggle on MouseUp (default, when _OpenOnArrow=0)
	// - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=0)
	// - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=1)
	// - Double-click on label = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1)
	// - Double-click on arrow = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1 and _OpenOnArrow=0)
	// It is rather standard that arrow click react on Down rather than Up.
	// We set ImGuiButtonFlags_PressedOnClickRelease on OpenOnDoubleClick because we want the item to be active on the initial MouseDown in order for drag and drop to work.
	if (is_mouse_x_over_arrow)
		button_flags |= ImGuiButtonFlags_PressedOnClick;
	else if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
		button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
	else
		button_flags |= ImGuiButtonFlags_PressedOnClickRelease;

	bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;
	const bool was_selected = selected;

	// Multi-selection support (header)
	if (is_multi_select) {
		// Handle multi-select + alter button flags for it
		MultiSelectItemHeader(id, &selected, &button_flags);
		if (is_mouse_x_over_arrow)
			button_flags = (button_flags | ImGuiButtonFlags_PressedOnClick) & ~ImGuiButtonFlags_PressedOnClickRelease;
	} else {
		if (window != g.HoveredWindow || !is_mouse_x_over_arrow)
			button_flags |= ImGuiButtonFlags_NoKeyModifiers;
	}

	bool hovered, held;
	bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);
	bool toggled = false;
	if (!is_leaf) {
		if (pressed && g.DragDropHoldJustPressedId != id) {
			if ((flags & ImGuiTreeNodeFlags_OpenOnMask_) == 0 || (g.NavActivateId == id && !is_multi_select))
				toggled = true; // Single click
			if (flags & ImGuiTreeNodeFlags_OpenOnArrow)
				toggled |= is_mouse_x_over_arrow && !g.NavDisableMouseHover; // Lightweight equivalent of IsMouseHoveringRect() since ButtonBehavior() already did the job
			if ((flags & ImGuiTreeNodeFlags_OpenOnDoubleClick) && g.IO.MouseClickedCount[0] == 2)
				toggled = true; // Double click
		} else if (pressed && g.DragDropHoldJustPressedId == id) {
			IM_ASSERT(button_flags & ImGuiButtonFlags_PressedOnDragDropHold);
			if (!is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
				toggled = true;
			else
				pressed = false; // Cancel press so it doesn't trigger selection.
		}

		if (g.NavId == id && g.NavMoveDir == ImGuiDir_Left && is_open) {
			toggled = true;
			NavClearPreferredPosForAxis(ImGuiAxis_X);
			NavMoveRequestCancel();
		}
		if (g.NavId == id && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?
		{
			toggled = true;
			NavClearPreferredPosForAxis(ImGuiAxis_X);
			NavMoveRequestCancel();
		}

		if (toggled) {
			is_open = !is_open;
			window->DC.StateStorage->SetInt(storage_id, is_open);
			g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledOpen;
		}
	}

	// Multi-selection support (footer)
	if (is_multi_select) {
		bool pressed_copy = pressed && !toggled;
		MultiSelectItemFooter(id, &selected, &pressed_copy);
		if (pressed)
			SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, interact_bb);
	}

	if (selected != was_selected)
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

	// Render
	{
		const ImU32 text_col = GetColorU32(ImGuiCol_Text);
		ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_Compact;
		if (is_multi_select)
			nav_highlight_flags |= ImGuiNavHighlightFlags_AlwaysDraw; // Always show the nav rectangle
		if (display_frame) {
			// Framed type
			const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered
																								 : ImGuiCol_Header);
			RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding);
			RenderNavHighlight(frame_bb, id, nav_highlight_flags);
			if (flags & ImGuiTreeNodeFlags_Bullet)
				RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.60f, text_pos.y + g.FontSize * 0.5f), text_col);
			else if (!is_leaf)
				RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y), text_col, is_open ? ((flags & ImGuiTreeNodeFlags_UpsideDownArrow) ? ImGuiDir_Up : ImGuiDir_Down) : ImGuiDir_Right, 1.0f);
			else // Leaf without bullet, left-adjusted text
				text_pos.x -= text_offset_x - padding.x;
			if (flags & ImGuiTreeNodeFlags_ClipLabelForTrailingButton)
				frame_bb.Max.x -= g.FontSize + style.FramePadding.x;
			if (g.LogEnabled)
				LogSetNextTextDecoration("###", "###");
		} else {
			// Unframed typed for tree nodes
			if (hovered || selected) {
				const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered
																									 : ImGuiCol_Header);
				RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, false);
			}
			RenderNavHighlight(frame_bb, id, nav_highlight_flags);
			if (flags & ImGuiTreeNodeFlags_Bullet)
				RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.5f, text_pos.y + g.FontSize * 0.5f), text_col);
			else if (!is_leaf)
				RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y + g.FontSize * 0.15f), text_col, is_open ? ((flags & ImGuiTreeNodeFlags_UpsideDownArrow) ? ImGuiDir_Up : ImGuiDir_Down) : ImGuiDir_Right, 0.70f);
			if (g.LogEnabled)
				LogSetNextTextDecoration(">", NULL);
		}

		if (span_all_columns)
			TablePopBackgroundChannel();

		// Label
		if (display_frame)
			RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
		else
			RenderText(text_pos, label, label_end, false);
	}

	if (store_tree_node_stack_data && is_open)
		TreeNodeStoreStackData(flags); // Call before TreePushOverrideID()
	if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
		TreePushOverrideID(id); // Could use TreePush(label) but this avoid computing twice

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
	return is_open;
}

void ImGui::TreePush(const char *str_id) {
	ImGuiWindow *window = GetCurrentWindow();
	Indent();
	window->DC.TreeDepth++;
	PushID(str_id);
}

void ImGui::TreePush(const void *ptr_id) {
	ImGuiWindow *window = GetCurrentWindow();
	Indent();
	window->DC.TreeDepth++;
	PushID(ptr_id);
}

void ImGui::TreePushOverrideID(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	Indent();
	window->DC.TreeDepth++;
	PushOverrideID(id);
}

void ImGui::TreePop() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	Unindent();

	window->DC.TreeDepth--;
	ImU32 tree_depth_mask = (1 << window->DC.TreeDepth);

	if (window->DC.TreeHasStackDataDepthMask & tree_depth_mask) // Only set during request
	{
		ImGuiTreeNodeStackData *data = &g.TreeNodeStack.back();
		IM_ASSERT(data->ID == window->IDStack.back());
		if (data->TreeFlags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) {
			// Handle Left arrow to move to parent tree node (when ImGuiTreeNodeFlags_NavLeftJumpsBackHere is enabled)
			if (g.NavIdIsAlive && g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
				NavMoveRequestResolveWithPastTreeNode(&g.NavMoveResultLocal, data);
		}
		g.TreeNodeStack.pop_back();
		window->DC.TreeHasStackDataDepthMask &= ~tree_depth_mask;
	}

	IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
	PopID();
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
float ImGui::GetTreeNodeToLabelSpacing() {
	ImGuiContext &g = *GImGui;
	return g.FontSize + (g.Style.FramePadding.x * 2.0f);
}

// Set next TreeNode/CollapsingHeader open state.
void ImGui::SetNextItemOpen(bool is_open, ImGuiCond cond) {
	ImGuiContext &g = *GImGui;
	if (g.CurrentWindow->SkipItems)
		return;
	g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasOpen;
	g.NextItemData.OpenVal = is_open;
	g.NextItemData.OpenCond = (ImU8)(cond ? cond : ImGuiCond_Always);
}

// Set next TreeNode/CollapsingHeader storage id.
void ImGui::SetNextItemStorageID(ImGuiID storage_id) {
	ImGuiContext &g = *GImGui;
	if (g.CurrentWindow->SkipItems)
		return;
	g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasStorageID;
	g.NextItemData.StorageId = storage_id;
}

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
bool ImGui::CollapsingHeader(const char *label, ImGuiTreeNodeFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;
	ImGuiID id = window->GetID(label);
	return TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader, label);
}

// p_visible == NULL                        : regular collapsing header
// p_visible != NULL && *p_visible == true  : show a small close button on the corner of the header, clicking the button will set *p_visible = false
// p_visible != NULL && *p_visible == false : do not show the header at all
// Do not mistake this with the Open state of the header itself, which you can adjust with SetNextItemOpen() or ImGuiTreeNodeFlags_DefaultOpen.
bool ImGui::CollapsingHeader(const char *label, bool *p_visible, ImGuiTreeNodeFlags flags) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	if (p_visible && !*p_visible)
		return false;

	ImGuiID id = window->GetID(label);
	flags |= ImGuiTreeNodeFlags_CollapsingHeader;
	if (p_visible)
		flags |= ImGuiTreeNodeFlags_AllowOverlap | (ImGuiTreeNodeFlags)ImGuiTreeNodeFlags_ClipLabelForTrailingButton;
	bool is_open = TreeNodeBehavior(id, flags, label);
	if (p_visible != NULL) {
		// Create a small overlapping close button
		// FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
		// FIXME: CloseButton can overlap into text, need find a way to clip the text somehow.
		ImGuiContext &g = *GImGui;
		ImGuiLastItemData last_item_backup = g.LastItemData;
		float button_size = g.FontSize;
		float button_x = ImMax(g.LastItemData.Rect.Min.x, g.LastItemData.Rect.Max.x - g.Style.FramePadding.x - button_size);
		float button_y = g.LastItemData.Rect.Min.y + g.Style.FramePadding.y;
		ImGuiID close_button_id = GetIDWithSeed("#CLOSE", NULL, id);
		if (CloseButton(close_button_id, ImVec2(button_x, button_y)))
			*p_visible = false;
		g.LastItemData = last_item_backup;
	}

	return is_open;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Selectable
//-------------------------------------------------------------------------
// - Selectable()
//-------------------------------------------------------------------------

// Tip: pass a non-visible label (e.g. "##hello") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
// With this scheme, ImGuiSelectableFlags_SpanAllColumns and ImGuiSelectableFlags_AllowOverlap are also frequently used flags.
// FIXME: Selectable() with (size.x == 0.0f) and (SelectableTextAlign.x > 0.0f) followed by SameLine() is currently not supported.
bool ImGui::Selectable(const char *label, bool selected, ImGuiSelectableFlags flags, const ImVec2 &size_arg) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;

	// Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.
	ImGuiID id = window->GetID(label);
	ImVec2 label_size = CalcTextSize(label, NULL, true);
	ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
	ImVec2 pos = window->DC.CursorPos;
	pos.y += window->DC.CurrLineTextBaseOffset;
	ItemSize(size, 0.0f);

	// Fill horizontal space
	// We don't support (size < 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.
	const bool span_all_columns = (flags & ImGuiSelectableFlags_SpanAllColumns) != 0;
	const float min_x = span_all_columns ? window->ParentWorkRect.Min.x : pos.x;
	const float max_x = span_all_columns ? window->ParentWorkRect.Max.x : window->WorkRect.Max.x;
	if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_SpanAvailWidth))
		size.x = ImMax(label_size.x, max_x - min_x);

	// Text stays at the submission position, but bounding box may be extended on both sides
	const ImVec2 text_min = pos;
	const ImVec2 text_max(min_x + size.x, pos.y + size.y);

	// Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.
	// FIXME: Not part of layout so not included in clipper calculation, but ItemSize currently doesn't allow offsetting CursorPos.
	ImRect bb(min_x, pos.y, text_max.x, text_max.y);
	if ((flags & ImGuiSelectableFlags_NoPadWithHalfSpacing) == 0) {
		const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;
		const float spacing_y = style.ItemSpacing.y;
		const float spacing_L = IM_TRUNC(spacing_x * 0.50f);
		const float spacing_U = IM_TRUNC(spacing_y * 0.50f);
		bb.Min.x -= spacing_L;
		bb.Min.y -= spacing_U;
		bb.Max.x += (spacing_x - spacing_L);
		bb.Max.y += (spacing_y - spacing_U);
	}
	//if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }

	const bool disabled_item = (flags & ImGuiSelectableFlags_Disabled) != 0;
	const ImGuiItemFlags extra_item_flags = disabled_item ? (ImGuiItemFlags)ImGuiItemFlags_Disabled : ImGuiItemFlags_None;
	bool is_visible;
	if (span_all_columns) {
		// Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackgroundChannel for every Selectable..
		const float backup_clip_rect_min_x = window->ClipRect.Min.x;
		const float backup_clip_rect_max_x = window->ClipRect.Max.x;
		window->ClipRect.Min.x = window->ParentWorkRect.Min.x;
		window->ClipRect.Max.x = window->ParentWorkRect.Max.x;
		is_visible = ItemAdd(bb, id, NULL, extra_item_flags);
		window->ClipRect.Min.x = backup_clip_rect_min_x;
		window->ClipRect.Max.x = backup_clip_rect_max_x;
	} else {
		is_visible = ItemAdd(bb, id, NULL, extra_item_flags);
	}

	const bool is_multi_select = (g.LastItemData.InFlags & ImGuiItemFlags_IsMultiSelect) != 0;
	if (!is_visible)
		if (!is_multi_select || !g.BoxSelectState.UnclipMode || !g.BoxSelectState.UnclipRect.Overlaps(bb)) // Extra layer of "no logic clip" for box-select support (would be more overhead to add to ItemAdd)
			return false;

	const bool disabled_global = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
	if (disabled_item && !disabled_global) // Only testing this as an optimization
		BeginDisabled();

	// FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,
	// which would be advantageous since most selectable are not selected.
	if (span_all_columns) {
		if (g.CurrentTable)
			TablePushBackgroundChannel();
		else if (window->DC.CurrentColumns)
			PushColumnsBackground();
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasClipRect;
		g.LastItemData.ClipRect = window->ClipRect;
	}

	// We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
	ImGuiButtonFlags button_flags = 0;
	if (flags & ImGuiSelectableFlags_NoHoldingActiveID) {
		button_flags |= ImGuiButtonFlags_NoHoldingActiveId;
	}
	if (flags & ImGuiSelectableFlags_NoSetKeyOwner) {
		button_flags |= ImGuiButtonFlags_NoSetKeyOwner;
	}
	if (flags & ImGuiSelectableFlags_SelectOnClick) {
		button_flags |= ImGuiButtonFlags_PressedOnClick;
	}
	if (flags & ImGuiSelectableFlags_SelectOnRelease) {
		button_flags |= ImGuiButtonFlags_PressedOnRelease;
	}
	if (flags & ImGuiSelectableFlags_AllowDoubleClick) {
		button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
	}
	if ((flags & ImGuiSelectableFlags_AllowOverlap) || (g.LastItemData.InFlags & ImGuiItemFlags_AllowOverlap)) {
		button_flags |= ImGuiButtonFlags_AllowOverlap;
	}

	// Multi-selection support (header)
	const bool was_selected = selected;
	if (is_multi_select) {
		// Handle multi-select + alter button flags for it
		MultiSelectItemHeader(id, &selected, &button_flags);
	}

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

	// Multi-selection support (footer)
	if (is_multi_select) {
		MultiSelectItemFooter(id, &selected, &pressed);
	} else {
		// Auto-select when moved into
		// - This will be more fully fleshed in the range-select branch
		// - This is not exposed as it won't nicely work with some user side handling of shift/control
		// - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons
		//   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())
		//   - (2) usage will fail with clipped items
		//   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.
		if ((flags & ImGuiSelectableFlags_SelectOnNav) && g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == g.CurrentFocusScopeId)
			if (g.NavJustMovedToId == id)
				selected = pressed = true;
	}

	// Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with gamepad/keyboard
	if (pressed || (hovered && (flags & ImGuiSelectableFlags_SetNavIdOnHover))) {
		if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent) {
			SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)
			g.NavDisableHighlight = true;
		}
	}
	if (pressed)
		MarkItemEdited(id);

	if (selected != was_selected)
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

	// Render
	if (is_visible) {
		const bool highlighted = hovered || (flags & ImGuiSelectableFlags_Highlight);
		if (highlighted || selected) {
			// FIXME-MULTISELECT: Styling: Color for 'selected' elements? ImGuiCol_HeaderSelected
			ImU32 col;
			if (selected && !highlighted)
				col = GetColorU32(ImLerp(GetStyleColorVec4(ImGuiCol_Header), GetStyleColorVec4(ImGuiCol_HeaderHovered), 0.5f));
			else
				col = GetColorU32((held && highlighted) ? ImGuiCol_HeaderActive : highlighted ? ImGuiCol_HeaderHovered
																							  : ImGuiCol_Header);
			RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
		}
		if (g.NavId == id) {
			ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_Compact | ImGuiNavHighlightFlags_NoRounding;
			if (is_multi_select)
				nav_highlight_flags |= ImGuiNavHighlightFlags_AlwaysDraw; // Always show the nav rectangle
			RenderNavHighlight(bb, id, nav_highlight_flags);
		}
	}

	if (span_all_columns) {
		if (g.CurrentTable)
			TablePopBackgroundChannel();
		else if (window->DC.CurrentColumns)
			PopColumnsBackground();
	}

	if (is_visible)
		RenderTextClipped(text_min, text_max, label, NULL, &label_size, style.SelectableTextAlign, &bb);

	// Automatically close popups
	if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_NoAutoClosePopups) && (g.LastItemData.InFlags & ImGuiItemFlags_AutoClosePopups))
		CloseCurrentPopup();

	if (disabled_item && !disabled_global)
		EndDisabled();

	// Selectable() always returns a pressed state!
	// Users of BeginMultiSelect()/EndMultiSelect() scope: you may call ImGui::IsItemToggledSelection() to retrieve
	// selection toggle, only useful if you need that state updated (e.g. for rendering purpose) before reaching EndMultiSelect().
	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	return pressed; //-V1020
}

bool ImGui::Selectable(const char *label, bool *p_selected, ImGuiSelectableFlags flags, const ImVec2 &size_arg) {
	if (Selectable(label, *p_selected, flags, size_arg)) {
		*p_selected = !*p_selected;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Typing-Select support
//-------------------------------------------------------------------------

// [Experimental] Currently not exposed in public API.
// Consume character inputs and return search request, if any.
// This would typically only be called on the focused window or location you want to grab inputs for, e.g.
//   if (ImGui::IsWindowFocused(...))
//       if (ImGuiTypingSelectRequest* req = ImGui::GetTypingSelectRequest())
//           focus_idx = ImGui::TypingSelectFindMatch(req, my_items.size(), [](void*, int n) { return my_items[n]->Name; }, &my_items, -1);
// However the code is written in a way where calling it from multiple locations is safe (e.g. to obtain buffer).
ImGuiTypingSelectRequest *ImGui::GetTypingSelectRequest(ImGuiTypingSelectFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiTypingSelectState *data = &g.TypingSelectState;
	ImGuiTypingSelectRequest *out_request = &data->Request;

	// Clear buffer
	const float TYPING_SELECT_RESET_TIMER = 1.80f; // FIXME: Potentially move to IO config.
	const int TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK = 4; // Lock single char matching when repeating same char 4 times
	if (data->SearchBuffer[0] != 0) {
		bool clear_buffer = false;
		clear_buffer |= (g.NavFocusScopeId != data->FocusScope);
		clear_buffer |= (data->LastRequestTime + TYPING_SELECT_RESET_TIMER < g.Time);
		clear_buffer |= g.NavAnyRequest;
		clear_buffer |= g.ActiveId != 0 && g.NavActivateId == 0; // Allow temporary SPACE activation to not interfere
		clear_buffer |= IsKeyPressed(ImGuiKey_Escape) || IsKeyPressed(ImGuiKey_Enter);
		clear_buffer |= IsKeyPressed(ImGuiKey_Backspace) && (flags & ImGuiTypingSelectFlags_AllowBackspace) == 0;
		//if (clear_buffer) { IMGUI_DEBUG_LOG("GetTypingSelectRequest(): Clear SearchBuffer.\n"); }
		if (clear_buffer)
			data->Clear();
	}

	// Append to buffer
	const int buffer_max_len = IM_ARRAYSIZE(data->SearchBuffer) - 1;
	int buffer_len = (int)strlen(data->SearchBuffer);
	bool select_request = false;
	for (ImWchar w : g.IO.InputQueueCharacters) {
		const int w_len = ImTextCountUtf8BytesFromStr(&w, &w + 1);
		if (w < 32 || (buffer_len == 0 && ImCharIsBlankW(w)) || (buffer_len + w_len > buffer_max_len)) // Ignore leading blanks
			continue;
		char w_buf[5];
		ImTextCharToUtf8(w_buf, (unsigned int)w);
		if (data->SingleCharModeLock && w_len == out_request->SingleCharSize && memcmp(w_buf, data->SearchBuffer, w_len) == 0) {
			select_request = true; // Same character: don't need to append to buffer.
			continue;
		}
		if (data->SingleCharModeLock) {
			data->Clear(); // Different character: clear
			buffer_len = 0;
		}
		memcpy(data->SearchBuffer + buffer_len, w_buf, w_len + 1); // Append
		buffer_len += w_len;
		select_request = true;
	}
	g.IO.InputQueueCharacters.resize(0);

	// Handle backspace
	if ((flags & ImGuiTypingSelectFlags_AllowBackspace) && IsKeyPressed(ImGuiKey_Backspace, ImGuiInputFlags_Repeat)) {
		char *p = (char *)(void *)ImTextFindPreviousUtf8Codepoint(data->SearchBuffer, data->SearchBuffer + buffer_len);
		*p = 0;
		buffer_len = (int)(p - data->SearchBuffer);
	}

	// Return request if any
	if (buffer_len == 0)
		return NULL;
	if (select_request) {
		data->FocusScope = g.NavFocusScopeId;
		data->LastRequestFrame = g.FrameCount;
		data->LastRequestTime = (float)g.Time;
	}
	out_request->Flags = flags;
	out_request->SearchBufferLen = buffer_len;
	out_request->SearchBuffer = data->SearchBuffer;
	out_request->SelectRequest = (data->LastRequestFrame == g.FrameCount);
	out_request->SingleCharMode = false;
	out_request->SingleCharSize = 0;

	// Calculate if buffer contains the same character repeated.
	// - This can be used to implement a special search mode on first character.
	// - Performed on UTF-8 codepoint for correctness.
	// - SingleCharMode is always set for first input character, because it usually leads to a "next".
	if (flags & ImGuiTypingSelectFlags_AllowSingleCharMode) {
		const char *buf_begin = out_request->SearchBuffer;
		const char *buf_end = out_request->SearchBuffer + out_request->SearchBufferLen;
		const int c0_len = ImTextCountUtf8BytesFromChar(buf_begin, buf_end);
		const char *p = buf_begin + c0_len;
		for (; p < buf_end; p += c0_len)
			if (memcmp(buf_begin, p, (size_t)c0_len) != 0)
				break;
		const int single_char_count = (p == buf_end) ? (out_request->SearchBufferLen / c0_len) : 0;
		out_request->SingleCharMode = (single_char_count > 0 || data->SingleCharModeLock);
		out_request->SingleCharSize = (ImS8)c0_len;
		data->SingleCharModeLock |= (single_char_count >= TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK); // From now on we stop search matching to lock to single char mode.
	}

	return out_request;
}

static int ImStrimatchlen(const char *s1, const char *s1_end, const char *s2) {
	int match_len = 0;
	while (s1 < s1_end && ImToUpper(*s1++) == ImToUpper(*s2++))
		match_len++;
	return match_len;
}

// Default handler for finding a result for typing-select. You may implement your own.
// You might want to display a tooltip to visualize the current request SearchBuffer
// When SingleCharMode is set:
// - it is better to NOT display a tooltip of other on-screen display indicator.
// - the index of the currently focused item is required.
//   if your SetNextItemSelectionUserData() values are indices, you can obtain it from ImGuiMultiSelectIO::NavIdItem, otherwise from g.NavLastValidSelectionUserData.
int ImGui::TypingSelectFindMatch(ImGuiTypingSelectRequest *req, int items_count, const char *(*get_item_name_func)(void *, int), void *user_data, int nav_item_idx) {
	if (req == NULL || req->SelectRequest == false) // Support NULL parameter so both calls can be done from same spot.
		return -1;
	int idx = -1;
	if (req->SingleCharMode && (req->Flags & ImGuiTypingSelectFlags_AllowSingleCharMode))
		idx = TypingSelectFindNextSingleCharMatch(req, items_count, get_item_name_func, user_data, nav_item_idx);
	else
		idx = TypingSelectFindBestLeadingMatch(req, items_count, get_item_name_func, user_data);
	if (idx != -1)
		NavRestoreHighlightAfterMove();
	return idx;
}

// Special handling when a single character is repeated: perform search on a single letter and goes to next.
int ImGui::TypingSelectFindNextSingleCharMatch(ImGuiTypingSelectRequest *req, int items_count, const char *(*get_item_name_func)(void *, int), void *user_data, int nav_item_idx) {
	// FIXME: Assume selection user data is index. Would be extremely practical.
	//if (nav_item_idx == -1)
	//    nav_item_idx = (int)g.NavLastValidSelectionUserData;

	int first_match_idx = -1;
	bool return_next_match = false;
	for (int idx = 0; idx < items_count; idx++) {
		const char *item_name = get_item_name_func(user_data, idx);
		if (ImStrimatchlen(req->SearchBuffer, req->SearchBuffer + req->SingleCharSize, item_name) < req->SingleCharSize)
			continue;
		if (return_next_match) // Return next matching item after current item.
			return idx;
		if (first_match_idx == -1 && nav_item_idx == -1) // Return first match immediately if we don't have a nav_item_idx value.
			return idx;
		if (first_match_idx == -1) // Record first match for wrapping.
			first_match_idx = idx;
		if (nav_item_idx == idx) // Record that we encountering nav_item so we can return next match.
			return_next_match = true;
	}
	return first_match_idx; // First result
}

int ImGui::TypingSelectFindBestLeadingMatch(ImGuiTypingSelectRequest *req, int items_count, const char *(*get_item_name_func)(void *, int), void *user_data) {
	int longest_match_idx = -1;
	int longest_match_len = 0;
	for (int idx = 0; idx < items_count; idx++) {
		const char *item_name = get_item_name_func(user_data, idx);
		const int match_len = ImStrimatchlen(req->SearchBuffer, req->SearchBuffer + req->SearchBufferLen, item_name);
		if (match_len <= longest_match_len)
			continue;
		longest_match_idx = idx;
		longest_match_len = match_len;
		if (match_len == req->SearchBufferLen)
			break;
	}
	return longest_match_idx;
}

void ImGui::DebugNodeTypingSelectState(ImGuiTypingSelectState *data) {
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	Text("SearchBuffer = \"%s\"", data->SearchBuffer);
	Text("SingleCharMode = %d, Size = %d, Lock = %d", data->Request.SingleCharMode, data->Request.SingleCharSize, data->SingleCharModeLock);
	Text("LastRequest = time: %.2f, frame: %d", data->LastRequestTime, data->LastRequestFrame);
#else
	IM_UNUSED(data);
#endif
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Box-Select support
// This has been extracted away from Multi-Select logic in the hope that it could eventually be used elsewhere, but hasn't been yet.
//-------------------------------------------------------------------------
// Extra logic in MultiSelectItemFooter() and ImGuiListClipper::Step()
//-------------------------------------------------------------------------
// - BoxSelectPreStartDrag() [Internal]
// - BoxSelectActivateDrag() [Internal]
// - BoxSelectDeactivateDrag() [Internal]
// - BoxSelectScrollWithMouseDrag() [Internal]
// - BeginBoxSelect() [Internal]
// - EndBoxSelect() [Internal]
//-------------------------------------------------------------------------

// Call on the initial click.
static void BoxSelectPreStartDrag(ImGuiID id, ImGuiSelectionUserData clicked_item) {
	ImGuiContext &g = *GImGui;
	ImGuiBoxSelectState *bs = &g.BoxSelectState;
	bs->ID = id;
	bs->IsStarting = true; // Consider starting box-select.
	bs->IsStartedFromVoid = (clicked_item == ImGuiSelectionUserData_Invalid);
	bs->IsStartedSetNavIdOnce = bs->IsStartedFromVoid;
	bs->KeyMods = g.IO.KeyMods;
	bs->StartPosRel = bs->EndPosRel = ImGui::WindowPosAbsToRel(g.CurrentWindow, g.IO.MousePos);
	bs->ScrollAccum = ImVec2(0.0f, 0.0f);
}

static void BoxSelectActivateDrag(ImGuiBoxSelectState *bs, ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	IMGUI_DEBUG_LOG_SELECTION("[selection] BeginBoxSelect() 0X%08X: Activate\n", bs->ID);
	bs->IsActive = true;
	bs->Window = window;
	bs->IsStarting = false;
	ImGui::SetActiveID(bs->ID, window);
	ImGui::SetActiveIdUsingAllKeyboardKeys();
	if (bs->IsStartedFromVoid && (bs->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0)
		bs->RequestClear = true;
}

static void BoxSelectDeactivateDrag(ImGuiBoxSelectState *bs) {
	ImGuiContext &g = *GImGui;
	bs->IsActive = bs->IsStarting = false;
	if (g.ActiveId == bs->ID) {
		IMGUI_DEBUG_LOG_SELECTION("[selection] BeginBoxSelect() 0X%08X: Deactivate\n", bs->ID);
		ImGui::ClearActiveID();
	}
	bs->ID = 0;
}

static void BoxSelectScrollWithMouseDrag(ImGuiBoxSelectState *bs, ImGuiWindow *window, const ImRect &inner_r) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(bs->Window == window);
	for (int n = 0; n < 2; n++) // each axis
	{
		const float mouse_pos = g.IO.MousePos[n];
		const float dist = (mouse_pos > inner_r.Max[n]) ? mouse_pos - inner_r.Max[n] : (mouse_pos < inner_r.Min[n]) ? mouse_pos - inner_r.Min[n]
																													: 0.0f;
		const float scroll_curr = window->Scroll[n];
		if (dist == 0.0f || (dist < 0.0f && scroll_curr < 0.0f) || (dist > 0.0f && scroll_curr >= window->ScrollMax[n]))
			continue;

		const float speed_multiplier = ImLinearRemapClamp(g.FontSize, g.FontSize * 5.0f, 1.0f, 4.0f, ImAbs(dist)); // x1 to x4 depending on distance
		const float scroll_step = g.FontSize * 35.0f * speed_multiplier * ImSign(dist) * g.IO.DeltaTime;
		bs->ScrollAccum[n] += scroll_step;

		// Accumulate into a stored value so we can handle high-framerate
		const float scroll_step_i = ImFloor(bs->ScrollAccum[n]);
		if (scroll_step_i == 0.0f)
			continue;
		if (n == 0)
			ImGui::SetScrollX(window, scroll_curr + scroll_step_i);
		else
			ImGui::SetScrollY(window, scroll_curr + scroll_step_i);
		bs->ScrollAccum[n] -= scroll_step_i;
	}
}

bool ImGui::BeginBoxSelect(const ImRect &scope_rect, ImGuiWindow *window, ImGuiID box_select_id, ImGuiMultiSelectFlags ms_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiBoxSelectState *bs = &g.BoxSelectState;
	KeepAliveID(box_select_id);
	if (bs->ID != box_select_id)
		return false;

	// IsStarting is set by MultiSelectItemFooter() when considering a possible box-select. We validate it here and lock geometry.
	bs->UnclipMode = false;
	bs->RequestClear = false;
	if (bs->IsStarting && IsMouseDragPastThreshold(0))
		BoxSelectActivateDrag(bs, window);
	else if ((bs->IsStarting || bs->IsActive) && g.IO.MouseDown[0] == false)
		BoxSelectDeactivateDrag(bs);
	if (!bs->IsActive)
		return false;

	// Current frame absolute prev/current rectangles are used to toggle selection.
	// They are derived from positions relative to scrolling space.
	ImVec2 start_pos_abs = WindowPosRelToAbs(window, bs->StartPosRel);
	ImVec2 prev_end_pos_abs = WindowPosRelToAbs(window, bs->EndPosRel); // Clamped already
	ImVec2 curr_end_pos_abs = g.IO.MousePos;
	if (ms_flags & ImGuiMultiSelectFlags_ScopeWindow) // Box-select scrolling only happens with ScopeWindow
		curr_end_pos_abs = ImClamp(curr_end_pos_abs, scope_rect.Min, scope_rect.Max);
	bs->BoxSelectRectPrev.Min = ImMin(start_pos_abs, prev_end_pos_abs);
	bs->BoxSelectRectPrev.Max = ImMax(start_pos_abs, prev_end_pos_abs);
	bs->BoxSelectRectCurr.Min = ImMin(start_pos_abs, curr_end_pos_abs);
	bs->BoxSelectRectCurr.Max = ImMax(start_pos_abs, curr_end_pos_abs);

	// Box-select 2D mode detects horizontal changes (vertical ones are already picked by Clipper)
	// Storing an extra rect used by widgets supporting box-select.
	if (ms_flags & ImGuiMultiSelectFlags_BoxSelect2d)
		if (bs->BoxSelectRectPrev.Min.x != bs->BoxSelectRectCurr.Min.x || bs->BoxSelectRectPrev.Max.x != bs->BoxSelectRectCurr.Max.x) {
			bs->UnclipMode = true;
			bs->UnclipRect = bs->BoxSelectRectPrev; // FIXME-OPT: UnclipRect x coordinates could be intersection of Prev and Curr rect on X axis.
			bs->UnclipRect.Add(bs->BoxSelectRectCurr);
		}

	//GetForegroundDrawList()->AddRect(bs->UnclipRect.Min, bs->UnclipRect.Max, IM_COL32(255,0,0,200), 0.0f, 0, 3.0f);
	//GetForegroundDrawList()->AddRect(bs->BoxSelectRectPrev.Min, bs->BoxSelectRectPrev.Max, IM_COL32(255,0,0,200), 0.0f, 0, 3.0f);
	//GetForegroundDrawList()->AddRect(bs->BoxSelectRectCurr.Min, bs->BoxSelectRectCurr.Max, IM_COL32(0,255,0,200), 0.0f, 0, 1.0f);
	return true;
}

void ImGui::EndBoxSelect(const ImRect &scope_rect, ImGuiMultiSelectFlags ms_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiBoxSelectState *bs = &g.BoxSelectState;
	IM_ASSERT(bs->IsActive);
	bs->UnclipMode = false;

	// Render selection rectangle
	bs->EndPosRel = WindowPosAbsToRel(window, ImClamp(g.IO.MousePos, scope_rect.Min, scope_rect.Max)); // Clamp stored position according to current scrolling view
	ImRect box_select_r = bs->BoxSelectRectCurr;
	box_select_r.ClipWith(scope_rect);
	window->DrawList->AddRectFilled(box_select_r.Min, box_select_r.Max, GetColorU32(ImGuiCol_SeparatorHovered, 0.30f)); // FIXME-MULTISELECT: Styling
	window->DrawList->AddRect(box_select_r.Min, box_select_r.Max, GetColorU32(ImGuiCol_NavHighlight)); // FIXME-MULTISELECT: Styling

	// Scroll
	const bool enable_scroll = (ms_flags & ImGuiMultiSelectFlags_ScopeWindow) && (ms_flags & ImGuiMultiSelectFlags_BoxSelectNoScroll) == 0;
	if (enable_scroll) {
		ImRect scroll_r = scope_rect;
		scroll_r.Expand(-g.FontSize);
		//GetForegroundDrawList()->AddRect(scroll_r.Min, scroll_r.Max, IM_COL32(0, 255, 0, 255));
		if (!scroll_r.Contains(g.IO.MousePos))
			BoxSelectScrollWithMouseDrag(bs, window, scroll_r);
	}
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Multi-Select support
//-------------------------------------------------------------------------
// - DebugLogMultiSelectRequests() [Internal]
// - CalcScopeRect() [Internal]
// - BeginMultiSelect()
// - EndMultiSelect()
// - SetNextItemSelectionUserData()
// - MultiSelectItemHeader() [Internal]
// - MultiSelectItemFooter() [Internal]
// - DebugNodeMultiSelectState() [Internal]
//-------------------------------------------------------------------------

static void DebugLogMultiSelectRequests(const char *function, const ImGuiMultiSelectIO *io) {
	ImGuiContext &g = *GImGui;
	for (const ImGuiSelectionRequest &req : io->Requests) {
		if (req.Type == ImGuiSelectionRequestType_SetAll)
			IMGUI_DEBUG_LOG_SELECTION("[selection] %s: Request: SetAll %d (= %s)\n", function, req.Selected, req.Selected ? "SelectAll" : "Clear");
		if (req.Type == ImGuiSelectionRequestType_SetRange)
			IMGUI_DEBUG_LOG_SELECTION("[selection] %s: Request: SetRange %" IM_PRId64 "..%" IM_PRId64 " (0x%" IM_PRIX64 "..0x%" IM_PRIX64 ") = %d (dir %d)\n", function, req.RangeFirstItem, req.RangeLastItem, req.RangeFirstItem, req.RangeLastItem, req.Selected, req.RangeDirection);
	}
}

static ImRect CalcScopeRect(ImGuiMultiSelectTempData *ms, ImGuiWindow *window) {
	if (ms->Flags & ImGuiMultiSelectFlags_ScopeRect) {
		// Warning: this depends on CursorMaxPos so it means to be called by EndMultiSelect() only
		return ImRect(ms->ScopeRectMin, ImMax(window->DC.CursorMaxPos, ms->ScopeRectMin));
	} else {
		// Add inner table decoration (#7821) // FIXME: Why not baking in InnerClipRect?
		ImRect scope_rect = window->InnerClipRect;
		scope_rect.Min = ImMin(scope_rect.Min + ImVec2(window->DecoInnerSizeX1, window->DecoInnerSizeY1), scope_rect.Max);
		return scope_rect;
	}
}

// Return ImGuiMultiSelectIO structure.
// Lifetime: don't hold on ImGuiMultiSelectIO* pointers over multiple frames or past any subsequent call to BeginMultiSelect() or EndMultiSelect().
// Passing 'selection_size' and 'items_count' parameters is currently optional.
// - 'selection_size' is useful to disable some shortcut routing: e.g. ImGuiMultiSelectFlags_ClearOnEscape won't claim Escape key when selection_size 0,
//    allowing a first press to clear selection THEN the second press to leave child window and return to parent.
// - 'items_count' is stored in ImGuiMultiSelectIO which makes it a convenient way to pass the information to your ApplyRequest() handler (but you may pass it differently).
// - If they are costly for you to compute (e.g. external intrusive selection without maintaining size), you may avoid them and pass -1.
//   - If you can easily tell if your selection is empty or not, you may pass 0/1, or you may enable ImGuiMultiSelectFlags_ClearOnEscape flag dynamically.
ImGuiMultiSelectIO *ImGui::BeginMultiSelect(ImGuiMultiSelectFlags flags, int selection_size, int items_count) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	if (++g.MultiSelectTempDataStacked > g.MultiSelectTempData.Size)
		g.MultiSelectTempData.resize(g.MultiSelectTempDataStacked, ImGuiMultiSelectTempData());
	ImGuiMultiSelectTempData *ms = &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1];
	IM_STATIC_ASSERT(offsetof(ImGuiMultiSelectTempData, IO) == 0); // Clear() relies on that.
	g.CurrentMultiSelect = ms;
	if ((flags & (ImGuiMultiSelectFlags_ScopeWindow | ImGuiMultiSelectFlags_ScopeRect)) == 0)
		flags |= ImGuiMultiSelectFlags_ScopeWindow;
	if (flags & ImGuiMultiSelectFlags_SingleSelect)
		flags &= ~(ImGuiMultiSelectFlags_BoxSelect2d | ImGuiMultiSelectFlags_BoxSelect1d);
	if (flags & ImGuiMultiSelectFlags_BoxSelect2d)
		flags &= ~ImGuiMultiSelectFlags_BoxSelect1d;

	// FIXME: BeginFocusScope()
	const ImGuiID id = window->IDStack.back();
	ms->Clear();
	ms->FocusScopeId = id;
	ms->Flags = flags;
	ms->IsFocused = (ms->FocusScopeId == g.NavFocusScopeId);
	ms->BackupCursorMaxPos = window->DC.CursorMaxPos;
	ms->ScopeRectMin = window->DC.CursorMaxPos = window->DC.CursorPos;
	PushFocusScope(ms->FocusScopeId);
	if (flags & ImGuiMultiSelectFlags_ScopeWindow) // Mark parent child window as navigable into, with highlight. Assume user will always submit interactive items.
		window->DC.NavLayersActiveMask |= 1 << ImGuiNavLayer_Main;

	// Use copy of keyboard mods at the time of the request, otherwise we would requires mods to be held for an extra frame.
	ms->KeyMods = g.NavJustMovedToId ? (g.NavJustMovedToIsTabbing ? 0 : g.NavJustMovedToKeyMods) : g.IO.KeyMods;
	if (flags & ImGuiMultiSelectFlags_NoRangeSelect)
		ms->KeyMods &= ~ImGuiMod_Shift;

	// Bind storage
	ImGuiMultiSelectState *storage = g.MultiSelectStorage.GetOrAddByKey(id);
	storage->ID = id;
	storage->LastFrameActive = g.FrameCount;
	storage->LastSelectionSize = selection_size;
	storage->Window = window;
	ms->Storage = storage;

	// Output to user
	ms->IO.Requests.resize(0);
	ms->IO.RangeSrcItem = storage->RangeSrcItem;
	ms->IO.NavIdItem = storage->NavIdItem;
	ms->IO.NavIdSelected = (storage->NavIdSelected == 1) ? true : false;
	ms->IO.ItemsCount = items_count;

	// Clear when using Navigation to move within the scope
	// (we compare FocusScopeId so it possible to use multiple selections inside a same window)
	bool request_clear = false;
	bool request_select_all = false;
	if (g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == ms->FocusScopeId && g.NavJustMovedToHasSelectionData) {
		if (ms->KeyMods & ImGuiMod_Shift)
			ms->IsKeyboardSetRange = true;
		if (ms->IsKeyboardSetRange)
			IM_ASSERT(storage->RangeSrcItem != ImGuiSelectionUserData_Invalid); // Not ready -> could clear?
		if ((ms->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0 && (flags & (ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_NoAutoSelect)) == 0)
			request_clear = true;
	} else if (g.NavJustMovedFromFocusScopeId == ms->FocusScopeId) {
		// Also clear on leaving scope (may be optional?)
		if ((ms->KeyMods & (ImGuiMod_Ctrl | ImGuiMod_Shift)) == 0 && (flags & (ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_NoAutoSelect)) == 0)
			request_clear = true;
	}

	// Box-select handling: update active state.
	ImGuiBoxSelectState *bs = &g.BoxSelectState;
	if (flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d)) {
		ms->BoxSelectId = GetID("##BoxSelect");
		if (BeginBoxSelect(CalcScopeRect(ms, window), window, ms->BoxSelectId, flags))
			request_clear |= bs->RequestClear;
	}

	if (ms->IsFocused) {
		// Shortcut: Clear selection (Escape)
		// - Only claim shortcut if selection is not empty, allowing further presses on Escape to e.g. leave current child window.
		// - Box select also handle Escape and needs to pass an id to bypass ActiveIdUsingAllKeyboardKeys lock.
		if (flags & ImGuiMultiSelectFlags_ClearOnEscape) {
			if (selection_size != 0 || bs->IsActive)
				if (Shortcut(ImGuiKey_Escape, ImGuiInputFlags_None, bs->IsActive ? bs->ID : 0)) {
					request_clear = true;
					if (bs->IsActive)
						BoxSelectDeactivateDrag(bs);
				}
		}

		// Shortcut: Select all (CTRL+A)
		if (!(flags & ImGuiMultiSelectFlags_SingleSelect) && !(flags & ImGuiMultiSelectFlags_NoSelectAll))
			if (Shortcut(ImGuiMod_Ctrl | ImGuiKey_A))
				request_select_all = true;
	}

	if (request_clear || request_select_all) {
		MultiSelectAddSetAll(ms, request_select_all);
		if (!request_select_all)
			storage->LastSelectionSize = 0;
	}
	ms->LoopRequestSetAll = request_select_all ? 1 : request_clear ? 0
																   : -1;
	ms->LastSubmittedItem = ImGuiSelectionUserData_Invalid;

	if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection)
		DebugLogMultiSelectRequests("BeginMultiSelect", &ms->IO);

	return &ms->IO;
}

// Return updated ImGuiMultiSelectIO structure.
// Lifetime: don't hold on ImGuiMultiSelectIO* pointers over multiple frames or past any subsequent call to BeginMultiSelect() or EndMultiSelect().
ImGuiMultiSelectIO *ImGui::EndMultiSelect() {
	ImGuiContext &g = *GImGui;
	ImGuiMultiSelectTempData *ms = g.CurrentMultiSelect;
	ImGuiMultiSelectState *storage = ms->Storage;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(ms->FocusScopeId == g.CurrentFocusScopeId);
	IM_ASSERT(g.CurrentMultiSelect != NULL && storage->Window == g.CurrentWindow);
	IM_ASSERT(g.MultiSelectTempDataStacked > 0 && &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1] == g.CurrentMultiSelect);

	ImRect scope_rect = CalcScopeRect(ms, window);
	if (ms->IsFocused) {
		// We currently don't allow user code to modify RangeSrcItem by writing to BeginIO's version, but that would be an easy change here.
		if (ms->IO.RangeSrcReset || (ms->RangeSrcPassedBy == false && ms->IO.RangeSrcItem != ImGuiSelectionUserData_Invalid)) // Can't read storage->RangeSrcItem here -> we want the state at begining of the scope (see tests for easy failure)
		{
			IMGUI_DEBUG_LOG_SELECTION("[selection] EndMultiSelect: Reset RangeSrcItem.\n"); // Will set be to NavId.
			storage->RangeSrcItem = ImGuiSelectionUserData_Invalid;
		}
		if (ms->NavIdPassedBy == false && storage->NavIdItem != ImGuiSelectionUserData_Invalid) {
			IMGUI_DEBUG_LOG_SELECTION("[selection] EndMultiSelect: Reset NavIdItem.\n");
			storage->NavIdItem = ImGuiSelectionUserData_Invalid;
			storage->NavIdSelected = -1;
		}

		if ((ms->Flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d)) && GetBoxSelectState(ms->BoxSelectId))
			EndBoxSelect(scope_rect, ms->Flags);
	}

	if (ms->IsEndIO == false)
		ms->IO.Requests.resize(0);

	// Clear selection when clicking void?
	// We specifically test for IsMouseDragPastThreshold(0) == false to allow box-selection!
	// The InnerRect test is necessary for non-child/decorated windows.
	bool scope_hovered = IsWindowHovered() && window->InnerRect.Contains(g.IO.MousePos);
	if (scope_hovered && (ms->Flags & ImGuiMultiSelectFlags_ScopeRect))
		scope_hovered &= scope_rect.Contains(g.IO.MousePos);
	if (scope_hovered && g.HoveredId == 0 && g.ActiveId == 0) {
		if (ms->Flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d)) {
			if (!g.BoxSelectState.IsActive && !g.BoxSelectState.IsStarting && g.IO.MouseClickedCount[0] == 1) {
				BoxSelectPreStartDrag(ms->BoxSelectId, ImGuiSelectionUserData_Invalid);
				FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);
				SetHoveredID(ms->BoxSelectId);
				if (ms->Flags & ImGuiMultiSelectFlags_ScopeRect)
					SetNavID(0, ImGuiNavLayer_Main, ms->FocusScopeId, ImRect(g.IO.MousePos, g.IO.MousePos)); // Automatically switch FocusScope for initial click from void to box-select.
			}
		}

		if (ms->Flags & ImGuiMultiSelectFlags_ClearOnClickVoid)
			if (IsMouseReleased(0) && IsMouseDragPastThreshold(0) == false && g.IO.KeyMods == ImGuiMod_None)
				MultiSelectAddSetAll(ms, false);
	}

	// Courtesy nav wrapping helper flag
	if (ms->Flags & ImGuiMultiSelectFlags_NavWrapX) {
		IM_ASSERT(ms->Flags & ImGuiMultiSelectFlags_ScopeWindow); // Only supported at window scope
		ImGui::NavMoveRequestTryWrapping(ImGui::GetCurrentWindow(), ImGuiNavMoveFlags_WrapX);
	}

	// Unwind
	window->DC.CursorMaxPos = ImMax(ms->BackupCursorMaxPos, window->DC.CursorMaxPos);
	PopFocusScope();

	if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection)
		DebugLogMultiSelectRequests("EndMultiSelect", &ms->IO);

	ms->FocusScopeId = 0;
	ms->Flags = ImGuiMultiSelectFlags_None;
	g.CurrentMultiSelect = (--g.MultiSelectTempDataStacked > 0) ? &g.MultiSelectTempData[g.MultiSelectTempDataStacked - 1] : NULL;

	return &ms->IO;
}

void ImGui::SetNextItemSelectionUserData(ImGuiSelectionUserData selection_user_data) {
	// Note that flags will be cleared by ItemAdd(), so it's only useful for Navigation code!
	// This designed so widgets can also cheaply set this before calling ItemAdd(), so we are not tied to MultiSelect api.
	ImGuiContext &g = *GImGui;
	g.NextItemData.SelectionUserData = selection_user_data;
	g.NextItemData.FocusScopeId = g.CurrentFocusScopeId;

	if (ImGuiMultiSelectTempData *ms = g.CurrentMultiSelect) {
		// Auto updating RangeSrcPassedBy for cases were clipper is not used (done before ItemAdd() clipping)
		g.NextItemData.ItemFlags |= ImGuiItemFlags_HasSelectionUserData | ImGuiItemFlags_IsMultiSelect;
		if (ms->IO.RangeSrcItem == selection_user_data)
			ms->RangeSrcPassedBy = true;
	} else {
		g.NextItemData.ItemFlags |= ImGuiItemFlags_HasSelectionUserData;
	}
}

// In charge of:
// - Applying SetAll for submitted items.
// - Applying SetRange for submitted items and record end points.
// - Altering button behavior flags to facilitate use with drag and drop.
void ImGui::MultiSelectItemHeader(ImGuiID id, bool *p_selected, ImGuiButtonFlags *p_button_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiMultiSelectTempData *ms = g.CurrentMultiSelect;

	bool selected = *p_selected;
	if (ms->IsFocused) {
		ImGuiMultiSelectState *storage = ms->Storage;
		ImGuiSelectionUserData item_data = g.NextItemData.SelectionUserData;
		IM_ASSERT(g.NextItemData.FocusScopeId == g.CurrentFocusScopeId && "Forgot to call SetNextItemSelectionUserData() prior to item, required in BeginMultiSelect()/EndMultiSelect() scope");

		// Apply SetAll (Clear/SelectAll) requests requested by BeginMultiSelect().
		// This is only useful if the user hasn't processed them already, and this only works if the user isn't using the clipper.
		// If you are using a clipper you need to process the SetAll request after calling BeginMultiSelect()
		if (ms->LoopRequestSetAll != -1)
			selected = (ms->LoopRequestSetAll == 1);

		// When using SHIFT+Nav: because it can incur scrolling we cannot afford a frame of lag with the selection highlight (otherwise scrolling would happen before selection)
		// For this to work, we need someone to set 'RangeSrcPassedBy = true' at some point (either clipper either SetNextItemSelectionUserData() function)
		if (ms->IsKeyboardSetRange) {
			IM_ASSERT(id != 0 && (ms->KeyMods & ImGuiMod_Shift) != 0);
			const bool is_range_dst = (ms->RangeDstPassedBy == false) && g.NavJustMovedToId == id; // Assume that g.NavJustMovedToId is not clipped.
			if (is_range_dst)
				ms->RangeDstPassedBy = true;
			if (is_range_dst && storage->RangeSrcItem == ImGuiSelectionUserData_Invalid) // If we don't have RangeSrc, assign RangeSrc = RangeDst
			{
				storage->RangeSrcItem = item_data;
				storage->RangeSelected = selected ? 1 : 0;
			}
			const bool is_range_src = storage->RangeSrcItem == item_data;
			if (is_range_src || is_range_dst || ms->RangeSrcPassedBy != ms->RangeDstPassedBy) {
				// Apply range-select value to visible items
				IM_ASSERT(storage->RangeSrcItem != ImGuiSelectionUserData_Invalid && storage->RangeSelected != -1);
				selected = (storage->RangeSelected != 0);
			} else if ((ms->KeyMods & ImGuiMod_Ctrl) == 0 && (ms->Flags & ImGuiMultiSelectFlags_NoAutoClear) == 0) {
				// Clear other items
				selected = false;
			}
		}
		*p_selected = selected;
	}

	// Alter button behavior flags
	// To handle drag and drop of multiple items we need to avoid clearing selection on click.
	// Enabling this test makes actions using CTRL+SHIFT delay their effect on MouseUp which is annoying, but it allows drag and drop of multiple items.
	if (p_button_flags != NULL) {
		ImGuiButtonFlags button_flags = *p_button_flags;
		button_flags |= ImGuiButtonFlags_NoHoveredOnFocus;
		if ((!selected || (g.ActiveId == id && g.ActiveIdHasBeenPressedBefore)) && !(ms->Flags & ImGuiMultiSelectFlags_SelectOnClickRelease))
			button_flags = (button_flags | ImGuiButtonFlags_PressedOnClick) & ~ImGuiButtonFlags_PressedOnClickRelease;
		else
			button_flags |= ImGuiButtonFlags_PressedOnClickRelease;
		*p_button_flags = button_flags;
	}
}

// In charge of:
// - Auto-select on navigation.
// - Box-select toggle handling.
// - Right-click handling.
// - Altering selection based on Ctrl/Shift modifiers, both for keyboard and mouse.
// - Record current selection state for RangeSrc
// This is all rather complex, best to run and refer to "widgets_multiselect_xxx" tests in imgui_test_suite.
void ImGui::MultiSelectItemFooter(ImGuiID id, bool *p_selected, bool *p_pressed) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	bool selected = *p_selected;
	bool pressed = *p_pressed;
	ImGuiMultiSelectTempData *ms = g.CurrentMultiSelect;
	ImGuiMultiSelectState *storage = ms->Storage;
	if (pressed)
		ms->IsFocused = true;

	bool hovered = false;
	if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect)
		hovered = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);
	if (!ms->IsFocused && !hovered)
		return;

	ImGuiSelectionUserData item_data = g.NextItemData.SelectionUserData;

	ImGuiMultiSelectFlags flags = ms->Flags;
	const bool is_singleselect = (flags & ImGuiMultiSelectFlags_SingleSelect) != 0;
	bool is_ctrl = (ms->KeyMods & ImGuiMod_Ctrl) != 0;
	bool is_shift = (ms->KeyMods & ImGuiMod_Shift) != 0;

	bool apply_to_range_src = false;

	if (g.NavId == id && storage->RangeSrcItem == ImGuiSelectionUserData_Invalid)
		apply_to_range_src = true;
	if (ms->IsEndIO == false) {
		ms->IO.Requests.resize(0);
		ms->IsEndIO = true;
	}

	// Auto-select as you navigate a list
	if (g.NavJustMovedToId == id) {
		if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0) {
			if (is_ctrl && is_shift)
				pressed = true;
			else if (!is_ctrl)
				selected = pressed = true;
		} else {
			// With NoAutoSelect, using Shift+keyboard performs a write/copy
			if (is_shift)
				pressed = true;
			else if (!is_ctrl)
				apply_to_range_src = true; // Since if (pressed) {} main block is not running we update this
		}
	}

	if (apply_to_range_src) {
		storage->RangeSrcItem = item_data;
		storage->RangeSelected = selected; // Will be updated at the end of this function anyway.
	}

	// Box-select toggle handling
	if (ms->BoxSelectId != 0)
		if (ImGuiBoxSelectState *bs = GetBoxSelectState(ms->BoxSelectId)) {
			const bool rect_overlap_curr = bs->BoxSelectRectCurr.Overlaps(g.LastItemData.Rect);
			const bool rect_overlap_prev = bs->BoxSelectRectPrev.Overlaps(g.LastItemData.Rect);
			if ((rect_overlap_curr && !rect_overlap_prev && !selected) || (rect_overlap_prev && !rect_overlap_curr)) {
				if (storage->LastSelectionSize <= 0 && bs->IsStartedSetNavIdOnce) {
					pressed = true; // First item act as a pressed: code below will emit selection request and set NavId (whatever we emit here will be overridden anyway)
					bs->IsStartedSetNavIdOnce = false;
				} else {
					selected = !selected;
					MultiSelectAddSetRange(ms, selected, +1, item_data, item_data);
				}
				storage->LastSelectionSize = ImMax(storage->LastSelectionSize + 1, 1);
			}
		}

	// Right-click handling.
	// FIXME-MULTISELECT: Currently filtered out by ImGuiMultiSelectFlags_NoAutoSelect but maybe should be moved to Selectable(). See https://github.com/ocornut/imgui/pull/5816
	if (hovered && IsMouseClicked(1) && (flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0) {
		if (g.ActiveId != 0 && g.ActiveId != id)
			ClearActiveID();
		SetFocusID(id, window);
		if (!pressed && !selected) {
			pressed = true;
			is_ctrl = is_shift = false;
		}
	}

	// Unlike Space, Enter doesn't alter selection (but can still return a press) unless current item is not selected.
	// The later, "unless current item is not select", may become optional? It seems like a better default if Enter doesn't necessarily open something
	// (unlike e.g. Windows explorer). For use case where Enter always open something, we might decide to make this optional?
	const bool enter_pressed = pressed && (g.NavActivateId == id) && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput);

	// Alter selection
	if (pressed && (!enter_pressed || !selected)) {
		// Box-select
		ImGuiInputSource input_source = (g.NavJustMovedToId == id || g.NavActivateId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;
		if (flags & (ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_BoxSelect2d))
			if (selected == false && !g.BoxSelectState.IsActive && !g.BoxSelectState.IsStarting && input_source == ImGuiInputSource_Mouse && g.IO.MouseClickedCount[0] == 1)
				BoxSelectPreStartDrag(ms->BoxSelectId, item_data);

		//----------------------------------------------------------------------------------------
		// ACTION                      | Begin  | Pressed/Activated  | End
		//----------------------------------------------------------------------------------------
		// Keys Navigated:             | Clear  | Src=item, Sel=1               SetRange 1
		// Keys Navigated: Ctrl        | n/a    | n/a
		// Keys Navigated:      Shift  | n/a    | Dst=item, Sel=1,   => Clear + SetRange 1
		// Keys Navigated: Ctrl+Shift  | n/a    | Dst=item, Sel=Src  => Clear + SetRange Src-Dst
		// Keys Activated:             | n/a    | Src=item, Sel=1    => Clear + SetRange 1
		// Keys Activated: Ctrl        | n/a    | Src=item, Sel=!Sel =>         SetSange 1
		// Keys Activated:      Shift  | n/a    | Dst=item, Sel=1    => Clear + SetSange 1
		//----------------------------------------------------------------------------------------
		// Mouse Pressed:              | n/a    | Src=item, Sel=1,   => Clear + SetRange 1
		// Mouse Pressed:  Ctrl        | n/a    | Src=item, Sel=!Sel =>         SetRange 1
		// Mouse Pressed:       Shift  | n/a    | Dst=item, Sel=1,   => Clear + SetRange 1
		// Mouse Pressed:  Ctrl+Shift  | n/a    | Dst=item, Sel=!Sel =>         SetRange Src-Dst
		//----------------------------------------------------------------------------------------

		if ((flags & ImGuiMultiSelectFlags_NoAutoClear) == 0) {
			bool request_clear = false;
			if (is_singleselect)
				request_clear = true;
			else if ((input_source == ImGuiInputSource_Mouse || g.NavActivateId == id) && !is_ctrl)
				request_clear = (flags & ImGuiMultiSelectFlags_NoAutoClearOnReselect) ? !selected : true;
			else if ((input_source == ImGuiInputSource_Keyboard || input_source == ImGuiInputSource_Gamepad) && is_shift && !is_ctrl)
				request_clear = true; // With is_shift==false the RequestClear was done in BeginIO, not necessary to do again.
			if (request_clear)
				MultiSelectAddSetAll(ms, false);
		}

		int range_direction;
		bool range_selected;
		if (is_shift && !is_singleselect) {
			//IM_ASSERT(storage->HasRangeSrc && storage->HasRangeValue);
			if (storage->RangeSrcItem == ImGuiSelectionUserData_Invalid)
				storage->RangeSrcItem = item_data;
			if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0) {
				// Shift+Arrow always select
				// Ctrl+Shift+Arrow copy source selection state (already stored by BeginMultiSelect() in storage->RangeSelected)
				range_selected = (is_ctrl && storage->RangeSelected != -1) ? (storage->RangeSelected != 0) : true;
			} else {
				// Shift+Arrow copy source selection state
				// Shift+Click always copy from target selection state
				if (ms->IsKeyboardSetRange)
					range_selected = (storage->RangeSelected != -1) ? (storage->RangeSelected != 0) : true;
				else
					range_selected = !selected;
			}
			range_direction = ms->RangeSrcPassedBy ? +1 : -1;
		} else {
			// Ctrl inverts selection, otherwise always select
			if ((flags & ImGuiMultiSelectFlags_NoAutoSelect) == 0)
				selected = is_ctrl ? !selected : true;
			else
				selected = !selected;
			storage->RangeSrcItem = item_data;
			range_selected = selected;
			range_direction = +1;
		}
		MultiSelectAddSetRange(ms, range_selected, range_direction, storage->RangeSrcItem, item_data);
	}

	// Update/store the selection state of the Source item (used by CTRL+SHIFT, when Source is unselected we perform a range unselect)
	if (storage->RangeSrcItem == item_data)
		storage->RangeSelected = selected ? 1 : 0;

	// Update/store the selection state of focused item
	if (g.NavId == id) {
		storage->NavIdItem = item_data;
		storage->NavIdSelected = selected ? 1 : 0;
	}
	if (storage->NavIdItem == item_data)
		ms->NavIdPassedBy = true;
	ms->LastSubmittedItem = item_data;

	*p_selected = selected;
	*p_pressed = pressed;
}

void ImGui::MultiSelectAddSetAll(ImGuiMultiSelectTempData *ms, bool selected) {
	ImGuiSelectionRequest req = { ImGuiSelectionRequestType_SetAll, selected, 0, ImGuiSelectionUserData_Invalid, ImGuiSelectionUserData_Invalid };
	ms->IO.Requests.resize(0); // Can always clear previous requests
	ms->IO.Requests.push_back(req); // Add new request
}

void ImGui::MultiSelectAddSetRange(ImGuiMultiSelectTempData *ms, bool selected, int range_dir, ImGuiSelectionUserData first_item, ImGuiSelectionUserData last_item) {
	// Merge contiguous spans into same request (unless NoRangeSelect is set which guarantees single-item ranges)
	if (ms->IO.Requests.Size > 0 && first_item == last_item && (ms->Flags & ImGuiMultiSelectFlags_NoRangeSelect) == 0) {
		ImGuiSelectionRequest *prev = &ms->IO.Requests.Data[ms->IO.Requests.Size - 1];
		if (prev->Type == ImGuiSelectionRequestType_SetRange && prev->RangeLastItem == ms->LastSubmittedItem && prev->Selected == selected) {
			prev->RangeLastItem = last_item;
			return;
		}
	}

	ImGuiSelectionRequest req = { ImGuiSelectionRequestType_SetRange, selected, (ImS8)range_dir, (range_dir > 0) ? first_item : last_item, (range_dir > 0) ? last_item : first_item };
	ms->IO.Requests.push_back(req); // Add new request
}

void ImGui::DebugNodeMultiSelectState(ImGuiMultiSelectState *storage) {
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	const bool is_active = (storage->LastFrameActive >= GetFrameCount() - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
	if (!is_active) {
		PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled));
	}
	bool open = TreeNode((void *)(intptr_t)storage->ID, "MultiSelect 0x%08X in '%s'%s", storage->ID, storage->Window ? storage->Window->Name : "N/A", is_active ? "" : " *Inactive*");
	if (!is_active) {
		PopStyleColor();
	}
	if (!open)
		return;
	Text("RangeSrcItem = %" IM_PRId64 " (0x%" IM_PRIX64 "), RangeSelected = %d", storage->RangeSrcItem, storage->RangeSrcItem, storage->RangeSelected);
	Text("NavIdItem = %" IM_PRId64 " (0x%" IM_PRIX64 "), NavIdSelected = %d", storage->NavIdItem, storage->NavIdItem, storage->NavIdSelected);
	Text("LastSelectionSize = %d", storage->LastSelectionSize); // Provided by user
	TreePop();
#else
	IM_UNUSED(storage);
#endif
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Multi-Select helpers
//-------------------------------------------------------------------------
// - ImGuiSelectionBasicStorage
// - ImGuiSelectionExternalStorage
//-------------------------------------------------------------------------

ImGuiSelectionBasicStorage::ImGuiSelectionBasicStorage() {
	Size = 0;
	PreserveOrder = false;
	UserData = NULL;
	AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage *, int idx) { return (ImGuiID)idx; };
	_SelectionOrder = 1; // Always >0
}

void ImGuiSelectionBasicStorage::Clear() {
	Size = 0;
	_SelectionOrder = 1; // Always >0
	_Storage.Data.resize(0);
}

void ImGuiSelectionBasicStorage::Swap(ImGuiSelectionBasicStorage &r) {
	ImSwap(Size, r.Size);
	ImSwap(_SelectionOrder, r._SelectionOrder);
	_Storage.Data.swap(r._Storage.Data);
}

bool ImGuiSelectionBasicStorage::Contains(ImGuiID id) const {
	return _Storage.GetInt(id, 0) != 0;
}

static int IMGUI_CDECL PairComparerByValueInt(const void *lhs, const void *rhs) {
	int lhs_v = ((const ImGuiStoragePair *)lhs)->val_i;
	int rhs_v = ((const ImGuiStoragePair *)rhs)->val_i;
	return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1
											   : 0);
}

// GetNextSelectedItem() is an abstraction allowing us to change our underlying actual storage system without impacting user.
// (e.g. store unselected vs compact down, compact down on demand, use raw ImVector<ImGuiID> instead of ImGuiStorage...)
bool ImGuiSelectionBasicStorage::GetNextSelectedItem(void **opaque_it, ImGuiID *out_id) {
	ImGuiStoragePair *it = (ImGuiStoragePair *)*opaque_it;
	ImGuiStoragePair *it_end = _Storage.Data.Data + _Storage.Data.Size;
	if (PreserveOrder && it == NULL && it_end != NULL)
		ImQsort(_Storage.Data.Data, (size_t)_Storage.Data.Size, sizeof(ImGuiStoragePair), PairComparerByValueInt); // ~ImGuiStorage::BuildSortByValueInt()
	if (it == NULL)
		it = _Storage.Data.Data;
	IM_ASSERT(it >= _Storage.Data.Data && it <= it_end);
	if (it != it_end)
		while (it->val_i == 0 && it < it_end)
			it++;
	const bool has_more = (it != it_end);
	*opaque_it = has_more ? (void **)(it + 1) : (void **)(it);
	*out_id = has_more ? it->key : 0;
	if (PreserveOrder && !has_more)
		_Storage.BuildSortByKey();
	return has_more;
}

void ImGuiSelectionBasicStorage::SetItemSelected(ImGuiID id, bool selected) {
	int *p_int = _Storage.GetIntRef(id, 0);
	if (selected && *p_int == 0) {
		*p_int = _SelectionOrder++;
		Size++;
	} else if (!selected && *p_int != 0) {
		*p_int = 0;
		Size--;
	}
}

// Optimized for batch edits (with same value of 'selected')
static void ImGuiSelectionBasicStorage_BatchSetItemSelected(ImGuiSelectionBasicStorage *selection, ImGuiID id, bool selected, int size_before_amends, int selection_order) {
	ImGuiStorage *storage = &selection->_Storage;
	ImGuiStoragePair *it = ImLowerBound(storage->Data.Data, storage->Data.Data + size_before_amends, id);
	const bool is_contained = (it != storage->Data.Data + size_before_amends) && (it->key == id);
	if (selected == (is_contained && it->val_i != 0))
		return;
	if (selected && !is_contained)
		storage->Data.push_back(ImGuiStoragePair(id, selection_order)); // Push unsorted at end of vector, will be sorted in SelectionMultiAmendsFinish()
	else if (is_contained)
		it->val_i = selected ? selection_order : 0; // Modify in-place.
	selection->Size += selected ? +1 : -1;
}

static void ImGuiSelectionBasicStorage_BatchFinish(ImGuiSelectionBasicStorage *selection, bool selected, int size_before_amends) {
	ImGuiStorage *storage = &selection->_Storage;
	if (selected && selection->Size != size_before_amends)
		storage->BuildSortByKey(); // When done selecting: sort everything
}

// Apply requests coming from BeginMultiSelect() and EndMultiSelect().
// - Enable 'Demo->Tools->Debug Log->Selection' to see selection requests as they happen.
// - Honoring SetRange requests requires that you can iterate/interpolate between RangeFirstItem and RangeLastItem.
//   - In this demo we often submit indices to SetNextItemSelectionUserData() + store the same indices in persistent selection.
//   - Your code may do differently. If you store pointers or objects ID in ImGuiSelectionUserData you may need to perform
//     a lookup in order to have some way to iterate/interpolate between two items.
// - A full-featured application is likely to allow search/filtering which is likely to lead to using indices
//   and constructing a view index <> object id/ptr data structure anyway.
// WHEN YOUR APPLICATION SETTLES ON A CHOICE, YOU WILL PROBABLY PREFER TO GET RID OF THIS UNNECESSARY 'ImGuiSelectionBasicStorage' INDIRECTION LOGIC.
// Notice that with the simplest adapter (using indices everywhere), all functions return their parameters.
// The most simple implementation (using indices everywhere) would look like:
//   for (ImGuiSelectionRequest& req : ms_io->Requests)
//   {
//      if (req.Type == ImGuiSelectionRequestType_SetAll)    { Clear(); if (req.Selected) { for (int n = 0; n < items_count; n++) { SetItemSelected(n, true); } }
//      if (req.Type == ImGuiSelectionRequestType_SetRange)  { for (int n = (int)ms_io->RangeFirstItem; n <= (int)ms_io->RangeLastItem; n++) { SetItemSelected(n, ms_io->Selected); } }
//   }
void ImGuiSelectionBasicStorage::ApplyRequests(ImGuiMultiSelectIO *ms_io) {
	// For convenience we obtain ItemsCount as passed to BeginMultiSelect(), which is optional.
	// It makes sense when using ImGuiSelectionBasicStorage to simply pass your items count to BeginMultiSelect().
	// Other scheme may handle SetAll differently.
	IM_ASSERT(ms_io->ItemsCount != -1 && "Missing value for items_count in BeginMultiSelect() call!");
	IM_ASSERT(AdapterIndexToStorageId != NULL);

	// This is optimized/specialized to cope with very large selections (e.g. 100k+ items)
	// - A simpler version could call SetItemSelected() directly instead of ImGuiSelectionBasicStorage_BatchSetItemSelected() + ImGuiSelectionBasicStorage_BatchFinish().
	// - Optimized select can append unsorted, then sort in a second pass. Optimized unselect can clear in-place then compact in a second pass.
	// - A more optimal version wouldn't even use ImGuiStorage but directly a ImVector<ImGuiID> to reduce bandwidth, but this is a reasonable trade off to reuse code.
	// - There are many ways this could be better optimized. The worse case scenario being: using BoxSelect2d in a grid, box-select scrolling down while wiggling
	//   left and right: it affects coarse clipping + can emit multiple SetRange with 1 item each.)
	// FIXME-OPT: For each block of consecutive SetRange request:
	// - add all requests to a sorted list, store ID, selected, offset in ImGuiStorage.
	// - rewrite sorted storage a single time.
	for (ImGuiSelectionRequest &req : ms_io->Requests) {
		if (req.Type == ImGuiSelectionRequestType_SetAll) {
			Clear();
			if (req.Selected) {
				_Storage.Data.reserve(ms_io->ItemsCount);
				const int size_before_amends = _Storage.Data.Size;
				for (int idx = 0; idx < ms_io->ItemsCount; idx++, _SelectionOrder++)
					ImGuiSelectionBasicStorage_BatchSetItemSelected(this, GetStorageIdFromIndex(idx), req.Selected, size_before_amends, _SelectionOrder);
				ImGuiSelectionBasicStorage_BatchFinish(this, req.Selected, size_before_amends);
			}
		} else if (req.Type == ImGuiSelectionRequestType_SetRange) {
			const int selection_changes = (int)req.RangeLastItem - (int)req.RangeFirstItem + 1;
			//ImGuiContext& g = *GImGui; IMGUI_DEBUG_LOG_SELECTION("Req %d/%d: set %d to %d\n", ms_io->Requests.index_from_ptr(&req), ms_io->Requests.Size, selection_changes, req.Selected);
			if (selection_changes == 1 || (selection_changes < Size / 100)) {
				// Multiple sorted insertion + copy likely to be faster.
				// Technically we could do a single copy with a little more work (sort sequential SetRange requests)
				for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++)
					SetItemSelected(GetStorageIdFromIndex(idx), req.Selected);
			} else {
				// Append insertion + single sort likely be faster.
				// Use req.RangeDirection to set order field so that shift+clicking from 1 to 5 is different than shift+clicking from 5 to 1
				const int size_before_amends = _Storage.Data.Size;
				int selection_order = _SelectionOrder + ((req.RangeDirection < 0) ? selection_changes - 1 : 0);
				for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++, selection_order += req.RangeDirection)
					ImGuiSelectionBasicStorage_BatchSetItemSelected(this, GetStorageIdFromIndex(idx), req.Selected, size_before_amends, selection_order);
				if (req.Selected)
					_SelectionOrder += selection_changes;
				ImGuiSelectionBasicStorage_BatchFinish(this, req.Selected, size_before_amends);
			}
		}
	}
}

//-------------------------------------------------------------------------

ImGuiSelectionExternalStorage::ImGuiSelectionExternalStorage() {
	UserData = NULL;
	AdapterSetItemSelected = NULL;
}

// Apply requests coming from BeginMultiSelect() and EndMultiSelect().
// We also pull 'ms_io->ItemsCount' as passed for BeginMultiSelect() for consistency with ImGuiSelectionBasicStorage
// This makes no assumption about underlying storage.
void ImGuiSelectionExternalStorage::ApplyRequests(ImGuiMultiSelectIO *ms_io) {
	IM_ASSERT(AdapterSetItemSelected);
	for (ImGuiSelectionRequest &req : ms_io->Requests) {
		if (req.Type == ImGuiSelectionRequestType_SetAll)
			for (int idx = 0; idx < ms_io->ItemsCount; idx++)
				AdapterSetItemSelected(this, idx, req.Selected);
		if (req.Type == ImGuiSelectionRequestType_SetRange)
			for (int idx = (int)req.RangeFirstItem; idx <= (int)req.RangeLastItem; idx++)
				AdapterSetItemSelected(this, idx, req.Selected);
	}
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ListBox
//-------------------------------------------------------------------------
// - BeginListBox()
// - EndListBox()
// - ListBox()
//-------------------------------------------------------------------------

// This is essentially a thin wrapper to using BeginChild/EndChild with the ImGuiChildFlags_FrameStyle flag for stylistic changes + displaying a label.
// Tip: To have a list filling the entire window width, use size.x = -FLT_MIN and pass an non-visible label e.g. "##empty"
// Tip: If your vertical size is calculated from an item count (e.g. 10 * item_height) consider adding a fractional part to facilitate seeing scrolling boundaries (e.g. 10.25 * item_height).
bool ImGui::BeginListBox(const char *label, const ImVec2 &size_arg) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	const ImGuiStyle &style = g.Style;
	const ImGuiID id = GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	// Size default to hold ~7.25 items.
	// Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
	ImVec2 size = ImTrunc(CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.25f + style.FramePadding.y * 2.0f));
	ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));
	ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
	ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
	g.NextItemData.ClearFlags();

	if (!IsRectVisible(bb.Min, bb.Max)) {
		ItemSize(bb.GetSize(), style.FramePadding.y);
		ItemAdd(bb, 0, &frame_bb);
		g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
		return false;
	}

	// FIXME-OPT: We could omit the BeginGroup() if label_size.x == 0.0f but would need to omit the EndGroup() as well.
	BeginGroup();
	if (label_size.x > 0.0f) {
		ImVec2 label_pos = ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y);
		RenderText(label_pos, label);
		window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, label_pos + label_size);
		AlignTextToFramePadding();
	}

	BeginChild(id, frame_bb.GetSize(), ImGuiChildFlags_FrameStyle);
	return true;
}

void ImGui::EndListBox() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT((window->Flags & ImGuiWindowFlags_ChildWindow) && "Mismatched BeginListBox/EndListBox calls. Did you test the return value of BeginListBox?");
	IM_UNUSED(window);

	EndChild();
	EndGroup(); // This is only required to be able to do IsItemXXX query on the whole ListBox including label
}

bool ImGui::ListBox(const char *label, int *current_item, const char *const items[], int items_count, int height_items) {
	const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void *)items, items_count, height_items);
	return value_changed;
}

// This is merely a helper around BeginListBox(), EndListBox().
// Considering using those directly to submit custom data or store selection differently.
bool ImGui::ListBox(const char *label, int *current_item, const char *(*getter)(void *user_data, int idx), void *user_data, int items_count, int height_in_items) {
	ImGuiContext &g = *GImGui;

	// Calculate size from "height_in_items"
	if (height_in_items < 0)
		height_in_items = ImMin(items_count, 7);
	float height_in_items_f = height_in_items + 0.25f;
	ImVec2 size(0.0f, ImTrunc(GetTextLineHeightWithSpacing() * height_in_items_f + g.Style.FramePadding.y * 2.0f));

	if (!BeginListBox(label, size))
		return false;

	// Assume all items have even height (= 1 line of text). If you need items of different height,
	// you can create a custom version of ListBox() in your code without using the clipper.
	bool value_changed = false;
	ImGuiListClipper clipper;
	clipper.Begin(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
	clipper.IncludeItemByIndex(*current_item);
	while (clipper.Step())
		for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++) {
			const char *item_text = getter(user_data, i);
			if (item_text == NULL)
				item_text = "*Unknown item*";

			PushID(i);
			const bool item_selected = (i == *current_item);
			if (Selectable(item_text, item_selected)) {
				*current_item = i;
				value_changed = true;
			}
			if (item_selected)
				SetItemDefaultFocus();
			PopID();
		}
	EndListBox();

	if (value_changed)
		MarkItemEdited(g.LastItemData.ID);

	return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: PlotLines, PlotHistogram
//-------------------------------------------------------------------------
// - PlotEx() [Internal]
// - PlotLines()
// - PlotHistogram()
//-------------------------------------------------------------------------
// Plot/Graph widgets are not very good.
// Consider writing your own, or using a third-party one, see:
// - ImPlot https://github.com/epezent/implot
// - others https://github.com/ocornut/imgui/wiki/Useful-Extensions
//-------------------------------------------------------------------------

int ImGui::PlotEx(ImGuiPlotType plot_type, const char *label, float (*values_getter)(void *data, int idx), void *data, int values_count, int values_offset, const char *overlay_text, float scale_min, float scale_max, const ImVec2 &size_arg) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return -1;

	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), label_size.y + style.FramePadding.y * 2.0f);

	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
	const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_NoNav))
		return -1;
	bool hovered;
	ButtonBehavior(frame_bb, id, &hovered, NULL);

	// Determine scale from values if not specified
	if (scale_min == FLT_MAX || scale_max == FLT_MAX) {
		float v_min = FLT_MAX;
		float v_max = -FLT_MAX;
		for (int i = 0; i < values_count; i++) {
			const float v = values_getter(data, i);
			if (v != v) // Ignore NaN values
				continue;
			v_min = ImMin(v_min, v);
			v_max = ImMax(v_max, v);
		}
		if (scale_min == FLT_MAX)
			scale_min = v_min;
		if (scale_max == FLT_MAX)
			scale_max = v_max;
	}

	RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	const int values_count_min = (plot_type == ImGuiPlotType_Lines) ? 2 : 1;
	int idx_hovered = -1;
	if (values_count >= values_count_min) {
		int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
		int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

		// Tooltip on hover
		if (hovered && inner_bb.Contains(g.IO.MousePos)) {
			const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);
			const int v_idx = (int)(t * item_count);
			IM_ASSERT(v_idx >= 0 && v_idx < values_count);

			const float v0 = values_getter(data, (v_idx + values_offset) % values_count);
			const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);
			if (plot_type == ImGuiPlotType_Lines)
				SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx + 1, v1);
			else if (plot_type == ImGuiPlotType_Histogram)
				SetTooltip("%d: %8.4g", v_idx, v0);
			idx_hovered = v_idx;
		}

		const float t_step = 1.0f / (float)res_w;
		const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

		float v0 = values_getter(data, (0 + values_offset) % values_count);
		float t0 = 0.0f;
		ImVec2 tp0 = ImVec2(t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale)); // Point in the normalized space of our target rectangle
		float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (1 + scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f); // Where does the zero line stands

		const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);
		const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

		for (int n = 0; n < res_w; n++) {
			const float t1 = t0 + t_step;
			const int v1_idx = (int)(t0 * item_count + 0.5f);
			IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
			const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);
			const ImVec2 tp1 = ImVec2(t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale));

			// NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
			ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);
			ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));
			if (plot_type == ImGuiPlotType_Lines) {
				window->DrawList->AddLine(pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);
			} else if (plot_type == ImGuiPlotType_Histogram) {
				if (pos1.x >= pos0.x + 2.0f)
					pos1.x -= 1.0f;
				window->DrawList->AddRectFilled(pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);
			}

			t0 = t1;
			tp0 = tp1;
		}
	}

	// Text overlay
	if (overlay_text)
		RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f, 0.0f));

	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

	// Return hovered index or -1 if none are hovered.
	// This is currently not exposed in the public API because we need a larger redesign of the whole thing, but in the short-term we are making it available in PlotEx().
	return idx_hovered;
}

struct ImGuiPlotArrayGetterData {
	const float *Values;
	int Stride;

	ImGuiPlotArrayGetterData(const float *values, int stride) {
		Values = values;
		Stride = stride;
	}
};

static float Plot_ArrayGetter(void *data, int idx) {
	ImGuiPlotArrayGetterData *plot_data = (ImGuiPlotArrayGetterData *)data;
	const float v = *(const float *)(const void *)((const unsigned char *)plot_data->Values + (size_t)idx * plot_data->Stride);
	return v;
}

void ImGui::PlotLines(const char *label, const float *values, int values_count, int values_offset, const char *overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride) {
	ImGuiPlotArrayGetterData data(values, stride);
	PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void *)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotLines(const char *label, float (*values_getter)(void *data, int idx), void *data, int values_count, int values_offset, const char *overlay_text, float scale_min, float scale_max, ImVec2 graph_size) {
	PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char *label, const float *values, int values_count, int values_offset, const char *overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride) {
	ImGuiPlotArrayGetterData data(values, stride);
	PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void *)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char *label, float (*values_getter)(void *data, int idx), void *data, int values_count, int values_offset, const char *overlay_text, float scale_min, float scale_max, ImVec2 graph_size) {
	PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Value helpers
// Those is not very useful, legacy API.
//-------------------------------------------------------------------------
// - Value()
//-------------------------------------------------------------------------

void ImGui::Value(const char *prefix, bool b) {
	Text("%s: %s", prefix, (b ? "true" : "false"));
}

void ImGui::Value(const char *prefix, int v) {
	Text("%s: %d", prefix, v);
}

void ImGui::Value(const char *prefix, unsigned int v) {
	Text("%s: %d", prefix, v);
}

void ImGui::Value(const char *prefix, float v, const char *float_format) {
	if (float_format) {
		char fmt[64];
		ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);
		Text(fmt, prefix, v);
	} else {
		Text("%s: %.3f", prefix, v);
	}
}

//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - ImGuiMenuColumns [Internal]
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItemEx() [Internal]
// - MenuItem()
//-------------------------------------------------------------------------

// Helpers for internal use
void ImGuiMenuColumns::Update(float spacing, bool window_reappearing) {
	if (window_reappearing)
		memset(Widths, 0, sizeof(Widths));
	Spacing = (ImU16)spacing;
	CalcNextTotalWidth(true);
	memset(Widths, 0, sizeof(Widths));
	TotalWidth = NextTotalWidth;
	NextTotalWidth = 0;
}

void ImGuiMenuColumns::CalcNextTotalWidth(bool update_offsets) {
	ImU16 offset = 0;
	bool want_spacing = false;
	for (int i = 0; i < IM_ARRAYSIZE(Widths); i++) {
		ImU16 width = Widths[i];
		if (want_spacing && width > 0)
			offset += Spacing;
		want_spacing |= (width > 0);
		if (update_offsets) {
			if (i == 1) {
				OffsetLabel = offset;
			}
			if (i == 2) {
				OffsetShortcut = offset;
			}
			if (i == 3) {
				OffsetMark = offset;
			}
		}
		offset += width;
	}
	NextTotalWidth = offset;
}

float ImGuiMenuColumns::DeclColumns(float w_icon, float w_label, float w_shortcut, float w_mark) {
	Widths[0] = ImMax(Widths[0], (ImU16)w_icon);
	Widths[1] = ImMax(Widths[1], (ImU16)w_label);
	Widths[2] = ImMax(Widths[2], (ImU16)w_shortcut);
	Widths[3] = ImMax(Widths[3], (ImU16)w_mark);
	CalcNextTotalWidth(false);
	return (float)ImMax(TotalWidth, NextTotalWidth);
}

// FIXME: Provided a rectangle perhaps e.g. a BeginMenuBarEx() could be used anywhere..
// Currently the main responsibility of this function being to setup clip-rect + horizontal layout + menu navigation layer.
// Ideally we also want this to be responsible for claiming space out of the main window scrolling rectangle, in which case ImGuiWindowFlags_MenuBar will become unnecessary.
// Then later the same system could be used for multiple menu-bars, scrollbars, side-bars.
bool ImGui::BeginMenuBar() {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;
	if (!(window->Flags & ImGuiWindowFlags_MenuBar))
		return false;

	IM_ASSERT(!window->DC.MenuBarAppending);
	BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a group for that backup/restore
	PushID("##menubar");

	// We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
	// We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
	ImRect bar_rect = window->MenuBarRect();
	ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));
	clip_rect.ClipWith(window->OuterRectClipped);
	PushClipRect(clip_rect.Min, clip_rect.Max, false);

	// We overwrite CursorMaxPos because BeginGroup sets it to CursorPos (essentially the .EmitItem hack in EndMenuBar() would need something analogous here, maybe a BeginGroupEx() with flags).
	window->DC.CursorPos = window->DC.CursorMaxPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);
	window->DC.LayoutType = ImGuiLayoutType_Horizontal;
	window->DC.IsSameLine = false;
	window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
	window->DC.MenuBarAppending = true;
	AlignTextToFramePadding();
	return true;
}

void ImGui::EndMenuBar() {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return;
	ImGuiContext &g = *GImGui;

	// Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
	if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu)) {
		// Try to find out if the request is for one of our child menu
		ImGuiWindow *nav_earliest_child = g.NavWindow;
		while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))
			nav_earliest_child = nav_earliest_child->ParentWindow;
		if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0) {
			// To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
			// This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth bothering)
			const ImGuiNavLayer layer = ImGuiNavLayer_Menu;
			IM_ASSERT(window->DC.NavLayersActiveMaskNext & (1 << layer)); // Sanity check (FIXME: Seems unnecessary)
			FocusWindow(window);
			SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
			g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.
			g.NavDisableMouseHover = g.NavMousePosDirty = true;
			NavMoveRequestForward(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags); // Repeat
		}
	}

	IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
	IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
	IM_ASSERT(window->DC.MenuBarAppending);
	PopClipRect();
	PopID();
	window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->Pos.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.

	// FIXME: Extremely confusing, cleanup by (a) working on WorkRect stack system (b) not using a Group confusingly here.
	ImGuiGroupData &group_data = g.GroupStack.back();
	group_data.EmitItem = false;
	ImVec2 restore_cursor_max_pos = group_data.BackupCursorMaxPos;
	window->DC.IdealMaxPos.x = ImMax(window->DC.IdealMaxPos.x, window->DC.CursorMaxPos.x - window->Scroll.x); // Convert ideal extents for scrolling layer equivalent.
	EndGroup(); // Restore position on layer 0 // FIXME: Misleading to use a group for that backup/restore
	window->DC.LayoutType = ImGuiLayoutType_Vertical;
	window->DC.IsSameLine = false;
	window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
	window->DC.MenuBarAppending = false;
	window->DC.CursorMaxPos = restore_cursor_max_pos;
}

// Important: calling order matters!
// FIXME: Somehow overlapping with docking tech.
// FIXME: The "rect-cut" aspect of this could be formalized into a lower-level helper (rect-cut: https://halt.software/dead-simple-layouts)
bool ImGui::BeginViewportSideBar(const char *name, ImGuiViewport *viewport_p, ImGuiDir dir, float axis_size, ImGuiWindowFlags window_flags) {
	IM_ASSERT(dir != ImGuiDir_None);

	ImGuiWindow *bar_window = FindWindowByName(name);
	if (bar_window == NULL || bar_window->BeginCount == 0) {
		// Calculate and set window size/position
		ImGuiViewportP *viewport = (ImGuiViewportP *)(void *)(viewport_p ? viewport_p : GetMainViewport());
		ImRect avail_rect = viewport->GetBuildWorkRect();
		ImGuiAxis axis = (dir == ImGuiDir_Up || dir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
		ImVec2 pos = avail_rect.Min;
		if (dir == ImGuiDir_Right || dir == ImGuiDir_Down)
			pos[axis] = avail_rect.Max[axis] - axis_size;
		ImVec2 size = avail_rect.GetSize();
		size[axis] = axis_size;
		SetNextWindowPos(pos);
		SetNextWindowSize(size);

		// Report our size into work area (for next frame) using actual window size
		if (dir == ImGuiDir_Up || dir == ImGuiDir_Left)
			viewport->BuildWorkInsetMin[axis] += axis_size;
		else if (dir == ImGuiDir_Down || dir == ImGuiDir_Right)
			viewport->BuildWorkInsetMax[axis] += axis_size;
	}

	window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
	PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
	PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0, 0)); // Lift normal size constraint
	bool is_open = Begin(name, NULL, window_flags);
	PopStyleVar(2);

	return is_open;
}

bool ImGui::BeginMainMenuBar() {
	ImGuiContext &g = *GImGui;
	ImGuiViewportP *viewport = (ImGuiViewportP *)(void *)GetMainViewport();

	// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
	// FIXME: This could be generalized as an opt-in way to clamp window->DC.CursorStartPos to avoid SafeArea?
	// FIXME: Consider removing support for safe area down the line... it's messy. Nowadays consoles have support for TV calibration in OS settings.
	g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));
	ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
	float height = GetFrameHeight();
	bool is_open = BeginViewportSideBar("##MainMenuBar", viewport, ImGuiDir_Up, height, window_flags);
	g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);

	if (is_open)
		BeginMenuBar();
	else
		End();
	return is_open;
}

void ImGui::EndMainMenuBar() {
	EndMenuBar();

	// When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
	// FIXME: With this strategy we won't be able to restore a NULL focus.
	ImGuiContext &g = *GImGui;
	if (g.CurrentWindow == g.NavWindow && g.NavLayer == ImGuiNavLayer_Main && !g.NavAnyRequest)
		FocusTopMostWindowUnderOne(g.NavWindow, NULL, NULL, ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild);

	End();
}

static bool IsRootOfOpenMenuSet() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if ((g.OpenPopupStack.Size <= g.BeginPopupStack.Size) || (window->Flags & ImGuiWindowFlags_ChildMenu))
		return false;

	// Initially we used 'upper_popup->OpenParentId == window->IDStack.back()' to differentiate multiple menu sets from each others
	// (e.g. inside menu bar vs loose menu items) based on parent ID.
	// This would however prevent the use of e.g. PushID() user code submitting menus.
	// Previously this worked between popup and a first child menu because the first child menu always had the _ChildWindow flag,
	// making hovering on parent popup possible while first child menu was focused - but this was generally a bug with other side effects.
	// Instead we don't treat Popup specifically (in order to consistently support menu features in them), maybe the first child menu of a Popup
	// doesn't have the _ChildWindow flag, and we rely on this IsRootOfOpenMenuSet() check to allow hovering between root window/popup and first child menu.
	// In the end, lack of ID check made it so we could no longer differentiate between separate menu sets. To compensate for that, we at least check parent window nav layer.
	// This fixes the most common case of menu opening on hover when moving between window content and menu bar. Multiple different menu sets in same nav layer would still
	// open on hover, but that should be a lesser problem, because if such menus are close in proximity in window content then it won't feel weird and if they are far apart
	// it likely won't be a problem anyone runs into.
	const ImGuiPopupData *upper_popup = &g.OpenPopupStack[g.BeginPopupStack.Size];
	if (window->DC.NavLayerCurrent != upper_popup->ParentNavLayer)
		return false;
	return upper_popup->Window && (upper_popup->Window->Flags & ImGuiWindowFlags_ChildMenu) && ImGui::IsWindowChildOf(upper_popup->Window, window, true);
}

bool ImGui::BeginMenuEx(const char *label, const char *icon, bool enabled) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	const ImGuiID id = window->GetID(label);
	bool menu_is_open = IsPopupOpen(id, ImGuiPopupFlags_None);

	// Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
	// The first menu in a hierarchy isn't so hovering doesn't get across (otherwise e.g. resizing borders with ImGuiButtonFlags_FlattenChildren would react), but top-most BeginMenu() will bypass that limitation.
	ImGuiWindowFlags window_flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;
	if (window->Flags & ImGuiWindowFlags_ChildMenu)
		window_flags |= ImGuiWindowFlags_ChildWindow;

	// If a menu with same the ID was already submitted, we will append to it, matching the behavior of Begin().
	// We are relying on a O(N) search - so O(N log N) over the frame - which seems like the most efficient for the expected small amount of BeginMenu() calls per frame.
	// If somehow this is ever becoming a problem we can switch to use e.g. ImGuiStorage mapping key to last frame used.
	if (g.MenusIdSubmittedThisFrame.contains(id)) {
		if (menu_is_open)
			menu_is_open = BeginPopupEx(id, window_flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
		else
			g.NextWindowData.ClearFlags(); // we behave like Begin() and need to consume those values
		return menu_is_open;
	}

	// Tag menu as used. Next time BeginMenu() with same ID is called it will append to existing menu
	g.MenusIdSubmittedThisFrame.push_back(id);

	ImVec2 label_size = CalcTextSize(label, NULL, true);

	// Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent without always being a Child window)
	// This is only done for items for the menu set and not the full parent window.
	const bool menuset_is_open = IsRootOfOpenMenuSet();
	if (menuset_is_open)
		PushItemFlag(ImGuiItemFlags_NoWindowHoverableCheck, true);

	// The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
	// However the final position is going to be different! It is chosen by FindBestWindowPosForPopup().
	// e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
	ImVec2 popup_pos, pos = window->DC.CursorPos;
	PushID(label);
	if (!enabled)
		BeginDisabled();
	const ImGuiMenuColumns *offsets = &window->DC.MenuColumns;
	bool pressed;

	// We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.
	const ImGuiSelectableFlags selectable_flags = ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlags_SelectOnClick | ImGuiSelectableFlags_NoAutoClosePopups;
	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal) {
		// Menu inside an horizontal menu bar
		// Selectable extend their highlight by half ItemSpacing in each direction.
		// For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
		popup_pos = ImVec2(pos.x - 1.0f - IM_TRUNC(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight);
		window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * 0.5f);
		PushStyleVarX(ImGuiStyleVar_ItemSpacing, style.ItemSpacing.x * 2.0f);
		float w = label_size.x;
		ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
		pressed = Selectable("", menu_is_open, selectable_flags, ImVec2(w, label_size.y));
		RenderText(text_pos, label);
		PopStyleVar();
		window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
	} else {
		// Menu inside a regular/vertical menu
		// (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
		//  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
		popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
		float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
		float checkmark_w = IM_TRUNC(g.FontSize * 1.20f);
		float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, 0.0f, checkmark_w); // Feedback to next frame
		float extra_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);
		ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
		pressed = Selectable("", menu_is_open, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));
		RenderText(text_pos, label);
		if (icon_w > 0.0f)
			RenderText(pos + ImVec2(offsets->OffsetIcon, 0.0f), icon);
		RenderArrow(window->DrawList, pos + ImVec2(offsets->OffsetMark + extra_w + g.FontSize * 0.30f, 0.0f), GetColorU32(ImGuiCol_Text), ImGuiDir_Right);
	}
	if (!enabled)
		EndDisabled();

	const bool hovered = (g.HoveredId == id) && enabled && !g.NavDisableMouseHover;
	if (menuset_is_open)
		PopItemFlag();

	bool want_open = false;
	bool want_open_nav_init = false;
	bool want_close = false;
	if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
	{
		// Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu
		// Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
		bool moving_toward_child_menu = false;
		ImGuiPopupData *child_popup = (g.BeginPopupStack.Size < g.OpenPopupStack.Size) ? &g.OpenPopupStack[g.BeginPopupStack.Size] : NULL; // Popup candidate (testing below)
		ImGuiWindow *child_menu_window = (child_popup && child_popup->Window && child_popup->Window->ParentWindow == window) ? child_popup->Window : NULL;
		if (g.HoveredWindow == window && child_menu_window != NULL) {
			const float ref_unit = g.FontSize; // FIXME-DPI
			const float child_dir = (window->Pos.x < child_menu_window->Pos.x) ? 1.0f : -1.0f;
			const ImRect next_window_rect = child_menu_window->Rect();
			ImVec2 ta = (g.IO.MousePos - g.IO.MouseDelta);
			ImVec2 tb = (child_dir > 0.0f) ? next_window_rect.GetTL() : next_window_rect.GetTR();
			ImVec2 tc = (child_dir > 0.0f) ? next_window_rect.GetBL() : next_window_rect.GetBR();
			const float pad_farmost_h = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, ref_unit * 0.5f, ref_unit * 2.5f); // Add a bit of extra slack.
			ta.x += child_dir * -0.5f;
			tb.x += child_dir * ref_unit;
			tc.x += child_dir * ref_unit;
			tb.y = ta.y + ImMax((tb.y - pad_farmost_h) - ta.y, -ref_unit * 8.0f); // Triangle has maximum height to limit the slope and the bias toward large sub-menus
			tc.y = ta.y + ImMin((tc.y + pad_farmost_h) - ta.y, +ref_unit * 8.0f);
			moving_toward_child_menu = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
			//GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc, moving_toward_child_menu ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG]
		}

		// The 'HovereWindow == window' check creates an inconsistency (e.g. moving away from menu slowly tends to hit same window, whereas moving away fast does not)
		// But we also need to not close the top-menu menu when moving over void. Perhaps we should extend the triangle check to a larger polygon.
		// (Remember to test this on BeginPopup("A")->BeginMenu("B") sequence which behaves slightly differently as B isn't a Child of A and hovering isn't shared.)
		if (menu_is_open && !hovered && g.HoveredWindow == window && !moving_toward_child_menu && !g.NavDisableMouseHover && g.ActiveId == 0)
			want_close = true;

		// Open
		// (note: at this point 'hovered' actually includes the NavDisableMouseHover == false test)
		if (!menu_is_open && pressed) // Click/activate to open
			want_open = true;
		else if (!menu_is_open && hovered && !moving_toward_child_menu) // Hover to open
			want_open = true;
		else if (!menu_is_open && hovered && g.HoveredIdTimer >= 0.30f && g.MouseStationaryTimer >= 0.30f) // Hover to open (timer fallback)
			want_open = true;
		if (g.NavId == id && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open
		{
			want_open = want_open_nav_init = true;
			NavMoveRequestCancel();
			NavRestoreHighlightAfterMove();
		}
	} else {
		// Menu bar
		if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it
		{
			want_close = true;
			want_open = menu_is_open = false;
		} else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others
		{
			want_open = true;
		} else if (g.NavId == id && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open
		{
			want_open = true;
			NavMoveRequestCancel();
		}
	}

	if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
		want_close = true;
	if (want_close && IsPopupOpen(id, ImGuiPopupFlags_None))
		ClosePopupToLevel(g.BeginPopupStack.Size, true);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));
	PopID();

	if (want_open && !menu_is_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size) {
		// Don't reopen/recycle same menu level in the same frame if it is a different menu ID, first close the other menu and yield for a frame.
		OpenPopup(label);
	} else if (want_open) {
		menu_is_open = true;
		OpenPopup(label, ImGuiPopupFlags_NoReopen); // | (want_open_nav_init ? ImGuiPopupFlags_NoReopenAlwaysNavInit : 0));
	}

	if (menu_is_open) {
		ImGuiLastItemData last_item_in_parent = g.LastItemData;
		SetNextWindowPos(popup_pos, ImGuiCond_Always); // Note: misleading: the value will serve as reference for FindBestWindowPosForPopup(), not actual pos.
		PushStyleVar(ImGuiStyleVar_ChildRounding, style.PopupRounding); // First level will use _PopupRounding, subsequent will use _ChildRounding
		menu_is_open = BeginPopupEx(id, window_flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
		PopStyleVar();
		if (menu_is_open) {
			// Implement what ImGuiPopupFlags_NoReopenAlwaysNavInit would do:
			// Perform an init request in the case the popup was already open (via a previous mouse hover)
			if (want_open && want_open_nav_init && !g.NavInitRequest) {
				FocusWindow(g.CurrentWindow, ImGuiFocusRequestFlags_UnlessBelowModal);
				NavInitWindow(g.CurrentWindow, false);
			}

			// Restore LastItemData so IsItemXXXX functions can work after BeginMenu()/EndMenu()
			// (This fixes using IsItemClicked() and IsItemHovered(), but IsItemHovered() also relies on its support for ImGuiItemFlags_NoWindowHoverableCheck)
			g.LastItemData = last_item_in_parent;
			if (g.HoveredWindow == window)
				g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
		}
	} else {
		g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
	}

	return menu_is_open;
}

bool ImGui::BeginMenu(const char *label, bool enabled) {
	return BeginMenuEx(label, NULL, enabled);
}

void ImGui::EndMenu() {
	// Nav: When a left move request our menu failed, close ourselves.
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(window->Flags & ImGuiWindowFlags_Popup); // Mismatched BeginMenu()/EndMenu() calls
	ImGuiWindow *parent_window = window->ParentWindow; // Should always be != NULL is we passed assert.
	if (window->BeginCount == window->BeginCountPreviousFrame)
		if (g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet())
			if (g.NavWindow && (g.NavWindow->RootWindowForNav == window) && parent_window->DC.LayoutType == ImGuiLayoutType_Vertical) {
				ClosePopupToLevel(g.BeginPopupStack.Size - 1, true);
				NavMoveRequestCancel();
			}

	EndPopup();
}

bool ImGui::MenuItemEx(const char *label, const char *icon, const char *shortcut, bool selected, bool enabled) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	ImGuiStyle &style = g.Style;
	ImVec2 pos = window->DC.CursorPos;
	ImVec2 label_size = CalcTextSize(label, NULL, true);

	// See BeginMenuEx() for comments about this.
	const bool menuset_is_open = IsRootOfOpenMenuSet();
	if (menuset_is_open)
		PushItemFlag(ImGuiItemFlags_NoWindowHoverableCheck, true);

	// We've been using the equivalent of ImGuiSelectableFlags_SetNavIdOnHover on all Selectable() since early Nav system days (commit 43ee5d73),
	// but I am unsure whether this should be kept at all. For now moved it to be an opt-in feature used by menus only.
	bool pressed;
	PushID(label);
	if (!enabled)
		BeginDisabled();

	// We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.
	const ImGuiSelectableFlags selectable_flags = ImGuiSelectableFlags_SelectOnRelease | ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlags_SetNavIdOnHover;
	const ImGuiMenuColumns *offsets = &window->DC.MenuColumns;
	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal) {
		// Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
		// Note that in this situation: we don't render the shortcut, we render a highlight instead of the selected tick mark.
		float w = label_size.x;
		window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * 0.5f);
		ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
		PushStyleVarX(ImGuiStyleVar_ItemSpacing, style.ItemSpacing.x * 2.0f);
		pressed = Selectable("", selected, selectable_flags, ImVec2(w, 0.0f));
		PopStyleVar();
		if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible)
			RenderText(text_pos, label);
		window->DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
	} else {
		// Menu item inside a vertical menu
		// (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
		//  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
		float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
		float shortcut_w = (shortcut && shortcut[0]) ? CalcTextSize(shortcut, NULL).x : 0.0f;
		float checkmark_w = IM_TRUNC(g.FontSize * 1.20f);
		float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, shortcut_w, checkmark_w); // Feedback for next frame
		float stretch_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);
		pressed = Selectable("", false, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));
		if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible) {
			RenderText(pos + ImVec2(offsets->OffsetLabel, 0.0f), label);
			if (icon_w > 0.0f)
				RenderText(pos + ImVec2(offsets->OffsetIcon, 0.0f), icon);
			if (shortcut_w > 0.0f) {
				PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]);
				RenderText(pos + ImVec2(offsets->OffsetShortcut + stretch_w, 0.0f), shortcut, NULL, false);
				PopStyleColor();
			}
			if (selected)
				RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);
		}
	}
	IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));
	if (!enabled)
		EndDisabled();
	PopID();
	if (menuset_is_open)
		PopItemFlag();

	return pressed;
}

bool ImGui::MenuItem(const char *label, const char *shortcut, bool selected, bool enabled) {
	return MenuItemEx(label, NULL, shortcut, selected, enabled);
}

bool ImGui::MenuItem(const char *label, const char *shortcut, bool *p_selected, bool enabled) {
	if (MenuItemEx(label, NULL, shortcut, p_selected ? *p_selected : false, enabled)) {
		if (p_selected)
			*p_selected = !*p_selected;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - BeginTabBarEx() [Internal]
// - EndTabBar()
// - TabBarLayout() [Internal]
// - TabBarCalcTabID() [Internal]
// - TabBarCalcMaxTabWidth() [Internal]
// - TabBarFindTabById() [Internal]
// - TabBarFindTabByOrder() [Internal]
// - TabBarGetCurrentTab() [Internal]
// - TabBarGetTabName() [Internal]
// - TabBarRemoveTab() [Internal]
// - TabBarCloseTab() [Internal]
// - TabBarScrollClamp() [Internal]
// - TabBarScrollToTab() [Internal]
// - TabBarQueueFocus() [Internal]
// - TabBarQueueReorder() [Internal]
// - TabBarProcessReorderFromMousePos() [Internal]
// - TabBarProcessReorder() [Internal]
// - TabBarScrollingButtons() [Internal]
// - TabBarTabListPopupButton() [Internal]
//-------------------------------------------------------------------------

struct ImGuiTabBarSection {
	int TabCount; // Number of tabs in this section.
	float Width; // Sum of width of tabs in this section (after shrinking down)
	float Spacing; // Horizontal spacing at the end of the section.

	ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }
};

namespace ImGui {
static void TabBarLayout(ImGuiTabBar *tab_bar);
static ImU32 TabBarCalcTabID(ImGuiTabBar *tab_bar, const char *label, ImGuiWindow *docked_window);
static float TabBarCalcMaxTabWidth();
static float TabBarScrollClamp(ImGuiTabBar *tab_bar, float scrolling);
static void TabBarScrollToTab(ImGuiTabBar *tab_bar, ImGuiID tab_id, ImGuiTabBarSection *sections);
static ImGuiTabItem *TabBarScrollingButtons(ImGuiTabBar *tab_bar);
static ImGuiTabItem *TabBarTabListPopupButton(ImGuiTabBar *tab_bar);
} //namespace ImGui

ImGuiTabBar::ImGuiTabBar() {
	memset(this, 0, sizeof(*this));
	CurrFrameVisible = PrevFrameVisible = -1;
	LastTabItemIdx = -1;
}

static inline int TabItemGetSectionIdx(const ImGuiTabItem *tab) {
	return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2
																									: 1;
}

static int IMGUI_CDECL TabItemComparerBySection(const void *lhs, const void *rhs) {
	const ImGuiTabItem *a = (const ImGuiTabItem *)lhs;
	const ImGuiTabItem *b = (const ImGuiTabItem *)rhs;
	const int a_section = TabItemGetSectionIdx(a);
	const int b_section = TabItemGetSectionIdx(b);
	if (a_section != b_section)
		return a_section - b_section;
	return (int)(a->IndexDuringLayout - b->IndexDuringLayout);
}

static int IMGUI_CDECL TabItemComparerByBeginOrder(const void *lhs, const void *rhs) {
	const ImGuiTabItem *a = (const ImGuiTabItem *)lhs;
	const ImGuiTabItem *b = (const ImGuiTabItem *)rhs;
	return (int)(a->BeginOrder - b->BeginOrder);
}

static ImGuiTabBar *GetTabBarFromTabBarRef(const ImGuiPtrOrIndex &ref) {
	ImGuiContext &g = *GImGui;
	return ref.Ptr ? (ImGuiTabBar *)ref.Ptr : g.TabBars.GetByIndex(ref.Index);
}

static ImGuiPtrOrIndex GetTabBarRefFromTabBar(ImGuiTabBar *tab_bar) {
	ImGuiContext &g = *GImGui;
	if (g.TabBars.Contains(tab_bar))
		return ImGuiPtrOrIndex(g.TabBars.GetIndex(tab_bar));
	return ImGuiPtrOrIndex(tab_bar);
}

bool ImGui::BeginTabBar(const char *str_id, ImGuiTabBarFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return false;

	ImGuiID id = window->GetID(str_id);
	ImGuiTabBar *tab_bar = g.TabBars.GetOrAddByKey(id);
	ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->WorkRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);
	tab_bar->ID = id;
	tab_bar->SeparatorMinX = tab_bar->BarRect.Min.x - IM_TRUNC(window->WindowPadding.x * 0.5f);
	tab_bar->SeparatorMaxX = tab_bar->BarRect.Max.x + IM_TRUNC(window->WindowPadding.x * 0.5f);
	//if (g.NavWindow && IsWindowChildOf(g.NavWindow, window, false, false))
	flags |= ImGuiTabBarFlags_IsFocused;
	return BeginTabBarEx(tab_bar, tab_bar_bb, flags);
}

bool ImGui::BeginTabBarEx(ImGuiTabBar *tab_bar, const ImRect &tab_bar_bb, ImGuiTabBarFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return false;

	IM_ASSERT(tab_bar->ID != 0);
	if ((flags & ImGuiTabBarFlags_DockNode) == 0)
		PushOverrideID(tab_bar->ID);

	// Add to stack
	g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));
	g.CurrentTabBar = tab_bar;

	// Append with multiple BeginTabBar()/EndTabBar() pairs.
	tab_bar->BackupCursorPos = window->DC.CursorPos;
	if (tab_bar->CurrFrameVisible == g.FrameCount) {
		window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);
		tab_bar->BeginCount++;
		return true;
	}

	// Ensure correct ordering when toggling ImGuiTabBarFlags_Reorderable flag, or when a new tab was added while being not reorderable
	if ((flags & ImGuiTabBarFlags_Reorderable) != (tab_bar->Flags & ImGuiTabBarFlags_Reorderable) || (tab_bar->TabsAddedNew && !(flags & ImGuiTabBarFlags_Reorderable)))
		ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByBeginOrder);
	tab_bar->TabsAddedNew = false;

	// Flags
	if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
		flags |= ImGuiTabBarFlags_FittingPolicyDefault_;

	tab_bar->Flags = flags;
	tab_bar->BarRect = tab_bar_bb;
	tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()
	tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;
	tab_bar->CurrFrameVisible = g.FrameCount;
	tab_bar->PrevTabsContentsHeight = tab_bar->CurrTabsContentsHeight;
	tab_bar->CurrTabsContentsHeight = 0.0f;
	tab_bar->ItemSpacingY = g.Style.ItemSpacing.y;
	tab_bar->FramePadding = g.Style.FramePadding;
	tab_bar->TabsActiveCount = 0;
	tab_bar->LastTabItemIdx = -1;
	tab_bar->BeginCount = 1;

	// Set cursor pos in a way which only be used in the off-chance the user erroneously submits item before BeginTabItem(): items will overlap
	window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);

	// Draw separator
	// (it would be misleading to draw this in EndTabBar() suggesting that it may be drawn over tabs, as tab bar are appendable)
	const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabSelected : ImGuiCol_TabDimmedSelected);
	if (g.Style.TabBarBorderSize > 0.0f) {
		const float y = tab_bar->BarRect.Max.y;
		window->DrawList->AddRectFilled(ImVec2(tab_bar->SeparatorMinX, y - g.Style.TabBarBorderSize), ImVec2(tab_bar->SeparatorMaxX, y), col);
	}
	return true;
}

void ImGui::EndTabBar() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return;

	ImGuiTabBar *tab_bar = g.CurrentTabBar;
	if (tab_bar == NULL) {
		IM_ASSERT_USER_ERROR(tab_bar != NULL, "Mismatched BeginTabBar()/EndTabBar()!");
		return;
	}

	// Fallback in case no TabItem have been submitted
	if (tab_bar->WantLayout)
		TabBarLayout(tab_bar);

	// Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
	const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
	if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing) {
		tab_bar->CurrTabsContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, tab_bar->CurrTabsContentsHeight);
		window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->CurrTabsContentsHeight;
	} else {
		window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->PrevTabsContentsHeight;
	}
	if (tab_bar->BeginCount > 1)
		window->DC.CursorPos = tab_bar->BackupCursorPos;

	tab_bar->LastTabItemIdx = -1;
	if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)
		PopID();

	g.CurrentTabBarStack.pop_back();
	g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());
}

// Scrolling happens only in the central section (leading/trailing sections are not scrolling)
static float TabBarCalcScrollableWidth(ImGuiTabBar *tab_bar, ImGuiTabBarSection *sections) {
	return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;
}

// This is called only once a frame before by the first call to ItemTab()
// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.
static void ImGui::TabBarLayout(ImGuiTabBar *tab_bar) {
	ImGuiContext &g = *GImGui;
	tab_bar->WantLayout = false;

	// Garbage collect by compacting list
	// Detect if we need to sort out tab list (e.g. in rare case where a tab changed section)
	int tab_dst_n = 0;
	bool need_sort_by_section = false;
	ImGuiTabBarSection sections[3]; // Layout sections: Leading, Central, Trailing
	for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++) {
		ImGuiTabItem *tab = &tab_bar->Tabs[tab_src_n];
		if (tab->LastFrameVisible < tab_bar->PrevFrameVisible || tab->WantClose) {
			// Remove tab
			if (tab_bar->VisibleTabId == tab->ID) {
				tab_bar->VisibleTabId = 0;
			}
			if (tab_bar->SelectedTabId == tab->ID) {
				tab_bar->SelectedTabId = 0;
			}
			if (tab_bar->NextSelectedTabId == tab->ID) {
				tab_bar->NextSelectedTabId = 0;
			}
			continue;
		}
		if (tab_dst_n != tab_src_n)
			tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];

		tab = &tab_bar->Tabs[tab_dst_n];
		tab->IndexDuringLayout = (ImS16)tab_dst_n;

		// We will need sorting if tabs have changed section (e.g. moved from one of Leading/Central/Trailing to another)
		int curr_tab_section_n = TabItemGetSectionIdx(tab);
		if (tab_dst_n > 0) {
			ImGuiTabItem *prev_tab = &tab_bar->Tabs[tab_dst_n - 1];
			int prev_tab_section_n = TabItemGetSectionIdx(prev_tab);
			if (curr_tab_section_n == 0 && prev_tab_section_n != 0)
				need_sort_by_section = true;
			if (prev_tab_section_n == 2 && curr_tab_section_n != 2)
				need_sort_by_section = true;
		}

		sections[curr_tab_section_n].TabCount++;
		tab_dst_n++;
	}
	if (tab_bar->Tabs.Size != tab_dst_n)
		tab_bar->Tabs.resize(tab_dst_n);

	if (need_sort_by_section)
		ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerBySection);

	// Calculate spacing between sections
	sections[0].Spacing = sections[0].TabCount > 0 && (sections[1].TabCount + sections[2].TabCount) > 0 ? g.Style.ItemInnerSpacing.x : 0.0f;
	sections[1].Spacing = sections[1].TabCount > 0 && sections[2].TabCount > 0 ? g.Style.ItemInnerSpacing.x : 0.0f;

	// Setup next selected tab
	ImGuiID scroll_to_tab_id = 0;
	if (tab_bar->NextSelectedTabId) {
		tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;
		tab_bar->NextSelectedTabId = 0;
		scroll_to_tab_id = tab_bar->SelectedTabId;
	}

	// Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
	if (tab_bar->ReorderRequestTabId != 0) {
		if (TabBarProcessReorder(tab_bar))
			if (tab_bar->ReorderRequestTabId == tab_bar->SelectedTabId)
				scroll_to_tab_id = tab_bar->ReorderRequestTabId;
		tab_bar->ReorderRequestTabId = 0;
	}

	// Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
	const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;
	if (tab_list_popup_button)
		if (ImGuiTabItem *tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Min.x!
			scroll_to_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

	// Leading/Trailing tabs will be shrink only if central one aren't visible anymore, so layout the shrink data as: leading, trailing, central
	// (whereas our tabs are stored as: leading, central, trailing)
	int shrink_buffer_indexes[3] = { 0, sections[0].TabCount + sections[2].TabCount, sections[0].TabCount };
	g.ShrinkWidthBuffer.resize(tab_bar->Tabs.Size);

	// Compute ideal tabs widths + store them into shrink buffer
	ImGuiTabItem *most_recently_selected_tab = NULL;
	int curr_section_n = -1;
	bool found_selected_tab_id = false;
	for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++) {
		ImGuiTabItem *tab = &tab_bar->Tabs[tab_n];
		IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);

		if ((most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected) && !(tab->Flags & ImGuiTabItemFlags_Button))
			most_recently_selected_tab = tab;
		if (tab->ID == tab_bar->SelectedTabId)
			found_selected_tab_id = true;
		if (scroll_to_tab_id == 0 && g.NavJustMovedToId == tab->ID)
			scroll_to_tab_id = tab->ID;

		// Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
		// Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
		// and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
		const char *tab_name = TabBarGetTabName(tab_bar, tab);
		const bool has_close_button_or_unsaved_marker = (tab->Flags & ImGuiTabItemFlags_NoCloseButton) == 0 || (tab->Flags & ImGuiTabItemFlags_UnsavedDocument);
		tab->ContentWidth = (tab->RequestedWidth >= 0.0f) ? tab->RequestedWidth : TabItemCalcSize(tab_name, has_close_button_or_unsaved_marker).x;

		int section_n = TabItemGetSectionIdx(tab);
		ImGuiTabBarSection *section = &sections[section_n];
		section->Width += tab->ContentWidth + (section_n == curr_section_n ? g.Style.ItemInnerSpacing.x : 0.0f);
		curr_section_n = section_n;

		// Store data so we can build an array sorted by width if we need to shrink tabs down
		IM_MSVC_WARNING_SUPPRESS(6385);
		ImGuiShrinkWidthItem *shrink_width_item = &g.ShrinkWidthBuffer[shrink_buffer_indexes[section_n]++];
		shrink_width_item->Index = tab_n;
		shrink_width_item->Width = shrink_width_item->InitialWidth = tab->ContentWidth;
		tab->Width = ImMax(tab->ContentWidth, 1.0f);
	}

	// Compute total ideal width (used for e.g. auto-resizing a window)
	tab_bar->WidthAllTabsIdeal = 0.0f;
	for (int section_n = 0; section_n < 3; section_n++)
		tab_bar->WidthAllTabsIdeal += sections[section_n].Width + sections[section_n].Spacing;

	// Horizontal scrolling buttons
	// (note that TabBarScrollButtons() will alter BarRect.Max.x)
	if ((tab_bar->WidthAllTabsIdeal > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll))
		if (ImGuiTabItem *scroll_and_select_tab = TabBarScrollingButtons(tab_bar)) {
			scroll_to_tab_id = scroll_and_select_tab->ID;
			if ((scroll_and_select_tab->Flags & ImGuiTabItemFlags_Button) == 0)
				tab_bar->SelectedTabId = scroll_to_tab_id;
		}

	// Shrink widths if full tabs don't fit in their allocated space
	float section_0_w = sections[0].Width + sections[0].Spacing;
	float section_1_w = sections[1].Width + sections[1].Spacing;
	float section_2_w = sections[2].Width + sections[2].Spacing;
	bool central_section_is_visible = (section_0_w + section_2_w) < tab_bar->BarRect.GetWidth();
	float width_excess;
	if (central_section_is_visible)
		width_excess = ImMax(section_1_w - (tab_bar->BarRect.GetWidth() - section_0_w - section_2_w), 0.0f); // Excess used to shrink central section
	else
		width_excess = (section_0_w + section_2_w) - tab_bar->BarRect.GetWidth(); // Excess used to shrink leading/trailing section

	// With ImGuiTabBarFlags_FittingPolicyScroll policy, we will only shrink leading/trailing if the central section is not visible anymore
	if (width_excess >= 1.0f && ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown) || !central_section_is_visible)) {
		int shrink_data_count = (central_section_is_visible ? sections[1].TabCount : sections[0].TabCount + sections[2].TabCount);
		int shrink_data_offset = (central_section_is_visible ? sections[0].TabCount + sections[2].TabCount : 0);
		ShrinkWidths(g.ShrinkWidthBuffer.Data + shrink_data_offset, shrink_data_count, width_excess);

		// Apply shrunk values into tabs and sections
		for (int tab_n = shrink_data_offset; tab_n < shrink_data_offset + shrink_data_count; tab_n++) {
			ImGuiTabItem *tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];
			float shrinked_width = IM_TRUNC(g.ShrinkWidthBuffer[tab_n].Width);
			if (shrinked_width < 0.0f)
				continue;

			shrinked_width = ImMax(1.0f, shrinked_width);
			int section_n = TabItemGetSectionIdx(tab);
			sections[section_n].Width -= (tab->Width - shrinked_width);
			tab->Width = shrinked_width;
		}
	}

	// Layout all active tabs
	int section_tab_index = 0;
	float tab_offset = 0.0f;
	tab_bar->WidthAllTabs = 0.0f;
	for (int section_n = 0; section_n < 3; section_n++) {
		ImGuiTabBarSection *section = &sections[section_n];
		if (section_n == 2)
			tab_offset = ImMin(ImMax(0.0f, tab_bar->BarRect.GetWidth() - section->Width), tab_offset);

		for (int tab_n = 0; tab_n < section->TabCount; tab_n++) {
			ImGuiTabItem *tab = &tab_bar->Tabs[section_tab_index + tab_n];
			tab->Offset = tab_offset;
			tab->NameOffset = -1;
			tab_offset += tab->Width + (tab_n < section->TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0f);
		}
		tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);
		tab_offset += section->Spacing;
		section_tab_index += section->TabCount;
	}

	// Clear name buffers
	tab_bar->TabsNames.Buf.resize(0);

	// If we have lost the selected tab, select the next most recently active one
	if (found_selected_tab_id == false)
		tab_bar->SelectedTabId = 0;
	if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)
		scroll_to_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

	// Lock in visible tab
	tab_bar->VisibleTabId = tab_bar->SelectedTabId;
	tab_bar->VisibleTabWasSubmitted = false;

	// Apply request requests
	if (scroll_to_tab_id != 0)
		TabBarScrollToTab(tab_bar, scroll_to_tab_id, sections);
	else if ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll) && IsMouseHoveringRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, true) && IsWindowContentHoverable(g.CurrentWindow)) {
		const float wheel = g.IO.MouseWheelRequestAxisSwap ? g.IO.MouseWheel : g.IO.MouseWheelH;
		const ImGuiKey wheel_key = g.IO.MouseWheelRequestAxisSwap ? ImGuiKey_MouseWheelY : ImGuiKey_MouseWheelX;
		if (TestKeyOwner(wheel_key, tab_bar->ID) && wheel != 0.0f) {
			const float scroll_step = wheel * TabBarCalcScrollableWidth(tab_bar, sections) / 3.0f;
			tab_bar->ScrollingTargetDistToVisibility = 0.0f;
			tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget - scroll_step);
		}
		SetKeyOwner(wheel_key, tab_bar->ID);
	}

	// Update scrolling
	tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);
	tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);
	if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget) {
		// Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.
		// Teleport if we are aiming far off the visible line
		tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, 70.0f * g.FontSize);
		tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);
		const bool teleport = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) || (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);
		tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed);
	} else {
		tab_bar->ScrollingSpeed = 0.0f;
	}
	tab_bar->ScrollingRectMinX = tab_bar->BarRect.Min.x + sections[0].Width + sections[0].Spacing;
	tab_bar->ScrollingRectMaxX = tab_bar->BarRect.Max.x - sections[2].Width - sections[1].Spacing;

	// Actual layout in host window (we don't do it in BeginTabBar() so as not to waste an extra frame)
	ImGuiWindow *window = g.CurrentWindow;
	window->DC.CursorPos = tab_bar->BarRect.Min;
	ItemSize(ImVec2(tab_bar->WidthAllTabs, tab_bar->BarRect.GetHeight()), tab_bar->FramePadding.y);
	window->DC.IdealMaxPos.x = ImMax(window->DC.IdealMaxPos.x, tab_bar->BarRect.Min.x + tab_bar->WidthAllTabsIdeal);
}

// Dockable windows uses Name/ID in the global namespace. Non-dockable items use the ID stack.
static ImU32 ImGui::TabBarCalcTabID(ImGuiTabBar *tab_bar, const char *label, ImGuiWindow *docked_window) {
	IM_ASSERT(docked_window == NULL); // master branch only
	IM_UNUSED(docked_window);
	if (tab_bar->Flags & ImGuiTabBarFlags_DockNode) {
		ImGuiID id = ImHashStr(label);
		KeepAliveID(id);
		return id;
	} else {
		ImGuiWindow *window = GImGui->CurrentWindow;
		return window->GetID(label);
	}
}

static float ImGui::TabBarCalcMaxTabWidth() {
	ImGuiContext &g = *GImGui;
	return g.FontSize * 20.0f;
}

ImGuiTabItem *ImGui::TabBarFindTabByID(ImGuiTabBar *tab_bar, ImGuiID tab_id) {
	if (tab_id != 0)
		for (int n = 0; n < tab_bar->Tabs.Size; n++)
			if (tab_bar->Tabs[n].ID == tab_id)
				return &tab_bar->Tabs[n];
	return NULL;
}

// Order = visible order, not submission order! (which is tab->BeginOrder)
ImGuiTabItem *ImGui::TabBarFindTabByOrder(ImGuiTabBar *tab_bar, int order) {
	if (order < 0 || order >= tab_bar->Tabs.Size)
		return NULL;
	return &tab_bar->Tabs[order];
}

ImGuiTabItem *ImGui::TabBarGetCurrentTab(ImGuiTabBar *tab_bar) {
	if (tab_bar->LastTabItemIdx < 0 || tab_bar->LastTabItemIdx >= tab_bar->Tabs.Size)
		return NULL;
	return &tab_bar->Tabs[tab_bar->LastTabItemIdx];
}

const char *ImGui::TabBarGetTabName(ImGuiTabBar *tab_bar, ImGuiTabItem *tab) {
	if (tab->NameOffset == -1)
		return "N/A";
	IM_ASSERT(tab->NameOffset < tab_bar->TabsNames.Buf.Size);
	return tab_bar->TabsNames.Buf.Data + tab->NameOffset;
}

// The *TabId fields are already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.
void ImGui::TabBarRemoveTab(ImGuiTabBar *tab_bar, ImGuiID tab_id) {
	if (ImGuiTabItem *tab = TabBarFindTabByID(tab_bar, tab_id))
		tab_bar->Tabs.erase(tab);
	if (tab_bar->VisibleTabId == tab_id) {
		tab_bar->VisibleTabId = 0;
	}
	if (tab_bar->SelectedTabId == tab_id) {
		tab_bar->SelectedTabId = 0;
	}
	if (tab_bar->NextSelectedTabId == tab_id) {
		tab_bar->NextSelectedTabId = 0;
	}
}

// Called on manual closure attempt
void ImGui::TabBarCloseTab(ImGuiTabBar *tab_bar, ImGuiTabItem *tab) {
	if (tab->Flags & ImGuiTabItemFlags_Button)
		return; // A button appended with TabItemButton().

	if ((tab->Flags & (ImGuiTabItemFlags_UnsavedDocument | ImGuiTabItemFlags_NoAssumedClosure)) == 0) {
		// This will remove a frame of lag for selecting another tab on closure.
		// However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
		tab->WantClose = true;
		if (tab_bar->VisibleTabId == tab->ID) {
			tab->LastFrameVisible = -1;
			tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;
		}
	} else {
		// Actually select before expecting closure attempt (on an UnsavedDocument tab user is expect to e.g. show a popup)
		if (tab_bar->VisibleTabId != tab->ID)
			TabBarQueueFocus(tab_bar, tab);
	}
}

static float ImGui::TabBarScrollClamp(ImGuiTabBar *tab_bar, float scrolling) {
	scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());
	return ImMax(scrolling, 0.0f);
}

// Note: we may scroll to tab that are not selected! e.g. using keyboard arrow keys
static void ImGui::TabBarScrollToTab(ImGuiTabBar *tab_bar, ImGuiID tab_id, ImGuiTabBarSection *sections) {
	ImGuiTabItem *tab = TabBarFindTabByID(tab_bar, tab_id);
	if (tab == NULL)
		return;
	if (tab->Flags & ImGuiTabItemFlags_SectionMask_)
		return;

	ImGuiContext &g = *GImGui;
	float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)
	int order = TabBarGetTabOrder(tab_bar, tab);

	// Scrolling happens only in the central section (leading/trailing sections are not scrolling)
	float scrollable_width = TabBarCalcScrollableWidth(tab_bar, sections);

	// We make all tabs positions all relative Sections[0].Width to make code simpler
	float tab_x1 = tab->Offset - sections[0].Width + (order > sections[0].TabCount - 1 ? -margin : 0.0f);
	float tab_x2 = tab->Offset - sections[0].Width + tab->Width + (order + 1 < tab_bar->Tabs.Size - sections[2].TabCount ? margin : 1.0f);
	tab_bar->ScrollingTargetDistToVisibility = 0.0f;
	if (tab_bar->ScrollingTarget > tab_x1 || (tab_x2 - tab_x1 >= scrollable_width)) {
		// Scroll to the left
		tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);
		tab_bar->ScrollingTarget = tab_x1;
	} else if (tab_bar->ScrollingTarget < tab_x2 - scrollable_width) {
		// Scroll to the right
		tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar->ScrollingAnim, 0.0f);
		tab_bar->ScrollingTarget = tab_x2 - scrollable_width;
	}
}

void ImGui::TabBarQueueFocus(ImGuiTabBar *tab_bar, ImGuiTabItem *tab) {
	tab_bar->NextSelectedTabId = tab->ID;
}

void ImGui::TabBarQueueReorder(ImGuiTabBar *tab_bar, ImGuiTabItem *tab, int offset) {
	IM_ASSERT(offset != 0);
	IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
	tab_bar->ReorderRequestTabId = tab->ID;
	tab_bar->ReorderRequestOffset = (ImS16)offset;
}

void ImGui::TabBarQueueReorderFromMousePos(ImGuiTabBar *tab_bar, ImGuiTabItem *src_tab, ImVec2 mouse_pos) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
	if ((tab_bar->Flags & ImGuiTabBarFlags_Reorderable) == 0)
		return;

	const bool is_central_section = (src_tab->Flags & ImGuiTabItemFlags_SectionMask_) == 0;
	const float bar_offset = tab_bar->BarRect.Min.x - (is_central_section ? tab_bar->ScrollingTarget : 0);

	// Count number of contiguous tabs we are crossing over
	const int dir = (bar_offset + src_tab->Offset) > mouse_pos.x ? -1 : +1;
	const int src_idx = tab_bar->Tabs.index_from_ptr(src_tab);
	int dst_idx = src_idx;
	for (int i = src_idx; i >= 0 && i < tab_bar->Tabs.Size; i += dir) {
		// Reordered tabs must share the same section
		const ImGuiTabItem *dst_tab = &tab_bar->Tabs[i];
		if (dst_tab->Flags & ImGuiTabItemFlags_NoReorder)
			break;
		if ((dst_tab->Flags & ImGuiTabItemFlags_SectionMask_) != (src_tab->Flags & ImGuiTabItemFlags_SectionMask_))
			break;
		dst_idx = i;

		// Include spacing after tab, so when mouse cursor is between tabs we would not continue checking further tabs that are not hovered.
		const float x1 = bar_offset + dst_tab->Offset - g.Style.ItemInnerSpacing.x;
		const float x2 = bar_offset + dst_tab->Offset + dst_tab->Width + g.Style.ItemInnerSpacing.x;
		//GetForegroundDrawList()->AddRect(ImVec2(x1, tab_bar->BarRect.Min.y), ImVec2(x2, tab_bar->BarRect.Max.y), IM_COL32(255, 0, 0, 255));
		if ((dir < 0 && mouse_pos.x > x1) || (dir > 0 && mouse_pos.x < x2))
			break;
	}

	if (dst_idx != src_idx)
		TabBarQueueReorder(tab_bar, src_tab, dst_idx - src_idx);
}

bool ImGui::TabBarProcessReorder(ImGuiTabBar *tab_bar) {
	ImGuiTabItem *tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId);
	if (tab1 == NULL || (tab1->Flags & ImGuiTabItemFlags_NoReorder))
		return false;

	//IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
	int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;
	if (tab2_order < 0 || tab2_order >= tab_bar->Tabs.Size)
		return false;

	// Reordered tabs must share the same section
	// (Note: TabBarQueueReorderFromMousePos() also has a similar test but since we allow direct calls to TabBarQueueReorder() we do it here too)
	ImGuiTabItem *tab2 = &tab_bar->Tabs[tab2_order];
	if (tab2->Flags & ImGuiTabItemFlags_NoReorder)
		return false;
	if ((tab1->Flags & ImGuiTabItemFlags_SectionMask_) != (tab2->Flags & ImGuiTabItemFlags_SectionMask_))
		return false;

	ImGuiTabItem item_tmp = *tab1;
	ImGuiTabItem *src_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 + 1 : tab2;
	ImGuiTabItem *dst_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 : tab2 + 1;
	const int move_count = (tab_bar->ReorderRequestOffset > 0) ? tab_bar->ReorderRequestOffset : -tab_bar->ReorderRequestOffset;
	memmove(dst_tab, src_tab, move_count * sizeof(ImGuiTabItem));
	*tab2 = item_tmp;

	if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)
		MarkIniSettingsDirty();
	return true;
}

static ImGuiTabItem *ImGui::TabBarScrollingButtons(ImGuiTabBar *tab_bar) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);
	const float scrolling_buttons_width = arrow_button_size.x * 2.0f;

	const ImVec2 backup_cursor_pos = window->DC.CursorPos;
	//window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));

	int select_dir = 0;
	ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
	arrow_col.w *= 0.5f;

	PushStyleColor(ImGuiCol_Text, arrow_col);
	PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
	const float backup_repeat_delay = g.IO.KeyRepeatDelay;
	const float backup_repeat_rate = g.IO.KeyRepeatRate;
	g.IO.KeyRepeatDelay = 0.250f;
	g.IO.KeyRepeatRate = 0.200f;
	float x = ImMax(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.x - scrolling_buttons_width);
	window->DC.CursorPos = ImVec2(x, tab_bar->BarRect.Min.y);
	if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
		select_dir = -1;
	window->DC.CursorPos = ImVec2(x + arrow_button_size.x, tab_bar->BarRect.Min.y);
	if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
		select_dir = +1;
	PopStyleColor(2);
	g.IO.KeyRepeatRate = backup_repeat_rate;
	g.IO.KeyRepeatDelay = backup_repeat_delay;

	ImGuiTabItem *tab_to_scroll_to = NULL;
	if (select_dir != 0)
		if (ImGuiTabItem *tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId)) {
			int selected_order = TabBarGetTabOrder(tab_bar, tab_item);
			int target_order = selected_order + select_dir;

			// Skip tab item buttons until another tab item is found or end is reached
			while (tab_to_scroll_to == NULL) {
				// If we are at the end of the list, still scroll to make our tab visible
				tab_to_scroll_to = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order];

				// Cross through buttons
				// (even if first/last item is a button, return it so we can update the scroll)
				if (tab_to_scroll_to->Flags & ImGuiTabItemFlags_Button) {
					target_order += select_dir;
					selected_order += select_dir;
					tab_to_scroll_to = (target_order < 0 || target_order >= tab_bar->Tabs.Size) ? tab_to_scroll_to : NULL;
				}
			}
		}
	window->DC.CursorPos = backup_cursor_pos;
	tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

	return tab_to_scroll_to;
}

static ImGuiTabItem *ImGui::TabBarTabListPopupButton(ImGuiTabBar *tab_bar) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	// We use g.Style.FramePadding.y to match the square ArrowButton size
	const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;
	const ImVec2 backup_cursor_pos = window->DC.CursorPos;
	window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);
	tab_bar->BarRect.Min.x += tab_list_popup_button_width;

	ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
	arrow_col.w *= 0.5f;
	PushStyleColor(ImGuiCol_Text, arrow_col);
	PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
	bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview | ImGuiComboFlags_HeightLargest);
	PopStyleColor(2);

	ImGuiTabItem *tab_to_select = NULL;
	if (open) {
		for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++) {
			ImGuiTabItem *tab = &tab_bar->Tabs[tab_n];
			if (tab->Flags & ImGuiTabItemFlags_Button)
				continue;

			const char *tab_name = TabBarGetTabName(tab_bar, tab);
			if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))
				tab_to_select = tab;
		}
		EndCombo();
	}

	window->DC.CursorPos = backup_cursor_pos;
	return tab_to_select;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
//-------------------------------------------------------------------------
// - BeginTabItem()
// - EndTabItem()
// - TabItemButton()
// - TabItemEx() [Internal]
// - SetTabItemClosed()
// - TabItemCalcSize() [Internal]
// - TabItemBackground() [Internal]
// - TabItemLabelAndCloseButton() [Internal]
//-------------------------------------------------------------------------

bool ImGui::BeginTabItem(const char *label, bool *p_open, ImGuiTabItemFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return false;

	ImGuiTabBar *tab_bar = g.CurrentTabBar;
	if (tab_bar == NULL) {
		IM_ASSERT_USER_ERROR(tab_bar, "Needs to be called between BeginTabBar() and EndTabBar()!");
		return false;
	}
	IM_ASSERT(!(flags & ImGuiTabItemFlags_Button)); // BeginTabItem() Can't be used with button flags, use TabItemButton() instead!

	bool ret = TabItemEx(tab_bar, label, p_open, flags, NULL);
	if (ret && !(flags & ImGuiTabItemFlags_NoPushId)) {
		ImGuiTabItem *tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
		PushOverrideID(tab->ID); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)
	}
	return ret;
}

void ImGui::EndTabItem() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return;

	ImGuiTabBar *tab_bar = g.CurrentTabBar;
	if (tab_bar == NULL) {
		IM_ASSERT_USER_ERROR(tab_bar != NULL, "Needs to be called between BeginTabBar() and EndTabBar()!");
		return;
	}
	IM_ASSERT(tab_bar->LastTabItemIdx >= 0);
	ImGuiTabItem *tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
	if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))
		PopID();
}

bool ImGui::TabItemButton(const char *label, ImGuiTabItemFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return false;

	ImGuiTabBar *tab_bar = g.CurrentTabBar;
	if (tab_bar == NULL) {
		IM_ASSERT_USER_ERROR(tab_bar != NULL, "Needs to be called between BeginTabBar() and EndTabBar()!");
		return false;
	}
	return TabItemEx(tab_bar, label, NULL, flags | ImGuiTabItemFlags_Button | ImGuiTabItemFlags_NoReorder, NULL);
}

bool ImGui::TabItemEx(ImGuiTabBar *tab_bar, const char *label, bool *p_open, ImGuiTabItemFlags flags, ImGuiWindow *docked_window) {
	// Layout whole tab bar if not already done
	ImGuiContext &g = *GImGui;
	if (tab_bar->WantLayout) {
		ImGuiNextItemData backup_next_item_data = g.NextItemData;
		TabBarLayout(tab_bar);
		g.NextItemData = backup_next_item_data;
	}
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return false;

	const ImGuiStyle &style = g.Style;
	const ImGuiID id = TabBarCalcTabID(tab_bar, label, docked_window);

	// If the user called us with *p_open == false, we early out and don't render.
	// We make a call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	if (p_open && !*p_open) {
		ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);
		return false;
	}

	IM_ASSERT(!p_open || !(flags & ImGuiTabItemFlags_Button));
	IM_ASSERT((flags & (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)) != (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)); // Can't use both Leading and Trailing

	// Store into ImGuiTabItemFlags_NoCloseButton, also honor ImGuiTabItemFlags_NoCloseButton passed by user (although not documented)
	if (flags & ImGuiTabItemFlags_NoCloseButton)
		p_open = NULL;
	else if (p_open == NULL)
		flags |= ImGuiTabItemFlags_NoCloseButton;

	// Acquire tab data
	ImGuiTabItem *tab = TabBarFindTabByID(tab_bar, id);
	bool tab_is_new = false;
	if (tab == NULL) {
		tab_bar->Tabs.push_back(ImGuiTabItem());
		tab = &tab_bar->Tabs.back();
		tab->ID = id;
		tab_bar->TabsAddedNew = tab_is_new = true;
	}
	tab_bar->LastTabItemIdx = (ImS16)tab_bar->Tabs.index_from_ptr(tab);

	// Calculate tab contents size
	ImVec2 size = TabItemCalcSize(label, (p_open != NULL) || (flags & ImGuiTabItemFlags_UnsavedDocument));
	tab->RequestedWidth = -1.0f;
	if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasWidth)
		size.x = tab->RequestedWidth = g.NextItemData.Width;
	if (tab_is_new)
		tab->Width = ImMax(1.0f, size.x);
	tab->ContentWidth = size.x;
	tab->BeginOrder = tab_bar->TabsActiveCount++;

	const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
	const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;
	const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);
	const bool tab_just_unsaved = (flags & ImGuiTabItemFlags_UnsavedDocument) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument);
	const bool is_tab_button = (flags & ImGuiTabItemFlags_Button) != 0;
	tab->LastFrameVisible = g.FrameCount;
	tab->Flags = flags;

	// Append name _WITH_ the zero-terminator
	if (docked_window != NULL) {
		IM_ASSERT(docked_window == NULL); // master branch only
	} else {
		tab->NameOffset = (ImS32)tab_bar->TabsNames.size();
		tab_bar->TabsNames.append(label, label + strlen(label) + 1);
	}

	// Update selected tab
	if (!is_tab_button) {
		if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)
			if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)
				TabBarQueueFocus(tab_bar, tab); // New tabs gets activated
		if ((flags & ImGuiTabItemFlags_SetSelected) && (tab_bar->SelectedTabId != id)) // _SetSelected can only be passed on explicit tab bar
			TabBarQueueFocus(tab_bar, tab);
	}

	// Lock visibility
	// (Note: tab_contents_visible != tab_selected... because CTRL+TAB operations may preview some tabs without selecting them!)
	bool tab_contents_visible = (tab_bar->VisibleTabId == id);
	if (tab_contents_visible)
		tab_bar->VisibleTabWasSubmitted = true;

	// On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
	if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)
		if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))
			tab_contents_visible = true;

	// Note that tab_is_new is not necessarily the same as tab_appearing! When a tab bar stops being submitted
	// and then gets submitted again, the tabs will have 'tab_appearing=true' but 'tab_is_new=false'.
	if (tab_appearing && (!tab_bar_appearing || tab_is_new)) {
		ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);
		if (is_tab_button)
			return false;
		return tab_contents_visible;
	}

	if (tab_bar->SelectedTabId == id)
		tab->LastFrameSelected = g.FrameCount;

	// Backup current layout position
	const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;

	// Layout
	const bool is_central_section = (tab->Flags & ImGuiTabItemFlags_SectionMask_) == 0;
	size.x = tab->Width;
	if (is_central_section)
		window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2(IM_TRUNC(tab->Offset - tab_bar->ScrollingAnim), 0.0f);
	else
		window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2(tab->Offset, 0.0f);
	ImVec2 pos = window->DC.CursorPos;
	ImRect bb(pos, pos + size);

	// We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
	const bool want_clip_rect = is_central_section && (bb.Min.x < tab_bar->ScrollingRectMinX || bb.Max.x > tab_bar->ScrollingRectMaxX);
	if (want_clip_rect)
		PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);

	ImVec2 backup_cursor_max_pos = window->DC.CursorMaxPos;
	ItemSize(bb.GetSize(), style.FramePadding.y);
	window->DC.CursorMaxPos = backup_cursor_max_pos;

	if (!ItemAdd(bb, id)) {
		if (want_clip_rect)
			PopClipRect();
		window->DC.CursorPos = backup_main_cursor_pos;
		return tab_contents_visible;
	}

	// Click to Select a tab
	// Allow the close button to overlap
	ImGuiButtonFlags button_flags = ((is_tab_button ? ImGuiButtonFlags_PressedOnClickRelease : ImGuiButtonFlags_PressedOnClick) | ImGuiButtonFlags_AllowOverlap);
	if (g.DragDropActive)
		button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
	if (pressed && !is_tab_button)
		TabBarQueueFocus(tab_bar, tab);

	// Drag and drop: re-order tabs
	if (held && !tab_appearing && IsMouseDragging(0)) {
		if (!g.DragDropActive && (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)) {
			// While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
			if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x) {
				TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
			} else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x) {
				TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
			}
		}
	}

#if 0
    if (hovered && g.HoveredIdNotActiveTimer > TOOLTIP_DELAY && bb.GetWidth() < tab->ContentWidth)
    {
        // Enlarge tab display when hovering
        bb.Max.x = bb.Min.x + IM_TRUNC(ImLerp(bb.GetWidth(), tab->ContentWidth, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f)));
        display_draw_list = GetForegroundDrawList(window);
        TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));
    }
#endif

	// Render tab shape
	ImDrawList *display_draw_list = window->DrawList;
	const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabSelected : ImGuiCol_TabDimmedSelected)
																									 : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabDimmed));
	TabItemBackground(display_draw_list, bb, flags, tab_col);
	if (tab_contents_visible && (tab_bar->Flags & ImGuiTabBarFlags_DrawSelectedOverline) && style.TabBarOverlineSize > 0.0f) {
		float x_offset = IM_TRUNC(0.4f * style.TabRounding);
		if (x_offset < 2.0f * g.CurrentDpiScale)
			x_offset = 0.0f;
		float y_offset = 1.0f * g.CurrentDpiScale;
		display_draw_list->AddLine(bb.GetTL() + ImVec2(x_offset, y_offset), bb.GetTR() + ImVec2(-x_offset, y_offset), GetColorU32(tab_bar_focused ? ImGuiCol_TabSelectedOverline : ImGuiCol_TabDimmedSelectedOverline), style.TabBarOverlineSize);
	}
	RenderNavHighlight(bb, id);

	// Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
	const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);
	if (tab_bar->SelectedTabId != tab->ID && hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)) && !is_tab_button)
		TabBarQueueFocus(tab_bar, tab);

	if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)
		flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

	// Render tab label, process close button
	const ImGuiID close_button_id = p_open ? GetIDWithSeed("#CLOSE", NULL, id) : 0;
	bool just_closed;
	bool text_clipped;
	TabItemLabelAndCloseButton(display_draw_list, bb, tab_just_unsaved ? (flags & ~ImGuiTabItemFlags_UnsavedDocument) : flags, tab_bar->FramePadding, label, id, close_button_id, tab_contents_visible, &just_closed, &text_clipped);
	if (just_closed && p_open != NULL) {
		*p_open = false;
		TabBarCloseTab(tab_bar, tab);
	}

	// Restore main window position so user can draw there
	if (want_clip_rect)
		PopClipRect();
	window->DC.CursorPos = backup_main_cursor_pos;

	// Tooltip
	// (Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer-> seems ok)
	// (We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar, which g.HoveredId ignores)
	// FIXME: This is a mess.
	// FIXME: We may want disabled tab to still display the tooltip?
	if (text_clipped && g.HoveredId == id && !held)
		if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip) && !(tab->Flags & ImGuiTabItemFlags_NoTooltip))
			SetItemTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);

	IM_ASSERT(!is_tab_button || !(tab_bar->SelectedTabId == tab->ID && is_tab_button)); // TabItemButton should not be selected
	if (is_tab_button)
		return pressed;
	return tab_contents_visible;
}

// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.
// To use it to need to call the function SetTabItemClosed() between BeginTabBar() and EndTabBar().
// Tabs closed by the close button will automatically be flagged to avoid this issue.
void ImGui::SetTabItemClosed(const char *label) {
	ImGuiContext &g = *GImGui;
	bool is_within_manual_tab_bar = g.CurrentTabBar && !(g.CurrentTabBar->Flags & ImGuiTabBarFlags_DockNode);
	if (is_within_manual_tab_bar) {
		ImGuiTabBar *tab_bar = g.CurrentTabBar;
		ImGuiID tab_id = TabBarCalcTabID(tab_bar, label, NULL);
		if (ImGuiTabItem *tab = TabBarFindTabByID(tab_bar, tab_id))
			tab->WantClose = true; // Will be processed by next call to TabBarLayout()
	}
}

ImVec2 ImGui::TabItemCalcSize(const char *label, bool has_close_button_or_unsaved_marker) {
	ImGuiContext &g = *GImGui;
	ImVec2 label_size = CalcTextSize(label, NULL, true);
	ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);
	if (has_close_button_or_unsaved_marker)
		size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.
	else
		size.x += g.Style.FramePadding.x + 1.0f;
	return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);
}

ImVec2 ImGui::TabItemCalcSize(ImGuiWindow *) {
	IM_ASSERT(0); // This function exists to facilitate merge with 'docking' branch.
	return ImVec2(0.0f, 0.0f);
}

void ImGui::TabItemBackground(ImDrawList *draw_list, const ImRect &bb, ImGuiTabItemFlags flags, ImU32 col) {
	// While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
	ImGuiContext &g = *GImGui;
	const float width = bb.GetWidth();
	IM_UNUSED(flags);
	IM_ASSERT(width > 0.0f);
	const float rounding = ImMax(0.0f, ImMin((flags & ImGuiTabItemFlags_Button) ? g.Style.FrameRounding : g.Style.TabRounding, width * 0.5f - 1.0f));
	const float y1 = bb.Min.y + 1.0f;
	const float y2 = bb.Max.y - g.Style.TabBarBorderSize;
	draw_list->PathLineTo(ImVec2(bb.Min.x, y2));
	draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);
	draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);
	draw_list->PathLineTo(ImVec2(bb.Max.x, y2));
	draw_list->PathFillConvex(col);
	if (g.Style.TabBorderSize > 0.0f) {
		draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));
		draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);
		draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);
		draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));
		draw_list->PathStroke(GetColorU32(ImGuiCol_Border), 0, g.Style.TabBorderSize);
	}
}

// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.
void ImGui::TabItemLabelAndCloseButton(ImDrawList *draw_list, const ImRect &bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char *label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool *out_just_closed, bool *out_text_clipped) {
	ImGuiContext &g = *GImGui;
	ImVec2 label_size = CalcTextSize(label, NULL, true);

	if (out_just_closed)
		*out_just_closed = false;
	if (out_text_clipped)
		*out_text_clipped = false;

	if (bb.GetWidth() <= 1.0f)
		return;

	// In Style V2 we'll have full override of all colors per state (e.g. focused, selected)
	// But right now if you want to alter text color of tabs this is what you need to do.
#if 0
    const float backup_alpha = g.Style.Alpha;
    if (!is_contents_visible)
        g.Style.Alpha *= 0.7f;
#endif

	// Render text label (with clipping + alpha gradient) + unsaved marker
	ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);
	ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;

	// Return clipped state ignoring the close button
	if (out_text_clipped) {
		*out_text_clipped = (text_ellipsis_clip_bb.Min.x + label_size.x) > text_pixel_clip_bb.Max.x;
		//draw_list->AddCircle(text_ellipsis_clip_bb.Min, 3.0f, *out_text_clipped ? IM_COL32(255, 0, 0, 255) : IM_COL32(0, 255, 0, 255));
	}

	const float button_sz = g.FontSize;
	const ImVec2 button_pos(ImMax(bb.Min.x, bb.Max.x - frame_padding.x - button_sz), bb.Min.y + frame_padding.y);

	// Close Button & Unsaved Marker
	// We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
	//  'hovered' will be true when hovering the Tab but NOT when hovering the close button
	//  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
	//  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
	bool close_button_pressed = false;
	bool close_button_visible = false;
	if (close_button_id != 0)
		if (is_contents_visible || bb.GetWidth() >= ImMax(button_sz, g.Style.TabMinWidthForCloseButton))
			if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == tab_id || g.ActiveId == close_button_id)
				close_button_visible = true;
	bool unsaved_marker_visible = (flags & ImGuiTabItemFlags_UnsavedDocument) != 0 && (button_pos.x + button_sz <= bb.Max.x);

	if (close_button_visible) {
		ImGuiLastItemData last_item_backup = g.LastItemData;
		if (CloseButton(close_button_id, button_pos))
			close_button_pressed = true;
		g.LastItemData = last_item_backup;

		// Close with middle mouse button
		if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))
			close_button_pressed = true;
	} else if (unsaved_marker_visible) {
		const ImRect bullet_bb(button_pos, button_pos + ImVec2(button_sz, button_sz));
		RenderBullet(draw_list, bullet_bb.GetCenter(), GetColorU32(ImGuiCol_Text));
	}

	// This is all rather complicated
	// (the main idea is that because the close button only appears on hover, we don't want it to alter the ellipsis position)
	// FIXME: if FramePadding is noticeably large, ellipsis_max_x will be wrong here (e.g. #3497), maybe for consistency that parameter of RenderTextEllipsis() shouldn't exist..
	float ellipsis_max_x = close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0f;
	if (close_button_visible || unsaved_marker_visible) {
		text_pixel_clip_bb.Max.x -= close_button_visible ? (button_sz) : (button_sz * 0.80f);
		text_ellipsis_clip_bb.Max.x -= unsaved_marker_visible ? (button_sz * 0.80f) : 0.0f;
		ellipsis_max_x = text_pixel_clip_bb.Max.x;
	}
	RenderTextEllipsis(draw_list, text_ellipsis_clip_bb.Min, text_ellipsis_clip_bb.Max, text_pixel_clip_bb.Max.x, ellipsis_max_x, label, NULL, &label_size);

#if 0
    if (!is_contents_visible)
        g.Style.Alpha = backup_alpha;
#endif

	if (out_just_closed)
		*out_just_closed = close_button_pressed;
}

#endif // #ifndef IMGUI_DISABLE
#line 0

#line 1 "sfw/render_gui/imgui_tables.cpp"
// dear imgui, v1.91.1
// (tables and columns code)

/*

Index of this file:

// [SECTION] Commentary
// [SECTION] Header mess
// [SECTION] Tables: Main code
// [SECTION] Tables: Simple accessors
// [SECTION] Tables: Row changes
// [SECTION] Tables: Columns changes
// [SECTION] Tables: Columns width management
// [SECTION] Tables: Drawing
// [SECTION] Tables: Sorting
// [SECTION] Tables: Headers
// [SECTION] Tables: Context Menu
// [SECTION] Tables: Settings (.ini data)
// [SECTION] Tables: Garbage Collection
// [SECTION] Tables: Debugging
// [SECTION] Columns, BeginColumns, EndColumns, etc.

*/

// Navigating this file:
// - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
// - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.

//-----------------------------------------------------------------------------
// [SECTION] Commentary
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical tables call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - BeginTable()                               user begin into a table
//    | BeginChild()                            - (if ScrollX/ScrollY is set)
//    | TableBeginInitMemory()                  - first time table is used
//    | TableResetSettings()                    - on settings reset
//    | TableLoadSettings()                     - on settings load
//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests
//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)
//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width
// - TableSetupColumn()                         user submit columns details (optional)
// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)
//-----------------------------------------------------------------------------
// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().
//    | TableSetupDrawChannels()                - setup ImDrawList channels
//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission
//    | TableBeginContextMenuPopup()
//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents
//-----------------------------------------------------------------------------
// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)
//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction
//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu
// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)
// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())
//    | TableEndRow()                           - finish existing row
//    | TableBeginRow()                         - add a new row
// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell
//    | TableEndCell()                          - close existing column/cell
//    | TableBeginCell()                        - enter into current column/cell
// - [...]                                      user emit contents
//-----------------------------------------------------------------------------
// - EndTable()                                 user ends the table
//    | TableDrawBorders()                      - draw outer borders, inner vertical borders
//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required
//    | EndChild()                              - (if ScrollX/ScrollY is set)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TABLE SIZING
//-----------------------------------------------------------------------------
// (Read carefully because this is subtle but it does make sense!)
//-----------------------------------------------------------------------------
// About 'outer_size':
// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.
// Default value is ImVec2(0.0f, 0.0f).
//   X
//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.
//   - outer_size.x  > 0.0f  ->  Set Fixed width.
//   Y with ScrollX/ScrollY disabled: we output table directly in current window
//   - outer_size.y  < 0.0f  ->  Bottom-align (but will auto extend, unless _NoHostExtendY is set). Not meaningful if parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  No minimum height (but will auto extend, unless _NoHostExtendY is set)
//   - outer_size.y  > 0.0f  ->  Set Minimum height (but will auto extend, unless _NoHostExtendY is set)
//   Y with ScrollX/ScrollY enabled: using a child window for scrolling
//   - outer_size.y  < 0.0f  ->  Bottom-align. Not meaningful if parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  Bottom-align, consistent with BeginChild(). Not recommended unless table is last item in parent window.
//   - outer_size.y  > 0.0f  ->  Set Exact height. Recommended when using Scrolling on any axis.
//-----------------------------------------------------------------------------
// Outer size is also affected by the NoHostExtendX/NoHostExtendY flags.
// Important to note how the two flags have slightly different behaviors!
//   - ImGuiTableFlags_NoHostExtendX -> Make outer width auto-fit to columns (overriding outer_size.x value). Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
//   - ImGuiTableFlags_NoHostExtendY -> Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY is disabled. Data below the limit will be clipped and not visible.
// In theory ImGuiTableFlags_NoHostExtendY could be the default and any non-scrolling tables with outer_size.y != 0.0f would use exact height.
// This would be consistent but perhaps less useful and more confusing (as vertically clipped items are not useful and not easily noticeable).
//-----------------------------------------------------------------------------
// About 'inner_width':
//   With ScrollX disabled:
//   - inner_width          ->  *ignored*
//   With ScrollX enabled:
//   - inner_width  < 0.0f  ->  *illegal* fit in known width (right align from outer_size.x) <-- weird
//   - inner_width  = 0.0f  ->  fit in outer_width: Fixed size columns will take space they need (if avail, otherwise shrink down), Stretch columns becomes Fixed columns.
//   - inner_width  > 0.0f  ->  override scrolling width, generally to be larger than outer_size.x. Fixed column take space they need (if avail, otherwise shrink down), Stretch columns share remaining space!
//-----------------------------------------------------------------------------
// Details:
// - If you want to use Stretch columns with ScrollX, you generally need to specify 'inner_width' otherwise the concept
//   of "available space" doesn't make sense.
// - Even if not really useful, we allow 'inner_width < outer_size.x' for consistency and to facilitate understanding
//   of what the value does.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// COLUMNS SIZING POLICIES
// (Reference: ImGuiTableFlags_SizingXXX flags and ImGuiTableColumnFlags_WidthXXX flags)
//-----------------------------------------------------------------------------
// About overriding column sizing policy and width/weight with TableSetupColumn():
// We use a default parameter of -1 for 'init_width'/'init_weight'.
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  <= 0 (default)  --> width is automatic
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  >  0 (explicit) --> width is custom
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight <= 0 (default)  --> weight is 1.0f
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight >  0 (explicit) --> weight is custom
// Widths are specified _without_ CellPadding. If you specify a width of 100.0f, the column will be cover (100.0f + Padding * 2.0f)
// and you can fit a 100.0f wide item in it without clipping and with padding honored.
//-----------------------------------------------------------------------------
// About default sizing policy (if you don't specify a ImGuiTableColumnFlags_WidthXXXX flag)
//   - with Table policy ImGuiTableFlags_SizingFixedFit      --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is equal to contents width
//   - with Table policy ImGuiTableFlags_SizingFixedSame     --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is max of all contents width
//   - with Table policy ImGuiTableFlags_SizingStretchSame   --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is 1.0f
//   - with Table policy ImGuiTableFlags_SizingStretchWeight --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is proportional to contents
// Default Width and default Weight can be overridden when calling TableSetupColumn().
//-----------------------------------------------------------------------------
// About mixing Fixed/Auto and Stretch columns together:
//   - the typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.
//   - using mixed policies with ScrollX does not make much sense, as using Stretch columns with ScrollX does not make much sense in the first place!
//     that is, unless 'inner_width' is passed to BeginTable() to explicitly provide a total width to layout columns in.
//   - when using ImGuiTableFlags_SizingFixedSame with mixed columns, only the Fixed/Auto columns will match their widths to the width of the maximum contents.
//   - when using ImGuiTableFlags_SizingStretchSame with mixed columns, only the Stretch columns will match their weights/widths.
//-----------------------------------------------------------------------------
// About using column width:
// If a column is manually resizable or has a width specified with TableSetupColumn():
//   - you may use GetContentRegionAvail().x to query the width available in a given column.
//   - right-side alignment features such as SetNextItemWidth(-x) or PushItemWidth(-x) will rely on this width.
// If the column is not resizable and has no width specified with TableSetupColumn():
//   - its width will be automatic and be set to the max of items submitted.
//   - therefore you generally cannot have ALL items of the columns use e.g. SetNextItemWidth(-FLT_MIN).
//   - but if the column has one or more items of known/fixed size, this will become the reference width used by SetNextItemWidth(-FLT_MIN).
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TABLES CLIPPING/CULLING
//-----------------------------------------------------------------------------
// About clipping/culling of Rows in Tables:
// - For large numbers of rows, it is recommended you use ImGuiListClipper to submit only visible rows.
//   ImGuiListClipper is reliant on the fact that rows are of equal height.
//   See 'Demo->Tables->Vertical Scrolling' or 'Demo->Tables->Advanced' for a demo of using the clipper.
// - Note that auto-resizing columns don't play well with using the clipper.
//   By default a table with _ScrollX but without _Resizable will have column auto-resize.
//   So, if you want to use the clipper, make sure to either enable _Resizable, either setup columns width explicitly with _WidthFixed.
//-----------------------------------------------------------------------------
// About clipping/culling of Columns in Tables:
// - Both TableSetColumnIndex() and TableNextColumn() return true when the column is visible or performing
//   width measurements. Otherwise, you may skip submitting the contents of a cell/column, BUT ONLY if you know
//   it is not going to contribute to row height.
//   In many situations, you may skip submitting contents for every column but one (e.g. the first one).
// - Case A: column is not hidden by user, and at least partially in sight (most common case).
// - Case B: column is clipped / out of sight (because of scrolling or parent ClipRect): TableNextColumn() return false as a hint but we still allow layout output.
// - Case C: column is hidden explicitly by the user (e.g. via the context menu, or _DefaultHide column flag, etc.).
//
//                        [A]         [B]          [C]
//  TableNextColumn():    true        false        false       -> [userland] when TableNextColumn() / TableSetColumnIndex() returns false, user can skip submitting items but only if the column doesn't contribute to row height.
//          SkipItems:    false       false        true        -> [internal] when SkipItems is true, most widgets will early out if submitted, resulting is no layout output.
//           ClipRect:    normal      zero-width   zero-width  -> [internal] when ClipRect is zero, ItemAdd() will return false and most widgets will early out mid-way.
//  ImDrawList output:    normal      dummy        dummy       -> [internal] when using the dummy channel, ImDrawList submissions (if any) will be wasted (because cliprect is zero-width anyway).
//
// - We need to distinguish those cases because non-hidden columns that are clipped outside of scrolling bounds should still contribute their height to the row.
//   However, in the majority of cases, the contribution to row height is the same for all columns, or the tallest cells are known by the programmer.
//-----------------------------------------------------------------------------
// About clipping/culling of whole Tables:
// - Scrolling tables with a known outer size can be clipped earlier as BeginTable() will return false.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif

#ifndef IMGUI_DISABLE

// System includes
#include <stdint.h> // intptr_t

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(disable : 4127) // condition expression is constant
#pragma warning(disable : 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning(disable : 5054) // operator '|': deprecated between enumerations of different types
#endif
#pragma warning(disable : 26451) // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning(disable : 26812) // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option" // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast" // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral" // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant" // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion" // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wenum-enum-conversion" // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')
#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion" // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage" // warning: 'xxx' is an unsafe pointer used for buffer access
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wformat-nonliteral" // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-----------------------------------------------------------------------------
// [SECTION] Tables: Main code
//-----------------------------------------------------------------------------
// - TableFixFlags() [Internal]
// - TableFindByID() [Internal]
// - BeginTable()
// - BeginTableEx() [Internal]
// - TableBeginInitMemory() [Internal]
// - TableBeginApplyRequests() [Internal]
// - TableSetupColumnFlags() [Internal]
// - TableUpdateLayout() [Internal]
// - TableUpdateBorders() [Internal]
// - EndTable()
// - TableSetupColumn()
// - TableSetupScrollFreeze()
//-----------------------------------------------------------------------------

// Configuration
static const int TABLE_DRAW_CHANNEL_BG0 = 0;
static const int TABLE_DRAW_CHANNEL_BG2_FROZEN = 1;
static const int TABLE_DRAW_CHANNEL_NOCLIP = 2; // When using ImGuiTableFlags_NoClip (this becomes the last visible channel)
static const float TABLE_BORDER_SIZE = 1.0f; // FIXME-TABLE: Currently hard-coded because of clipping assumptions with outer borders rendering.
static const float TABLE_RESIZE_SEPARATOR_HALF_THICKNESS = 4.0f; // Extend outside inner borders.
static const float TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER = 0.06f; // Delay/timer before making the hover feedback (color+cursor) visible because tables/columns tends to be more cramped.

// Helper
inline ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow *outer_window) {
	// Adjust flags: set default sizing policy
	if ((flags & ImGuiTableFlags_SizingMask_) == 0)
		flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;

	// Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame
	if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
		flags |= ImGuiTableFlags_NoKeepColumnsVisible;

	// Adjust flags: enforce borders when resizable
	if (flags & ImGuiTableFlags_Resizable)
		flags |= ImGuiTableFlags_BordersInnerV;

	// Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling going on
	if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))
		flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);

	// Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody
	if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)
		flags &= ~ImGuiTableFlags_NoBordersInBody;

	// Adjust flags: disable saved settings if there's nothing to save
	if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)
		flags |= ImGuiTableFlags_NoSavedSettings;

	// Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)
	if (outer_window->RootWindow->Flags & ImGuiWindowFlags_NoSavedSettings)
		flags |= ImGuiTableFlags_NoSavedSettings;

	return flags;
}

ImGuiTable *ImGui::TableFindByID(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	return g.Tables.GetByKey(id);
}

// Read about "TABLE SIZING" at the top of this file.
bool ImGui::BeginTable(const char *str_id, int columns_count, ImGuiTableFlags flags, const ImVec2 &outer_size, float inner_width) {
	ImGuiID id = GetID(str_id);
	return BeginTableEx(str_id, id, columns_count, flags, outer_size, inner_width);
}

bool ImGui::BeginTableEx(const char *name, ImGuiID id, int columns_count, ImGuiTableFlags flags, const ImVec2 &outer_size, float inner_width) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *outer_window = GetCurrentWindow();
	if (outer_window->SkipItems) // Consistent with other tables + beneficial side effect that assert on miscalling EndTable() will be more visible.
		return false;

	// Sanity checks
	IM_ASSERT(columns_count > 0 && columns_count < IMGUI_TABLE_MAX_COLUMNS);
	if (flags & ImGuiTableFlags_ScrollX)
		IM_ASSERT(inner_width >= 0.0f);

	// If an outer size is specified ahead we will be able to early out when not visible. Exact clipping criteria may evolve.
	// FIXME: coarse clipping because access to table data causes two issues:
	// - instance numbers varying/unstable. may not be a direct problem for users, but could make outside access broken or confusing, e.g. TestEngine.
	// - can't implement support for ImGuiChildFlags_ResizeY as we need to somehow pull the height data from somewhere. this also needs stable instance numbers.
	// The side-effects of accessing table data on coarse clip would be:
	// - always reserving the pooled ImGuiTable data ahead for a fully clipped table (minor IMHO). Also the 'outer_window_is_measuring_size' criteria may already be defeating this in some situations.
	// - always performing the GetOrAddByKey() O(log N) query in g.Tables.Map[].
	const bool use_child_window = (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) != 0;
	const ImVec2 avail_size = GetContentRegionAvail();
	const ImVec2 actual_outer_size = CalcItemSize(outer_size, ImMax(avail_size.x, 1.0f), use_child_window ? ImMax(avail_size.y, 1.0f) : 0.0f);
	const ImRect outer_rect(outer_window->DC.CursorPos, outer_window->DC.CursorPos + actual_outer_size);
	const bool outer_window_is_measuring_size = (outer_window->AutoFitFramesX > 0) || (outer_window->AutoFitFramesY > 0); // Doesn't apply to AlwaysAutoResize windows!
	if (use_child_window && IsClippedEx(outer_rect, 0) && !outer_window_is_measuring_size) {
		ItemSize(outer_rect);
		ItemAdd(outer_rect, id);
		return false;
	}

	// [DEBUG] Debug break requested by user
	if (g.DebugBreakInTable == id)
		IM_DEBUG_BREAK();

	// Acquire storage for the table
	ImGuiTable *table = g.Tables.GetOrAddByKey(id);

	// Acquire temporary buffers
	const int table_idx = g.Tables.GetIndex(table);
	if (++g.TablesTempDataStacked > g.TablesTempData.Size)
		g.TablesTempData.resize(g.TablesTempDataStacked, ImGuiTableTempData());
	ImGuiTableTempData *temp_data = table->TempData = &g.TablesTempData[g.TablesTempDataStacked - 1];
	temp_data->TableIndex = table_idx;
	table->DrawSplitter = &table->TempData->DrawSplitter;
	table->DrawSplitter->Clear();

	// Fix flags
	table->IsDefaultSizingPolicy = (flags & ImGuiTableFlags_SizingMask_) == 0;
	flags = TableFixFlags(flags, outer_window);

	// Initialize
	const int previous_frame_active = table->LastFrameActive;
	const int instance_no = (previous_frame_active != g.FrameCount) ? 0 : table->InstanceCurrent + 1;
	const ImGuiTableFlags previous_flags = table->Flags;
	table->ID = id;
	table->Flags = flags;
	table->LastFrameActive = g.FrameCount;
	table->OuterWindow = table->InnerWindow = outer_window;
	table->ColumnsCount = columns_count;
	table->IsLayoutLocked = false;
	table->InnerWidth = inner_width;
	temp_data->UserOuterSize = outer_size;

	// Instance data (for instance 0, TableID == TableInstanceID)
	ImGuiID instance_id;
	table->InstanceCurrent = (ImS16)instance_no;
	if (instance_no > 0) {
		IM_ASSERT(table->ColumnsCount == columns_count && "BeginTable(): Cannot change columns count mid-frame while preserving same ID");
		if (table->InstanceDataExtra.Size < instance_no)
			table->InstanceDataExtra.push_back(ImGuiTableInstanceData());
		instance_id = GetIDWithSeed(instance_no, GetIDWithSeed("##Instances", NULL, id)); // Push "##Instances" followed by (int)instance_no in ID stack.
	} else {
		instance_id = id;
	}
	ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent);
	table_instance->TableInstanceID = instance_id;

	// When not using a child window, WorkRect.Max will grow as we append contents.
	if (use_child_window) {
		// Ensure no vertical scrollbar appears if we only want horizontal one, to make flag consistent
		// (we have no other way to disable vertical scrollbar of a window while keeping the horizontal one showing)
		ImVec2 override_content_size(FLT_MAX, FLT_MAX);
		if ((flags & ImGuiTableFlags_ScrollX) && !(flags & ImGuiTableFlags_ScrollY))
			override_content_size.y = FLT_MIN;

		// Ensure specified width (when not specified, Stretched columns will act as if the width == OuterWidth and
		// never lead to any scrolling). We don't handle inner_width < 0.0f, we could potentially use it to right-align
		// based on the right side of the child window work rect, which would require knowing ahead if we are going to
		// have decoration taking horizontal spaces (typically a vertical scrollbar).
		if ((flags & ImGuiTableFlags_ScrollX) && inner_width > 0.0f)
			override_content_size.x = inner_width;

		if (override_content_size.x != FLT_MAX || override_content_size.y != FLT_MAX)
			SetNextWindowContentSize(ImVec2(override_content_size.x != FLT_MAX ? override_content_size.x : 0.0f, override_content_size.y != FLT_MAX ? override_content_size.y : 0.0f));

		// Reset scroll if we are reactivating it
		if ((previous_flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) == 0)
			SetNextWindowScroll(ImVec2(0.0f, 0.0f));

		// Create scrolling region (without border and zero window padding)
		ImGuiWindowFlags child_window_flags = (flags & ImGuiTableFlags_ScrollX) ? ImGuiWindowFlags_HorizontalScrollbar : ImGuiWindowFlags_None;
		BeginChildEx(name, instance_id, outer_rect.GetSize(), ImGuiChildFlags_None, child_window_flags);
		table->InnerWindow = g.CurrentWindow;
		table->WorkRect = table->InnerWindow->WorkRect;
		table->OuterRect = table->InnerWindow->Rect();
		table->InnerRect = table->InnerWindow->InnerRect;
		IM_ASSERT(table->InnerWindow->WindowPadding.x == 0.0f && table->InnerWindow->WindowPadding.y == 0.0f && table->InnerWindow->WindowBorderSize == 0.0f);

		// Allow submitting when host is measuring
		if (table->InnerWindow->SkipItems && outer_window_is_measuring_size)
			table->InnerWindow->SkipItems = false;

		// When using multiple instances, ensure they have the same amount of horizontal decorations (aka vertical scrollbar) so stretched columns can be aligned)
		if (instance_no == 0) {
			table->HasScrollbarYPrev = table->HasScrollbarYCurr;
			table->HasScrollbarYCurr = false;
		}
		table->HasScrollbarYCurr |= table->InnerWindow->ScrollbarY;
	} else {
		// For non-scrolling tables, WorkRect == OuterRect == InnerRect.
		// But at this point we do NOT have a correct value for .Max.y (unless a height has been explicitly passed in). It will only be updated in EndTable().
		table->WorkRect = table->OuterRect = table->InnerRect = outer_rect;
		table->HasScrollbarYPrev = table->HasScrollbarYCurr = false;
	}

	// Push a standardized ID for both child-using and not-child-using tables
	PushOverrideID(id);
	if (instance_no > 0)
		PushOverrideID(instance_id); // FIXME: Somehow this is not resolved by stack-tool, even tho GetIDWithSeed() submitted the symbol.

	// Backup a copy of host window members we will modify
	ImGuiWindow *inner_window = table->InnerWindow;
	table->HostIndentX = inner_window->DC.Indent.x;
	table->HostClipRect = inner_window->ClipRect;
	table->HostSkipItems = inner_window->SkipItems;
	temp_data->HostBackupWorkRect = inner_window->WorkRect;
	temp_data->HostBackupParentWorkRect = inner_window->ParentWorkRect;
	temp_data->HostBackupColumnsOffset = outer_window->DC.ColumnsOffset;
	temp_data->HostBackupPrevLineSize = inner_window->DC.PrevLineSize;
	temp_data->HostBackupCurrLineSize = inner_window->DC.CurrLineSize;
	temp_data->HostBackupCursorMaxPos = inner_window->DC.CursorMaxPos;
	temp_data->HostBackupItemWidth = outer_window->DC.ItemWidth;
	temp_data->HostBackupItemWidthStackSize = outer_window->DC.ItemWidthStack.Size;
	inner_window->DC.PrevLineSize = inner_window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

	// Make borders not overlap our contents by offsetting HostClipRect (#6765, #7428, #3752)
	// (we normally shouldn't alter HostClipRect as we rely on TableMergeDrawChannels() expanding non-clipped column toward the
	// limits of that rectangle, in order for ImDrawListSplitter::Merge() to merge the draw commands. However since the overlap
	// problem only affect scrolling tables in this case we can get away with doing it without extra cost).
	if (inner_window != outer_window) {
		// FIXME: Because inner_window's Scrollbar doesn't know about border size, since it's not encoded in window->WindowBorderSize,
		// it already overlaps it and doesn't need an extra offset. Ideally we should be able to pass custom border size with
		// different x/y values to BeginChild().
		if (flags & ImGuiTableFlags_BordersOuterV) {
			table->HostClipRect.Min.x = ImMin(table->HostClipRect.Min.x + TABLE_BORDER_SIZE, table->HostClipRect.Max.x);
			if (inner_window->DecoOuterSizeX2 == 0.0f)
				table->HostClipRect.Max.x = ImMax(table->HostClipRect.Max.x - TABLE_BORDER_SIZE, table->HostClipRect.Min.x);
		}
		if (flags & ImGuiTableFlags_BordersOuterH) {
			table->HostClipRect.Min.y = ImMin(table->HostClipRect.Min.y + TABLE_BORDER_SIZE, table->HostClipRect.Max.y);
			if (inner_window->DecoOuterSizeY2 == 0.0f)
				table->HostClipRect.Max.y = ImMax(table->HostClipRect.Max.y - TABLE_BORDER_SIZE, table->HostClipRect.Min.y);
		}
	}

	// Padding and Spacing
	// - None               ........Content..... Pad .....Content........
	// - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |
	// - PadInner           ........Content.. Pad | Pad ..Content........
	// - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |
	const bool pad_outer_x = (flags & ImGuiTableFlags_NoPadOuterX) ? false : (flags & ImGuiTableFlags_PadOuterX) ? true
																												 : (flags & ImGuiTableFlags_BordersOuterV) != 0;
	const bool pad_inner_x = (flags & ImGuiTableFlags_NoPadInnerX) ? false : true;
	const float inner_spacing_for_border = (flags & ImGuiTableFlags_BordersInnerV) ? TABLE_BORDER_SIZE : 0.0f;
	const float inner_spacing_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) == 0) ? g.Style.CellPadding.x : 0.0f;
	const float inner_padding_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) != 0) ? g.Style.CellPadding.x : 0.0f;
	table->CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border;
	table->CellSpacingX2 = inner_spacing_explicit;
	table->CellPaddingX = inner_padding_explicit;

	const float outer_padding_for_border = (flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
	const float outer_padding_explicit = pad_outer_x ? g.Style.CellPadding.x : 0.0f;
	table->OuterPaddingX = (outer_padding_for_border + outer_padding_explicit) - table->CellPaddingX;

	table->CurrentColumn = -1;
	table->CurrentRow = -1;
	table->RowBgColorCounter = 0;
	table->LastRowFlags = ImGuiTableRowFlags_None;
	table->InnerClipRect = (inner_window == outer_window) ? table->WorkRect : inner_window->ClipRect;
	table->InnerClipRect.ClipWith(table->WorkRect); // We need this to honor inner_width
	table->InnerClipRect.ClipWithFull(table->HostClipRect);
	table->InnerClipRect.Max.y = (flags & ImGuiTableFlags_NoHostExtendY) ? ImMin(table->InnerClipRect.Max.y, inner_window->WorkRect.Max.y) : table->HostClipRect.Max.y;

	table->RowPosY1 = table->RowPosY2 = table->WorkRect.Min.y; // This is needed somehow
	table->RowTextBaseline = 0.0f; // This will be cleared again by TableBeginRow()
	table->RowCellPaddingY = 0.0f;
	table->FreezeRowsRequest = table->FreezeRowsCount = 0; // This will be setup by TableSetupScrollFreeze(), if any
	table->FreezeColumnsRequest = table->FreezeColumnsCount = 0;
	table->IsUnfrozenRows = true;
	table->DeclColumnsCount = table->AngledHeadersCount = 0;
	if (previous_frame_active + 1 < g.FrameCount)
		table->IsActiveIdInTable = false;
	table->AngledHeadersHeight = 0.0f;
	temp_data->AngledHeadersExtraWidth = 0.0f;

	// Using opaque colors facilitate overlapping lines of the grid, otherwise we'd need to improve TableDrawBorders()
	table->BorderColorStrong = GetColorU32(ImGuiCol_TableBorderStrong);
	table->BorderColorLight = GetColorU32(ImGuiCol_TableBorderLight);

	// Make table current
	g.CurrentTable = table;
	outer_window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();
	outer_window->DC.CurrentTableIdx = table_idx;
	if (inner_window != outer_window) // So EndChild() within the inner window can restore the table properly.
		inner_window->DC.CurrentTableIdx = table_idx;

	if ((previous_flags & ImGuiTableFlags_Reorderable) && (flags & ImGuiTableFlags_Reorderable) == 0)
		table->IsResetDisplayOrderRequest = true;

	// Mark as used to avoid GC
	if (table_idx >= g.TablesLastTimeActive.Size)
		g.TablesLastTimeActive.resize(table_idx + 1, -1.0f);
	g.TablesLastTimeActive[table_idx] = (float)g.Time;
	temp_data->LastTimeActive = (float)g.Time;
	table->MemoryCompacted = false;

	// Setup memory buffer (clear data if columns count changed)
	ImGuiTableColumn *old_columns_to_preserve = NULL;
	void *old_columns_raw_data = NULL;
	const int old_columns_count = table->Columns.size();
	if (old_columns_count != 0 && old_columns_count != columns_count) {
		// Attempt to preserve width on column count change (#4046)
		old_columns_to_preserve = table->Columns.Data;
		old_columns_raw_data = table->RawData;
		table->RawData = NULL;
	}
	if (table->RawData == NULL) {
		TableBeginInitMemory(table, columns_count);
		table->IsInitializing = table->IsSettingsRequestLoad = true;
	}
	if (table->IsResetAllRequest)
		TableResetSettings(table);
	if (table->IsInitializing) {
		// Initialize
		table->SettingsOffset = -1;
		table->IsSortSpecsDirty = true;
		table->InstanceInteracted = -1;
		table->ContextPopupColumn = -1;
		table->ReorderColumn = table->ResizedColumn = table->LastResizedColumn = -1;
		table->AutoFitSingleColumn = -1;
		table->HoveredColumnBody = table->HoveredColumnBorder = -1;
		for (int n = 0; n < columns_count; n++) {
			ImGuiTableColumn *column = &table->Columns[n];
			if (old_columns_to_preserve && n < old_columns_count) {
				// FIXME: We don't attempt to preserve column order in this path.
				*column = old_columns_to_preserve[n];
			} else {
				float width_auto = column->WidthAuto;
				*column = ImGuiTableColumn();
				column->WidthAuto = width_auto;
				column->IsPreserveWidthAuto = true; // Preserve WidthAuto when reinitializing a live table: not technically necessary but remove a visible flicker
				column->IsEnabled = column->IsUserEnabled = column->IsUserEnabledNextFrame = true;
			}
			column->DisplayOrder = table->DisplayOrderToIndex[n] = (ImGuiTableColumnIdx)n;
		}
	}
	if (old_columns_raw_data)
		IM_FREE(old_columns_raw_data);

	// Load settings
	if (table->IsSettingsRequestLoad)
		TableLoadSettings(table);

	// Handle DPI/font resize
	// This is designed to facilitate DPI changes with the assumption that e.g. style.CellPadding has been scaled as well.
	// It will also react to changing fonts with mixed results. It doesn't need to be perfect but merely provide a decent transition.
	// FIXME-DPI: Provide consistent standards for reference size. Perhaps using g.CurrentDpiScale would be more self explanatory.
	// This is will lead us to non-rounded WidthRequest in columns, which should work but is a poorly tested path.
	const float new_ref_scale_unit = g.FontSize; // g.Font->GetCharAdvance('A') ?
	if (table->RefScale != 0.0f && table->RefScale != new_ref_scale_unit) {
		const float scale_factor = new_ref_scale_unit / table->RefScale;
		//IMGUI_DEBUG_PRINT("[table] %08X RefScaleUnit %.3f -> %.3f, scaling width by %.3f\n", table->ID, table->RefScaleUnit, new_ref_scale_unit, scale_factor);
		for (int n = 0; n < columns_count; n++)
			table->Columns[n].WidthRequest = table->Columns[n].WidthRequest * scale_factor;
	}
	table->RefScale = new_ref_scale_unit;

	// Disable output until user calls TableNextRow() or TableNextColumn() leading to the TableUpdateLayout() call..
	// This is not strictly necessary but will reduce cases were "out of table" output will be misleading to the user.
	// Because we cannot safely assert in EndTable() when no rows have been created, this seems like our best option.
	inner_window->SkipItems = true;

	// Clear names
	// At this point the ->NameOffset field of each column will be invalid until TableUpdateLayout() or the first call to TableSetupColumn()
	if (table->ColumnsNames.Buf.Size > 0)
		table->ColumnsNames.Buf.resize(0);

	// Apply queued resizing/reordering/hiding requests
	TableBeginApplyRequests(table);

	return true;
}

// For reference, the average total _allocation count_ for a table is:
// + 0 (for ImGuiTable instance, we are pooling allocations in g.Tables[])
// + 1 (for table->RawData allocated below)
// + 1 (for table->ColumnsNames, if names are used)
// Shared allocations for the maximum number of simultaneously nested tables (generally a very small number)
// + 1 (for table->Splitter._Channels)
// + 2 * active_channels_count (for ImDrawCmd and ImDrawIdx buffers inside channels)
// Where active_channels_count is variable but often == columns_count or == columns_count + 1, see TableSetupDrawChannels() for details.
// Unused channels don't perform their +2 allocations.
void ImGui::TableBeginInitMemory(ImGuiTable *table, int columns_count) {
	// Allocate single buffer for our arrays
	const int columns_bit_array_size = (int)ImBitArrayGetStorageSizeInBytes(columns_count);
	ImSpanAllocator<6> span_allocator;
	span_allocator.Reserve(0, columns_count * sizeof(ImGuiTableColumn));
	span_allocator.Reserve(1, columns_count * sizeof(ImGuiTableColumnIdx));
	span_allocator.Reserve(2, columns_count * sizeof(ImGuiTableCellData), 4);
	for (int n = 3; n < 6; n++)
		span_allocator.Reserve(n, columns_bit_array_size);
	table->RawData = IM_ALLOC(span_allocator.GetArenaSizeInBytes());
	memset(table->RawData, 0, span_allocator.GetArenaSizeInBytes());
	span_allocator.SetArenaBasePtr(table->RawData);
	span_allocator.GetSpan(0, &table->Columns);
	span_allocator.GetSpan(1, &table->DisplayOrderToIndex);
	span_allocator.GetSpan(2, &table->RowCellData);
	table->EnabledMaskByDisplayOrder = (ImU32 *)span_allocator.GetSpanPtrBegin(3);
	table->EnabledMaskByIndex = (ImU32 *)span_allocator.GetSpanPtrBegin(4);
	table->VisibleMaskByIndex = (ImU32 *)span_allocator.GetSpanPtrBegin(5);
}

// Apply queued resizing/reordering/hiding requests
void ImGui::TableBeginApplyRequests(ImGuiTable *table) {
	// Handle resizing request
	// (We process this in the TableBegin() of the first instance of each table)
	// FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?
	if (table->InstanceCurrent == 0) {
		if (table->ResizedColumn != -1 && table->ResizedColumnNextWidth != FLT_MAX)
			TableSetColumnWidth(table->ResizedColumn, table->ResizedColumnNextWidth);
		table->LastResizedColumn = table->ResizedColumn;
		table->ResizedColumnNextWidth = FLT_MAX;
		table->ResizedColumn = -1;

		// Process auto-fit for single column, which is a special case for stretch columns and fixed columns with FixedSame policy.
		// FIXME-TABLE: Would be nice to redistribute available stretch space accordingly to other weights, instead of giving it all to siblings.
		if (table->AutoFitSingleColumn != -1) {
			TableSetColumnWidth(table->AutoFitSingleColumn, table->Columns[table->AutoFitSingleColumn].WidthAuto);
			table->AutoFitSingleColumn = -1;
		}
	}

	// Handle reordering request
	// Note: we don't clear ReorderColumn after handling the request.
	if (table->InstanceCurrent == 0) {
		if (table->HeldHeaderColumn == -1 && table->ReorderColumn != -1)
			table->ReorderColumn = -1;
		table->HeldHeaderColumn = -1;
		if (table->ReorderColumn != -1 && table->ReorderColumnDir != 0) {
			// We need to handle reordering across hidden columns.
			// In the configuration below, moving C to the right of E will lead to:
			//    ... C [D] E  --->  ... [D] E  C   (Column name/index)
			//    ... 2  3  4        ...  2  3  4   (Display order)
			const int reorder_dir = table->ReorderColumnDir;
			IM_ASSERT(reorder_dir == -1 || reorder_dir == +1);
			IM_ASSERT(table->Flags & ImGuiTableFlags_Reorderable);
			ImGuiTableColumn *src_column = &table->Columns[table->ReorderColumn];
			ImGuiTableColumn *dst_column = &table->Columns[(reorder_dir == -1) ? src_column->PrevEnabledColumn : src_column->NextEnabledColumn];
			IM_UNUSED(dst_column);
			const int src_order = src_column->DisplayOrder;
			const int dst_order = dst_column->DisplayOrder;
			src_column->DisplayOrder = (ImGuiTableColumnIdx)dst_order;
			for (int order_n = src_order + reorder_dir; order_n != dst_order + reorder_dir; order_n += reorder_dir)
				table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder -= (ImGuiTableColumnIdx)reorder_dir;
			IM_ASSERT(dst_column->DisplayOrder == dst_order - reorder_dir);

			// Display order is stored in both columns->IndexDisplayOrder and table->DisplayOrder[]. Rebuild later from the former.
			for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
				table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
			table->ReorderColumnDir = 0;
			table->IsSettingsDirty = true;
		}
	}

	// Handle display order reset request
	if (table->IsResetDisplayOrderRequest) {
		for (int n = 0; n < table->ColumnsCount; n++)
			table->DisplayOrderToIndex[n] = table->Columns[n].DisplayOrder = (ImGuiTableColumnIdx)n;
		table->IsResetDisplayOrderRequest = false;
		table->IsSettingsDirty = true;
	}
}

// Adjust flags: default width mode + stretch columns are not allowed when auto extending
static void TableSetupColumnFlags(ImGuiTable *table, ImGuiTableColumn *column, ImGuiTableColumnFlags flags_in) {
	ImGuiTableColumnFlags flags = flags_in;

	// Sizing Policy
	if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0) {
		const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
		if (table_sizing_policy == ImGuiTableFlags_SizingFixedFit || table_sizing_policy == ImGuiTableFlags_SizingFixedSame)
			flags |= ImGuiTableColumnFlags_WidthFixed;
		else
			flags |= ImGuiTableColumnFlags_WidthStretch;
	} else {
		IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_WidthMask_)); // Check that only 1 of each set is used.
	}

	// Resize
	if ((table->Flags & ImGuiTableFlags_Resizable) == 0)
		flags |= ImGuiTableColumnFlags_NoResize;

	// Sorting
	if ((flags & ImGuiTableColumnFlags_NoSortAscending) && (flags & ImGuiTableColumnFlags_NoSortDescending))
		flags |= ImGuiTableColumnFlags_NoSort;

	// Indentation
	if ((flags & ImGuiTableColumnFlags_IndentMask_) == 0)
		flags |= (table->Columns.index_from_ptr(column) == 0) ? ImGuiTableColumnFlags_IndentEnable : ImGuiTableColumnFlags_IndentDisable;

	// Alignment
	//if ((flags & ImGuiTableColumnFlags_AlignMask_) == 0)
	//    flags |= ImGuiTableColumnFlags_AlignCenter;
	//IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_AlignMask_)); // Check that only 1 of each set is used.

	// Preserve status flags
	column->Flags = flags | (column->Flags & ImGuiTableColumnFlags_StatusMask_);

	// Build an ordered list of available sort directions
	column->SortDirectionsAvailCount = column->SortDirectionsAvailMask = column->SortDirectionsAvailList = 0;
	if (table->Flags & ImGuiTableFlags_Sortable) {
		int count = 0, mask = 0, list = 0;
		if ((flags & ImGuiTableColumnFlags_PreferSortAscending) != 0 && (flags & ImGuiTableColumnFlags_NoSortAscending) == 0) {
			mask |= 1 << ImGuiSortDirection_Ascending;
			list |= ImGuiSortDirection_Ascending << (count << 1);
			count++;
		}
		if ((flags & ImGuiTableColumnFlags_PreferSortDescending) != 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) {
			mask |= 1 << ImGuiSortDirection_Descending;
			list |= ImGuiSortDirection_Descending << (count << 1);
			count++;
		}
		if ((flags & ImGuiTableColumnFlags_PreferSortAscending) == 0 && (flags & ImGuiTableColumnFlags_NoSortAscending) == 0) {
			mask |= 1 << ImGuiSortDirection_Ascending;
			list |= ImGuiSortDirection_Ascending << (count << 1);
			count++;
		}
		if ((flags & ImGuiTableColumnFlags_PreferSortDescending) == 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) {
			mask |= 1 << ImGuiSortDirection_Descending;
			list |= ImGuiSortDirection_Descending << (count << 1);
			count++;
		}
		if ((table->Flags & ImGuiTableFlags_SortTristate) || count == 0) {
			mask |= 1 << ImGuiSortDirection_None;
			count++;
		}
		column->SortDirectionsAvailList = (ImU8)list;
		column->SortDirectionsAvailMask = (ImU8)mask;
		column->SortDirectionsAvailCount = (ImU8)count;
		ImGui::TableFixColumnSortDirection(table, column);
	}
}

// Layout columns for the frame. This is in essence the followup to BeginTable() and this is our largest function.
// Runs on the first call to TableNextRow(), to give a chance for TableSetupColumn() and other TableSetupXXXXX() functions to be called first.
// FIXME-TABLE: Our width (and therefore our WorkRect) will be minimal in the first frame for _WidthAuto columns.
// Increase feedback side-effect with widgets relying on WorkRect.Max.x... Maybe provide a default distribution for _WidthAuto columns?
void ImGui::TableUpdateLayout(ImGuiTable *table) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(table->IsLayoutLocked == false);

	const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
	table->IsDefaultDisplayOrder = true;
	table->ColumnsEnabledCount = 0;
	ImBitArrayClearAllBits(table->EnabledMaskByIndex, table->ColumnsCount);
	ImBitArrayClearAllBits(table->EnabledMaskByDisplayOrder, table->ColumnsCount);
	table->LeftMostEnabledColumn = -1;
	table->MinColumnWidth = ImMax(1.0f, g.Style.FramePadding.x * 1.0f); // g.Style.ColumnsMinSpacing; // FIXME-TABLE

	// [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width for columns. Count fixed/stretch columns.
	// Process columns in their visible orders as we are building the Prev/Next indices.
	int count_fixed = 0; // Number of columns that have fixed sizing policies
	int count_stretch = 0; // Number of columns that have stretch sizing policies
	int prev_visible_column_idx = -1;
	bool has_auto_fit_request = false;
	bool has_resizable = false;
	float stretch_sum_width_auto = 0.0f;
	float fixed_max_width_auto = 0.0f;
	for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
		const int column_n = table->DisplayOrderToIndex[order_n];
		if (column_n != order_n)
			table->IsDefaultDisplayOrder = false;
		ImGuiTableColumn *column = &table->Columns[column_n];

		// Clear column setup if not submitted by user. Currently we make it mandatory to call TableSetupColumn() every frame.
		// It would easily work without but we're not ready to guarantee it since e.g. names need resubmission anyway.
		// We take a slight shortcut but in theory we could be calling TableSetupColumn() here with dummy values, it should yield the same effect.
		if (table->DeclColumnsCount <= column_n) {
			TableSetupColumnFlags(table, column, ImGuiTableColumnFlags_None);
			column->NameOffset = -1;
			column->UserID = 0;
			column->InitStretchWeightOrWidth = -1.0f;
		}

		// Update Enabled state, mark settings and sort specs dirty
		if (!(table->Flags & ImGuiTableFlags_Hideable) || (column->Flags & ImGuiTableColumnFlags_NoHide))
			column->IsUserEnabledNextFrame = true;
		if (column->IsUserEnabled != column->IsUserEnabledNextFrame) {
			column->IsUserEnabled = column->IsUserEnabledNextFrame;
			table->IsSettingsDirty = true;
		}
		column->IsEnabled = column->IsUserEnabled && (column->Flags & ImGuiTableColumnFlags_Disabled) == 0;

		if (column->SortOrder != -1 && !column->IsEnabled)
			table->IsSortSpecsDirty = true;
		if (column->SortOrder > 0 && !(table->Flags & ImGuiTableFlags_SortMulti))
			table->IsSortSpecsDirty = true;

		// Auto-fit unsized columns
		const bool start_auto_fit = (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? (column->WidthRequest < 0.0f) : (column->StretchWeight < 0.0f);
		if (start_auto_fit)
			column->AutoFitQueue = column->CannotSkipItemsQueue = (1 << 3) - 1; // Fit for three frames

		if (!column->IsEnabled) {
			column->IndexWithinEnabledSet = -1;
			continue;
		}

		// Mark as enabled and link to previous/next enabled column
		column->PrevEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
		column->NextEnabledColumn = -1;
		if (prev_visible_column_idx != -1)
			table->Columns[prev_visible_column_idx].NextEnabledColumn = (ImGuiTableColumnIdx)column_n;
		else
			table->LeftMostEnabledColumn = (ImGuiTableColumnIdx)column_n;
		column->IndexWithinEnabledSet = table->ColumnsEnabledCount++;
		ImBitArraySetBit(table->EnabledMaskByIndex, column_n);
		ImBitArraySetBit(table->EnabledMaskByDisplayOrder, column->DisplayOrder);
		prev_visible_column_idx = column_n;
		IM_ASSERT(column->IndexWithinEnabledSet <= column->DisplayOrder);

		// Calculate ideal/auto column width (that's the width required for all contents to be visible without clipping)
		// Combine width from regular rows + width from headers unless requested not to.
		if (!column->IsPreserveWidthAuto)
			column->WidthAuto = TableGetColumnWidthAuto(table, column);

		// Non-resizable columns keep their requested width (apply user value regardless of IsPreserveWidthAuto)
		const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
		if (column_is_resizable)
			has_resizable = true;
		if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f && !column_is_resizable)
			column->WidthAuto = column->InitStretchWeightOrWidth;

		if (column->AutoFitQueue != 0x00)
			has_auto_fit_request = true;
		if (column->Flags & ImGuiTableColumnFlags_WidthStretch) {
			stretch_sum_width_auto += column->WidthAuto;
			count_stretch++;
		} else {
			fixed_max_width_auto = ImMax(fixed_max_width_auto, column->WidthAuto);
			count_fixed++;
		}
	}
	if ((table->Flags & ImGuiTableFlags_Sortable) && table->SortSpecsCount == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
		table->IsSortSpecsDirty = true;
	table->RightMostEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
	IM_ASSERT(table->LeftMostEnabledColumn >= 0 && table->RightMostEnabledColumn >= 0);

	// [Part 2] Disable child window clipping while fitting columns. This is not strictly necessary but makes it possible to avoid
	// the column fitting having to wait until the first visible frame of the child container (may or not be a good thing). Also see #6510.
	// FIXME-TABLE: for always auto-resizing columns may not want to do that all the time.
	if (has_auto_fit_request && table->OuterWindow != table->InnerWindow)
		table->InnerWindow->SkipItems = false;
	if (has_auto_fit_request)
		table->IsSettingsDirty = true;

	// [Part 3] Fix column flags and record a few extra information.
	float sum_width_requests = 0.0f; // Sum of all width for fixed and auto-resize columns, excluding width contributed by Stretch columns but including spacing/padding.
	float stretch_sum_weights = 0.0f; // Sum of all weights for stretch columns.
	table->LeftMostStretchedColumn = table->RightMostStretchedColumn = -1;
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
		if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
			continue;
		ImGuiTableColumn *column = &table->Columns[column_n];

		const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
		if (column->Flags & ImGuiTableColumnFlags_WidthFixed) {
			// Apply same widths policy
			float width_auto = column->WidthAuto;
			if (table_sizing_policy == ImGuiTableFlags_SizingFixedSame && (column->AutoFitQueue != 0x00 || !column_is_resizable))
				width_auto = fixed_max_width_auto;

			// Apply automatic width
			// Latch initial size for fixed columns and update it constantly for auto-resizing column (unless clipped!)
			if (column->AutoFitQueue != 0x00)
				column->WidthRequest = width_auto;
			else if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !column_is_resizable && column->IsRequestOutput)
				column->WidthRequest = width_auto;

			// FIXME-TABLE: Increase minimum size during init frame to avoid biasing auto-fitting widgets
			// (e.g. TextWrapped) too much. Otherwise what tends to happen is that TextWrapped would output a very
			// large height (= first frame scrollbar display very off + clipper would skip lots of items).
			// This is merely making the side-effect less extreme, but doesn't properly fixes it.
			// FIXME: Move this to ->WidthGiven to avoid temporary lossyless?
			// FIXME: This break IsPreserveWidthAuto from not flickering if the stored WidthAuto was smaller.
			if (column->AutoFitQueue > 0x01 && table->IsInitializing && !column->IsPreserveWidthAuto)
				column->WidthRequest = ImMax(column->WidthRequest, table->MinColumnWidth * 4.0f); // FIXME-TABLE: Another constant/scale?
			sum_width_requests += column->WidthRequest;
		} else {
			// Initialize stretch weight
			if (column->AutoFitQueue != 0x00 || column->StretchWeight < 0.0f || !column_is_resizable) {
				if (column->InitStretchWeightOrWidth > 0.0f)
					column->StretchWeight = column->InitStretchWeightOrWidth;
				else if (table_sizing_policy == ImGuiTableFlags_SizingStretchProp)
					column->StretchWeight = (column->WidthAuto / stretch_sum_width_auto) * count_stretch;
				else
					column->StretchWeight = 1.0f;
			}

			stretch_sum_weights += column->StretchWeight;
			if (table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder > column->DisplayOrder)
				table->LeftMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
			if (table->RightMostStretchedColumn == -1 || table->Columns[table->RightMostStretchedColumn].DisplayOrder < column->DisplayOrder)
				table->RightMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
		}
		column->IsPreserveWidthAuto = false;
		sum_width_requests += table->CellPaddingX * 2.0f;
	}
	table->ColumnsEnabledFixedCount = (ImGuiTableColumnIdx)count_fixed;
	table->ColumnsStretchSumWeights = stretch_sum_weights;

	// [Part 4] Apply final widths based on requested widths
	const ImRect work_rect = table->WorkRect;
	const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
	const float width_removed = (table->HasScrollbarYPrev && !table->InnerWindow->ScrollbarY) ? g.Style.ScrollbarSize : 0.0f; // To synchronize decoration width of synched tables with mismatching scrollbar state (#5920)
	const float width_avail = ImMax(1.0f, (((table->Flags & ImGuiTableFlags_ScrollX) && table->InnerWidth == 0.0f) ? table->InnerClipRect.GetWidth() : work_rect.GetWidth()) - width_removed);
	const float width_avail_for_stretched_columns = width_avail - width_spacings - sum_width_requests;
	float width_remaining_for_stretched_columns = width_avail_for_stretched_columns;
	table->ColumnsGivenWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount;
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
		if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
			continue;
		ImGuiTableColumn *column = &table->Columns[column_n];

		// Allocate width for stretched/weighted columns (StretchWeight gets converted into WidthRequest)
		if (column->Flags & ImGuiTableColumnFlags_WidthStretch) {
			float weight_ratio = column->StretchWeight / stretch_sum_weights;
			column->WidthRequest = IM_TRUNC(ImMax(width_avail_for_stretched_columns * weight_ratio, table->MinColumnWidth) + 0.01f);
			width_remaining_for_stretched_columns -= column->WidthRequest;
		}

		// [Resize Rule 1] The right-most Visible column is not resizable if there is at least one Stretch column
		// See additional comments in TableSetColumnWidth().
		if (column->NextEnabledColumn == -1 && table->LeftMostStretchedColumn != -1)
			column->Flags |= ImGuiTableColumnFlags_NoDirectResize_;

		// Assign final width, record width in case we will need to shrink
		column->WidthGiven = ImTrunc(ImMax(column->WidthRequest, table->MinColumnWidth));
		table->ColumnsGivenWidth += column->WidthGiven;
	}

	// [Part 5] Redistribute stretch remainder width due to rounding (remainder width is < 1.0f * number of Stretch column).
	// Using right-to-left distribution (more likely to match resizing cursor).
	if (width_remaining_for_stretched_columns >= 1.0f && !(table->Flags & ImGuiTableFlags_PreciseWidths))
		for (int order_n = table->ColumnsCount - 1; stretch_sum_weights > 0.0f && width_remaining_for_stretched_columns >= 1.0f && order_n >= 0; order_n--) {
			if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
				continue;
			ImGuiTableColumn *column = &table->Columns[table->DisplayOrderToIndex[order_n]];
			if (!(column->Flags & ImGuiTableColumnFlags_WidthStretch))
				continue;
			column->WidthRequest += 1.0f;
			column->WidthGiven += 1.0f;
			width_remaining_for_stretched_columns -= 1.0f;
		}

	// Determine if table is hovered which will be used to flag columns as hovered.
	// - In principle we'd like to use the equivalent of IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
	//   but because our item is partially submitted at this point we use ItemHoverable() and a workaround (temporarily
	//   clear ActiveId, which is equivalent to the change provided by _AllowWhenBLockedByActiveItem).
	// - This allows columns to be marked as hovered when e.g. clicking a button inside the column, or using drag and drop.
	ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent);
	table_instance->HoveredRowLast = table_instance->HoveredRowNext;
	table_instance->HoveredRowNext = -1;
	table->HoveredColumnBody = table->HoveredColumnBorder = -1;
	const ImRect mouse_hit_rect(table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.Max.x, ImMax(table->OuterRect.Max.y, table->OuterRect.Min.y + table_instance->LastOuterHeight));
	const ImGuiID backup_active_id = g.ActiveId;
	g.ActiveId = 0;
	const bool is_hovering_table = ItemHoverable(mouse_hit_rect, 0, ImGuiItemFlags_None);
	g.ActiveId = backup_active_id;

	// Determine skewed MousePos.x to support angled headers.
	float mouse_skewed_x = g.IO.MousePos.x;
	if (table->AngledHeadersHeight > 0.0f)
		if (g.IO.MousePos.y >= table->OuterRect.Min.y && g.IO.MousePos.y <= table->OuterRect.Min.y + table->AngledHeadersHeight)
			mouse_skewed_x += ImTrunc((table->OuterRect.Min.y + table->AngledHeadersHeight - g.IO.MousePos.y) * table->AngledHeadersSlope);

	// [Part 6] Setup final position, offset, skip/clip states and clipping rectangles, detect hovered column
	// Process columns in their visible orders as we are comparing the visible order and adjusting host_clip_rect while looping.
	int visible_n = 0;
	bool has_at_least_one_column_requesting_output = false;
	bool offset_x_frozen = (table->FreezeColumnsCount > 0);
	float offset_x = ((table->FreezeColumnsCount > 0) ? table->OuterRect.Min.x : work_rect.Min.x) + table->OuterPaddingX - table->CellSpacingX1;
	ImRect host_clip_rect = table->InnerClipRect;
	//host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;
	ImBitArrayClearAllBits(table->VisibleMaskByIndex, table->ColumnsCount);
	for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
		const int column_n = table->DisplayOrderToIndex[order_n];
		ImGuiTableColumn *column = &table->Columns[column_n];

		column->NavLayerCurrent = (ImS8)(table->FreezeRowsCount > 0 ? ImGuiNavLayer_Menu : ImGuiNavLayer_Main); // Use Count NOT request so Header line changes layer when frozen

		if (offset_x_frozen && table->FreezeColumnsCount == visible_n) {
			offset_x += work_rect.Min.x - table->OuterRect.Min.x;
			offset_x_frozen = false;
		}

		// Clear status flags
		column->Flags &= ~ImGuiTableColumnFlags_StatusMask_;

		if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n)) {
			// Hidden column: clear a few fields and we are done with it for the remainder of the function.
			// We set a zero-width clip rect but set Min.y/Max.y properly to not interfere with the clipper.
			column->MinX = column->MaxX = column->WorkMinX = column->ClipRect.Min.x = column->ClipRect.Max.x = offset_x;
			column->WidthGiven = 0.0f;
			column->ClipRect.Min.y = work_rect.Min.y;
			column->ClipRect.Max.y = FLT_MAX;
			column->ClipRect.ClipWithFull(host_clip_rect);
			column->IsVisibleX = column->IsVisibleY = column->IsRequestOutput = false;
			column->IsSkipItems = true;
			column->ItemWidth = 1.0f;
			continue;
		}

		// Lock start position
		column->MinX = offset_x;

		// Lock width based on start position and minimum/maximum width for this position
		column->WidthMax = TableCalcMaxColumnWidth(table, column_n);
		column->WidthGiven = ImMin(column->WidthGiven, column->WidthMax);
		column->WidthGiven = ImMax(column->WidthGiven, ImMin(column->WidthRequest, table->MinColumnWidth));
		column->MaxX = offset_x + column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;

		// Lock other positions
		// - ClipRect.Min.x: Because merging draw commands doesn't compare min boundaries, we make ClipRect.Min.x match left bounds to be consistent regardless of merging.
		// - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding) makes things more consistent when resizing down, tho slightly detrimental to visibility in very-small column.
		// - ClipRect.Max.x: using MaxX makes it easier for header to receive hover highlight with no discontinuity and display sorting arrow.
		// - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x - WorkMinX) width, which means ClipRect.max.x cannot stray off host_clip_rect.Max.x else right-most column may appear shorter.
		const float previous_instance_work_min_x = column->WorkMinX;
		column->WorkMinX = column->MinX + table->CellPaddingX + table->CellSpacingX1;
		column->WorkMaxX = column->MaxX - table->CellPaddingX - table->CellSpacingX2; // Expected max
		column->ItemWidth = ImTrunc(column->WidthGiven * 0.65f);
		column->ClipRect.Min.x = column->MinX;
		column->ClipRect.Min.y = work_rect.Min.y;
		column->ClipRect.Max.x = column->MaxX; //column->WorkMaxX;
		column->ClipRect.Max.y = FLT_MAX;
		column->ClipRect.ClipWithFull(host_clip_rect);

		// Mark column as Clipped (not in sight)
		// Note that scrolling tables (where inner_window != outer_window) handle Y clipped earlier in BeginTable() so IsVisibleY really only applies to non-scrolling tables.
		// FIXME-TABLE: Because InnerClipRect.Max.y is conservatively ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the scroll line as not IsVisibleY.
		// Taking advantage of LastOuterHeight would yield good results there...
		// FIXME-TABLE: Y clipping is disabled because it effectively means not submitting will reduce contents width which is fed to outer_window->DC.CursorMaxPos.x,
		// and this may be used (e.g. typically by outer_window using AlwaysAutoResize or outer_window's horizontal scrollbar, but could be something else).
		// Possible solution to preserve last known content width for clipped column. Test 'table_reported_size' fails when enabling Y clipping and window is resized small.
		column->IsVisibleX = (column->ClipRect.Max.x > column->ClipRect.Min.x);
		column->IsVisibleY = true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);
		const bool is_visible = column->IsVisibleX; //&& column->IsVisibleY;
		if (is_visible)
			ImBitArraySetBit(table->VisibleMaskByIndex, column_n);

		// Mark column as requesting output from user. Note that fixed + non-resizable sets are auto-fitting at all times and therefore always request output.
		column->IsRequestOutput = is_visible || column->AutoFitQueue != 0 || column->CannotSkipItemsQueue != 0;

		// Mark column as SkipItems (ignoring all items/layout)
		// (table->HostSkipItems is a copy of inner_window->SkipItems before we cleared it above in Part 2)
		column->IsSkipItems = !column->IsEnabled || table->HostSkipItems;
		if (column->IsSkipItems)
			IM_ASSERT(!is_visible);
		if (column->IsRequestOutput && !column->IsSkipItems)
			has_at_least_one_column_requesting_output = true;

		// Update status flags
		column->Flags |= ImGuiTableColumnFlags_IsEnabled;
		if (is_visible)
			column->Flags |= ImGuiTableColumnFlags_IsVisible;
		if (column->SortOrder != -1)
			column->Flags |= ImGuiTableColumnFlags_IsSorted;

		// Detect hovered column
		if (is_hovering_table && mouse_skewed_x >= column->ClipRect.Min.x && mouse_skewed_x < column->ClipRect.Max.x) {
			column->Flags |= ImGuiTableColumnFlags_IsHovered;
			table->HoveredColumnBody = (ImGuiTableColumnIdx)column_n;
		}

		// Alignment
		// FIXME-TABLE: This align based on the whole column width, not per-cell, and therefore isn't useful in
		// many cases (to be able to honor this we might be able to store a log of cells width, per row, for
		// visible rows, but nav/programmatic scroll would have visible artifacts.)
		//if (column->Flags & ImGuiTableColumnFlags_AlignRight)
		//    column->WorkMinX = ImMax(column->WorkMinX, column->MaxX - column->ContentWidthRowsUnfrozen);
		//else if (column->Flags & ImGuiTableColumnFlags_AlignCenter)
		//    column->WorkMinX = ImLerp(column->WorkMinX, ImMax(column->StartX, column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);

		// Reset content width variables
		if (table->InstanceCurrent == 0) {
			column->ContentMaxXFrozen = column->WorkMinX;
			column->ContentMaxXUnfrozen = column->WorkMinX;
			column->ContentMaxXHeadersUsed = column->WorkMinX;
			column->ContentMaxXHeadersIdeal = column->WorkMinX;
		} else {
			// As we store an absolute value to make per-cell updates faster, we need to offset values used for width computation.
			const float offset_from_previous_instance = column->WorkMinX - previous_instance_work_min_x;
			column->ContentMaxXFrozen += offset_from_previous_instance;
			column->ContentMaxXUnfrozen += offset_from_previous_instance;
			column->ContentMaxXHeadersUsed += offset_from_previous_instance;
			column->ContentMaxXHeadersIdeal += offset_from_previous_instance;
		}

		// Don't decrement auto-fit counters until container window got a chance to submit its items
		if (table->HostSkipItems == false) {
			column->AutoFitQueue >>= 1;
			column->CannotSkipItemsQueue >>= 1;
		}

		if (visible_n < table->FreezeColumnsCount)
			host_clip_rect.Min.x = ImClamp(column->MaxX + TABLE_BORDER_SIZE, host_clip_rect.Min.x, host_clip_rect.Max.x);

		offset_x += column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;
		visible_n++;
	}

	// In case the table is visible (e.g. decorations) but all columns clipped, we keep a column visible.
	// Else if give no chance to a clipper-savy user to submit rows and therefore total contents height used by scrollbar.
	if (has_at_least_one_column_requesting_output == false) {
		table->Columns[table->LeftMostEnabledColumn].IsRequestOutput = true;
		table->Columns[table->LeftMostEnabledColumn].IsSkipItems = false;
	}

	// [Part 7] Detect/store when we are hovering the unused space after the right-most column (so e.g. context menus can react on it)
	// Clear Resizable flag if none of our column are actually resizable (either via an explicit _NoResize flag, either
	// because of using _WidthAuto/_WidthStretch). This will hide the resizing option from the context menu.
	const float unused_x1 = ImMax(table->WorkRect.Min.x, table->Columns[table->RightMostEnabledColumn].ClipRect.Max.x);
	if (is_hovering_table && table->HoveredColumnBody == -1)
		if (mouse_skewed_x >= unused_x1)
			table->HoveredColumnBody = (ImGuiTableColumnIdx)table->ColumnsCount;
	if (has_resizable == false && (table->Flags & ImGuiTableFlags_Resizable))
		table->Flags &= ~ImGuiTableFlags_Resizable;

	table->IsActiveIdAliveBeforeTable = (g.ActiveIdIsAlive != 0);

	// [Part 8] Lock actual OuterRect/WorkRect right-most position.
	// This is done late to handle the case of fixed-columns tables not claiming more widths that they need.
	// Because of this we are careful with uses of WorkRect and InnerClipRect before this point.
	if (table->RightMostStretchedColumn != -1)
		table->Flags &= ~ImGuiTableFlags_NoHostExtendX;
	if (table->Flags & ImGuiTableFlags_NoHostExtendX) {
		table->OuterRect.Max.x = table->WorkRect.Max.x = unused_x1;
		table->InnerClipRect.Max.x = ImMin(table->InnerClipRect.Max.x, unused_x1);
	}
	table->InnerWindow->ParentWorkRect = table->WorkRect;
	table->BorderX1 = table->InnerClipRect.Min.x;
	table->BorderX2 = table->InnerClipRect.Max.x;

	// Setup window's WorkRect.Max.y for GetContentRegionAvail(). Other values will be updated in each TableBeginCell() call.
	float window_content_max_y;
	if (table->Flags & ImGuiTableFlags_NoHostExtendY)
		window_content_max_y = table->OuterRect.Max.y;
	else
		window_content_max_y = ImMax(table->InnerWindow->ContentRegionRect.Max.y, (table->Flags & ImGuiTableFlags_ScrollY) ? 0.0f : table->OuterRect.Max.y);
	table->InnerWindow->WorkRect.Max.y = ImClamp(window_content_max_y - g.Style.CellPadding.y, table->InnerWindow->WorkRect.Min.y, table->InnerWindow->WorkRect.Max.y);

	// [Part 9] Allocate draw channels and setup background cliprect
	TableSetupDrawChannels(table);

	// [Part 10] Hit testing on borders
	if (table->Flags & ImGuiTableFlags_Resizable)
		TableUpdateBorders(table);
	table_instance->LastTopHeadersRowHeight = 0.0f;
	table->IsLayoutLocked = true;
	table->IsUsingHeaders = false;

	// Highlight header
	table->HighlightColumnHeader = -1;
	if (table->IsContextPopupOpen && table->ContextPopupColumn != -1 && table->InstanceInteracted == table->InstanceCurrent)
		table->HighlightColumnHeader = table->ContextPopupColumn;
	else if ((table->Flags & ImGuiTableFlags_HighlightHoveredColumn) && table->HoveredColumnBody != -1 && table->HoveredColumnBody != table->ColumnsCount && table->HoveredColumnBorder == -1)
		if (g.ActiveId == 0 || (table->IsActiveIdInTable || g.DragDropActive))
			table->HighlightColumnHeader = table->HoveredColumnBody;

	// [Part 11] Default context menu
	// - To append to this menu: you can call TableBeginContextMenuPopup()/.../EndPopup().
	// - To modify or replace this: set table->IsContextPopupNoDefaultContents = true, then call TableBeginContextMenuPopup()/.../EndPopup().
	// - You may call TableDrawDefaultContextMenu() with selected flags to display specific sections of the default menu,
	//   e.g. TableDrawDefaultContextMenu(table, table->Flags & ~ImGuiTableFlags_Hideable) will display everything EXCEPT columns visibility options.
	if (table->DisableDefaultContextMenu == false && TableBeginContextMenuPopup(table)) {
		TableDrawDefaultContextMenu(table, table->Flags);
		EndPopup();
	}

	// [Part 12] Sanitize and build sort specs before we have a chance to use them for display.
	// This path will only be exercised when sort specs are modified before header rows (e.g. init or visibility change)
	if (table->IsSortSpecsDirty && (table->Flags & ImGuiTableFlags_Sortable))
		TableSortSpecsBuild(table);

	// [Part 13] Setup inner window decoration size (for scrolling / nav tracking to properly take account of frozen rows/columns)
	if (table->FreezeColumnsRequest > 0)
		table->InnerWindow->DecoInnerSizeX1 = table->Columns[table->DisplayOrderToIndex[table->FreezeColumnsRequest - 1]].MaxX - table->OuterRect.Min.x;
	if (table->FreezeRowsRequest > 0)
		table->InnerWindow->DecoInnerSizeY1 = table_instance->LastFrozenHeight;
	table_instance->LastFrozenHeight = 0.0f;

	// Initial state
	ImGuiWindow *inner_window = table->InnerWindow;
	if (table->Flags & ImGuiTableFlags_NoClip)
		table->DrawSplitter->SetCurrentChannel(inner_window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
	else
		inner_window->DrawList->PushClipRect(inner_window->InnerClipRect.Min, inner_window->InnerClipRect.Max, false);
}

// Process hit-testing on resizing borders. Actual size change will be applied in EndTable()
// - Set table->HoveredColumnBorder with a short delay/timer to reduce visual feedback noise.
void ImGui::TableUpdateBorders(ImGuiTable *table) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(table->Flags & ImGuiTableFlags_Resizable);

	// At this point OuterRect height may be zero or under actual final height, so we rely on temporal coherency and
	// use the final height from last frame. Because this is only affecting _interaction_ with columns, it is not
	// really problematic (whereas the actual visual will be displayed in EndTable() and using the current frame height).
	// Actual columns highlight/render will be performed in EndTable() and not be affected.
	ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent);
	const float hit_half_width = ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale);
	const float hit_y1 = (table->FreezeRowsCount >= 1 ? table->OuterRect.Min.y : table->WorkRect.Min.y) + table->AngledHeadersHeight;
	const float hit_y2_body = ImMax(table->OuterRect.Max.y, hit_y1 + table_instance->LastOuterHeight - table->AngledHeadersHeight);
	const float hit_y2_head = hit_y1 + table_instance->LastTopHeadersRowHeight;

	for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
		if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
			continue;

		const int column_n = table->DisplayOrderToIndex[order_n];
		ImGuiTableColumn *column = &table->Columns[column_n];
		if (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_))
			continue;

		// ImGuiTableFlags_NoBordersInBodyUntilResize will be honored in TableDrawBorders()
		const float border_y2_hit = (table->Flags & ImGuiTableFlags_NoBordersInBody) ? hit_y2_head : hit_y2_body;
		if ((table->Flags & ImGuiTableFlags_NoBordersInBody) && table->IsUsingHeaders == false)
			continue;

		if (!column->IsVisibleX && table->LastResizedColumn != column_n)
			continue;

		ImGuiID column_id = TableGetColumnResizeID(table, column_n, table->InstanceCurrent);
		ImRect hit_rect(column->MaxX - hit_half_width, hit_y1, column->MaxX + hit_half_width, border_y2_hit);
		ItemAdd(hit_rect, column_id, NULL, ImGuiItemFlags_NoNav);
		//GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max, IM_COL32(255, 0, 0, 100));

		bool hovered = false, held = false;
		bool pressed = ButtonBehavior(hit_rect, column_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_NoNavFocus);
		if (pressed && IsMouseDoubleClicked(0)) {
			TableSetColumnWidthAutoSingle(table, column_n);
			ClearActiveID();
			held = false;
		}
		if (held) {
			if (table->LastResizedColumn == -1)
				table->ResizeLockMinContentsX2 = table->RightMostEnabledColumn != -1 ? table->Columns[table->RightMostEnabledColumn].MaxX : -FLT_MAX;
			table->ResizedColumn = (ImGuiTableColumnIdx)column_n;
			table->InstanceInteracted = table->InstanceCurrent;
		}
		if ((hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) || held) {
			table->HoveredColumnBorder = (ImGuiTableColumnIdx)column_n;
			SetMouseCursor(ImGuiMouseCursor_ResizeEW);
		}
	}
}

void ImGui::EndTable() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(table != NULL && "Only call EndTable() if BeginTable() returns true!");

	// This assert would be very useful to catch a common error... unfortunately it would probably trigger in some
	// cases, and for consistency user may sometimes output empty tables (and still benefit from e.g. outer border)
	//IM_ASSERT(table->IsLayoutLocked && "Table unused: never called TableNextRow(), is that the intent?");

	// If the user never got to call TableNextRow() or TableNextColumn(), we call layout ourselves to ensure all our
	// code paths are consistent (instead of just hoping that TableBegin/TableEnd will work), get borders drawn, etc.
	if (!table->IsLayoutLocked)
		TableUpdateLayout(table);

	const ImGuiTableFlags flags = table->Flags;
	ImGuiWindow *inner_window = table->InnerWindow;
	ImGuiWindow *outer_window = table->OuterWindow;
	ImGuiTableTempData *temp_data = table->TempData;
	IM_ASSERT(inner_window == g.CurrentWindow);
	IM_ASSERT(outer_window == inner_window || outer_window == inner_window->ParentWindow);

	if (table->IsInsideRow)
		TableEndRow(table);

	// Context menu in columns body
	if (flags & ImGuiTableFlags_ContextMenuInBody)
		if (table->HoveredColumnBody != -1 && !IsAnyItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
			TableOpenContextMenu((int)table->HoveredColumnBody);

	// Finalize table height
	ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent);
	inner_window->DC.PrevLineSize = temp_data->HostBackupPrevLineSize;
	inner_window->DC.CurrLineSize = temp_data->HostBackupCurrLineSize;
	inner_window->DC.CursorMaxPos = temp_data->HostBackupCursorMaxPos;
	const float inner_content_max_y = table->RowPosY2;
	IM_ASSERT(table->RowPosY2 == inner_window->DC.CursorPos.y);
	if (inner_window != outer_window)
		inner_window->DC.CursorMaxPos.y = inner_content_max_y;
	else if (!(flags & ImGuiTableFlags_NoHostExtendY))
		table->OuterRect.Max.y = table->InnerRect.Max.y = ImMax(table->OuterRect.Max.y, inner_content_max_y); // Patch OuterRect/InnerRect height
	table->WorkRect.Max.y = ImMax(table->WorkRect.Max.y, table->OuterRect.Max.y);
	table_instance->LastOuterHeight = table->OuterRect.GetHeight();

	// Setup inner scrolling range
	// FIXME: This ideally should be done earlier, in BeginTable() SetNextWindowContentSize call, just like writing to inner_window->DC.CursorMaxPos.y,
	// but since the later is likely to be impossible to do we'd rather update both axises together.
	if (table->Flags & ImGuiTableFlags_ScrollX) {
		const float outer_padding_for_border = (table->Flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
		float max_pos_x = table->InnerWindow->DC.CursorMaxPos.x;
		if (table->RightMostEnabledColumn != -1)
			max_pos_x = ImMax(max_pos_x, table->Columns[table->RightMostEnabledColumn].WorkMaxX + table->CellPaddingX + table->OuterPaddingX - outer_padding_for_border);
		if (table->ResizedColumn != -1)
			max_pos_x = ImMax(max_pos_x, table->ResizeLockMinContentsX2);
		table->InnerWindow->DC.CursorMaxPos.x = max_pos_x + table->TempData->AngledHeadersExtraWidth;
	}

	// Pop clipping rect
	if (!(flags & ImGuiTableFlags_NoClip))
		inner_window->DrawList->PopClipRect();
	inner_window->ClipRect = inner_window->DrawList->_ClipRectStack.back();

	// Draw borders
	if ((flags & ImGuiTableFlags_Borders) != 0)
		TableDrawBorders(table);

#if 0
    // Strip out dummy channel draw calls
    // We have no way to prevent user submitting direct ImDrawList calls into a hidden column (but ImGui:: calls will be clipped out)
    // Pros: remove draw calls which will have no effect. since they'll have zero-size cliprect they may be early out anyway.
    // Cons: making it harder for users watching metrics/debugger to spot the wasted vertices.
    if (table->DummyDrawChannel != (ImGuiTableColumnIdx)-1)
    {
        ImDrawChannel* dummy_channel = &table->DrawSplitter._Channels[table->DummyDrawChannel];
        dummy_channel->_CmdBuffer.resize(0);
        dummy_channel->_IdxBuffer.resize(0);
    }
#endif

	// Flatten channels and merge draw calls
	ImDrawListSplitter *splitter = table->DrawSplitter;
	splitter->SetCurrentChannel(inner_window->DrawList, 0);
	if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
		TableMergeDrawChannels(table);
	splitter->Merge(inner_window->DrawList);

	// Update ColumnsAutoFitWidth to get us ahead for host using our size to auto-resize without waiting for next BeginTable()
	float auto_fit_width_for_fixed = 0.0f;
	float auto_fit_width_for_stretched = 0.0f;
	float auto_fit_width_for_stretched_min = 0.0f;
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
		if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n)) {
			ImGuiTableColumn *column = &table->Columns[column_n];
			float column_width_request = ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !(column->Flags & ImGuiTableColumnFlags_NoResize)) ? column->WidthRequest : TableGetColumnWidthAuto(table, column);
			if (column->Flags & ImGuiTableColumnFlags_WidthFixed)
				auto_fit_width_for_fixed += column_width_request;
			else
				auto_fit_width_for_stretched += column_width_request;
			if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) && (column->Flags & ImGuiTableColumnFlags_NoResize) != 0)
				auto_fit_width_for_stretched_min = ImMax(auto_fit_width_for_stretched_min, column_width_request / (column->StretchWeight / table->ColumnsStretchSumWeights));
		}
	const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
	table->ColumnsAutoFitWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount + auto_fit_width_for_fixed + ImMax(auto_fit_width_for_stretched, auto_fit_width_for_stretched_min);

	// Update scroll
	if ((table->Flags & ImGuiTableFlags_ScrollX) == 0 && inner_window != outer_window) {
		inner_window->Scroll.x = 0.0f;
	} else if (table->LastResizedColumn != -1 && table->ResizedColumn == -1 && inner_window->ScrollbarX && table->InstanceInteracted == table->InstanceCurrent) {
		// When releasing a column being resized, scroll to keep the resulting column in sight
		const float neighbor_width_to_keep_visible = table->MinColumnWidth + table->CellPaddingX * 2.0f;
		ImGuiTableColumn *column = &table->Columns[table->LastResizedColumn];
		if (column->MaxX < table->InnerClipRect.Min.x)
			SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x - neighbor_width_to_keep_visible, 1.0f);
		else if (column->MaxX > table->InnerClipRect.Max.x)
			SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x + neighbor_width_to_keep_visible, 1.0f);
	}

	// Apply resizing/dragging at the end of the frame
	if (table->ResizedColumn != -1 && table->InstanceCurrent == table->InstanceInteracted) {
		ImGuiTableColumn *column = &table->Columns[table->ResizedColumn];
		const float new_x2 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale));
		const float new_width = ImTrunc(new_x2 - column->MinX - table->CellSpacingX1 - table->CellPaddingX * 2.0f);
		table->ResizedColumnNextWidth = new_width;
	}

	table->IsActiveIdInTable = (g.ActiveIdIsAlive != 0 && table->IsActiveIdAliveBeforeTable == false);

	// Pop from id stack
	IM_ASSERT_USER_ERROR(inner_window->IDStack.back() == table_instance->TableInstanceID, "Mismatching PushID/PopID!");
	IM_ASSERT_USER_ERROR(outer_window->DC.ItemWidthStack.Size >= temp_data->HostBackupItemWidthStackSize, "Too many PopItemWidth!");
	if (table->InstanceCurrent > 0)
		PopID();
	PopID();

	// Restore window data that we modified
	const ImVec2 backup_outer_max_pos = outer_window->DC.CursorMaxPos;
	inner_window->WorkRect = temp_data->HostBackupWorkRect;
	inner_window->ParentWorkRect = temp_data->HostBackupParentWorkRect;
	inner_window->SkipItems = table->HostSkipItems;
	outer_window->DC.CursorPos = table->OuterRect.Min;
	outer_window->DC.ItemWidth = temp_data->HostBackupItemWidth;
	outer_window->DC.ItemWidthStack.Size = temp_data->HostBackupItemWidthStackSize;
	outer_window->DC.ColumnsOffset = temp_data->HostBackupColumnsOffset;

	// Layout in outer window
	// (FIXME: To allow auto-fit and allow desirable effect of SameLine() we dissociate 'used' vs 'ideal' size by overriding
	// CursorPosPrevLine and CursorMaxPos manually. That should be a more general layout feature, see same problem e.g. #3414)
	if (inner_window != outer_window) {
		short backup_nav_layers_active_mask = inner_window->DC.NavLayersActiveMask;
		inner_window->DC.NavLayersActiveMask |= 1 << ImGuiNavLayer_Main; // So empty table don't appear to navigate differently.
		EndChild();
		inner_window->DC.NavLayersActiveMask = backup_nav_layers_active_mask;
	} else {
		ItemSize(table->OuterRect.GetSize());
		ItemAdd(table->OuterRect, 0);
	}

	// Override declared contents width/height to enable auto-resize while not needlessly adding a scrollbar
	if (table->Flags & ImGuiTableFlags_NoHostExtendX) {
		// FIXME-TABLE: Could we remove this section?
		// ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize is calculated from latest contents
		IM_ASSERT((table->Flags & ImGuiTableFlags_ScrollX) == 0);
		outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth);
	} else if (temp_data->UserOuterSize.x <= 0.0f) {
		// Some references for this: #7651 + tests "table_reported_size", "table_reported_size_outer" equivalent Y block
		// - Checking for ImGuiTableFlags_ScrollX/ScrollY flag makes us a frame ahead when disabling those flags.
		// - FIXME-TABLE: Would make sense to pre-compute expected scrollbar visibility/sizes to generally save a frame of feedback.
		const float inner_content_max_x = table->OuterRect.Min.x + table->ColumnsAutoFitWidth; // Slightly misleading name but used for code symmetry with inner_content_max_y
		const float decoration_size = table->TempData->AngledHeadersExtraWidth + ((table->Flags & ImGuiTableFlags_ScrollY) ? inner_window->ScrollbarSizes.x : 0.0f);
		outer_window->DC.IdealMaxPos.x = ImMax(outer_window->DC.IdealMaxPos.x, inner_content_max_x + decoration_size - temp_data->UserOuterSize.x);
		outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, ImMin(table->OuterRect.Max.x, inner_content_max_x + decoration_size));
	} else {
		outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Max.x);
	}
	if (temp_data->UserOuterSize.y <= 0.0f) {
		const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollX) ? inner_window->ScrollbarSizes.y : 0.0f;
		outer_window->DC.IdealMaxPos.y = ImMax(outer_window->DC.IdealMaxPos.y, inner_content_max_y + decoration_size - temp_data->UserOuterSize.y);
		outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, ImMin(table->OuterRect.Max.y, inner_content_max_y + decoration_size));
	} else {
		// OuterRect.Max.y may already have been pushed downward from the initial value (unless ImGuiTableFlags_NoHostExtendY is set)
		outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, table->OuterRect.Max.y);
	}

	// Save settings
	if (table->IsSettingsDirty)
		TableSaveSettings(table);
	table->IsInitializing = false;

	// Clear or restore current table, if any
	IM_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table);
	IM_ASSERT(g.TablesTempDataStacked > 0);
	temp_data = (--g.TablesTempDataStacked > 0) ? &g.TablesTempData[g.TablesTempDataStacked - 1] : NULL;
	g.CurrentTable = temp_data ? g.Tables.GetByIndex(temp_data->TableIndex) : NULL;
	if (g.CurrentTable) {
		g.CurrentTable->TempData = temp_data;
		g.CurrentTable->DrawSplitter = &temp_data->DrawSplitter;
	}
	outer_window->DC.CurrentTableIdx = g.CurrentTable ? g.Tables.GetIndex(g.CurrentTable) : -1;
	NavUpdateCurrentWindowIsScrollPushableX();
}

// See "COLUMNS SIZING POLICIES" comments at the top of this file
// If (init_width_or_weight <= 0.0f) it is ignored
void ImGui::TableSetupColumn(const char *label, ImGuiTableColumnFlags flags, float init_width_or_weight, ImGuiID user_id) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");
	IM_ASSERT(table->IsLayoutLocked == false && "Need to call call TableSetupColumn() before first row!");
	IM_ASSERT((flags & ImGuiTableColumnFlags_StatusMask_) == 0 && "Illegal to pass StatusMask values to TableSetupColumn()");
	if (table->DeclColumnsCount >= table->ColumnsCount) {
		IM_ASSERT_USER_ERROR(table->DeclColumnsCount < table->ColumnsCount, "Called TableSetupColumn() too many times!");
		return;
	}

	ImGuiTableColumn *column = &table->Columns[table->DeclColumnsCount];
	table->DeclColumnsCount++;

	// Assert when passing a width or weight if policy is entirely left to default, to avoid storing width into weight and vice-versa.
	// Give a grace to users of ImGuiTableFlags_ScrollX.
	if (table->IsDefaultSizingPolicy && (flags & ImGuiTableColumnFlags_WidthMask_) == 0 && (flags & ImGuiTableFlags_ScrollX) == 0)
		IM_ASSERT(init_width_or_weight <= 0.0f && "Can only specify width/weight if sizing policy is set explicitly in either Table or Column.");

	// When passing a width automatically enforce WidthFixed policy
	// (whereas TableSetupColumnFlags would default to WidthAuto if table is not Resizable)
	if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0 && init_width_or_weight > 0.0f)
		if ((table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedFit || (table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
			flags |= ImGuiTableColumnFlags_WidthFixed;
	if (flags & ImGuiTableColumnFlags_AngledHeader) {
		flags |= ImGuiTableColumnFlags_NoHeaderLabel;
		table->AngledHeadersCount++;
	}

	TableSetupColumnFlags(table, column, flags);
	column->UserID = user_id;
	flags = column->Flags;

	// Initialize defaults
	column->InitStretchWeightOrWidth = init_width_or_weight;
	if (table->IsInitializing) {
		// Init width or weight
		if (column->WidthRequest < 0.0f && column->StretchWeight < 0.0f) {
			if ((flags & ImGuiTableColumnFlags_WidthFixed) && init_width_or_weight > 0.0f)
				column->WidthRequest = init_width_or_weight;
			if (flags & ImGuiTableColumnFlags_WidthStretch)
				column->StretchWeight = (init_width_or_weight > 0.0f) ? init_width_or_weight : -1.0f;

			// Disable auto-fit if an explicit width/weight has been specified
			if (init_width_or_weight > 0.0f)
				column->AutoFitQueue = 0x00;
		}

		// Init default visibility/sort state
		if ((flags & ImGuiTableColumnFlags_DefaultHide) && (table->SettingsLoadedFlags & ImGuiTableFlags_Hideable) == 0)
			column->IsUserEnabled = column->IsUserEnabledNextFrame = false;
		if (flags & ImGuiTableColumnFlags_DefaultSort && (table->SettingsLoadedFlags & ImGuiTableFlags_Sortable) == 0) {
			column->SortOrder = 0; // Multiple columns using _DefaultSort will be reassigned unique SortOrder values when building the sort specs.
			column->SortDirection = (column->Flags & ImGuiTableColumnFlags_PreferSortDescending) ? (ImS8)ImGuiSortDirection_Descending : (ImU8)(ImGuiSortDirection_Ascending);
		}
	}

	// Store name (append with zero-terminator in contiguous buffer)
	// FIXME: If we recorded the number of \n in names we could compute header row height
	column->NameOffset = -1;
	if (label != NULL && label[0] != 0) {
		column->NameOffset = (ImS16)table->ColumnsNames.size();
		table->ColumnsNames.append(label, label + strlen(label) + 1);
	}
}

// [Public]
void ImGui::TableSetupScrollFreeze(int columns, int rows) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");
	IM_ASSERT(table->IsLayoutLocked == false && "Need to call TableSetupColumn() before first row!");
	IM_ASSERT(columns >= 0 && columns < IMGUI_TABLE_MAX_COLUMNS);
	IM_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit

	table->FreezeColumnsRequest = (table->Flags & ImGuiTableFlags_ScrollX) ? (ImGuiTableColumnIdx)ImMin(columns, table->ColumnsCount) : 0;
	table->FreezeColumnsCount = (table->InnerWindow->Scroll.x != 0.0f) ? table->FreezeColumnsRequest : 0;
	table->FreezeRowsRequest = (table->Flags & ImGuiTableFlags_ScrollY) ? (ImGuiTableColumnIdx)rows : 0;
	table->FreezeRowsCount = (table->InnerWindow->Scroll.y != 0.0f) ? table->FreezeRowsRequest : 0;
	table->IsUnfrozenRows = (table->FreezeRowsCount == 0); // Make sure this is set before TableUpdateLayout() so ImGuiListClipper can benefit from it.b

	// Ensure frozen columns are ordered in their section. We still allow multiple frozen columns to be reordered.
	// FIXME-TABLE: This work for preserving 2143 into 21|43. How about 4321 turning into 21|43? (preserve relative order in each section)
	for (int column_n = 0; column_n < table->FreezeColumnsRequest; column_n++) {
		int order_n = table->DisplayOrderToIndex[column_n];
		if (order_n != column_n && order_n >= table->FreezeColumnsRequest) {
			ImSwap(table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder, table->Columns[table->DisplayOrderToIndex[column_n]].DisplayOrder);
			ImSwap(table->DisplayOrderToIndex[order_n], table->DisplayOrderToIndex[column_n]);
		}
	}
}

//-----------------------------------------------------------------------------
// [SECTION] Tables: Simple accessors
//-----------------------------------------------------------------------------
// - TableGetColumnCount()
// - TableGetColumnName()
// - TableGetColumnName() [Internal]
// - TableSetColumnEnabled()
// - TableGetColumnFlags()
// - TableGetCellBgRect() [Internal]
// - TableGetColumnResizeID() [Internal]
// - TableGetHoveredColumn() [Internal]
// - TableGetHoveredRow() [Internal]
// - TableSetBgColor()
//-----------------------------------------------------------------------------

int ImGui::TableGetColumnCount() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	return table ? table->ColumnsCount : 0;
}

const char *ImGui::TableGetColumnName(int column_n) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (!table)
		return NULL;
	if (column_n < 0)
		column_n = table->CurrentColumn;
	return TableGetColumnName(table, column_n);
}

const char *ImGui::TableGetColumnName(const ImGuiTable *table, int column_n) {
	if (table->IsLayoutLocked == false && column_n >= table->DeclColumnsCount)
		return ""; // NameOffset is invalid at this point
	const ImGuiTableColumn *column = &table->Columns[column_n];
	if (column->NameOffset == -1)
		return "";
	return &table->ColumnsNames.Buf[column->NameOffset];
}

// Change user accessible enabled/disabled state of a column (often perceived as "showing/hiding" from users point of view)
// Note that end-user can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
// - Require table to have the ImGuiTableFlags_Hideable flag because we are manipulating user accessible state.
// - Request will be applied during next layout, which happens on the first call to TableNextRow() after BeginTable().
// - For the getter you can test (TableGetColumnFlags() & ImGuiTableColumnFlags_IsEnabled) != 0.
// - Alternative: the ImGuiTableColumnFlags_Disabled is an overriding/master disable flag which will also hide the column from context menu.
void ImGui::TableSetColumnEnabled(int column_n, bool enabled) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(table != NULL);
	if (!table)
		return;
	IM_ASSERT(table->Flags & ImGuiTableFlags_Hideable); // See comments above
	if (column_n < 0)
		column_n = table->CurrentColumn;
	IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
	ImGuiTableColumn *column = &table->Columns[column_n];
	column->IsUserEnabledNextFrame = enabled;
}

// We allow querying for an extra column in order to poll the IsHovered state of the right-most section
ImGuiTableColumnFlags ImGui::TableGetColumnFlags(int column_n) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (!table)
		return ImGuiTableColumnFlags_None;
	if (column_n < 0)
		column_n = table->CurrentColumn;
	if (column_n == table->ColumnsCount)
		return (table->HoveredColumnBody == column_n) ? ImGuiTableColumnFlags_IsHovered : ImGuiTableColumnFlags_None;
	return table->Columns[column_n].Flags;
}

// Return the cell rectangle based on currently known height.
// - Important: we generally don't know our row height until the end of the row, so Max.y will be incorrect in many situations.
//   The only case where this is correct is if we provided a min_row_height to TableNextRow() and don't go below it, or in TableEndRow() when we locked that height.
// - Important: if ImGuiTableFlags_PadOuterX is set but ImGuiTableFlags_PadInnerX is not set, the outer-most left and right
//   columns report a small offset so their CellBgRect can extend up to the outer border.
//   FIXME: But the rendering code in TableEndRow() nullifies that with clamping required for scrolling.
ImRect ImGui::TableGetCellBgRect(const ImGuiTable *table, int column_n) {
	const ImGuiTableColumn *column = &table->Columns[column_n];
	float x1 = column->MinX;
	float x2 = column->MaxX;
	//if (column->PrevEnabledColumn == -1)
	//    x1 -= table->OuterPaddingX;
	//if (column->NextEnabledColumn == -1)
	//    x2 += table->OuterPaddingX;
	x1 = ImMax(x1, table->WorkRect.Min.x);
	x2 = ImMin(x2, table->WorkRect.Max.x);
	return ImRect(x1, table->RowPosY1, x2, table->RowPosY2);
}

// Return the resizing ID for the right-side of the given column.
ImGuiID ImGui::TableGetColumnResizeID(ImGuiTable *table, int column_n, int instance_no) {
	IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
	ImGuiID instance_id = TableGetInstanceID(table, instance_no);
	return instance_id + 1 + column_n; // FIXME: #6140: still not ideal
}

// Return -1 when table is not hovered. return columns_count if hovering the unused space at the right of the right-most visible column.
int ImGui::TableGetHoveredColumn() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (!table)
		return -1;
	return (int)table->HoveredColumnBody;
}

// Return -1 when table is not hovered. Return maxrow+1 if in table but below last submitted row.
// *IMPORTANT* Unlike TableGetHoveredColumn(), this has a one frame latency in updating the value.
// This difference with is the reason why this is not public yet.
int ImGui::TableGetHoveredRow() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (!table)
		return -1;
	ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent);
	return (int)table_instance->HoveredRowLast;
}

void ImGui::TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(target != ImGuiTableBgTarget_None);

	if (color == IM_COL32_DISABLE)
		color = 0;

	// We cannot draw neither the cell or row background immediately as we don't know the row height at this point in time.
	switch (target) {
		case ImGuiTableBgTarget_CellBg: {
			if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
				return;
			if (column_n == -1)
				column_n = table->CurrentColumn;
			if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
				return;
			if (table->RowCellDataCurrent < 0 || table->RowCellData[table->RowCellDataCurrent].Column != column_n)
				table->RowCellDataCurrent++;
			ImGuiTableCellData *cell_data = &table->RowCellData[table->RowCellDataCurrent];
			cell_data->BgColor = color;
			cell_data->Column = (ImGuiTableColumnIdx)column_n;
			break;
		}
		case ImGuiTableBgTarget_RowBg0:
		case ImGuiTableBgTarget_RowBg1: {
			if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
				return;
			IM_ASSERT(column_n == -1);
			int bg_idx = (target == ImGuiTableBgTarget_RowBg1) ? 1 : 0;
			table->RowBgColor[bg_idx] = color;
			break;
		}
		default:
			IM_ASSERT(0);
	}
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Row changes
//-------------------------------------------------------------------------
// - TableGetRowIndex()
// - TableNextRow()
// - TableBeginRow() [Internal]
// - TableEndRow() [Internal]
//-------------------------------------------------------------------------

// [Public] Note: for row coloring we use ->RowBgColorCounter which is the same value without counting header rows
int ImGui::TableGetRowIndex() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (!table)
		return 0;
	return table->CurrentRow;
}

// [Public] Starts into the first cell of a new row
void ImGui::TableNextRow(ImGuiTableRowFlags row_flags, float row_min_height) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;

	if (!table->IsLayoutLocked)
		TableUpdateLayout(table);
	if (table->IsInsideRow)
		TableEndRow(table);

	table->LastRowFlags = table->RowFlags;
	table->RowFlags = row_flags;
	table->RowCellPaddingY = g.Style.CellPadding.y;
	table->RowMinHeight = row_min_height;
	TableBeginRow(table);

	// We honor min_row_height requested by user, but cannot guarantee per-row maximum height,
	// because that would essentially require a unique clipping rectangle per-cell.
	table->RowPosY2 += table->RowCellPaddingY * 2.0f;
	table->RowPosY2 = ImMax(table->RowPosY2, table->RowPosY1 + row_min_height);

	// Disable output until user calls TableNextColumn()
	table->InnerWindow->SkipItems = true;
}

// [Internal] Only called by TableNextRow()
void ImGui::TableBeginRow(ImGuiTable *table) {
	ImGuiWindow *window = table->InnerWindow;
	IM_ASSERT(!table->IsInsideRow);

	// New row
	table->CurrentRow++;
	table->CurrentColumn = -1;
	table->RowBgColor[0] = table->RowBgColor[1] = IM_COL32_DISABLE;
	table->RowCellDataCurrent = -1;
	table->IsInsideRow = true;

	// Begin frozen rows
	float next_y1 = table->RowPosY2;
	if (table->CurrentRow == 0 && table->FreezeRowsCount > 0)
		next_y1 = window->DC.CursorPos.y = table->OuterRect.Min.y;

	table->RowPosY1 = table->RowPosY2 = next_y1;
	table->RowTextBaseline = 0.0f;
	table->RowIndentOffsetX = window->DC.Indent.x - table->HostIndentX; // Lock indent

	window->DC.PrevLineTextBaseOffset = 0.0f;
	window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + table->RowCellPaddingY); // This allows users to call SameLine() to share LineSize between columns.
	window->DC.PrevLineSize = window->DC.CurrLineSize = ImVec2(0.0f, 0.0f); // This allows users to call SameLine() to share LineSize between columns, and to call it from first column too.
	window->DC.IsSameLine = window->DC.IsSetPos = false;
	window->DC.CursorMaxPos.y = next_y1;

	// Making the header BG color non-transparent will allow us to overlay it multiple times when handling smooth dragging.
	if (table->RowFlags & ImGuiTableRowFlags_Headers) {
		TableSetBgColor(ImGuiTableBgTarget_RowBg0, GetColorU32(ImGuiCol_TableHeaderBg));
		if (table->CurrentRow == 0)
			table->IsUsingHeaders = true;
	}
}

// [Internal] Called by TableNextRow()
void ImGui::TableEndRow(ImGuiTable *table) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(window == table->InnerWindow);
	IM_ASSERT(table->IsInsideRow);

	if (table->CurrentColumn != -1)
		TableEndCell(table);

	// Logging
	if (g.LogEnabled)
		LogRenderedText(NULL, "|");

	// Position cursor at the bottom of our row so it can be used for e.g. clipping calculation. However it is
	// likely that the next call to TableBeginCell() will reposition the cursor to take account of vertical padding.
	window->DC.CursorPos.y = table->RowPosY2;

	// Row background fill
	const float bg_y1 = table->RowPosY1;
	const float bg_y2 = table->RowPosY2;
	const bool unfreeze_rows_actual = (table->CurrentRow + 1 == table->FreezeRowsCount);
	const bool unfreeze_rows_request = (table->CurrentRow + 1 == table->FreezeRowsRequest);
	ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent);
	if ((table->RowFlags & ImGuiTableRowFlags_Headers) && (table->CurrentRow == 0 || (table->LastRowFlags & ImGuiTableRowFlags_Headers)))
		table_instance->LastTopHeadersRowHeight += bg_y2 - bg_y1;

	const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y && bg_y1 <= table->InnerClipRect.Max.y);
	if (is_visible) {
		// Update data for TableGetHoveredRow()
		if (table->HoveredColumnBody != -1 && g.IO.MousePos.y >= bg_y1 && g.IO.MousePos.y < bg_y2 && table_instance->HoveredRowNext < 0)
			table_instance->HoveredRowNext = table->CurrentRow;

		// Decide of background color for the row
		ImU32 bg_col0 = 0;
		ImU32 bg_col1 = 0;
		if (table->RowBgColor[0] != IM_COL32_DISABLE)
			bg_col0 = table->RowBgColor[0];
		else if (table->Flags & ImGuiTableFlags_RowBg)
			bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? ImGuiCol_TableRowBgAlt : ImGuiCol_TableRowBg);
		if (table->RowBgColor[1] != IM_COL32_DISABLE)
			bg_col1 = table->RowBgColor[1];

		// Decide of top border color
		ImU32 top_border_col = 0;
		const float border_size = TABLE_BORDER_SIZE;
		if (table->CurrentRow > 0 && (table->Flags & ImGuiTableFlags_BordersInnerH))
			top_border_col = (table->LastRowFlags & ImGuiTableRowFlags_Headers) ? table->BorderColorStrong : table->BorderColorLight;

		const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;
		const bool draw_strong_bottom_border = unfreeze_rows_actual;
		if ((bg_col0 | bg_col1 | top_border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color) {
			// In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is
			// always followed by a change of clipping rectangle we perform the smallest overwrite possible here.
			if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
				window->DrawList->_CmdHeader.ClipRect = table->Bg0ClipRectForDrawCmd.ToVec4();
			table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_BG0);
		}

		// Draw row background
		// We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle
		if (bg_col0 || bg_col1) {
			ImRect row_rect(table->WorkRect.Min.x, bg_y1, table->WorkRect.Max.x, bg_y2);
			row_rect.ClipWith(table->BgClipRect);
			if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)
				window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);
			if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)
				window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);
		}

		// Draw cell background color
		if (draw_cell_bg_color) {
			ImGuiTableCellData *cell_data_end = &table->RowCellData[table->RowCellDataCurrent];
			for (ImGuiTableCellData *cell_data = &table->RowCellData[0]; cell_data <= cell_data_end; cell_data++) {
				// As we render the BG here we need to clip things (for layout we would not)
				// FIXME: This cancels the OuterPadding addition done by TableGetCellBgRect(), need to keep it while rendering correctly while scrolling.
				const ImGuiTableColumn *column = &table->Columns[cell_data->Column];
				ImRect cell_bg_rect = TableGetCellBgRect(table, cell_data->Column);
				cell_bg_rect.ClipWith(table->BgClipRect);
				cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column->ClipRect.Min.x); // So that first column after frozen one gets clipped when scrolling
				cell_bg_rect.Max.x = ImMin(cell_bg_rect.Max.x, column->MaxX);
				if (cell_bg_rect.Min.y < cell_bg_rect.Max.y)
					window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max, cell_data->BgColor);
			}
		}

		// Draw top border
		if (top_border_col && bg_y1 >= table->BgClipRect.Min.y && bg_y1 < table->BgClipRect.Max.y)
			window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), top_border_col, border_size);

		// Draw bottom border at the row unfreezing mark (always strong)
		if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y && bg_y2 < table->BgClipRect.Max.y)
			window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);
	}

	// End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)
	// We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and
	// get the new cursor position.
	if (unfreeze_rows_request) {
		for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
			table->Columns[column_n].NavLayerCurrent = ImGuiNavLayer_Main;
		const float y0 = ImMax(table->RowPosY2 + 1, window->InnerClipRect.Min.y);
		table_instance->LastFrozenHeight = y0 - table->OuterRect.Min.y;

		if (unfreeze_rows_actual) {
			IM_ASSERT(table->IsUnfrozenRows == false);
			table->IsUnfrozenRows = true;

			// BgClipRect starts as table->InnerClipRect, reduce it now and make BgClipRectForDrawCmd == BgClipRect
			table->BgClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y = ImMin(y0, window->InnerClipRect.Max.y);
			table->BgClipRect.Max.y = table->Bg2ClipRectForDrawCmd.Max.y = window->InnerClipRect.Max.y;
			table->Bg2DrawChannelCurrent = table->Bg2DrawChannelUnfrozen;
			IM_ASSERT(table->Bg2ClipRectForDrawCmd.Min.y <= table->Bg2ClipRectForDrawCmd.Max.y);

			float row_height = table->RowPosY2 - table->RowPosY1;
			table->RowPosY2 = window->DC.CursorPos.y = table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;
			table->RowPosY1 = table->RowPosY2 - row_height;
			for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
				ImGuiTableColumn *column = &table->Columns[column_n];
				column->DrawChannelCurrent = column->DrawChannelUnfrozen;
				column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;
			}

			// Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y
			SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);
			table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Columns[0].DrawChannelCurrent);
		}
	}

	if (!(table->RowFlags & ImGuiTableRowFlags_Headers))
		table->RowBgColorCounter++;
	table->IsInsideRow = false;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns changes
//-------------------------------------------------------------------------
// - TableGetColumnIndex()
// - TableSetColumnIndex()
// - TableNextColumn()
// - TableBeginCell() [Internal]
// - TableEndCell() [Internal]
//-------------------------------------------------------------------------

int ImGui::TableGetColumnIndex() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (!table)
		return 0;
	return table->CurrentColumn;
}

// [Public] Append into a specific column
bool ImGui::TableSetColumnIndex(int column_n) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (!table)
		return false;

	if (table->CurrentColumn != column_n) {
		if (table->CurrentColumn != -1)
			TableEndCell(table);
		IM_ASSERT(column_n >= 0 && table->ColumnsCount);
		TableBeginCell(table, column_n);
	}

	// Return whether the column is visible. User may choose to skip submitting items based on this return value,
	// however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
	return table->Columns[column_n].IsRequestOutput;
}

// [Public] Append into the next column, wrap and create a new row when already on last column
bool ImGui::TableNextColumn() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (!table)
		return false;

	if (table->IsInsideRow && table->CurrentColumn + 1 < table->ColumnsCount) {
		if (table->CurrentColumn != -1)
			TableEndCell(table);
		TableBeginCell(table, table->CurrentColumn + 1);
	} else {
		TableNextRow();
		TableBeginCell(table, 0);
	}

	// Return whether the column is visible. User may choose to skip submitting items based on this return value,
	// however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
	return table->Columns[table->CurrentColumn].IsRequestOutput;
}

// [Internal] Called by TableSetColumnIndex()/TableNextColumn()
// This is called very frequently, so we need to be mindful of unnecessary overhead.
// FIXME-TABLE FIXME-OPT: Could probably shortcut some things for non-active or clipped columns.
void ImGui::TableBeginCell(ImGuiTable *table, int column_n) {
	ImGuiContext &g = *GImGui;
	ImGuiTableColumn *column = &table->Columns[column_n];
	ImGuiWindow *window = table->InnerWindow;
	table->CurrentColumn = column_n;

	// Start position is roughly ~~ CellRect.Min + CellPadding + Indent
	float start_x = column->WorkMinX;
	if (column->Flags & ImGuiTableColumnFlags_IndentEnable)
		start_x += table->RowIndentOffsetX; // ~~ += window.DC.Indent.x - table->HostIndentX, except we locked it for the row.

	window->DC.CursorPos.x = start_x;
	window->DC.CursorPos.y = table->RowPosY1 + table->RowCellPaddingY;
	window->DC.CursorMaxPos.x = window->DC.CursorPos.x;
	window->DC.ColumnsOffset.x = start_x - window->Pos.x - window->DC.Indent.x; // FIXME-WORKRECT
	window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x; // PrevLine.y is preserved. This allows users to call SameLine() to share LineSize between columns.
	window->DC.CurrLineTextBaseOffset = table->RowTextBaseline;
	window->DC.NavLayerCurrent = (ImGuiNavLayer)column->NavLayerCurrent;

	// Note how WorkRect.Max.y is only set once during layout
	window->WorkRect.Min.y = window->DC.CursorPos.y;
	window->WorkRect.Min.x = column->WorkMinX;
	window->WorkRect.Max.x = column->WorkMaxX;
	window->DC.ItemWidth = column->ItemWidth;

	window->SkipItems = column->IsSkipItems;
	if (column->IsSkipItems) {
		g.LastItemData.ID = 0;
		g.LastItemData.StatusFlags = 0;
	}

	if (table->Flags & ImGuiTableFlags_NoClip) {
		// FIXME: if we end up drawing all borders/bg in EndTable, could remove this and just assert that channel hasn't changed.
		table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
		//IM_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);
	} else {
		// FIXME-TABLE: Could avoid this if draw channel is dummy channel?
		SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
		table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
	}

	// Logging
	if (g.LogEnabled && !column->IsSkipItems) {
		LogRenderedText(&window->DC.CursorPos, "|");
		g.LogLinePosY = FLT_MAX;
	}
}

// [Internal] Called by TableNextRow()/TableSetColumnIndex()/TableNextColumn()
void ImGui::TableEndCell(ImGuiTable *table) {
	ImGuiTableColumn *column = &table->Columns[table->CurrentColumn];
	ImGuiWindow *window = table->InnerWindow;

	if (window->DC.IsSetPos)
		ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

	// Report maximum position so we can infer content size per column.
	float *p_max_pos_x;
	if (table->RowFlags & ImGuiTableRowFlags_Headers)
		p_max_pos_x = &column->ContentMaxXHeadersUsed; // Useful in case user submit contents in header row that is not a TableHeader() call
	else
		p_max_pos_x = table->IsUnfrozenRows ? &column->ContentMaxXUnfrozen : &column->ContentMaxXFrozen;
	*p_max_pos_x = ImMax(*p_max_pos_x, window->DC.CursorMaxPos.x);
	if (column->IsEnabled)
		table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->RowCellPaddingY);
	column->ItemWidth = window->DC.ItemWidth;

	// Propagate text baseline for the entire row
	// FIXME-TABLE: Here we propagate text baseline from the last line of the cell.. instead of the first one.
	table->RowTextBaseline = ImMax(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns width management
//-------------------------------------------------------------------------
// - TableGetMaxColumnWidth() [Internal]
// - TableGetColumnWidthAuto() [Internal]
// - TableSetColumnWidth()
// - TableSetColumnWidthAutoSingle() [Internal]
// - TableSetColumnWidthAutoAll() [Internal]
// - TableUpdateColumnsWeightFromWidth() [Internal]
//-------------------------------------------------------------------------
// Note that actual columns widths are computed in TableUpdateLayout().
//-------------------------------------------------------------------------

// Maximum column content width given current layout. Use column->MinX so this value differs on a per-column basis.
float ImGui::TableCalcMaxColumnWidth(const ImGuiTable *table, int column_n) {
	const ImGuiTableColumn *column = &table->Columns[column_n];
	float max_width = FLT_MAX;
	const float min_column_distance = table->MinColumnWidth + table->CellPaddingX * 2.0f + table->CellSpacingX1 + table->CellSpacingX2;
	if (table->Flags & ImGuiTableFlags_ScrollX) {
		// Frozen columns can't reach beyond visible width else scrolling will naturally break.
		// (we use DisplayOrder as within a set of multiple frozen column reordering is possible)
		if (column->DisplayOrder < table->FreezeColumnsRequest) {
			max_width = (table->InnerClipRect.Max.x - (table->FreezeColumnsRequest - column->DisplayOrder) * min_column_distance) - column->MinX;
			max_width = max_width - table->OuterPaddingX - table->CellPaddingX - table->CellSpacingX2;
		}
	} else if ((table->Flags & ImGuiTableFlags_NoKeepColumnsVisible) == 0) {
		// If horizontal scrolling if disabled, we apply a final lossless shrinking of columns in order to make
		// sure they are all visible. Because of this we also know that all of the columns will always fit in
		// table->WorkRect and therefore in table->InnerRect (because ScrollX is off)
		// FIXME-TABLE: This is solved incorrectly but also quite a difficult problem to fix as we also want ClipRect width to match.
		// See "table_width_distrib" and "table_width_keep_visible" tests
		max_width = table->WorkRect.Max.x - (table->ColumnsEnabledCount - column->IndexWithinEnabledSet - 1) * min_column_distance - column->MinX;
		//max_width -= table->CellSpacingX1;
		max_width -= table->CellSpacingX2;
		max_width -= table->CellPaddingX * 2.0f;
		max_width -= table->OuterPaddingX;
	}
	return max_width;
}

// Note this is meant to be stored in column->WidthAuto, please generally use the WidthAuto field
float ImGui::TableGetColumnWidthAuto(ImGuiTable *table, ImGuiTableColumn *column) {
	const float content_width_body = ImMax(column->ContentMaxXFrozen, column->ContentMaxXUnfrozen) - column->WorkMinX;
	const float content_width_headers = column->ContentMaxXHeadersIdeal - column->WorkMinX;
	float width_auto = content_width_body;
	if (!(column->Flags & ImGuiTableColumnFlags_NoHeaderWidth))
		width_auto = ImMax(width_auto, content_width_headers);

	// Non-resizable fixed columns preserve their requested width
	if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f)
		if (!(table->Flags & ImGuiTableFlags_Resizable) || (column->Flags & ImGuiTableColumnFlags_NoResize))
			width_auto = column->InitStretchWeightOrWidth;

	return ImMax(width_auto, table->MinColumnWidth);
}

// 'width' = inner column width, without padding
void ImGui::TableSetColumnWidth(int column_n, float width) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(table != NULL && table->IsLayoutLocked == false);
	IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
	ImGuiTableColumn *column_0 = &table->Columns[column_n];
	float column_0_width = width;

	// Apply constraints early
	// Compare both requested and actual given width to avoid overwriting requested width when column is stuck (minimum size, bounded)
	IM_ASSERT(table->MinColumnWidth > 0.0f);
	const float min_width = table->MinColumnWidth;
	const float max_width = ImMax(min_width, column_0->WidthMax); // Don't use TableCalcMaxColumnWidth() here as it would rely on MinX from last instance (#7933)
	column_0_width = ImClamp(column_0_width, min_width, max_width);
	if (column_0->WidthGiven == column_0_width || column_0->WidthRequest == column_0_width)
		return;

	//IMGUI_DEBUG_PRINT("TableSetColumnWidth(%d, %.1f->%.1f)\n", column_0_idx, column_0->WidthGiven, column_0_width);
	ImGuiTableColumn *column_1 = (column_0->NextEnabledColumn != -1) ? &table->Columns[column_0->NextEnabledColumn] : NULL;

	// In this surprisingly not simple because of how we support mixing Fixed and multiple Stretch columns.
	// - All fixed: easy.
	// - All stretch: easy.
	// - One or more fixed + one stretch: easy.
	// - One or more fixed + more than one stretch: tricky.
	// Qt when manual resize is enabled only supports a single _trailing_ stretch column, we support more cases here.

	// When forwarding resize from Wn| to Fn+1| we need to be considerate of the _NoResize flag on Fn+1.
	// FIXME-TABLE: Find a way to rewrite all of this so interactions feel more consistent for the user.
	// Scenarios:
	// - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. Subsequent columns will be offset.
	// - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered.
	// - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered, but it doesn't make much sense as the Stretch column will always be minimal size.
	// - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
	// - W1 W2 W3  resize from W1| or W2|   --> ok
	// - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
	// - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule 1)
	// - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule 1)
	// - W1 W2 F3  resize from W1| or W2|   --> ok
	// - W1 F2 W3  resize from W1| or F2|   --> ok
	// - F1 W2 F3  resize from W2|          --> ok
	// - F1 W3 F2  resize from W3|          --> ok
	// - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3 will not move.
	// - W1 F2 F3  resize from F2|          --> ok
	// All resizes from a Wx columns are locking other columns.

	// Possible improvements:
	// - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3 would stretch down. Seems possible to fix. Would be most beneficial to simplify resize of all-weighted columns.
	// - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1 and F2 would need to stretch down, which would be lossy or ambiguous. Seems hard to fix.

	// [Resize Rule 1] Can't resize from right of right-most visible column if there is any Stretch column. Implemented in TableUpdateLayout().

	// If we have all Fixed columns OR resizing a Fixed column that doesn't come after a Stretch one, we can do an offsetting resize.
	// This is the preferred resize path
	if (column_0->Flags & ImGuiTableColumnFlags_WidthFixed)
		if (!column_1 || table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder >= column_0->DisplayOrder) {
			column_0->WidthRequest = column_0_width;
			table->IsSettingsDirty = true;
			return;
		}

	// We can also use previous column if there's no next one (this is used when doing an auto-fit on the right-most stretch column)
	if (column_1 == NULL)
		column_1 = (column_0->PrevEnabledColumn != -1) ? &table->Columns[column_0->PrevEnabledColumn] : NULL;
	if (column_1 == NULL)
		return;

	// Resizing from right-side of a Stretch column before a Fixed column forward sizing to left-side of fixed column.
	// (old_a + old_b == new_a + new_b) --> (new_a == old_a + old_b - new_b)
	float column_1_width = ImMax(column_1->WidthRequest - (column_0_width - column_0->WidthRequest), min_width);
	column_0_width = column_0->WidthRequest + column_1->WidthRequest - column_1_width;
	IM_ASSERT(column_0_width > 0.0f && column_1_width > 0.0f);
	column_0->WidthRequest = column_0_width;
	column_1->WidthRequest = column_1_width;
	if ((column_0->Flags | column_1->Flags) & ImGuiTableColumnFlags_WidthStretch)
		TableUpdateColumnsWeightFromWidth(table);
	table->IsSettingsDirty = true;
}

// Disable clipping then auto-fit, will take 2 frames
// (we don't take a shortcut for unclipped columns to reduce inconsistencies when e.g. resizing multiple columns)
void ImGui::TableSetColumnWidthAutoSingle(ImGuiTable *table, int column_n) {
	// Single auto width uses auto-fit
	ImGuiTableColumn *column = &table->Columns[column_n];
	if (!column->IsEnabled)
		return;
	column->CannotSkipItemsQueue = (1 << 0);
	table->AutoFitSingleColumn = (ImGuiTableColumnIdx)column_n;
}

void ImGui::TableSetColumnWidthAutoAll(ImGuiTable *table) {
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
		ImGuiTableColumn *column = &table->Columns[column_n];
		if (!column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_WidthStretch)) // Cannot reset weight of hidden stretch column
			continue;
		column->CannotSkipItemsQueue = (1 << 0);
		column->AutoFitQueue = (1 << 1);
	}
}

void ImGui::TableUpdateColumnsWeightFromWidth(ImGuiTable *table) {
	IM_ASSERT(table->LeftMostStretchedColumn != -1 && table->RightMostStretchedColumn != -1);

	// Measure existing quantities
	float visible_weight = 0.0f;
	float visible_width = 0.0f;
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
		ImGuiTableColumn *column = &table->Columns[column_n];
		if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
			continue;
		IM_ASSERT(column->StretchWeight > 0.0f);
		visible_weight += column->StretchWeight;
		visible_width += column->WidthRequest;
	}
	IM_ASSERT(visible_weight > 0.0f && visible_width > 0.0f);

	// Apply new weights
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
		ImGuiTableColumn *column = &table->Columns[column_n];
		if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
			continue;
		column->StretchWeight = (column->WidthRequest / visible_width) * visible_weight;
		IM_ASSERT(column->StretchWeight > 0.0f);
	}
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Drawing
//-------------------------------------------------------------------------
// - TablePushBackgroundChannel() [Internal]
// - TablePopBackgroundChannel() [Internal]
// - TableSetupDrawChannels() [Internal]
// - TableMergeDrawChannels() [Internal]
// - TableGetColumnBorderCol() [Internal]
// - TableDrawBorders() [Internal]
//-------------------------------------------------------------------------

// Bg2 is used by Selectable (and possibly other widgets) to render to the background.
// Unlike our Bg0/1 channel which we uses for RowBg/CellBg/Borders and where we guarantee all shapes to be CPU-clipped, the Bg2 channel being widgets-facing will rely on regular ClipRect.
void ImGui::TablePushBackgroundChannel() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiTable *table = g.CurrentTable;

	// Optimization: avoid SetCurrentChannel() + PushClipRect()
	table->HostBackupInnerClipRect = window->ClipRect;
	SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);
	table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);
}

void ImGui::TablePopBackgroundChannel() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiTable *table = g.CurrentTable;
	ImGuiTableColumn *column = &table->Columns[table->CurrentColumn];

	// Optimization: avoid PopClipRect() + SetCurrentChannel()
	SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);
	table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
}

// Allocate draw channels. Called by TableUpdateLayout()
// - We allocate them following storage order instead of display order so reordering columns won't needlessly
//   increase overall dormant memory cost.
// - We isolate headers draw commands in their own channels instead of just altering clip rects.
//   This is in order to facilitate merging of draw commands.
// - After crossing FreezeRowsCount, all columns see their current draw channel changed to a second set of channels.
// - We only use the dummy draw channel so we can push a null clipping rectangle into it without affecting other
//   channels, while simplifying per-row/per-cell overhead. It will be empty and discarded when merged.
// - We allocate 1 or 2 background draw channels. This is because we know TablePushBackgroundChannel() is only used for
//   horizontal spanning. If we allowed vertical spanning we'd need one background draw channel per merge group (1-4).
// Draw channel allocation (before merging):
// - NoClip                       --> 2+D+1 channels: bg0/1 + bg2 + foreground (same clip rect == always 1 draw call)
// - Clip                         --> 2+D+N channels
// - FreezeRows                   --> 2+D+N*2 (unless scrolling value is zero)
// - FreezeRows || FreezeColunns  --> 3+D+N*2 (unless scrolling value is zero)
// Where D is 1 if any column is clipped or hidden (dummy channel) otherwise 0.
void ImGui::TableSetupDrawChannels(ImGuiTable *table) {
	const int freeze_row_multiplier = (table->FreezeRowsCount > 0) ? 2 : 1;
	const int channels_for_row = (table->Flags & ImGuiTableFlags_NoClip) ? 1 : table->ColumnsEnabledCount;
	const int channels_for_bg = 1 + 1 * freeze_row_multiplier;
	const int channels_for_dummy = (table->ColumnsEnabledCount < table->ColumnsCount || (memcmp(table->VisibleMaskByIndex, table->EnabledMaskByIndex, ImBitArrayGetStorageSizeInBytes(table->ColumnsCount)) != 0)) ? +1 : 0;
	const int channels_total = channels_for_bg + (channels_for_row * freeze_row_multiplier) + channels_for_dummy;
	table->DrawSplitter->Split(table->InnerWindow->DrawList, channels_total);
	table->DummyDrawChannel = (ImGuiTableDrawChannelIdx)((channels_for_dummy > 0) ? channels_total - 1 : -1);
	table->Bg2DrawChannelCurrent = TABLE_DRAW_CHANNEL_BG2_FROZEN;
	table->Bg2DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)((table->FreezeRowsCount > 0) ? 2 + channels_for_row : TABLE_DRAW_CHANNEL_BG2_FROZEN);

	int draw_channel_current = 2;
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
		ImGuiTableColumn *column = &table->Columns[column_n];
		if (column->IsVisibleX && column->IsVisibleY) {
			column->DrawChannelFrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current);
			column->DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current + (table->FreezeRowsCount > 0 ? channels_for_row + 1 : 0));
			if (!(table->Flags & ImGuiTableFlags_NoClip))
				draw_channel_current++;
		} else {
			column->DrawChannelFrozen = column->DrawChannelUnfrozen = table->DummyDrawChannel;
		}
		column->DrawChannelCurrent = column->DrawChannelFrozen;
	}

	// Initial draw cmd starts with a BgClipRect that matches the one of its host, to facilitate merge draw commands by default.
	// All our cell highlight are manually clipped with BgClipRect. When unfreezing it will be made smaller to fit scrolling rect.
	// (This technically isn't part of setting up draw channels, but is reasonably related to be done here)
	table->BgClipRect = table->InnerClipRect;
	table->Bg0ClipRectForDrawCmd = table->OuterWindow->ClipRect;
	table->Bg2ClipRectForDrawCmd = table->HostClipRect;
	IM_ASSERT(table->BgClipRect.Min.y <= table->BgClipRect.Max.y);
}

// This function reorder draw channels based on matching clip rectangle, to facilitate merging them. Called by EndTable().
// For simplicity we call it TableMergeDrawChannels() but in fact it only reorder channels + overwrite ClipRect,
// actual merging is done by table->DrawSplitter.Merge() which is called right after TableMergeDrawChannels().
//
// Columns where the contents didn't stray off their local clip rectangle can be merged. To achieve
// this we merge their clip rect and make them contiguous in the channel list, so they can be merged
// by the call to DrawSplitter.Merge() following to the call to this function.
// We reorder draw commands by arranging them into a maximum of 4 distinct groups:
//
//   1 group:               2 groups:              2 groups:              4 groups:
//   [ 0. ] no freeze       [ 0. ] row freeze      [ 01 ] col freeze      [ 01 ] row+col freeze
//   [ .. ]  or no scroll   [ 2. ]  and v-scroll   [ .. ]  and h-scroll   [ 23 ]  and v+h-scroll
//
// Each column itself can use 1 channel (row freeze disabled) or 2 channels (row freeze enabled).
// When the contents of a column didn't stray off its limit, we move its channels into the corresponding group
// based on its position (within frozen rows/columns groups or not).
// At the end of the operation our 1-4 groups will each have a ImDrawCmd using the same ClipRect.
// This function assume that each column are pointing to a distinct draw channel,
// otherwise merge_group->ChannelsCount will not match set bit count of merge_group->ChannelsMask.
//
// Column channels will not be merged into one of the 1-4 groups in the following cases:
// - The contents stray off its clipping rectangle (we only compare the MaxX value, not the MinX value).
//   Direct ImDrawList calls won't be taken into account by default, if you use them make sure the ImGui:: bounds
//   matches, by e.g. calling SetCursorScreenPos().
// - The channel uses more than one draw command itself. We drop all our attempt at merging stuff here..
//   we could do better but it's going to be rare and probably not worth the hassle.
// Columns for which the draw channel(s) haven't been merged with other will use their own ImDrawCmd.
//
// This function is particularly tricky to understand.. take a breath.
void ImGui::TableMergeDrawChannels(ImGuiTable *table) {
	ImGuiContext &g = *GImGui;
	ImDrawListSplitter *splitter = table->DrawSplitter;
	const bool has_freeze_v = (table->FreezeRowsCount > 0);
	const bool has_freeze_h = (table->FreezeColumnsCount > 0);
	IM_ASSERT(splitter->_Current == 0);

	// Track which groups we are going to attempt to merge, and which channels goes into each group.
	struct MergeGroup {
		ImRect ClipRect;
		int ChannelsCount = 0;
		ImBitArrayPtr ChannelsMask = NULL;
	};
	int merge_group_mask = 0x00;
	MergeGroup merge_groups[4];

	// Use a reusable temp buffer for the merge masks as they are dynamically sized.
	const int max_draw_channels = (4 + table->ColumnsCount * 2);
	const int size_for_masks_bitarrays_one = (int)ImBitArrayGetStorageSizeInBytes(max_draw_channels);
	g.TempBuffer.reserve(size_for_masks_bitarrays_one * 5);
	memset(g.TempBuffer.Data, 0, size_for_masks_bitarrays_one * 5);
	for (int n = 0; n < IM_ARRAYSIZE(merge_groups); n++)
		merge_groups[n].ChannelsMask = (ImBitArrayPtr)(void *)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * n));
	ImBitArrayPtr remaining_mask = (ImBitArrayPtr)(void *)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * 4));

	// 1. Scan channels and take note of those which can be merged
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
		if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
			continue;
		ImGuiTableColumn *column = &table->Columns[column_n];

		const int merge_group_sub_count = has_freeze_v ? 2 : 1;
		for (int merge_group_sub_n = 0; merge_group_sub_n < merge_group_sub_count; merge_group_sub_n++) {
			const int channel_no = (merge_group_sub_n == 0) ? column->DrawChannelFrozen : column->DrawChannelUnfrozen;

			// Don't attempt to merge if there are multiple draw calls within the column
			ImDrawChannel *src_channel = &splitter->_Channels[channel_no];
			if (src_channel->_CmdBuffer.Size > 0 && src_channel->_CmdBuffer.back().ElemCount == 0 && src_channel->_CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
				src_channel->_CmdBuffer.pop_back();
			if (src_channel->_CmdBuffer.Size != 1)
				continue;

			// Find out the width of this merge group and check if it will fit in our column
			// (note that we assume that rendering didn't stray on the left direction. we should need a CursorMinPos to detect it)
			if (!(column->Flags & ImGuiTableColumnFlags_NoClip)) {
				float content_max_x;
				if (!has_freeze_v)
					content_max_x = ImMax(column->ContentMaxXUnfrozen, column->ContentMaxXHeadersUsed); // No row freeze
				else if (merge_group_sub_n == 0)
					content_max_x = ImMax(column->ContentMaxXFrozen, column->ContentMaxXHeadersUsed); // Row freeze: use width before freeze
				else
					content_max_x = column->ContentMaxXUnfrozen; // Row freeze: use width after freeze
				if (content_max_x > column->ClipRect.Max.x)
					continue;
			}

			const int merge_group_n = (has_freeze_h && column_n < table->FreezeColumnsCount ? 0 : 1) + (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2);
			IM_ASSERT(channel_no < max_draw_channels);
			MergeGroup *merge_group = &merge_groups[merge_group_n];
			if (merge_group->ChannelsCount == 0)
				merge_group->ClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
			ImBitArraySetBit(merge_group->ChannelsMask, channel_no);
			merge_group->ChannelsCount++;
			merge_group->ClipRect.Add(src_channel->_CmdBuffer[0].ClipRect);
			merge_group_mask |= (1 << merge_group_n);
		}

		// Invalidate current draw channel
		// (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to facilitate debugging/later inspection of data)
		column->DrawChannelCurrent = (ImGuiTableDrawChannelIdx)-1;
	}

	// [DEBUG] Display merge groups
#if 0
    if (g.IO.KeyShift)
        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
        {
            MergeGroup* merge_group = &merge_groups[merge_group_n];
            if (merge_group->ChannelsCount == 0)
                continue;
            char buf[32];
            ImFormatString(buf, 32, "MG%d:%d", merge_group_n, merge_group->ChannelsCount);
            ImVec2 text_pos = merge_group->ClipRect.Min + ImVec2(4, 4);
            ImVec2 text_size = CalcTextSize(buf, NULL);
            GetForegroundDrawList()->AddRectFilled(text_pos, text_pos + text_size, IM_COL32(0, 0, 0, 255));
            GetForegroundDrawList()->AddText(text_pos, IM_COL32(255, 255, 0, 255), buf, NULL);
            GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 255, 0, 255));
        }
#endif

	// 2. Rewrite channel list in our preferred order
	if (merge_group_mask != 0) {
		// We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since they won't move - see channels allocation in TableSetupDrawChannels().
		const int LEADING_DRAW_CHANNELS = 2;
		g.DrawChannelsTempMergeBuffer.resize(splitter->_Count - LEADING_DRAW_CHANNELS); // Use shared temporary storage so the allocation gets amortized
		ImDrawChannel *dst_tmp = g.DrawChannelsTempMergeBuffer.Data;
		ImBitArraySetBitRange(remaining_mask, LEADING_DRAW_CHANNELS, splitter->_Count);
		ImBitArrayClearBit(remaining_mask, table->Bg2DrawChannelUnfrozen);
		IM_ASSERT(has_freeze_v == false || table->Bg2DrawChannelUnfrozen != TABLE_DRAW_CHANNEL_BG2_FROZEN);
		int remaining_count = splitter->_Count - (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS);
		//ImRect host_rect = (table->InnerWindow == table->OuterWindow) ? table->InnerClipRect : table->HostClipRect;
		ImRect host_rect = table->HostClipRect;
		for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++) {
			if (int merge_channels_count = merge_groups[merge_group_n].ChannelsCount) {
				MergeGroup *merge_group = &merge_groups[merge_group_n];
				ImRect merge_clip_rect = merge_group->ClipRect;

				// Extend outer-most clip limits to match those of host, so draw calls can be merged even if
				// outer-most columns have some outer padding offsetting them from their parent ClipRect.
				// The principal cases this is dealing with are:
				// - On a same-window table (not scrolling = single group), all fitting columns ClipRect -> will extend and match host ClipRect -> will merge
				// - Columns can use padding and have left-most ClipRect.Min.x and right-most ClipRect.Max.x != from host ClipRect -> will extend and match host ClipRect -> will merge
				// FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on tables without scrolling if column doesn't fit
				// within host clip rect, solely because of the half-padding difference between window->WorkRect and window->InnerClipRect.
				if ((merge_group_n & 1) == 0 || !has_freeze_h)
					merge_clip_rect.Min.x = ImMin(merge_clip_rect.Min.x, host_rect.Min.x);
				if ((merge_group_n & 2) == 0 || !has_freeze_v)
					merge_clip_rect.Min.y = ImMin(merge_clip_rect.Min.y, host_rect.Min.y);
				if ((merge_group_n & 1) != 0)
					merge_clip_rect.Max.x = ImMax(merge_clip_rect.Max.x, host_rect.Max.x);
				if ((merge_group_n & 2) != 0 && (table->Flags & ImGuiTableFlags_NoHostExtendY) == 0)
					merge_clip_rect.Max.y = ImMax(merge_clip_rect.Max.y, host_rect.Max.y);
				//GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f); // [DEBUG]
				//GetForegroundDrawList()->AddLine(merge_group->ClipRect.Min, merge_clip_rect.Min, IM_COL32(255, 100, 0, 200));
				//GetForegroundDrawList()->AddLine(merge_group->ClipRect.Max, merge_clip_rect.Max, IM_COL32(255, 100, 0, 200));
				remaining_count -= merge_group->ChannelsCount;
				for (int n = 0; n < (size_for_masks_bitarrays_one >> 2); n++)
					remaining_mask[n] &= ~merge_group->ChannelsMask[n];
				for (int n = 0; n < splitter->_Count && merge_channels_count != 0; n++) {
					// Copy + overwrite new clip rect
					if (!IM_BITARRAY_TESTBIT(merge_group->ChannelsMask, n))
						continue;
					IM_BITARRAY_CLEARBIT(merge_group->ChannelsMask, n);
					merge_channels_count--;

					ImDrawChannel *channel = &splitter->_Channels[n];
					IM_ASSERT(channel->_CmdBuffer.Size == 1 && merge_clip_rect.Contains(ImRect(channel->_CmdBuffer[0].ClipRect)));
					channel->_CmdBuffer[0].ClipRect = merge_clip_rect.ToVec4();
					memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
				}
			}

			// Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)
			if (merge_group_n == 1 && has_freeze_v)
				memcpy(dst_tmp++, &splitter->_Channels[table->Bg2DrawChannelUnfrozen], sizeof(ImDrawChannel));
		}

		// Append unmergeable channels that we didn't reorder at the end of the list
		for (int n = 0; n < splitter->_Count && remaining_count != 0; n++) {
			if (!IM_BITARRAY_TESTBIT(remaining_mask, n))
				continue;
			ImDrawChannel *channel = &splitter->_Channels[n];
			memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
			remaining_count--;
		}
		IM_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data + g.DrawChannelsTempMergeBuffer.Size);
		memcpy(splitter->_Channels.Data + LEADING_DRAW_CHANNELS, g.DrawChannelsTempMergeBuffer.Data, (splitter->_Count - LEADING_DRAW_CHANNELS) * sizeof(ImDrawChannel));
	}
}

static ImU32 TableGetColumnBorderCol(ImGuiTable *table, int order_n, int column_n) {
	const bool is_hovered = (table->HoveredColumnBorder == column_n);
	const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);
	const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
	if (is_resized || is_hovered)
		return ImGui::GetColorU32(is_resized ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);
	if (is_frozen_separator || (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)))
		return table->BorderColorStrong;
	return table->BorderColorLight;
}

// FIXME-TABLE: This is a mess, need to redesign how we render borders (as some are also done in TableEndRow)
void ImGui::TableDrawBorders(ImGuiTable *table) {
	ImGuiWindow *inner_window = table->InnerWindow;
	if (!table->OuterWindow->ClipRect.Overlaps(table->OuterRect))
		return;

	ImDrawList *inner_drawlist = inner_window->DrawList;
	table->DrawSplitter->SetCurrentChannel(inner_drawlist, TABLE_DRAW_CHANNEL_BG0);
	inner_drawlist->PushClipRect(table->Bg0ClipRectForDrawCmd.Min, table->Bg0ClipRectForDrawCmd.Max, false);

	// Draw inner border and resizing feedback
	ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent);
	const float border_size = TABLE_BORDER_SIZE;
	const float draw_y1 = ImMax(table->InnerRect.Min.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table->AngledHeadersHeight) + ((table->Flags & ImGuiTableFlags_BordersOuterH) ? 1.0f : 0.0f);
	const float draw_y2_body = table->InnerRect.Max.y;
	const float draw_y2_head = table->IsUsingHeaders ? ImMin(table->InnerRect.Max.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table_instance->LastTopHeadersRowHeight) : draw_y1;
	if (table->Flags & ImGuiTableFlags_BordersInnerV) {
		for (int order_n = 0; order_n < table->ColumnsCount; order_n++) {
			if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
				continue;

			const int column_n = table->DisplayOrderToIndex[order_n];
			ImGuiTableColumn *column = &table->Columns[column_n];
			const bool is_hovered = (table->HoveredColumnBorder == column_n);
			const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);
			const bool is_resizable = (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_)) == 0;
			const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
			if (column->MaxX > table->InnerClipRect.Max.x && !is_resized)
				continue;

			// Decide whether right-most column is visible
			if (column->NextEnabledColumn == -1 && !is_resizable)
				if ((table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame || (table->Flags & ImGuiTableFlags_NoHostExtendX))
					continue;
			if (column->MaxX <= column->ClipRect.Min.x) // FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is problematic if we want to increase the border size..
				continue;

			// Draw in outer window so right-most column won't be clipped
			// Always draw full height border when being resized/hovered, or on the delimitation of frozen column scrolling.
			float draw_y2 = (is_hovered || is_resized || is_frozen_separator || (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) == 0) ? draw_y2_body : draw_y2_head;
			if (draw_y2 > draw_y1)
				inner_drawlist->AddLine(ImVec2(column->MaxX, draw_y1), ImVec2(column->MaxX, draw_y2), TableGetColumnBorderCol(table, order_n, column_n), border_size);
		}
	}

	// Draw outer border
	// FIXME: could use AddRect or explicit VLine/HLine helper?
	if (table->Flags & ImGuiTableFlags_BordersOuter) {
		// Display outer border offset by 1 which is a simple way to display it without adding an extra draw call
		// (Without the offset, in outer_window it would be rendered behind cells, because child windows are above their
		// parent. In inner_window, it won't reach out over scrollbars. Another weird solution would be to display part
		// of it in inner window, and the part that's over scrollbars in the outer window..)
		// Either solution currently won't allow us to use a larger border size: the border would clipped.
		const ImRect outer_border = table->OuterRect;
		const ImU32 outer_col = table->BorderColorStrong;
		if ((table->Flags & ImGuiTableFlags_BordersOuter) == ImGuiTableFlags_BordersOuter) {
			inner_drawlist->AddRect(outer_border.Min, outer_border.Max, outer_col, 0.0f, 0, border_size);
		} else if (table->Flags & ImGuiTableFlags_BordersOuterV) {
			inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Min.x, outer_border.Max.y), outer_col, border_size);
			inner_drawlist->AddLine(ImVec2(outer_border.Max.x, outer_border.Min.y), outer_border.Max, outer_col, border_size);
		} else if (table->Flags & ImGuiTableFlags_BordersOuterH) {
			inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Max.x, outer_border.Min.y), outer_col, border_size);
			inner_drawlist->AddLine(ImVec2(outer_border.Min.x, outer_border.Max.y), outer_border.Max, outer_col, border_size);
		}
	}
	if ((table->Flags & ImGuiTableFlags_BordersInnerH) && table->RowPosY2 < table->OuterRect.Max.y) {
		// Draw bottom-most row border between it is above outer border.
		const float border_y = table->RowPosY2;
		if (border_y >= table->BgClipRect.Min.y && border_y < table->BgClipRect.Max.y)
			inner_drawlist->AddLine(ImVec2(table->BorderX1, border_y), ImVec2(table->BorderX2, border_y), table->BorderColorLight, border_size);
	}

	inner_drawlist->PopClipRect();
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Sorting
//-------------------------------------------------------------------------
// - TableGetSortSpecs()
// - TableFixColumnSortDirection() [Internal]
// - TableGetColumnNextSortDirection() [Internal]
// - TableSetColumnSortDirection() [Internal]
// - TableSortSpecsSanitize() [Internal]
// - TableSortSpecsBuild() [Internal]
//-------------------------------------------------------------------------

// Return NULL if no sort specs (most often when ImGuiTableFlags_Sortable is not set)
// When 'sort_specs->SpecsDirty == true' you should sort your data. It will be true when sorting specs have
// changed since last call, or the first time. Make sure to set 'SpecsDirty = false' after sorting,
// else you may wastefully sort your data every frame!
// Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable()!
ImGuiTableSortSpecs *ImGui::TableGetSortSpecs() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(table != NULL);

	if (!(table->Flags & ImGuiTableFlags_Sortable))
		return NULL;

	// Require layout (in case TableHeadersRow() hasn't been called) as it may alter IsSortSpecsDirty in some paths.
	if (!table->IsLayoutLocked)
		TableUpdateLayout(table);

	TableSortSpecsBuild(table);
	return &table->SortSpecs;
}

static inline ImGuiSortDirection TableGetColumnAvailSortDirection(ImGuiTableColumn *column, int n) {
	IM_ASSERT(n < column->SortDirectionsAvailCount);
	return (ImGuiSortDirection)((column->SortDirectionsAvailList >> (n << 1)) & 0x03);
}

// Fix sort direction if currently set on a value which is unavailable (e.g. activating NoSortAscending/NoSortDescending)
void ImGui::TableFixColumnSortDirection(ImGuiTable *table, ImGuiTableColumn *column) {
	if (column->SortOrder == -1 || (column->SortDirectionsAvailMask & (1 << column->SortDirection)) != 0)
		return;
	column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
	table->IsSortSpecsDirty = true;
}

// Calculate next sort direction that would be set after clicking the column
// - If the PreferSortDescending flag is set, we will default to a Descending direction on the first click.
// - Note that the PreferSortAscending flag is never checked, it is essentially the default and therefore a no-op.
IM_STATIC_ASSERT(ImGuiSortDirection_None == 0 && ImGuiSortDirection_Ascending == 1 && ImGuiSortDirection_Descending == 2);
ImGuiSortDirection ImGui::TableGetColumnNextSortDirection(ImGuiTableColumn *column) {
	IM_ASSERT(column->SortDirectionsAvailCount > 0);
	if (column->SortOrder == -1)
		return TableGetColumnAvailSortDirection(column, 0);
	for (int n = 0; n < 3; n++)
		if (column->SortDirection == TableGetColumnAvailSortDirection(column, n))
			return TableGetColumnAvailSortDirection(column, (n + 1) % column->SortDirectionsAvailCount);
	IM_ASSERT(0);
	return ImGuiSortDirection_None;
}

// Note that the NoSortAscending/NoSortDescending flags are processed in TableSortSpecsSanitize(), and they may change/revert
// the value of SortDirection. We could technically also do it here but it would be unnecessary and duplicate code.
void ImGui::TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;

	if (!(table->Flags & ImGuiTableFlags_SortMulti))
		append_to_sort_specs = false;
	if (!(table->Flags & ImGuiTableFlags_SortTristate))
		IM_ASSERT(sort_direction != ImGuiSortDirection_None);

	ImGuiTableColumnIdx sort_order_max = 0;
	if (append_to_sort_specs)
		for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
			sort_order_max = ImMax(sort_order_max, table->Columns[other_column_n].SortOrder);

	ImGuiTableColumn *column = &table->Columns[column_n];
	column->SortDirection = (ImU8)sort_direction;
	if (column->SortDirection == ImGuiSortDirection_None)
		column->SortOrder = -1;
	else if (column->SortOrder == -1 || !append_to_sort_specs)
		column->SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0;

	for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++) {
		ImGuiTableColumn *other_column = &table->Columns[other_column_n];
		if (other_column != column && !append_to_sort_specs)
			other_column->SortOrder = -1;
		TableFixColumnSortDirection(table, other_column);
	}
	table->IsSettingsDirty = true;
	table->IsSortSpecsDirty = true;
}

void ImGui::TableSortSpecsSanitize(ImGuiTable *table) {
	IM_ASSERT(table->Flags & ImGuiTableFlags_Sortable);

	// Clear SortOrder from hidden column and verify that there's no gap or duplicate.
	int sort_order_count = 0;
	ImU64 sort_order_mask = 0x00;
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
		ImGuiTableColumn *column = &table->Columns[column_n];
		if (column->SortOrder != -1 && !column->IsEnabled)
			column->SortOrder = -1;
		if (column->SortOrder == -1)
			continue;
		sort_order_count++;
		sort_order_mask |= ((ImU64)1 << column->SortOrder);
		IM_ASSERT(sort_order_count < (int)sizeof(sort_order_mask) * 8);
	}

	const bool need_fix_linearize = ((ImU64)1 << sort_order_count) != (sort_order_mask + 1);
	const bool need_fix_single_sort_order = (sort_order_count > 1) && !(table->Flags & ImGuiTableFlags_SortMulti);
	if (need_fix_linearize || need_fix_single_sort_order) {
		ImU64 fixed_mask = 0x00;
		for (int sort_n = 0; sort_n < sort_order_count; sort_n++) {
			// Fix: Rewrite sort order fields if needed so they have no gap or duplicate.
			// (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists --> rewrite then as SortOrder 0..1)
			int column_with_smallest_sort_order = -1;
			for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
				if ((fixed_mask & ((ImU64)1 << (ImU64)column_n)) == 0 && table->Columns[column_n].SortOrder != -1)
					if (column_with_smallest_sort_order == -1 || table->Columns[column_n].SortOrder < table->Columns[column_with_smallest_sort_order].SortOrder)
						column_with_smallest_sort_order = column_n;
			IM_ASSERT(column_with_smallest_sort_order != -1);
			fixed_mask |= ((ImU64)1 << column_with_smallest_sort_order);
			table->Columns[column_with_smallest_sort_order].SortOrder = (ImGuiTableColumnIdx)sort_n;

			// Fix: Make sure only one column has a SortOrder if ImGuiTableFlags_MultiSortable is not set.
			if (need_fix_single_sort_order) {
				sort_order_count = 1;
				for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
					if (column_n != column_with_smallest_sort_order)
						table->Columns[column_n].SortOrder = -1;
				break;
			}
		}
	}

	// Fallback default sort order (if no column with the ImGuiTableColumnFlags_DefaultSort flag)
	if (sort_order_count == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
		for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
			ImGuiTableColumn *column = &table->Columns[column_n];
			if (column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_NoSort)) {
				sort_order_count = 1;
				column->SortOrder = 0;
				column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
				break;
			}
		}

	table->SortSpecsCount = (ImGuiTableColumnIdx)sort_order_count;
}

void ImGui::TableSortSpecsBuild(ImGuiTable *table) {
	bool dirty = table->IsSortSpecsDirty;
	if (dirty) {
		TableSortSpecsSanitize(table);
		table->SortSpecsMulti.resize(table->SortSpecsCount <= 1 ? 0 : table->SortSpecsCount);
		table->SortSpecs.SpecsDirty = true; // Mark as dirty for user
		table->IsSortSpecsDirty = false; // Mark as not dirty for us
	}

	// Write output
	// May be able to move all SortSpecs data from table (48 bytes) to ImGuiTableTempData if we decide to write it back on every BeginTable()
	ImGuiTableColumnSortSpecs *sort_specs = (table->SortSpecsCount == 0) ? NULL : (table->SortSpecsCount == 1) ? &table->SortSpecsSingle
																											   : table->SortSpecsMulti.Data;
	if (dirty && sort_specs != NULL)
		for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
			ImGuiTableColumn *column = &table->Columns[column_n];
			if (column->SortOrder == -1)
				continue;
			IM_ASSERT(column->SortOrder < table->SortSpecsCount);
			ImGuiTableColumnSortSpecs *sort_spec = &sort_specs[column->SortOrder];
			sort_spec->ColumnUserID = column->UserID;
			sort_spec->ColumnIndex = (ImGuiTableColumnIdx)column_n;
			sort_spec->SortOrder = (ImGuiTableColumnIdx)column->SortOrder;
			sort_spec->SortDirection = (ImGuiSortDirection)column->SortDirection;
		}

	table->SortSpecs.Specs = sort_specs;
	table->SortSpecs.SpecsCount = table->SortSpecsCount;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Headers
//-------------------------------------------------------------------------
// - TableGetHeaderRowHeight() [Internal]
// - TableGetHeaderAngledMaxLabelWidth() [Internal]
// - TableHeadersRow()
// - TableHeader()
// - TableAngledHeadersRow()
// - TableAngledHeadersRowEx() [Internal]
//-------------------------------------------------------------------------

float ImGui::TableGetHeaderRowHeight() {
	// Caring for a minor edge case:
	// Calculate row height, for the unlikely case that some labels may be taller than others.
	// If we didn't do that, uneven header height would highlight but smaller one before the tallest wouldn't catch input for all height.
	// In your custom header row you may omit this all together and just call TableNextRow() without a height...
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	float row_height = g.FontSize;
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
		if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
			if ((table->Columns[column_n].Flags & ImGuiTableColumnFlags_NoHeaderLabel) == 0)
				row_height = ImMax(row_height, CalcTextSize(TableGetColumnName(table, column_n)).y);
	return row_height + g.Style.CellPadding.y * 2.0f;
}

float ImGui::TableGetHeaderAngledMaxLabelWidth() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	float width = 0.0f;
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
		if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
			if (table->Columns[column_n].Flags & ImGuiTableColumnFlags_AngledHeader)
				width = ImMax(width, CalcTextSize(TableGetColumnName(table, column_n), NULL, true).x);
	return width + g.Style.CellPadding.y * 2.0f; // Swap padding
}

// [Public] This is a helper to output TableHeader() calls based on the column names declared in TableSetupColumn().
// The intent is that advanced users willing to create customized headers would not need to use this helper
// and can create their own! For example: TableHeader() may be preceded by Checkbox() or other custom widgets.
// See 'Demo->Tables->Custom headers' for a demonstration of implementing a custom version of this.
// This code is intentionally written to not make much use of internal functions, to give you better direction
// if you need to write your own.
// FIXME-TABLE: TableOpenContextMenu() and TableGetHeaderRowHeight() are not public.
void ImGui::TableHeadersRow() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(table != NULL && "Need to call TableHeadersRow() after BeginTable()!");

	// Call layout if not already done. This is automatically done by TableNextRow: we do it here _only_ to make
	// it easier to debug-step in TableUpdateLayout(). Your own version of this function doesn't need this.
	if (!table->IsLayoutLocked)
		TableUpdateLayout(table);

	// Open row
	const float row_height = TableGetHeaderRowHeight();
	TableNextRow(ImGuiTableRowFlags_Headers, row_height);
	const float row_y1 = GetCursorScreenPos().y;
	if (table->HostSkipItems) // Merely an optimization, you may skip in your own code.
		return;

	const int columns_count = TableGetColumnCount();
	for (int column_n = 0; column_n < columns_count; column_n++) {
		if (!TableSetColumnIndex(column_n))
			continue;

		// Push an id to allow empty/unnamed headers. This is also idiomatic as it ensure there is a consistent ID path to access columns (for e.g. automation)
		const char *name = (TableGetColumnFlags(column_n) & ImGuiTableColumnFlags_NoHeaderLabel) ? "" : TableGetColumnName(column_n);
		PushID(column_n);
		TableHeader(name);
		PopID();
	}

	// Allow opening popup from the right-most section after the last column.
	ImVec2 mouse_pos = ImGui::GetMousePos();
	if (IsMouseReleased(1) && TableGetHoveredColumn() == columns_count)
		if (mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height)
			TableOpenContextMenu(columns_count); // Will open a non-column-specific popup.
}

// Emit a column header (text + optional sort order)
// We cpu-clip text here so that all columns headers can be merged into a same draw call.
// Note that because of how we cpu-clip and display sorting indicators, you _cannot_ use SameLine() after a TableHeader()
void ImGui::TableHeader(const char *label) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return;

	ImGuiTable *table = g.CurrentTable;
	IM_ASSERT(table != NULL && "Need to call TableHeader() after BeginTable()!");
	IM_ASSERT(table->CurrentColumn != -1);
	const int column_n = table->CurrentColumn;
	ImGuiTableColumn *column = &table->Columns[column_n];

	// Label
	if (label == NULL)
		label = "";
	const char *label_end = FindRenderedTextEnd(label);
	ImVec2 label_size = CalcTextSize(label, label_end, true);
	ImVec2 label_pos = window->DC.CursorPos;

	// If we already got a row height, there's use that.
	// FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays off our ClipRect?
	ImRect cell_r = TableGetCellBgRect(table, column_n);
	float label_height = ImMax(label_size.y, table->RowMinHeight - table->RowCellPaddingY * 2.0f);

	// Calculate ideal size for sort order arrow
	float w_arrow = 0.0f;
	float w_sort_text = 0.0f;
	bool sort_arrow = false;
	char sort_order_suf[4] = "";
	const float ARROW_SCALE = 0.65f;
	if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort)) {
		w_arrow = ImTrunc(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x);
		if (column->SortOrder != -1)
			sort_arrow = true;
		if (column->SortOrder > 0) {
			ImFormatString(sort_order_suf, IM_ARRAYSIZE(sort_order_suf), "%d", column->SortOrder + 1);
			w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf).x;
		}
	}

	// We feed our unclipped width to the column without writing on CursorMaxPos, so that column is still considered for merging.
	float max_pos_x = label_pos.x + label_size.x + w_sort_text + w_arrow;
	column->ContentMaxXHeadersUsed = ImMax(column->ContentMaxXHeadersUsed, sort_arrow ? cell_r.Max.x : ImMin(max_pos_x, cell_r.Max.x));
	column->ContentMaxXHeadersIdeal = ImMax(column->ContentMaxXHeadersIdeal, max_pos_x);

	// Keep header highlighted when context menu is open.
	ImGuiID id = window->GetID(label);
	ImRect bb(cell_r.Min.x, cell_r.Min.y, cell_r.Max.x, ImMax(cell_r.Max.y, cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0f));
	ItemSize(ImVec2(0.0f, label_height)); // Don't declare unclipped width, it'll be fed ContentMaxPosHeadersIdeal
	if (!ItemAdd(bb, id))
		return;

	//GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
	//GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]

	// Using AllowOverlap mode because we cover the whole cell, and we want user to be able to submit subsequent items.
	const bool highlight = (table->HighlightColumnHeader == column_n);
	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_AllowOverlap);
	if (held || hovered || highlight) {
		const ImU32 col = GetColorU32(held ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered
																			 : ImGuiCol_Header);
		//RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
		TableSetBgColor(ImGuiTableBgTarget_CellBg, col, table->CurrentColumn);
	} else {
		// Submit single cell bg color in the case we didn't submit a full header row
		if ((table->RowFlags & ImGuiTableRowFlags_Headers) == 0)
			TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_TableHeaderBg), table->CurrentColumn);
	}
	RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_Compact | ImGuiNavHighlightFlags_NoRounding);
	if (held)
		table->HeldHeaderColumn = (ImGuiTableColumnIdx)column_n;
	window->DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5f;

	// Drag and drop to re-order columns.
	// FIXME-TABLE: Scroll request while reordering a column and it lands out of the scrolling zone.
	if (held && (table->Flags & ImGuiTableFlags_Reorderable) && IsMouseDragging(0) && !g.DragDropActive) {
		// While moving a column it will jump on the other side of the mouse, so we also test for MouseDelta.x
		table->ReorderColumn = (ImGuiTableColumnIdx)column_n;
		table->InstanceInteracted = table->InstanceCurrent;

		// We don't reorder: through the frozen<>unfrozen line, or through a column that is marked with ImGuiTableColumnFlags_NoReorder.
		if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < cell_r.Min.x)
			if (ImGuiTableColumn *prev_column = (column->PrevEnabledColumn != -1) ? &table->Columns[column->PrevEnabledColumn] : NULL)
				if (!((column->Flags | prev_column->Flags) & ImGuiTableColumnFlags_NoReorder))
					if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (prev_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
						table->ReorderColumnDir = -1;
		if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > cell_r.Max.x)
			if (ImGuiTableColumn *next_column = (column->NextEnabledColumn != -1) ? &table->Columns[column->NextEnabledColumn] : NULL)
				if (!((column->Flags | next_column->Flags) & ImGuiTableColumnFlags_NoReorder))
					if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (next_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
						table->ReorderColumnDir = +1;
	}

	// Sort order arrow
	const float ellipsis_max = ImMax(cell_r.Max.x - w_arrow - w_sort_text, label_pos.x);
	if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort)) {
		if (column->SortOrder != -1) {
			float x = ImMax(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text);
			float y = label_pos.y;
			if (column->SortOrder > 0) {
				PushStyleColor(ImGuiCol_Text, GetColorU32(ImGuiCol_Text, 0.70f));
				RenderText(ImVec2(x + g.Style.ItemInnerSpacing.x, y), sort_order_suf);
				PopStyleColor();
				x += w_sort_text;
			}
			RenderArrow(window->DrawList, ImVec2(x, y), GetColorU32(ImGuiCol_Text), column->SortDirection == ImGuiSortDirection_Ascending ? ImGuiDir_Up : ImGuiDir_Down, ARROW_SCALE);
		}

		// Handle clicking on column header to adjust Sort Order
		if (pressed && table->ReorderColumn != column_n) {
			ImGuiSortDirection sort_direction = TableGetColumnNextSortDirection(column);
			TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift);
		}
	}

	// Render clipped label. Clipping here ensure that in the majority of situations, all our header cells will
	// be merged into a single draw call.
	//window->DrawList->AddCircleFilled(ImVec2(ellipsis_max, label_pos.y), 40, IM_COL32_WHITE);
	RenderTextEllipsis(window->DrawList, label_pos, ImVec2(ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y), ellipsis_max, ellipsis_max, label, label_end, &label_size);

	const bool text_clipped = label_size.x > (ellipsis_max - label_pos.x);
	if (text_clipped && hovered && g.ActiveId == 0)
		SetItemTooltip("%.*s", (int)(label_end - label), label);

	// We don't use BeginPopupContextItem() because we want the popup to stay up even after the column is hidden
	if (IsMouseReleased(1) && IsItemHovered())
		TableOpenContextMenu(column_n);
}

// Unlike TableHeadersRow() it is not expected that you can reimplement or customize this with custom widgets.
// FIXME: No hit-testing/button on the angled header.
void ImGui::TableAngledHeadersRow() {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	ImGuiTableTempData *temp_data = table->TempData;
	temp_data->AngledHeadersRequests.resize(0);
	temp_data->AngledHeadersRequests.reserve(table->ColumnsEnabledCount);

	// Which column needs highlight?
	const ImGuiID row_id = GetID("##AngledHeaders");
	ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent);
	int highlight_column_n = table->HighlightColumnHeader;
	if (highlight_column_n == -1 && table->HoveredColumnBody != -1)
		if (table_instance->HoveredRowLast == 0 && table->HoveredColumnBorder == -1 && (g.ActiveId == 0 || g.ActiveId == row_id || (table->IsActiveIdInTable || g.DragDropActive)))
			highlight_column_n = table->HoveredColumnBody;

	// Build up request
	ImU32 col_header_bg = GetColorU32(ImGuiCol_TableHeaderBg);
	ImU32 col_text = GetColorU32(ImGuiCol_Text);
	for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
		if (IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n)) {
			const int column_n = table->DisplayOrderToIndex[order_n];
			ImGuiTableColumn *column = &table->Columns[column_n];
			if ((column->Flags & ImGuiTableColumnFlags_AngledHeader) == 0) // Note: can't rely on ImGuiTableColumnFlags_IsVisible test here.
				continue;
			ImGuiTableHeaderData request = { (ImGuiTableColumnIdx)column_n, col_text, col_header_bg, (column_n == highlight_column_n) ? GetColorU32(ImGuiCol_Header) : 0 };
			temp_data->AngledHeadersRequests.push_back(request);
		}

	// Render row
	TableAngledHeadersRowEx(row_id, g.Style.TableAngledHeadersAngle, 0.0f, temp_data->AngledHeadersRequests.Data, temp_data->AngledHeadersRequests.Size);
}

// Important: data must be fed left to right
void ImGui::TableAngledHeadersRowEx(ImGuiID row_id, float angle, float max_label_width, const ImGuiTableHeaderData *data, int data_count) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	ImGuiWindow *window = g.CurrentWindow;
	ImDrawList *draw_list = window->DrawList;
	IM_ASSERT(table != NULL && "Need to call TableHeadersRow() after BeginTable()!");
	IM_ASSERT(table->CurrentRow == -1 && "Must be first row");

	if (max_label_width == 0.0f)
		max_label_width = TableGetHeaderAngledMaxLabelWidth();

	// Angle argument expressed in (-IM_PI/2 .. +IM_PI/2) as it is easier to think about for user.
	const bool flip_label = (angle < 0.0f);
	angle -= IM_PI * 0.5f;
	const float cos_a = ImCos(angle);
	const float sin_a = ImSin(angle);
	const float label_cos_a = flip_label ? ImCos(angle + IM_PI) : cos_a;
	const float label_sin_a = flip_label ? ImSin(angle + IM_PI) : sin_a;
	const ImVec2 unit_right = ImVec2(cos_a, sin_a);

	// Calculate our base metrics and set angled headers data _before_ the first call to TableNextRow()
	// FIXME-STYLE: Would it be better for user to submit 'max_label_width' or 'row_height' ? One can be derived from the other.
	const float header_height = g.FontSize + g.Style.CellPadding.x * 2.0f;
	const float row_height = ImTrunc(ImFabs(ImRotate(ImVec2(max_label_width, flip_label ? +header_height : -header_height), cos_a, sin_a).y));
	table->AngledHeadersHeight = row_height;
	table->AngledHeadersSlope = (sin_a != 0.0f) ? (cos_a / sin_a) : 0.0f;
	const ImVec2 header_angled_vector = unit_right * (row_height / -sin_a); // vector from bottom-left to top-left, and from bottom-right to top-right

	// Declare row, override and draw our own background
	TableNextRow(ImGuiTableRowFlags_Headers, row_height);
	TableNextColumn();
	const ImRect row_r(table->WorkRect.Min.x, table->BgClipRect.Min.y, table->WorkRect.Max.x, table->RowPosY2);
	table->DrawSplitter->SetCurrentChannel(draw_list, TABLE_DRAW_CHANNEL_BG0);
	float clip_rect_min_x = table->BgClipRect.Min.x;
	if (table->FreezeColumnsCount > 0)
		clip_rect_min_x = ImMax(clip_rect_min_x, table->Columns[table->FreezeColumnsCount - 1].MaxX);
	TableSetBgColor(ImGuiTableBgTarget_RowBg0, 0); // Cancel
	PushClipRect(table->BgClipRect.Min, table->BgClipRect.Max, false); // Span all columns
	draw_list->AddRectFilled(ImVec2(table->BgClipRect.Min.x, row_r.Min.y), ImVec2(table->BgClipRect.Max.x, row_r.Max.y), GetColorU32(ImGuiCol_TableHeaderBg, 0.25f)); // FIXME-STYLE: Change row background with an arbitrary color.
	PushClipRect(ImVec2(clip_rect_min_x, table->BgClipRect.Min.y), table->BgClipRect.Max, true); // Span all columns

	ButtonBehavior(row_r, row_id, NULL, NULL);
	KeepAliveID(row_id);

	const float ascent_scaled = g.Font->Ascent * g.FontScale; // FIXME: Standardize those scaling factors better
	const float line_off_for_ascent_x = (ImMax((g.FontSize - ascent_scaled) * 0.5f, 0.0f) / -sin_a) * (flip_label ? -1.0f : 1.0f);
	const ImVec2 padding = g.Style.CellPadding; // We will always use swapped component
	const ImVec2 align = g.Style.TableAngledHeadersTextAlign;

	// Draw background and labels in first pass, then all borders.
	float max_x = 0.0f;
	for (int pass = 0; pass < 2; pass++)
		for (int order_n = 0; order_n < data_count; order_n++) {
			const ImGuiTableHeaderData *request = &data[order_n];
			const int column_n = request->Index;
			ImGuiTableColumn *column = &table->Columns[column_n];

			ImVec2 bg_shape[4];
			bg_shape[0] = ImVec2(column->MaxX, row_r.Max.y);
			bg_shape[1] = ImVec2(column->MinX, row_r.Max.y);
			bg_shape[2] = bg_shape[1] + header_angled_vector;
			bg_shape[3] = bg_shape[0] + header_angled_vector;
			if (pass == 0) {
				// Draw shape
				draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request->BgColor0);
				draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request->BgColor1); // Optional highlight
				max_x = ImMax(max_x, bg_shape[3].x);

				// Draw label
				// - First draw at an offset where RenderTextXXX() function won't meddle with applying current ClipRect, then transform to final offset.
				// - Handle multiple lines manually, as we want each lines to follow on the horizontal border, rather than see a whole block rotated.
				const char *label_name = TableGetColumnName(table, column_n);
				const char *label_name_end = FindRenderedTextEnd(label_name);
				const float line_off_step_x = (g.FontSize / -sin_a);
				const int label_lines = ImTextCountLines(label_name, label_name_end);

				// Left<>Right alignment
				float line_off_curr_x = flip_label ? (label_lines - 1) * line_off_step_x : 0.0f;
				float line_off_for_align_x = ImMax((((column->MaxX - column->MinX) - padding.x * 2.0f) - (label_lines * line_off_step_x)), 0.0f) * align.x;
				line_off_curr_x += line_off_for_align_x - line_off_for_ascent_x;

				// Register header width
				column->ContentMaxXHeadersUsed = column->ContentMaxXHeadersIdeal = column->WorkMinX + ImCeil(label_lines * line_off_step_x - line_off_for_align_x);

				while (label_name < label_name_end) {
					const char *label_name_eol = strchr(label_name, '\n');
					if (label_name_eol == NULL)
						label_name_eol = label_name_end;

					// FIXME: Individual line clipping for right-most column is broken for negative angles.
					ImVec2 label_size = CalcTextSize(label_name, label_name_eol);
					float clip_width = max_label_width - padding.y; // Using padding.y*2.0f would be symmetrical but hide more text.
					float clip_height = ImMin(label_size.y, column->ClipRect.Max.x - column->WorkMinX - line_off_curr_x);
					ImRect clip_r(window->ClipRect.Min, window->ClipRect.Min + ImVec2(clip_width, clip_height));
					int vtx_idx_begin = draw_list->_VtxCurrentIdx;
					PushStyleColor(ImGuiCol_Text, request->TextColor);
					RenderTextEllipsis(draw_list, clip_r.Min, clip_r.Max, clip_r.Max.x, clip_r.Max.x, label_name, label_name_eol, &label_size);
					PopStyleColor();
					int vtx_idx_end = draw_list->_VtxCurrentIdx;

					// Up<>Down alignment
					const float available_space = ImMax(clip_width - label_size.x + ImAbs(padding.x * cos_a) * 2.0f - ImAbs(padding.y * sin_a) * 2.0f, 0.0f);
					const float vertical_offset = available_space * align.y * (flip_label ? -1.0f : 1.0f);

					// Rotate and offset label
					ImVec2 pivot_in = ImVec2(window->ClipRect.Min.x - vertical_offset, window->ClipRect.Min.y + label_size.y);
					ImVec2 pivot_out = ImVec2(column->WorkMinX, row_r.Max.y);
					line_off_curr_x += flip_label ? -line_off_step_x : line_off_step_x;
					pivot_out += unit_right * padding.y;
					if (flip_label)
						pivot_out += unit_right * (clip_width - ImMax(0.0f, clip_width - label_size.x));
					pivot_out.x += flip_label ? line_off_curr_x + line_off_step_x : line_off_curr_x;
					ShadeVertsTransformPos(draw_list, vtx_idx_begin, vtx_idx_end, pivot_in, label_cos_a, label_sin_a, pivot_out); // Rotate and offset
					//if (g.IO.KeyShift) { ImDrawList* fg_dl = GetForegroundDrawList(); vtx_idx_begin = fg_dl->_VtxCurrentIdx; fg_dl->AddRect(clip_r.Min, clip_r.Max, IM_COL32(0, 255, 0, 255), 0.0f, 0, 1.0f); ShadeVertsTransformPos(fg_dl, vtx_idx_begin, fg_dl->_VtxCurrentIdx, pivot_in, label_cos_a, label_sin_a, pivot_out); }

					label_name = label_name_eol + 1;
				}
			}
			if (pass == 1) {
				// Draw border
				draw_list->AddLine(bg_shape[0], bg_shape[3], TableGetColumnBorderCol(table, order_n, column_n));
			}
		}
	PopClipRect();
	PopClipRect();
	table->TempData->AngledHeadersExtraWidth = ImMax(0.0f, max_x - table->Columns[table->RightMostEnabledColumn].MaxX);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Context Menu
//-------------------------------------------------------------------------
// - TableOpenContextMenu() [Internal]
// - TableBeginContextMenuPopup() [Internal]
// - TableDrawDefaultContextMenu() [Internal]
//-------------------------------------------------------------------------

// Use -1 to open menu not specific to a given column.
void ImGui::TableOpenContextMenu(int column_n) {
	ImGuiContext &g = *GImGui;
	ImGuiTable *table = g.CurrentTable;
	if (column_n == -1 && table->CurrentColumn != -1) // When called within a column automatically use this one (for consistency)
		column_n = table->CurrentColumn;
	if (column_n == table->ColumnsCount) // To facilitate using with TableGetHoveredColumn()
		column_n = -1;
	IM_ASSERT(column_n >= -1 && column_n < table->ColumnsCount);
	if (table->Flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable)) {
		table->IsContextPopupOpen = true;
		table->ContextPopupColumn = (ImGuiTableColumnIdx)column_n;
		table->InstanceInteracted = table->InstanceCurrent;
		const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
		OpenPopupEx(context_menu_id, ImGuiPopupFlags_None);
	}
}

bool ImGui::TableBeginContextMenuPopup(ImGuiTable *table) {
	if (!table->IsContextPopupOpen || table->InstanceCurrent != table->InstanceInteracted)
		return false;
	const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
	if (BeginPopupEx(context_menu_id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings))
		return true;
	table->IsContextPopupOpen = false;
	return false;
}

// Output context menu into current window (generally a popup)
// FIXME-TABLE: Ideally this should be writable by the user. Full programmatic access to that data?
// Sections to display are pulled from 'flags_for_section_to_display', which is typically == table->Flags.
// - ImGuiTableFlags_Resizable   -> display Sizing menu items
// - ImGuiTableFlags_Reorderable -> display "Reset Order"
////- ImGuiTableFlags_Sortable   -> display sorting options (disabled)
// - ImGuiTableFlags_Hideable    -> display columns visibility menu items
// It means if you have a custom context menus you can call this section and omit some sections, and add your own.
void ImGui::TableDrawDefaultContextMenu(ImGuiTable *table, ImGuiTableFlags flags_for_section_to_display) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return;

	bool want_separator = false;
	const int column_n = (table->ContextPopupColumn >= 0 && table->ContextPopupColumn < table->ColumnsCount) ? table->ContextPopupColumn : -1;
	ImGuiTableColumn *column = (column_n != -1) ? &table->Columns[column_n] : NULL;

	// Sizing
	if (flags_for_section_to_display & ImGuiTableFlags_Resizable) {
		if (column != NULL) {
			const bool can_resize = !(column->Flags & ImGuiTableColumnFlags_NoResize) && column->IsEnabled;
			if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableSizeOne), NULL, false, can_resize)) // "###SizeOne"
				TableSetColumnWidthAutoSingle(table, column_n);
		}

		const char *size_all_desc;
		if (table->ColumnsEnabledFixedCount == table->ColumnsEnabledCount && (table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame)
			size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllFit); // "###SizeAll" All fixed
		else
			size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllDefault); // "###SizeAll" All stretch or mixed
		if (MenuItem(size_all_desc, NULL))
			TableSetColumnWidthAutoAll(table);
		want_separator = true;
	}

	// Ordering
	if (flags_for_section_to_display & ImGuiTableFlags_Reorderable) {
		if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableResetOrder), NULL, false, !table->IsDefaultDisplayOrder))
			table->IsResetDisplayOrderRequest = true;
		want_separator = true;
	}

	// Reset all (should work but seems unnecessary/noisy to expose?)
	//if (MenuItem("Reset all"))
	//    table->IsResetAllRequest = true;

	// Sorting
	// (modify TableOpenContextMenu() to add _Sortable flag if enabling this)
#if 0
    if ((flags_for_section_to_display & ImGuiTableFlags_Sortable) && column != NULL && (column->Flags & ImGuiTableColumnFlags_NoSort) == 0)
    {
        if (want_separator)
            Separator();
        want_separator = true;

        bool append_to_sort_specs = g.IO.KeyShift;
        if (MenuItem("Sort in Ascending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Ascending, (column->Flags & ImGuiTableColumnFlags_NoSortAscending) == 0))
            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Ascending, append_to_sort_specs);
        if (MenuItem("Sort in Descending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Descending, (column->Flags & ImGuiTableColumnFlags_NoSortDescending) == 0))
            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Descending, append_to_sort_specs);
    }
#endif

	// Hiding / Visibility
	if (flags_for_section_to_display & ImGuiTableFlags_Hideable) {
		if (want_separator)
			Separator();
		want_separator = true;

		PushItemFlag(ImGuiItemFlags_AutoClosePopups, false);
		for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++) {
			ImGuiTableColumn *other_column = &table->Columns[other_column_n];
			if (other_column->Flags & ImGuiTableColumnFlags_Disabled)
				continue;

			const char *name = TableGetColumnName(table, other_column_n);
			if (name == NULL || name[0] == 0)
				name = "<Unknown>";

			// Make sure we can't hide the last active column
			bool menu_item_active = (other_column->Flags & ImGuiTableColumnFlags_NoHide) ? false : true;
			if (other_column->IsUserEnabled && table->ColumnsEnabledCount <= 1)
				menu_item_active = false;
			if (MenuItem(name, NULL, other_column->IsUserEnabled, menu_item_active))
				other_column->IsUserEnabledNextFrame = !other_column->IsUserEnabled;
		}
		PopItemFlag();
	}
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Settings (.ini data)
//-------------------------------------------------------------------------
// FIXME: The binding/finding/creating flow are too confusing.
//-------------------------------------------------------------------------
// - TableSettingsInit() [Internal]
// - TableSettingsCalcChunkSize() [Internal]
// - TableSettingsCreate() [Internal]
// - TableSettingsFindByID() [Internal]
// - TableGetBoundSettings() [Internal]
// - TableResetSettings()
// - TableSaveSettings() [Internal]
// - TableLoadSettings() [Internal]
// - TableSettingsHandler_ClearAll() [Internal]
// - TableSettingsHandler_ApplyAll() [Internal]
// - TableSettingsHandler_ReadOpen() [Internal]
// - TableSettingsHandler_ReadLine() [Internal]
// - TableSettingsHandler_WriteAll() [Internal]
// - TableSettingsInstallHandler() [Internal]
//-------------------------------------------------------------------------
// [Init] 1: TableSettingsHandler_ReadXXXX()   Load and parse .ini file into TableSettings.
// [Main] 2: TableLoadSettings()               When table is created, bind Table to TableSettings, serialize TableSettings data into Table.
// [Main] 3: TableSaveSettings()               When table properties are modified, serialize Table data into bound or new TableSettings, mark .ini as dirty.
// [Main] 4: TableSettingsHandler_WriteAll()   When .ini file is dirty (which can come from other source), save TableSettings into .ini file.
//-------------------------------------------------------------------------

// Clear and initialize empty settings instance
static void TableSettingsInit(ImGuiTableSettings *settings, ImGuiID id, int columns_count, int columns_count_max) {
	IM_PLACEMENT_NEW(settings)
	ImGuiTableSettings();
	ImGuiTableColumnSettings *settings_column = settings->GetColumnSettings();
	for (int n = 0; n < columns_count_max; n++, settings_column++)
		IM_PLACEMENT_NEW(settings_column)
		ImGuiTableColumnSettings();
	settings->ID = id;
	settings->ColumnsCount = (ImGuiTableColumnIdx)columns_count;
	settings->ColumnsCountMax = (ImGuiTableColumnIdx)columns_count_max;
	settings->WantApply = true;
}

static size_t TableSettingsCalcChunkSize(int columns_count) {
	return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);
}

ImGuiTableSettings *ImGui::TableSettingsCreate(ImGuiID id, int columns_count) {
	ImGuiContext &g = *GImGui;
	ImGuiTableSettings *settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));
	TableSettingsInit(settings, id, columns_count, columns_count);
	return settings;
}

// Find existing settings
ImGuiTableSettings *ImGui::TableSettingsFindByID(ImGuiID id) {
	// FIXME-OPT: Might want to store a lookup map for this?
	ImGuiContext &g = *GImGui;
	for (ImGuiTableSettings *settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
		if (settings->ID == id)
			return settings;
	return NULL;
}

// Get settings for a given table, NULL if none
ImGuiTableSettings *ImGui::TableGetBoundSettings(ImGuiTable *table) {
	if (table->SettingsOffset != -1) {
		ImGuiContext &g = *GImGui;
		ImGuiTableSettings *settings = g.SettingsTables.ptr_from_offset(table->SettingsOffset);
		IM_ASSERT(settings->ID == table->ID);
		if (settings->ColumnsCountMax >= table->ColumnsCount)
			return settings; // OK
		settings->ID = 0; // Invalidate storage, we won't fit because of a count change
	}
	return NULL;
}

// Restore initial state of table (with or without saved settings)
void ImGui::TableResetSettings(ImGuiTable *table) {
	table->IsInitializing = table->IsSettingsDirty = true;
	table->IsResetAllRequest = false;
	table->IsSettingsRequestLoad = false; // Don't reload from ini
	table->SettingsLoadedFlags = ImGuiTableFlags_None; // Mark as nothing loaded so our initialized data becomes authoritative
}

void ImGui::TableSaveSettings(ImGuiTable *table) {
	table->IsSettingsDirty = false;
	if (table->Flags & ImGuiTableFlags_NoSavedSettings)
		return;

	// Bind or create settings data
	ImGuiContext &g = *GImGui;
	ImGuiTableSettings *settings = TableGetBoundSettings(table);
	if (settings == NULL) {
		settings = TableSettingsCreate(table->ID, table->ColumnsCount);
		table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
	}
	settings->ColumnsCount = (ImGuiTableColumnIdx)table->ColumnsCount;

	// Serialize ImGuiTable/ImGuiTableColumn into ImGuiTableSettings/ImGuiTableColumnSettings
	IM_ASSERT(settings->ID == table->ID);
	IM_ASSERT(settings->ColumnsCount == table->ColumnsCount && settings->ColumnsCountMax >= settings->ColumnsCount);
	ImGuiTableColumn *column = table->Columns.Data;
	ImGuiTableColumnSettings *column_settings = settings->GetColumnSettings();

	bool save_ref_scale = false;
	settings->SaveFlags = ImGuiTableFlags_None;
	for (int n = 0; n < table->ColumnsCount; n++, column++, column_settings++) {
		const float width_or_weight = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? column->StretchWeight : column->WidthRequest;
		column_settings->WidthOrWeight = width_or_weight;
		column_settings->Index = (ImGuiTableColumnIdx)n;
		column_settings->DisplayOrder = column->DisplayOrder;
		column_settings->SortOrder = column->SortOrder;
		column_settings->SortDirection = column->SortDirection;
		column_settings->IsEnabled = column->IsUserEnabled;
		column_settings->IsStretch = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? 1 : 0;
		if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) == 0)
			save_ref_scale = true;

		// We skip saving some data in the .ini file when they are unnecessary to restore our state.
		// Note that fixed width where initial width was derived from auto-fit will always be saved as InitStretchWeightOrWidth will be 0.0f.
		// FIXME-TABLE: We don't have logic to easily compare SortOrder to DefaultSortOrder yet so it's always saved when present.
		if (width_or_weight != column->InitStretchWeightOrWidth)
			settings->SaveFlags |= ImGuiTableFlags_Resizable;
		if (column->DisplayOrder != n)
			settings->SaveFlags |= ImGuiTableFlags_Reorderable;
		if (column->SortOrder != -1)
			settings->SaveFlags |= ImGuiTableFlags_Sortable;
		if (column->IsUserEnabled != ((column->Flags & ImGuiTableColumnFlags_DefaultHide) == 0))
			settings->SaveFlags |= ImGuiTableFlags_Hideable;
	}
	settings->SaveFlags &= table->Flags;
	settings->RefScale = save_ref_scale ? table->RefScale : 0.0f;

	MarkIniSettingsDirty();
}

void ImGui::TableLoadSettings(ImGuiTable *table) {
	ImGuiContext &g = *GImGui;
	table->IsSettingsRequestLoad = false;
	if (table->Flags & ImGuiTableFlags_NoSavedSettings)
		return;

	// Bind settings
	ImGuiTableSettings *settings;
	if (table->SettingsOffset == -1) {
		settings = TableSettingsFindByID(table->ID);
		if (settings == NULL)
			return;
		if (settings->ColumnsCount != table->ColumnsCount) // Allow settings if columns count changed. We could otherwise decide to return...
			table->IsSettingsDirty = true;
		table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
	} else {
		settings = TableGetBoundSettings(table);
	}

	table->SettingsLoadedFlags = settings->SaveFlags;
	table->RefScale = settings->RefScale;

	// Serialize ImGuiTableSettings/ImGuiTableColumnSettings into ImGuiTable/ImGuiTableColumn
	ImGuiTableColumnSettings *column_settings = settings->GetColumnSettings();
	ImU64 display_order_mask = 0;
	for (int data_n = 0; data_n < settings->ColumnsCount; data_n++, column_settings++) {
		int column_n = column_settings->Index;
		if (column_n < 0 || column_n >= table->ColumnsCount)
			continue;

		ImGuiTableColumn *column = &table->Columns[column_n];
		if (settings->SaveFlags & ImGuiTableFlags_Resizable) {
			if (column_settings->IsStretch)
				column->StretchWeight = column_settings->WidthOrWeight;
			else
				column->WidthRequest = column_settings->WidthOrWeight;
			column->AutoFitQueue = 0x00;
		}
		if (settings->SaveFlags & ImGuiTableFlags_Reorderable)
			column->DisplayOrder = column_settings->DisplayOrder;
		else
			column->DisplayOrder = (ImGuiTableColumnIdx)column_n;
		display_order_mask |= (ImU64)1 << column->DisplayOrder;
		column->IsUserEnabled = column->IsUserEnabledNextFrame = column_settings->IsEnabled;
		column->SortOrder = column_settings->SortOrder;
		column->SortDirection = column_settings->SortDirection;
	}

	// Validate and fix invalid display order data
	const ImU64 expected_display_order_mask = (settings->ColumnsCount == 64) ? ~0 : ((ImU64)1 << settings->ColumnsCount) - 1;
	if (display_order_mask != expected_display_order_mask)
		for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
			table->Columns[column_n].DisplayOrder = (ImGuiTableColumnIdx)column_n;

	// Rebuild index
	for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
		table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
}

static void TableSettingsHandler_ClearAll(ImGuiContext *ctx, ImGuiSettingsHandler *) {
	ImGuiContext &g = *ctx;
	for (int i = 0; i != g.Tables.GetMapSize(); i++)
		if (ImGuiTable *table = g.Tables.TryGetMapData(i))
			table->SettingsOffset = -1;
	g.SettingsTables.clear();
}

// Apply to existing windows (if any)
static void TableSettingsHandler_ApplyAll(ImGuiContext *ctx, ImGuiSettingsHandler *) {
	ImGuiContext &g = *ctx;
	for (int i = 0; i != g.Tables.GetMapSize(); i++)
		if (ImGuiTable *table = g.Tables.TryGetMapData(i)) {
			table->IsSettingsRequestLoad = true;
			table->SettingsOffset = -1;
		}
}

static void *TableSettingsHandler_ReadOpen(ImGuiContext *, ImGuiSettingsHandler *, const char *name) {
	ImGuiID id = 0;
	int columns_count = 0;
	if (sscanf(name, "0x%08X,%d", &id, &columns_count) < 2)
		return NULL;

	if (ImGuiTableSettings *settings = ImGui::TableSettingsFindByID(id)) {
		if (settings->ColumnsCountMax >= columns_count) {
			TableSettingsInit(settings, id, columns_count, settings->ColumnsCountMax); // Recycle
			return settings;
		}
		settings->ID = 0; // Invalidate storage, we won't fit because of a count change
	}
	return ImGui::TableSettingsCreate(id, columns_count);
}

static void TableSettingsHandler_ReadLine(ImGuiContext *, ImGuiSettingsHandler *, void *entry, const char *line) {
	// "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
	ImGuiTableSettings *settings = (ImGuiTableSettings *)entry;
	float f = 0.0f;
	int column_n = 0, r = 0, n = 0;

	if (sscanf(line, "RefScale=%f", &f) == 1) {
		settings->RefScale = f;
		return;
	}

	if (sscanf(line, "Column %d%n", &column_n, &r) == 1) {
		if (column_n < 0 || column_n >= settings->ColumnsCount)
			return;
		line = ImStrSkipBlank(line + r);
		char c = 0;
		ImGuiTableColumnSettings *column = settings->GetColumnSettings() + column_n;
		column->Index = (ImGuiTableColumnIdx)column_n;
		if (sscanf(line, "UserID=0x%08X%n", (ImU32 *)&n, &r) == 1) {
			line = ImStrSkipBlank(line + r);
			column->UserID = (ImGuiID)n;
		}
		if (sscanf(line, "Width=%d%n", &n, &r) == 1) {
			line = ImStrSkipBlank(line + r);
			column->WidthOrWeight = (float)n;
			column->IsStretch = 0;
			settings->SaveFlags |= ImGuiTableFlags_Resizable;
		}
		if (sscanf(line, "Weight=%f%n", &f, &r) == 1) {
			line = ImStrSkipBlank(line + r);
			column->WidthOrWeight = f;
			column->IsStretch = 1;
			settings->SaveFlags |= ImGuiTableFlags_Resizable;
		}
		if (sscanf(line, "Visible=%d%n", &n, &r) == 1) {
			line = ImStrSkipBlank(line + r);
			column->IsEnabled = (ImU8)n;
			settings->SaveFlags |= ImGuiTableFlags_Hideable;
		}
		if (sscanf(line, "Order=%d%n", &n, &r) == 1) {
			line = ImStrSkipBlank(line + r);
			column->DisplayOrder = (ImGuiTableColumnIdx)n;
			settings->SaveFlags |= ImGuiTableFlags_Reorderable;
		}
		if (sscanf(line, "Sort=%d%c%n", &n, &c, &r) == 2) {
			line = ImStrSkipBlank(line + r);
			column->SortOrder = (ImGuiTableColumnIdx)n;
			column->SortDirection = (c == '^') ? ImGuiSortDirection_Descending : ImGuiSortDirection_Ascending;
			settings->SaveFlags |= ImGuiTableFlags_Sortable;
		}
	}
}

static void TableSettingsHandler_WriteAll(ImGuiContext *ctx, ImGuiSettingsHandler *handler, ImGuiTextBuffer *buf) {
	ImGuiContext &g = *ctx;
	for (ImGuiTableSettings *settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings)) {
		if (settings->ID == 0) // Skip ditched settings
			continue;

		// TableSaveSettings() may clear some of those flags when we establish that the data can be stripped
		// (e.g. Order was unchanged)
		const bool save_size = (settings->SaveFlags & ImGuiTableFlags_Resizable) != 0;
		const bool save_visible = (settings->SaveFlags & ImGuiTableFlags_Hideable) != 0;
		const bool save_order = (settings->SaveFlags & ImGuiTableFlags_Reorderable) != 0;
		const bool save_sort = (settings->SaveFlags & ImGuiTableFlags_Sortable) != 0;
		if (!save_size && !save_visible && !save_order && !save_sort)
			continue;

		buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve
		buf->appendf("[%s][0x%08X,%d]\n", handler->TypeName, settings->ID, settings->ColumnsCount);
		if (settings->RefScale != 0.0f)
			buf->appendf("RefScale=%g\n", settings->RefScale);
		ImGuiTableColumnSettings *column = settings->GetColumnSettings();
		for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++) {
			// "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
			bool save_column = column->UserID != 0 || save_size || save_visible || save_order || (save_sort && column->SortOrder != -1);
			if (!save_column)
				continue;
			buf->appendf("Column %-2d", column_n);
			if (column->UserID != 0) {
				buf->appendf(" UserID=%08X", column->UserID);
			}
			if (save_size && column->IsStretch) {
				buf->appendf(" Weight=%.4f", column->WidthOrWeight);
			}
			if (save_size && !column->IsStretch) {
				buf->appendf(" Width=%d", (int)column->WidthOrWeight);
			}
			if (save_visible) {
				buf->appendf(" Visible=%d", column->IsEnabled);
			}
			if (save_order) {
				buf->appendf(" Order=%d", column->DisplayOrder);
			}
			if (save_sort && column->SortOrder != -1) {
				buf->appendf(" Sort=%d%c", column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? 'v' : '^');
			}
			buf->append("\n");
		}
		buf->append("\n");
	}
}

void ImGui::TableSettingsAddSettingsHandler() {
	ImGuiSettingsHandler ini_handler;
	ini_handler.TypeName = "Table";
	ini_handler.TypeHash = ImHashStr("Table");
	ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
	ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
	ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
	ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
	ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
	AddSettingsHandler(&ini_handler);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Garbage Collection
//-------------------------------------------------------------------------
// - TableRemove() [Internal]
// - TableGcCompactTransientBuffers() [Internal]
// - TableGcCompactSettings() [Internal]
//-------------------------------------------------------------------------

// Remove Table (currently only used by TestEngine)
void ImGui::TableRemove(ImGuiTable *table) {
	//IMGUI_DEBUG_PRINT("TableRemove() id=0x%08X\n", table->ID);
	ImGuiContext &g = *GImGui;
	int table_idx = g.Tables.GetIndex(table);
	//memset(table->RawData.Data, 0, table->RawData.size_in_bytes());
	//memset(table, 0, sizeof(ImGuiTable));
	g.Tables.Remove(table->ID, table);
	g.TablesLastTimeActive[table_idx] = -1.0f;
}

// Free up/compact internal Table buffers for when it gets unused
void ImGui::TableGcCompactTransientBuffers(ImGuiTable *table) {
	//IMGUI_DEBUG_PRINT("TableGcCompactTransientBuffers() id=0x%08X\n", table->ID);
	ImGuiContext &g = *GImGui;
	IM_ASSERT(table->MemoryCompacted == false);
	table->SortSpecs.Specs = NULL;
	table->SortSpecsMulti.clear();
	table->IsSortSpecsDirty = true; // FIXME: In theory shouldn't have to leak into user performing a sort on resume.
	table->ColumnsNames.clear();
	table->MemoryCompacted = true;
	for (int n = 0; n < table->ColumnsCount; n++)
		table->Columns[n].NameOffset = -1;
	g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;
}

void ImGui::TableGcCompactTransientBuffers(ImGuiTableTempData *temp_data) {
	temp_data->DrawSplitter.ClearFreeMemory();
	temp_data->LastTimeActive = -1.0f;
}

// Compact and remove unused settings data (currently only used by TestEngine)
void ImGui::TableGcCompactSettings() {
	ImGuiContext &g = *GImGui;
	int required_memory = 0;
	for (ImGuiTableSettings *settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
		if (settings->ID != 0)
			required_memory += (int)TableSettingsCalcChunkSize(settings->ColumnsCount);
	if (required_memory == g.SettingsTables.Buf.Size)
		return;
	ImChunkStream<ImGuiTableSettings> new_chunk_stream;
	new_chunk_stream.Buf.reserve(required_memory);
	for (ImGuiTableSettings *settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
		if (settings->ID != 0)
			memcpy(new_chunk_stream.alloc_chunk(TableSettingsCalcChunkSize(settings->ColumnsCount)), settings, TableSettingsCalcChunkSize(settings->ColumnsCount));
	g.SettingsTables.swap(new_chunk_stream);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Debugging
//-------------------------------------------------------------------------
// - DebugNodeTable() [Internal]
//-------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_DEBUG_TOOLS

static const char *DebugNodeTableGetSizingPolicyDesc(ImGuiTableFlags sizing_policy) {
	sizing_policy &= ImGuiTableFlags_SizingMask_;
	if (sizing_policy == ImGuiTableFlags_SizingFixedFit) {
		return "FixedFit";
	}
	if (sizing_policy == ImGuiTableFlags_SizingFixedSame) {
		return "FixedSame";
	}
	if (sizing_policy == ImGuiTableFlags_SizingStretchProp) {
		return "StretchProp";
	}
	if (sizing_policy == ImGuiTableFlags_SizingStretchSame) {
		return "StretchSame";
	}
	return "N/A";
}

void ImGui::DebugNodeTable(ImGuiTable *table) {
	ImGuiContext &g = *GImGui;
	const bool is_active = (table->LastFrameActive >= g.FrameCount - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
	if (!is_active) {
		PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled));
	}
	bool open = TreeNode(table, "Table 0x%08X (%d columns, in '%s')%s", table->ID, table->ColumnsCount, table->OuterWindow->Name, is_active ? "" : " *Inactive*");
	if (!is_active) {
		PopStyleColor();
	}
	if (IsItemHovered())
		GetForegroundDrawList()->AddRect(table->OuterRect.Min, table->OuterRect.Max, IM_COL32(255, 255, 0, 255));
	if (IsItemVisible() && table->HoveredColumnBody != -1)
		GetForegroundDrawList()->AddRect(GetItemRectMin(), GetItemRectMax(), IM_COL32(255, 255, 0, 255));
	if (!open)
		return;
	if (table->InstanceCurrent > 0)
		Text("** %d instances of same table! Some data below will refer to last instance.", table->InstanceCurrent + 1);
	if (g.IO.ConfigDebugIsDebuggerPresent) {
		if (DebugBreakButton("**DebugBreak**", "in BeginTable()"))
			g.DebugBreakInTable = table->ID;
		SameLine();
	}

	bool clear_settings = SmallButton("Clear settings");
	BulletText("OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'", table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.GetWidth(), table->OuterRect.GetHeight(), DebugNodeTableGetSizingPolicyDesc(table->Flags));
	BulletText("ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s", table->ColumnsGivenWidth, table->ColumnsAutoFitWidth, table->InnerWidth, table->InnerWidth == 0.0f ? " (auto)" : "");
	BulletText("CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f", table->CellPaddingX, table->CellSpacingX1, table->CellSpacingX2, table->OuterPaddingX);
	BulletText("HoveredColumnBody: %d, HoveredColumnBorder: %d", table->HoveredColumnBody, table->HoveredColumnBorder);
	BulletText("ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d", table->ResizedColumn, table->ReorderColumn, table->HeldHeaderColumn);
	for (int n = 0; n < table->InstanceCurrent + 1; n++) {
		ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, n);
		BulletText("Instance %d: HoveredRow: %d, LastOuterHeight: %.2f", n, table_instance->HoveredRowLast, table_instance->LastOuterHeight);
	}
	//BulletText("BgDrawChannels: %d/%d", 0, table->BgDrawChannelUnfrozen);
	float sum_weights = 0.0f;
	for (int n = 0; n < table->ColumnsCount; n++)
		if (table->Columns[n].Flags & ImGuiTableColumnFlags_WidthStretch)
			sum_weights += table->Columns[n].StretchWeight;
	for (int n = 0; n < table->ColumnsCount; n++) {
		ImGuiTableColumn *column = &table->Columns[n];
		const char *name = TableGetColumnName(table, n);
		char buf[512];
		ImFormatString(buf, IM_ARRAYSIZE(buf),
				"Column %d order %d '%s': offset %+.2f to %+.2f%s\n"
				"Enabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, DrawChannels: %d,%d\n"
				"WidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f (%.1f%%)\n"
				"MinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\n"
				"ContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\n"
				"Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..",
				n, column->DisplayOrder, name, column->MinX - table->WorkRect.Min.x, column->MaxX - table->WorkRect.Min.x, (n < table->FreezeColumnsRequest) ? " (Frozen)" : "",
				column->IsEnabled, column->IsVisibleX, column->IsVisibleY, column->IsRequestOutput, column->IsSkipItems, column->DrawChannelFrozen, column->DrawChannelUnfrozen,
				column->WidthGiven, column->WidthRequest, column->WidthAuto, column->StretchWeight, column->StretchWeight > 0.0f ? (column->StretchWeight / sum_weights) * 100.0f : 0.0f,
				column->MinX, column->MaxX, column->MaxX - column->MinX, column->ClipRect.Min.x, column->ClipRect.Max.x, column->ClipRect.Max.x - column->ClipRect.Min.x,
				column->ContentMaxXFrozen - column->WorkMinX, column->ContentMaxXUnfrozen - column->WorkMinX, column->ContentMaxXHeadersUsed - column->WorkMinX, column->ContentMaxXHeadersIdeal - column->WorkMinX,
				column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? " (Asc)" : (column->SortDirection == ImGuiSortDirection_Descending) ? " (Des)"
																																								 : "",
				column->UserID, column->Flags,
				(column->Flags & ImGuiTableColumnFlags_WidthStretch) ? "WidthStretch " : "",
				(column->Flags & ImGuiTableColumnFlags_WidthFixed) ? "WidthFixed " : "",
				(column->Flags & ImGuiTableColumnFlags_NoResize) ? "NoResize " : "");
		Bullet();
		Selectable(buf);
		if (IsItemHovered()) {
			ImRect r(column->MinX, table->OuterRect.Min.y, column->MaxX, table->OuterRect.Max.y);
			GetForegroundDrawList()->AddRect(r.Min, r.Max, IM_COL32(255, 255, 0, 255));
		}
	}
	if (ImGuiTableSettings *settings = TableGetBoundSettings(table))
		DebugNodeTableSettings(settings);
	if (clear_settings)
		table->IsResetAllRequest = true;
	TreePop();
}

void ImGui::DebugNodeTableSettings(ImGuiTableSettings *settings) {
	if (!TreeNode((void *)(intptr_t)settings->ID, "Settings 0x%08X (%d columns)", settings->ID, settings->ColumnsCount))
		return;
	BulletText("SaveFlags: 0x%08X", settings->SaveFlags);
	BulletText("ColumnsCount: %d (max %d)", settings->ColumnsCount, settings->ColumnsCountMax);
	for (int n = 0; n < settings->ColumnsCount; n++) {
		ImGuiTableColumnSettings *column_settings = &settings->GetColumnSettings()[n];
		ImGuiSortDirection sort_dir = (column_settings->SortOrder != -1) ? (ImGuiSortDirection)column_settings->SortDirection : ImGuiSortDirection_None;
		BulletText("Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X",
				n, column_settings->DisplayOrder, column_settings->SortOrder,
				(sort_dir == ImGuiSortDirection_Ascending) ? "Asc" : (sort_dir == ImGuiSortDirection_Descending) ? "Des"
																												 : "---",
				column_settings->IsEnabled, column_settings->IsStretch ? "Weight" : "Width ", column_settings->WidthOrWeight, column_settings->UserID);
	}
	TreePop();
}

#else // #ifndef IMGUI_DISABLE_DEBUG_TOOLS

void ImGui::DebugNodeTable(ImGuiTable *) {}
void ImGui::DebugNodeTableSettings(ImGuiTableSettings *) {}

#endif

//-------------------------------------------------------------------------
// [SECTION] Columns, BeginColumns, EndColumns, etc.
// (This is a legacy API, prefer using BeginTable/EndTable!)
//-------------------------------------------------------------------------
// FIXME: sizing is lossy when columns width is very small (default width may turn negative etc.)
//-------------------------------------------------------------------------
// - SetWindowClipRectBeforeSetChannel() [Internal]
// - GetColumnIndex()
// - GetColumnsCount()
// - GetColumnOffset()
// - GetColumnWidth()
// - SetColumnOffset()
// - SetColumnWidth()
// - PushColumnClipRect() [Internal]
// - PushColumnsBackground() [Internal]
// - PopColumnsBackground() [Internal]
// - FindOrCreateColumns() [Internal]
// - GetColumnsID() [Internal]
// - BeginColumns()
// - NextColumn()
// - EndColumns()
// - Columns()
//-------------------------------------------------------------------------

// [Internal] Small optimization to avoid calls to PopClipRect/SetCurrentChannel/PushClipRect in sequences,
// they would meddle many times with the underlying ImDrawCmd.
// Instead, we do a preemptive overwrite of clipping rectangle _without_ altering the command-buffer and let
// the subsequent single call to SetCurrentChannel() does it things once.
void ImGui::SetWindowClipRectBeforeSetChannel(ImGuiWindow *window, const ImRect &clip_rect) {
	ImVec4 clip_rect_vec4 = clip_rect.ToVec4();
	window->ClipRect = clip_rect;
	window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;
	window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;
}

int ImGui::GetColumnIndex() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
}

int ImGui::GetColumnsCount() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
}

float ImGui::GetColumnOffsetFromNorm(const ImGuiOldColumns *columns, float offset_norm) {
	return offset_norm * (columns->OffMaxX - columns->OffMinX);
}

float ImGui::GetColumnNormFromOffset(const ImGuiOldColumns *columns, float offset) {
	return offset / (columns->OffMaxX - columns->OffMinX);
}

static const float COLUMNS_HIT_RECT_HALF_THICKNESS = 4.0f;

static float GetDraggedColumnOffset(ImGuiOldColumns *columns, int column_index) {
	// Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
	// window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
	IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

	float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale) - window->Pos.x;
	x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
	if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))
		x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

	return x;
}

float ImGui::GetColumnOffset(int column_index) {
	ImGuiWindow *window = GetCurrentWindowRead();
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	if (columns == NULL)
		return 0.0f;

	if (column_index < 0)
		column_index = columns->Current;
	IM_ASSERT(column_index < columns->Columns.Size);

	const float t = columns->Columns[column_index].OffsetNorm;
	const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);
	return x_offset;
}

static float GetColumnWidthEx(ImGuiOldColumns *columns, int column_index, bool before_resize = false) {
	if (column_index < 0)
		column_index = columns->Current;

	float offset_norm;
	if (before_resize)
		offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
	else
		offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
	return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	if (columns == NULL)
		return GetContentRegionAvail().x;

	if (column_index < 0)
		column_index = columns->Current;
	return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	IM_ASSERT(columns != NULL);

	if (column_index < 0)
		column_index = columns->Current;
	IM_ASSERT(column_index < columns->Columns.Size);

	const bool preserve_width = !(columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths) && (column_index < columns->Count - 1);
	const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

	if (!(columns->Flags & ImGuiOldColumnFlags_NoForceWithinWindow))
		offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
	columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);

	if (preserve_width)
		SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width) {
	ImGuiWindow *window = GetCurrentWindowRead();
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	IM_ASSERT(columns != NULL);

	if (column_index < 0)
		column_index = columns->Current;
	SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index) {
	ImGuiWindow *window = GetCurrentWindowRead();
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	if (column_index < 0)
		column_index = columns->Current;

	ImGuiOldColumnData *column = &columns->Columns[column_index];
	PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);
}

// Get into the columns background draw command (which is generally the same draw command as before we called BeginColumns)
void ImGui::PushColumnsBackground() {
	ImGuiWindow *window = GetCurrentWindowRead();
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	if (columns->Count == 1)
		return;

	// Optimization: avoid SetCurrentChannel() + PushClipRect()
	columns->HostBackupClipRect = window->ClipRect;
	SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);
	columns->Splitter.SetCurrentChannel(window->DrawList, 0);
}

void ImGui::PopColumnsBackground() {
	ImGuiWindow *window = GetCurrentWindowRead();
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	if (columns->Count == 1)
		return;

	// Optimization: avoid PopClipRect() + SetCurrentChannel()
	SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);
	columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);
}

ImGuiOldColumns *ImGui::FindOrCreateColumns(ImGuiWindow *window, ImGuiID id) {
	// We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
	for (int n = 0; n < window->ColumnsStorage.Size; n++)
		if (window->ColumnsStorage[n].ID == id)
			return &window->ColumnsStorage[n];

	window->ColumnsStorage.push_back(ImGuiOldColumns());
	ImGuiOldColumns *columns = &window->ColumnsStorage.back();
	columns->ID = id;
	return columns;
}

ImGuiID ImGui::GetColumnsID(const char *str_id, int columns_count) {
	ImGuiWindow *window = GetCurrentWindow();

	// Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
	// In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
	PushID(0x11223347 + (str_id ? 0 : columns_count));
	ImGuiID id = window->GetID(str_id ? str_id : "columns");
	PopID();

	return id;
}

void ImGui::BeginColumns(const char *str_id, int columns_count, ImGuiOldColumnFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();

	IM_ASSERT(columns_count >= 1);
	IM_ASSERT(window->DC.CurrentColumns == NULL); // Nested columns are currently not supported

	// Acquire storage for the columns set
	ImGuiID id = GetColumnsID(str_id, columns_count);
	ImGuiOldColumns *columns = FindOrCreateColumns(window, id);
	IM_ASSERT(columns->ID == id);
	columns->Current = 0;
	columns->Count = columns_count;
	columns->Flags = flags;
	window->DC.CurrentColumns = columns;
	window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();

	columns->HostCursorPosY = window->DC.CursorPos.y;
	columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;
	columns->HostInitialClipRect = window->ClipRect;
	columns->HostBackupParentWorkRect = window->ParentWorkRect;
	window->ParentWorkRect = window->WorkRect;

	// Set state for first column
	// We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
	const float column_padding = g.Style.ItemSpacing.x;
	const float half_clip_extend_x = ImTrunc(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));
	const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);
	const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;
	columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);
	columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);
	columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

	// Clear data if columns count changed
	if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
		columns->Columns.resize(0);

	// Initialize default widths
	columns->IsFirstFrame = (columns->Columns.Size == 0);
	if (columns->Columns.Size == 0) {
		columns->Columns.reserve(columns_count + 1);
		for (int n = 0; n < columns_count + 1; n++) {
			ImGuiOldColumnData column;
			column.OffsetNorm = n / (float)columns_count;
			columns->Columns.push_back(column);
		}
	}

	for (int n = 0; n < columns_count; n++) {
		// Compute clipping rectangle
		ImGuiOldColumnData *column = &columns->Columns[n];
		float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));
		float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
		column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
		column->ClipRect.ClipWithFull(window->ClipRect);
	}

	if (columns->Count > 1) {
		columns->Splitter.Split(window->DrawList, 1 + columns->Count);
		columns->Splitter.SetCurrentChannel(window->DrawList, 1);
		PushColumnClipRect(0);
	}

	// We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
	float offset_0 = GetColumnOffset(columns->Current);
	float offset_1 = GetColumnOffset(columns->Current + 1);
	float width = offset_1 - offset_0;
	PushItemWidth(width * 0.65f);
	window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
	window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
	window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
	window->WorkRect.Max.y = window->ContentRegionRect.Max.y;
}

void ImGui::NextColumn() {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems || window->DC.CurrentColumns == NULL)
		return;

	ImGuiContext &g = *GImGui;
	ImGuiOldColumns *columns = window->DC.CurrentColumns;

	if (columns->Count == 1) {
		window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
		IM_ASSERT(columns->Current == 0);
		return;
	}

	// Next column
	if (++columns->Current == columns->Count)
		columns->Current = 0;

	PopItemWidth();

	// Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()
	// (which would needlessly attempt to update commands in the wrong channel, then pop or overwrite them),
	ImGuiOldColumnData *column = &columns->Columns[columns->Current];
	SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
	columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

	const float column_padding = g.Style.ItemSpacing.x;
	columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
	if (columns->Current > 0) {
		// Columns 1+ ignore IndentX (by canceling it out)
		// FIXME-COLUMNS: Unnecessary, could be locked?
		window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;
	} else {
		// New row/line: column 0 honor IndentX.
		window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
		window->DC.IsSameLine = false;
		columns->LineMinY = columns->LineMaxY;
	}
	window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
	window->DC.CursorPos.y = columns->LineMinY;
	window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
	window->DC.CurrLineTextBaseOffset = 0.0f;

	// FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
	float offset_0 = GetColumnOffset(columns->Current);
	float offset_1 = GetColumnOffset(columns->Current + 1);
	float width = offset_1 - offset_0;
	PushItemWidth(width * 0.65f);
	window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

void ImGui::EndColumns() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	IM_ASSERT(columns != NULL);

	PopItemWidth();
	if (columns->Count > 1) {
		PopClipRect();
		columns->Splitter.Merge(window->DrawList);
	}

	const ImGuiOldColumnFlags flags = columns->Flags;
	columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
	window->DC.CursorPos.y = columns->LineMaxY;
	if (!(flags & ImGuiOldColumnFlags_GrowParentContentsSize))
		window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX; // Restore cursor max pos, as columns don't grow parent

	// Draw columns borders and handle resize
	// The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
	bool is_being_resized = false;
	if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems) {
		// We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
		const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);
		const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);
		int dragging_column = -1;
		for (int n = 1; n < columns->Count; n++) {
			ImGuiOldColumnData *column = &columns->Columns[n];
			float x = window->Pos.x + GetColumnOffset(n);
			const ImGuiID column_id = columns->ID + ImGuiID(n);
			const float column_hit_hw = ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale);
			const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));
			if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))
				continue;

			bool hovered = false, held = false;
			if (!(flags & ImGuiOldColumnFlags_NoResize)) {
				ButtonBehavior(column_hit_rect, column_id, &hovered, &held);
				if (hovered || held)
					g.MouseCursor = ImGuiMouseCursor_ResizeEW;
				if (held && !(column->Flags & ImGuiOldColumnFlags_NoResize))
					dragging_column = n;
			}

			// Draw column
			const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered
																					: ImGuiCol_Separator);
			const float xi = IM_TRUNC(x);
			window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);
		}

		// Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
		if (dragging_column != -1) {
			if (!columns->IsBeingResized)
				for (int n = 0; n < columns->Count + 1; n++)
					columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
			columns->IsBeingResized = is_being_resized = true;
			float x = GetDraggedColumnOffset(columns, dragging_column);
			SetColumnOffset(dragging_column, x);
		}
	}
	columns->IsBeingResized = is_being_resized;

	window->WorkRect = window->ParentWorkRect;
	window->ParentWorkRect = columns->HostBackupParentWorkRect;
	window->DC.CurrentColumns = NULL;
	window->DC.ColumnsOffset.x = 0.0f;
	window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
	NavUpdateCurrentWindowIsScrollPushableX();
}

void ImGui::Columns(int columns_count, const char *id, bool borders) {
	ImGuiWindow *window = GetCurrentWindow();
	IM_ASSERT(columns_count >= 1);

	ImGuiOldColumnFlags flags = (borders ? 0 : ImGuiOldColumnFlags_NoBorder);
	//flags |= ImGuiOldColumnFlags_NoPreserveWidths; // NB: Legacy behavior
	ImGuiOldColumns *columns = window->DC.CurrentColumns;
	if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)
		return;

	if (columns != NULL)
		EndColumns();

	if (columns_count != 1)
		BeginColumns(id, columns_count, flags);
}

//-------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE
#line 0

//#define STBRP_STATIC
//#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
//#define STBRP_SORT          ImQsort
//#define STB_RECT_PACK_IMPLEMENTATION
//{{F I L E:sfw/render_gui/imstb_rectpack.h}}

#line 1 "sfw/render_gui/imgui_draw.cpp"
// dear imgui, v1.91.1
// (drawing and font code)

/*

Index of this file:

// [SECTION] STB libraries implementation
// [SECTION] Style functions
// [SECTION] ImDrawList
// [SECTION] ImTriangulator, ImDrawList concave polygon fill
// [SECTION] ImDrawListSplitter
// [SECTION] ImDrawData
// [SECTION] Helpers ShadeVertsXXX functions
// [SECTION] ImFontConfig
// [SECTION] ImFontAtlas
// [SECTION] ImFontAtlas glyph ranges helpers
// [SECTION] ImFontGlyphRangesBuilder
// [SECTION] ImFont
// [SECTION] ImGui Internal Render Helpers
// [SECTION] Decompression code
// [SECTION] Default font data (ProggyClean.ttf)

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif

#ifndef IMGUI_DISABLE

#ifdef IMGUI_ENABLE_FREETYPE
#include "misc/freetype/imgui_freetype.h"
#endif

#include <stdio.h> // vsnprintf, sscanf, printf

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(disable : 4127) // condition expression is constant
#pragma warning(disable : 4505) // unreferenced local function has been removed (stb stuff)
#pragma warning(disable : 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#pragma warning(disable : 26451) // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning(disable : 26812) // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option" // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast" // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.
#pragma clang diagnostic ignored "-Wglobal-constructors" // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant" // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wcomma" // warning: possible misuse of comma operator here
#pragma clang diagnostic ignored "-Wreserved-id-macro" // warning: macro name is a reserved identifier
#pragma clang diagnostic ignored "-Wdouble-promotion" // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored "-Wreserved-identifier" // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage" // warning: 'xxx' is an unsafe pointer used for buffer access
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wunused-function" // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wdouble-promotion" // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion" // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wstack-protector" // warning: stack protector not protecting local variables: variable length buffer
#pragma GCC diagnostic ignored "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)
//-------------------------------------------------------------------------

// Compile time options:
//#define IMGUI_STB_NAMESPACE           ImStb
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

#ifdef IMGUI_STB_NAMESPACE
namespace IMGUI_STB_NAMESPACE {
#endif

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4456) // declaration of 'xx' hides previous local declaration
#pragma warning(disable : 6011) // (stb_rectpack) Dereferencing NULL pointer 'cur->next'.
#pragma warning(disable : 6385) // (stb_truetype) Reading invalid data from 'buffer':  the readable size is '_Old_3`kernel_width' bytes, but '3' bytes may be read.
#pragma warning(disable : 28182) // (stb_rectpack) Dereferencing NULL pointer. 'cur' contains the same NULL value as 'cur->next' did.
#endif

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wcast-qual" // warning: cast from 'const xxxx *' to 'xxx *' drops const qualifier
#endif

#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits" // warning: comparison is always true due to limited range of data type [-Wtype-limits]
#pragma GCC diagnostic ignored "-Wcast-qual" // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
#endif

#ifndef STB_RECT_PACK_IMPLEMENTATION // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION // in case the user already have an implementation in another compilation unit
#define STBRP_STATIC
#define STBRP_ASSERT(x) \
	do {                \
		IM_ASSERT(x);   \
	} while (0)
#define STBRP_SORT ImQsort
#define STB_RECT_PACK_IMPLEMENTATION
#endif
#ifdef IMGUI_STB_RECT_PACK_FILENAME
#include IMGUI_STB_RECT_PACK_FILENAME

#endif
#endif

#ifdef IMGUI_ENABLE_STB_TRUETYPE
#ifndef STB_TRUETYPE_IMPLEMENTATION // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION // in case the user already have an implementation in another compilation unit
#define STBTT_malloc(x, u) ((void)(u), IM_ALLOC(x))
#define STBTT_free(x, u) ((void)(u), IM_FREE(x))
#define STBTT_assert(x) \
	do {                \
		IM_ASSERT(x);   \
	} while (0)
#define STBTT_fmod(x, y) ImFmod(x, y)
#define STBTT_sqrt(x) ImSqrt(x)
#define STBTT_pow(x, y) ImPow(x, y)
#define STBTT_fabs(x) ImFabs(x)
#define STBTT_ifloor(x) ((int)ImFloor(x))
#define STBTT_iceil(x) ((int)ImCeil(x))
#define STBTT_STATIC
#define STB_TRUETYPE_IMPLEMENTATION
#else
#define STBTT_DEF extern
#endif
#ifdef IMGUI_STB_TRUETYPE_FILENAME
#include IMGUI_STB_TRUETYPE_FILENAME

#endif
#endif
#endif // IMGUI_ENABLE_STB_TRUETYPE

#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#ifdef IMGUI_STB_NAMESPACE
} // namespace ImStb
using namespace IMGUI_STB_NAMESPACE;
#endif

//-----------------------------------------------------------------------------
// [SECTION] Style functions
//-----------------------------------------------------------------------------

void ImGui::StyleColorsDark(ImGuiStyle *dst) {
	ImGuiStyle *style = dst ? dst : &ImGui::GetStyle();
	ImVec4 *colors = style->Colors;

	colors[ImGuiCol_Text] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
	colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_PopupBg] = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
	colors[ImGuiCol_Border] = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_FrameBg] = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_SliderGrab] = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_Button] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
	colors[ImGuiCol_Header] = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_Separator] = colors[ImGuiCol_Border];
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
	colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];
	colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.80f);
	colors[ImGuiCol_TabSelected] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
	colors[ImGuiCol_TabSelectedOverline] = colors[ImGuiCol_HeaderActive];
	colors[ImGuiCol_TabDimmed] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);
	colors[ImGuiCol_TabDimmedSelected] = ImLerp(colors[ImGuiCol_TabSelected], colors[ImGuiCol_TitleBg], 0.40f);
	colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
	colors[ImGuiCol_PlotLines] = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
	colors[ImGuiCol_TableHeaderBg] = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
	colors[ImGuiCol_TableBorderStrong] = ImVec4(0.31f, 0.31f, 0.35f, 1.00f); // Prefer using Alpha=1.0 here
	colors[ImGuiCol_TableBorderLight] = ImVec4(0.23f, 0.23f, 0.25f, 1.00f); // Prefer using Alpha=1.0 here
	colors[ImGuiCol_TableRowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
	colors[ImGuiCol_TextLink] = colors[ImGuiCol_HeaderActive];
	colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
	colors[ImGuiCol_NavHighlight] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
	colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
	colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
}

void ImGui::StyleColorsClassic(ImGuiStyle *dst) {
	ImGuiStyle *style = dst ? dst : &ImGui::GetStyle();
	ImVec4 *colors = style->Colors;

	colors[ImGuiCol_Text] = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.85f);
	colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_PopupBg] = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);
	colors[ImGuiCol_Border] = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_FrameBg] = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);
	colors[ImGuiCol_SliderGrab] = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
	colors[ImGuiCol_Button] = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);
	colors[ImGuiCol_Header] = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);
	colors[ImGuiCol_Separator] = ImVec4(0.50f, 0.50f, 0.50f, 0.60f);
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(1.00f, 1.00f, 1.00f, 0.10f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);
	colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];
	colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.80f);
	colors[ImGuiCol_TabSelected] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
	colors[ImGuiCol_TabSelectedOverline] = colors[ImGuiCol_HeaderActive];
	colors[ImGuiCol_TabDimmed] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);
	colors[ImGuiCol_TabDimmedSelected] = ImLerp(colors[ImGuiCol_TabSelected], colors[ImGuiCol_TitleBg], 0.40f);
	colors[ImGuiCol_TabDimmedSelectedOverline] = colors[ImGuiCol_HeaderActive];
	colors[ImGuiCol_PlotLines] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
	colors[ImGuiCol_TableHeaderBg] = ImVec4(0.27f, 0.27f, 0.38f, 1.00f);
	colors[ImGuiCol_TableBorderStrong] = ImVec4(0.31f, 0.31f, 0.45f, 1.00f); // Prefer using Alpha=1.0 here
	colors[ImGuiCol_TableBorderLight] = ImVec4(0.26f, 0.26f, 0.28f, 1.00f); // Prefer using Alpha=1.0 here
	colors[ImGuiCol_TableRowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.00f, 1.00f, 1.00f, 0.07f);
	colors[ImGuiCol_TextLink] = colors[ImGuiCol_HeaderActive];
	colors[ImGuiCol_TextSelectedBg] = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
	colors[ImGuiCol_NavHighlight] = colors[ImGuiCol_HeaderHovered];
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
	colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
	colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

// Those light colors are better suited with a thicker font than the default one + FrameBorder
void ImGui::StyleColorsLight(ImGuiStyle *dst) {
	ImGuiStyle *style = dst ? dst : &ImGui::GetStyle();
	ImVec4 *colors = style->Colors;

	colors[ImGuiCol_Text] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);
	colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_PopupBg] = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);
	colors[ImGuiCol_Border] = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_FrameBg] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_SliderGrab] = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);
	colors[ImGuiCol_Button] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
	colors[ImGuiCol_Header] = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_Separator] = ImVec4(0.39f, 0.39f, 0.39f, 0.62f);
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(0.35f, 0.35f, 0.35f, 0.17f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
	colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];
	colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.90f);
	colors[ImGuiCol_TabSelected] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
	colors[ImGuiCol_TabSelectedOverline] = colors[ImGuiCol_HeaderActive];
	colors[ImGuiCol_TabDimmed] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);
	colors[ImGuiCol_TabDimmedSelected] = ImLerp(colors[ImGuiCol_TabSelected], colors[ImGuiCol_TitleBg], 0.40f);
	colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.26f, 0.59f, 1.00f, 1.00f);
	colors[ImGuiCol_PlotLines] = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);
	colors[ImGuiCol_TableHeaderBg] = ImVec4(0.78f, 0.87f, 0.98f, 1.00f);
	colors[ImGuiCol_TableBorderStrong] = ImVec4(0.57f, 0.57f, 0.64f, 1.00f); // Prefer using Alpha=1.0 here
	colors[ImGuiCol_TableBorderLight] = ImVec4(0.68f, 0.68f, 0.74f, 1.00f); // Prefer using Alpha=1.0 here
	colors[ImGuiCol_TableRowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_TableRowBgAlt] = ImVec4(0.30f, 0.30f, 0.30f, 0.09f);
	colors[ImGuiCol_TextLink] = colors[ImGuiCol_HeaderActive];
	colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
	colors[ImGuiCol_NavHighlight] = colors[ImGuiCol_HeaderHovered];
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);
	colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);
	colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawList
//-----------------------------------------------------------------------------

ImDrawListSharedData::ImDrawListSharedData() {
	memset(this, 0, sizeof(*this));
	for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++) {
		const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
		ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
	}
	ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
}

void ImDrawListSharedData::SetCircleTessellationMaxError(float max_error) {
	if (CircleSegmentMaxError == max_error)
		return;

	IM_ASSERT(max_error > 0.0f);
	CircleSegmentMaxError = max_error;
	for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++) {
		const float radius = (float)i;
		CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
	}
	ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
}

// Initialize before use in a new frame. We always have a command ready in the buffer.
// In the majority of cases, you would want to call PushClipRect() and PushTextureID() after this.
void ImDrawList::_ResetForNewFrame() {
	// Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
	IM_STATIC_ASSERT(offsetof(ImDrawCmd, ClipRect) == 0);
	IM_STATIC_ASSERT(offsetof(ImDrawCmd, TextureId) == sizeof(ImVec4));
	IM_STATIC_ASSERT(offsetof(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
	if (_Splitter._Count > 1)
		_Splitter.Merge(this);

	CmdBuffer.resize(0);
	IdxBuffer.resize(0);
	VtxBuffer.resize(0);
	Flags = _Data->InitialFlags;
	memset(&_CmdHeader, 0, sizeof(_CmdHeader));
	_VtxCurrentIdx = 0;
	_VtxWritePtr = NULL;
	_IdxWritePtr = NULL;
	_ClipRectStack.resize(0);
	_TextureIdStack.resize(0);
	_Path.resize(0);
	_Splitter.Clear();
	CmdBuffer.push_back(ImDrawCmd());
	_FringeScale = 1.0f;
}

void ImDrawList::_ClearFreeMemory() {
	CmdBuffer.clear();
	IdxBuffer.clear();
	VtxBuffer.clear();
	Flags = ImDrawListFlags_None;
	_VtxCurrentIdx = 0;
	_VtxWritePtr = NULL;
	_IdxWritePtr = NULL;
	_ClipRectStack.clear();
	_TextureIdStack.clear();
	_Path.clear();
	_Splitter.ClearFreeMemory();
}

ImDrawList *ImDrawList::CloneOutput() const {
	ImDrawList *dst = IM_NEW(ImDrawList(_Data));
	dst->CmdBuffer = CmdBuffer;
	dst->IdxBuffer = IdxBuffer;
	dst->VtxBuffer = VtxBuffer;
	dst->Flags = Flags;
	return dst;
}

void ImDrawList::AddDrawCmd() {
	ImDrawCmd draw_cmd;
	draw_cmd.ClipRect = _CmdHeader.ClipRect; // Same as calling ImDrawCmd_HeaderCopy()
	draw_cmd.TextureId = _CmdHeader.TextureId;
	draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
	draw_cmd.IdxOffset = IdxBuffer.Size;

	IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
	CmdBuffer.push_back(draw_cmd);
}

// Pop trailing draw command (used before merging or presenting to user)
// Note that this leaves the ImDrawList in a state unfit for further commands, as most code assume that CmdBuffer.Size > 0 && CmdBuffer.back().UserCallback == NULL
void ImDrawList::_PopUnusedDrawCmd() {
	while (CmdBuffer.Size > 0) {
		ImDrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
		if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
			return; // break;
		CmdBuffer.pop_back();
	}
}

void ImDrawList::AddCallback(ImDrawCallback callback, void *callback_data) {
	IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
	ImDrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
	IM_ASSERT(curr_cmd->UserCallback == NULL);
	if (curr_cmd->ElemCount != 0) {
		AddDrawCmd();
		curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
	}
	curr_cmd->UserCallback = callback;
	curr_cmd->UserCallbackData = callback_data;

	AddDrawCmd(); // Force a new command after us (see comment below)
}

// Compare ClipRect, TextureId and VtxOffset with a single memcmp()
#define ImDrawCmd_HeaderSize (offsetof(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS) (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize)) // Compare ClipRect, TextureId, VtxOffset
#define ImDrawCmd_HeaderCopy(CMD_DST, CMD_SRC) (memcpy(CMD_DST, CMD_SRC, ImDrawCmd_HeaderSize)) // Copy ClipRect, TextureId, VtxOffset
#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1) (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)

// Try to merge two last draw commands
void ImDrawList::_TryMergeDrawCmds() {
	IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
	ImDrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
	ImDrawCmd *prev_cmd = curr_cmd - 1;
	if (ImDrawCmd_HeaderCompare(curr_cmd, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && curr_cmd->UserCallback == NULL && prev_cmd->UserCallback == NULL) {
		prev_cmd->ElemCount += curr_cmd->ElemCount;
		CmdBuffer.pop_back();
	}
}

// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
void ImDrawList::_OnChangedClipRect() {
	// If current command is used with different settings we need to add a new command
	IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
	ImDrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
	if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0) {
		AddDrawCmd();
		return;
	}
	IM_ASSERT(curr_cmd->UserCallback == NULL);

	// Try to merge with previous command if it matches, else use current command
	ImDrawCmd *prev_cmd = curr_cmd - 1;
	if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL) {
		CmdBuffer.pop_back();
		return;
	}
	curr_cmd->ClipRect = _CmdHeader.ClipRect;
}

void ImDrawList::_OnChangedTextureID() {
	// If current command is used with different settings we need to add a new command
	IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
	ImDrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
	if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId) {
		AddDrawCmd();
		return;
	}
	IM_ASSERT(curr_cmd->UserCallback == NULL);

	// Try to merge with previous command if it matches, else use current command
	ImDrawCmd *prev_cmd = curr_cmd - 1;
	if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL) {
		CmdBuffer.pop_back();
		return;
	}
	curr_cmd->TextureId = _CmdHeader.TextureId;
}

void ImDrawList::_OnChangedVtxOffset() {
	// We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.
	_VtxCurrentIdx = 0;
	IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
	ImDrawCmd *curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
	//IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
	if (curr_cmd->ElemCount != 0) {
		AddDrawCmd();
		return;
	}
	IM_ASSERT(curr_cmd->UserCallback == NULL);
	curr_cmd->VtxOffset = _CmdHeader.VtxOffset;
}

int ImDrawList::_CalcCircleAutoSegmentCount(float radius) const {
	// Automatic segment count
	const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy
	if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
		return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
	else
		return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
}

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
void ImDrawList::PushClipRect(const ImVec2 &cr_min, const ImVec2 &cr_max, bool intersect_with_current_clip_rect) {
	ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
	if (intersect_with_current_clip_rect) {
		ImVec4 current = _CmdHeader.ClipRect;
		if (cr.x < current.x)
			cr.x = current.x;
		if (cr.y < current.y)
			cr.y = current.y;
		if (cr.z > current.z)
			cr.z = current.z;
		if (cr.w > current.w)
			cr.w = current.w;
	}
	cr.z = ImMax(cr.x, cr.z);
	cr.w = ImMax(cr.y, cr.w);

	_ClipRectStack.push_back(cr);
	_CmdHeader.ClipRect = cr;
	_OnChangedClipRect();
}

void ImDrawList::PushClipRectFullScreen() {
	PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
}

void ImDrawList::PopClipRect() {
	_ClipRectStack.pop_back();
	_CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
	_OnChangedClipRect();
}

void ImDrawList::PushTextureID(ImTextureID texture_id) {
	_TextureIdStack.push_back(texture_id);
	_CmdHeader.TextureId = texture_id;
	_OnChangedTextureID();
}

void ImDrawList::PopTextureID() {
	_TextureIdStack.pop_back();
	_CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];
	_OnChangedTextureID();
}

// This is used by ImGui::PushFont()/PopFont(). It works because we never use _TextureIdStack[] elsewhere than in PushTextureID()/PopTextureID().
void ImDrawList::_SetTextureID(ImTextureID texture_id) {
	if (_CmdHeader.TextureId == texture_id)
		return;
	_CmdHeader.TextureId = texture_id;
	_OnChangedTextureID();
}

// Reserve space for a number of vertices and indices.
// You must finish filling your reserved data before calling PrimReserve() again, as it may reallocate or
// submit the intermediate results. PrimUnreserve() can be used to release unused allocations.
void ImDrawList::PrimReserve(int idx_count, int vtx_count) {
	// Large mesh support (when enabled)
	IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
	if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset)) {
		// FIXME: In theory we should be testing that vtx_count <64k here.
		// In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
		// to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
		_CmdHeader.VtxOffset = VtxBuffer.Size;
		_OnChangedVtxOffset();
	}

	ImDrawCmd *draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
	draw_cmd->ElemCount += idx_count;

	int vtx_buffer_old_size = VtxBuffer.Size;
	VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
	_VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

	int idx_buffer_old_size = IdxBuffer.Size;
	IdxBuffer.resize(idx_buffer_old_size + idx_count);
	_IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
}

// Release the number of reserved vertices/indices from the end of the last reservation made with PrimReserve().
void ImDrawList::PrimUnreserve(int idx_count, int vtx_count) {
	IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);

	ImDrawCmd *draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
	draw_cmd->ElemCount -= idx_count;
	VtxBuffer.shrink(VtxBuffer.Size - vtx_count);
	IdxBuffer.shrink(IdxBuffer.Size - idx_count);
}

// Fully unrolled with inline call to keep our debug builds decently fast.
void ImDrawList::PrimRect(const ImVec2 &a, const ImVec2 &c, ImU32 col) {
	ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
	ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
	_IdxWritePtr[0] = idx;
	_IdxWritePtr[1] = (ImDrawIdx)(idx + 1);
	_IdxWritePtr[2] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[3] = idx;
	_IdxWritePtr[4] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[5] = (ImDrawIdx)(idx + 3);
	_VtxWritePtr[0].pos = a;
	_VtxWritePtr[0].uv = uv;
	_VtxWritePtr[0].col = col;
	_VtxWritePtr[1].pos = b;
	_VtxWritePtr[1].uv = uv;
	_VtxWritePtr[1].col = col;
	_VtxWritePtr[2].pos = c;
	_VtxWritePtr[2].uv = uv;
	_VtxWritePtr[2].col = col;
	_VtxWritePtr[3].pos = d;
	_VtxWritePtr[3].uv = uv;
	_VtxWritePtr[3].col = col;
	_VtxWritePtr += 4;
	_VtxCurrentIdx += 4;
	_IdxWritePtr += 6;
}

void ImDrawList::PrimRectUV(const ImVec2 &a, const ImVec2 &c, const ImVec2 &uv_a, const ImVec2 &uv_c, ImU32 col) {
	ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
	ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
	_IdxWritePtr[0] = idx;
	_IdxWritePtr[1] = (ImDrawIdx)(idx + 1);
	_IdxWritePtr[2] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[3] = idx;
	_IdxWritePtr[4] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[5] = (ImDrawIdx)(idx + 3);
	_VtxWritePtr[0].pos = a;
	_VtxWritePtr[0].uv = uv_a;
	_VtxWritePtr[0].col = col;
	_VtxWritePtr[1].pos = b;
	_VtxWritePtr[1].uv = uv_b;
	_VtxWritePtr[1].col = col;
	_VtxWritePtr[2].pos = c;
	_VtxWritePtr[2].uv = uv_c;
	_VtxWritePtr[2].col = col;
	_VtxWritePtr[3].pos = d;
	_VtxWritePtr[3].uv = uv_d;
	_VtxWritePtr[3].col = col;
	_VtxWritePtr += 4;
	_VtxCurrentIdx += 4;
	_IdxWritePtr += 6;
}

void ImDrawList::PrimQuadUV(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c, const ImVec2 &d, const ImVec2 &uv_a, const ImVec2 &uv_b, const ImVec2 &uv_c, const ImVec2 &uv_d, ImU32 col) {
	ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
	_IdxWritePtr[0] = idx;
	_IdxWritePtr[1] = (ImDrawIdx)(idx + 1);
	_IdxWritePtr[2] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[3] = idx;
	_IdxWritePtr[4] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[5] = (ImDrawIdx)(idx + 3);
	_VtxWritePtr[0].pos = a;
	_VtxWritePtr[0].uv = uv_a;
	_VtxWritePtr[0].col = col;
	_VtxWritePtr[1].pos = b;
	_VtxWritePtr[1].uv = uv_b;
	_VtxWritePtr[1].col = col;
	_VtxWritePtr[2].pos = c;
	_VtxWritePtr[2].uv = uv_c;
	_VtxWritePtr[2].col = col;
	_VtxWritePtr[3].pos = d;
	_VtxWritePtr[3].uv = uv_d;
	_VtxWritePtr[3].col = col;
	_VtxWritePtr += 4;
	_VtxCurrentIdx += 4;
	_IdxWritePtr += 6;
}

// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superfluous function calls to optimize debug/non-inlined builds.
// - Those macros expects l-values and need to be used as their own statement.
// - Those macros are intentionally not surrounded by the 'do {} while (0)' idiom because even that translates to runtime with debug compilers.
#define IM_NORMALIZE2F_OVER_ZERO(VX, VY) \
	{                                    \
		float d2 = VX * VX + VY * VY;    \
		if (d2 > 0.0f) {                 \
			float inv_len = ImRsqrt(d2); \
			VX *= inv_len;               \
			VY *= inv_len;               \
		}                                \
	}                                    \
	(void)0
#define IM_FIXNORMAL2F_MAX_INVLEN2 100.0f // 500.0f (see #4053, #3366)
#define IM_FIXNORMAL2F(VX, VY)                         \
	{                                                  \
		float d2 = VX * VX + VY * VY;                  \
		if (d2 > 0.000001f) {                          \
			float inv_len2 = 1.0f / d2;                \
			if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) \
				inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; \
			VX *= inv_len2;                            \
			VY *= inv_len2;                            \
		}                                              \
	}                                                  \
	(void)0

// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
void ImDrawList::AddPolyline(const ImVec2 *points, const int points_count, ImU32 col, ImDrawFlags flags, float thickness) {
	if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)
		return;

	const bool closed = (flags & ImDrawFlags_Closed) != 0;
	const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
	const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
	const bool thick_line = (thickness > _FringeScale);

	if (Flags & ImDrawListFlags_AntiAliasedLines) {
		// Anti-aliased stroke
		const float AA_SIZE = _FringeScale;
		const ImU32 col_trans = col & ~IM_COL32_A_MASK;

		// Thicknesses <1.0 should behave like thickness 1.0
		thickness = ImMax(thickness, 1.0f);
		const int integer_thickness = (int)thickness;
		const float fractional_thickness = thickness - integer_thickness;

		// Do we want to draw this line using a texture?
		// - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
		// - If AA_SIZE is not 1.0f we cannot use the texture path.
		const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);

		// We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
		IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));

		const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
		const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
		PrimReserve(idx_count, vtx_count);

		// Temporary buffer
		// The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
		_Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
		ImVec2 *temp_normals = _Data->TempBuffer.Data;
		ImVec2 *temp_points = temp_normals + points_count;

		// Calculate normals (tangents) for each line segment
		for (int i1 = 0; i1 < count; i1++) {
			const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
			float dx = points[i2].x - points[i1].x;
			float dy = points[i2].y - points[i1].y;
			IM_NORMALIZE2F_OVER_ZERO(dx, dy);
			temp_normals[i1].x = dy;
			temp_normals[i1].y = -dx;
		}
		if (!closed)
			temp_normals[points_count - 1] = temp_normals[points_count - 2];

		// If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
		if (use_texture || !thick_line) {
			// [PATH 1] Texture-based lines (thick or non-thick)
			// [PATH 2] Non texture-based lines (non-thick)

			// The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
			// - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
			//   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
			// - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
			//   allow scaling geometry while preserving one-screen-pixel AA fringe).
			const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;

			// If line is not closed, the first and last points need to be generated differently as there are no normals to blend
			if (!closed) {
				temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
				temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
				temp_points[(points_count - 1) * 2 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * half_draw_size;
				temp_points[(points_count - 1) * 2 + 1] = points[points_count - 1] - temp_normals[points_count - 1] * half_draw_size;
			}

			// Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
			// This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
			// FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
			unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
			for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
			{
				const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
				const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment

				// Average normals
				float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
				float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
				IM_FIXNORMAL2F(dm_x, dm_y);
				dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
				dm_y *= half_draw_size;

				// Add temporary vertexes for the outer edges
				ImVec2 *out_vtx = &temp_points[i2 * 2];
				out_vtx[0].x = points[i2].x + dm_x;
				out_vtx[0].y = points[i2].y + dm_y;
				out_vtx[1].x = points[i2].x - dm_x;
				out_vtx[1].y = points[i2].y - dm_y;

				if (use_texture) {
					// Add indices for two triangles
					_IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0);
					_IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0);
					_IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
					_IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1);
					_IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1);
					_IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
					_IdxWritePtr += 6;
				} else {
					// Add indexes for four triangles
					_IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0);
					_IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0);
					_IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
					_IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2);
					_IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2);
					_IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
					_IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1);
					_IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1);
					_IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
					_IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0);
					_IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0);
					_IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
					_IdxWritePtr += 12;
				}

				idx1 = idx2;
			}

			// Add vertexes for each point on the line
			if (use_texture) {
				// If we're using textures we only need to emit the left/right edge vertices
				ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
				/*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
				{
					const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
					tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
					tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
					tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
					tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
				}*/
				ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
				ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
				for (int i = 0; i < points_count; i++) {
					_VtxWritePtr[0].pos = temp_points[i * 2 + 0];
					_VtxWritePtr[0].uv = tex_uv0;
					_VtxWritePtr[0].col = col; // Left-side outer edge
					_VtxWritePtr[1].pos = temp_points[i * 2 + 1];
					_VtxWritePtr[1].uv = tex_uv1;
					_VtxWritePtr[1].col = col; // Right-side outer edge
					_VtxWritePtr += 2;
				}
			} else {
				// If we're not using a texture, we need the center vertex as well
				for (int i = 0; i < points_count; i++) {
					_VtxWritePtr[0].pos = points[i];
					_VtxWritePtr[0].uv = opaque_uv;
					_VtxWritePtr[0].col = col; // Center of line
					_VtxWritePtr[1].pos = temp_points[i * 2 + 0];
					_VtxWritePtr[1].uv = opaque_uv;
					_VtxWritePtr[1].col = col_trans; // Left-side outer edge
					_VtxWritePtr[2].pos = temp_points[i * 2 + 1];
					_VtxWritePtr[2].uv = opaque_uv;
					_VtxWritePtr[2].col = col_trans; // Right-side outer edge
					_VtxWritePtr += 3;
				}
			}
		} else {
			// [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
			const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;

			// If line is not closed, the first and last points need to be generated differently as there are no normals to blend
			if (!closed) {
				const int points_last = points_count - 1;
				temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
				temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
				temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
				temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
				temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
				temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);
				temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);
				temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
			}

			// Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
			// This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
			// FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
			unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
			for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
			{
				const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
				const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment

				// Average normals
				float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
				float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
				IM_FIXNORMAL2F(dm_x, dm_y);
				float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
				float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
				float dm_in_x = dm_x * half_inner_thickness;
				float dm_in_y = dm_y * half_inner_thickness;

				// Add temporary vertices
				ImVec2 *out_vtx = &temp_points[i2 * 4];
				out_vtx[0].x = points[i2].x + dm_out_x;
				out_vtx[0].y = points[i2].y + dm_out_y;
				out_vtx[1].x = points[i2].x + dm_in_x;
				out_vtx[1].y = points[i2].y + dm_in_y;
				out_vtx[2].x = points[i2].x - dm_in_x;
				out_vtx[2].y = points[i2].y - dm_in_y;
				out_vtx[3].x = points[i2].x - dm_out_x;
				out_vtx[3].y = points[i2].y - dm_out_y;

				// Add indexes
				_IdxWritePtr[0] = (ImDrawIdx)(idx2 + 1);
				_IdxWritePtr[1] = (ImDrawIdx)(idx1 + 1);
				_IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2);
				_IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2);
				_IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2);
				_IdxWritePtr[5] = (ImDrawIdx)(idx2 + 1);
				_IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1);
				_IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1);
				_IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0);
				_IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0);
				_IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0);
				_IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
				_IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2);
				_IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2);
				_IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);
				_IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3);
				_IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3);
				_IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);
				_IdxWritePtr += 18;

				idx1 = idx2;
			}

			// Add vertices
			for (int i = 0; i < points_count; i++) {
				_VtxWritePtr[0].pos = temp_points[i * 4 + 0];
				_VtxWritePtr[0].uv = opaque_uv;
				_VtxWritePtr[0].col = col_trans;
				_VtxWritePtr[1].pos = temp_points[i * 4 + 1];
				_VtxWritePtr[1].uv = opaque_uv;
				_VtxWritePtr[1].col = col;
				_VtxWritePtr[2].pos = temp_points[i * 4 + 2];
				_VtxWritePtr[2].uv = opaque_uv;
				_VtxWritePtr[2].col = col;
				_VtxWritePtr[3].pos = temp_points[i * 4 + 3];
				_VtxWritePtr[3].uv = opaque_uv;
				_VtxWritePtr[3].col = col_trans;
				_VtxWritePtr += 4;
			}
		}
		_VtxCurrentIdx += (ImDrawIdx)vtx_count;
	} else {
		// [PATH 4] Non texture-based, Non anti-aliased lines
		const int idx_count = count * 6;
		const int vtx_count = count * 4; // FIXME-OPT: Not sharing edges
		PrimReserve(idx_count, vtx_count);

		for (int i1 = 0; i1 < count; i1++) {
			const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
			const ImVec2 &p1 = points[i1];
			const ImVec2 &p2 = points[i2];

			float dx = p2.x - p1.x;
			float dy = p2.y - p1.y;
			IM_NORMALIZE2F_OVER_ZERO(dx, dy);
			dx *= (thickness * 0.5f);
			dy *= (thickness * 0.5f);

			_VtxWritePtr[0].pos.x = p1.x + dy;
			_VtxWritePtr[0].pos.y = p1.y - dx;
			_VtxWritePtr[0].uv = opaque_uv;
			_VtxWritePtr[0].col = col;
			_VtxWritePtr[1].pos.x = p2.x + dy;
			_VtxWritePtr[1].pos.y = p2.y - dx;
			_VtxWritePtr[1].uv = opaque_uv;
			_VtxWritePtr[1].col = col;
			_VtxWritePtr[2].pos.x = p2.x - dy;
			_VtxWritePtr[2].pos.y = p2.y + dx;
			_VtxWritePtr[2].uv = opaque_uv;
			_VtxWritePtr[2].col = col;
			_VtxWritePtr[3].pos.x = p1.x - dy;
			_VtxWritePtr[3].pos.y = p1.y + dx;
			_VtxWritePtr[3].uv = opaque_uv;
			_VtxWritePtr[3].col = col;
			_VtxWritePtr += 4;

			_IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx);
			_IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1);
			_IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
			_IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx);
			_IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2);
			_IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
			_IdxWritePtr += 6;
			_VtxCurrentIdx += 4;
		}
	}
}

// - We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
// - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
void ImDrawList::AddConvexPolyFilled(const ImVec2 *points, const int points_count, ImU32 col) {
	if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
		return;

	const ImVec2 uv = _Data->TexUvWhitePixel;

	if (Flags & ImDrawListFlags_AntiAliasedFill) {
		// Anti-aliased Fill
		const float AA_SIZE = _FringeScale;
		const ImU32 col_trans = col & ~IM_COL32_A_MASK;
		const int idx_count = (points_count - 2) * 3 + points_count * 6;
		const int vtx_count = (points_count * 2);
		PrimReserve(idx_count, vtx_count);

		// Add indexes for fill
		unsigned int vtx_inner_idx = _VtxCurrentIdx;
		unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
		for (int i = 2; i < points_count; i++) {
			_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx);
			_IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1));
			_IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
			_IdxWritePtr += 3;
		}

		// Compute normals
		_Data->TempBuffer.reserve_discard(points_count);
		ImVec2 *temp_normals = _Data->TempBuffer.Data;
		for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
			const ImVec2 &p0 = points[i0];
			const ImVec2 &p1 = points[i1];
			float dx = p1.x - p0.x;
			float dy = p1.y - p0.y;
			IM_NORMALIZE2F_OVER_ZERO(dx, dy);
			temp_normals[i0].x = dy;
			temp_normals[i0].y = -dx;
		}

		for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
			// Average normals
			const ImVec2 &n0 = temp_normals[i0];
			const ImVec2 &n1 = temp_normals[i1];
			float dm_x = (n0.x + n1.x) * 0.5f;
			float dm_y = (n0.y + n1.y) * 0.5f;
			IM_FIXNORMAL2F(dm_x, dm_y);
			dm_x *= AA_SIZE * 0.5f;
			dm_y *= AA_SIZE * 0.5f;

			// Add vertices
			_VtxWritePtr[0].pos.x = (points[i1].x - dm_x);
			_VtxWritePtr[0].pos.y = (points[i1].y - dm_y);
			_VtxWritePtr[0].uv = uv;
			_VtxWritePtr[0].col = col; // Inner
			_VtxWritePtr[1].pos.x = (points[i1].x + dm_x);
			_VtxWritePtr[1].pos.y = (points[i1].y + dm_y);
			_VtxWritePtr[1].uv = uv;
			_VtxWritePtr[1].col = col_trans; // Outer
			_VtxWritePtr += 2;

			// Add indexes for fringes
			_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
			_IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1));
			_IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
			_IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
			_IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1));
			_IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
			_IdxWritePtr += 6;
		}
		_VtxCurrentIdx += (ImDrawIdx)vtx_count;
	} else {
		// Non Anti-aliased Fill
		const int idx_count = (points_count - 2) * 3;
		const int vtx_count = points_count;
		PrimReserve(idx_count, vtx_count);
		for (int i = 0; i < vtx_count; i++) {
			_VtxWritePtr[0].pos = points[i];
			_VtxWritePtr[0].uv = uv;
			_VtxWritePtr[0].col = col;
			_VtxWritePtr++;
		}
		for (int i = 2; i < points_count; i++) {
			_IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx);
			_IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1);
			_IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
			_IdxWritePtr += 3;
		}
		_VtxCurrentIdx += (ImDrawIdx)vtx_count;
	}
}

void ImDrawList::_PathArcToFastEx(const ImVec2 &center, float radius, int a_min_sample, int a_max_sample, int a_step) {
	if (radius < 0.5f) {
		_Path.push_back(center);
		return;
	}

	// Calculate arc auto segment step size
	if (a_step <= 0)
		a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);

	// Make sure we never do steps larger than one quarter of the circle
	a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4);

	const int sample_range = ImAbs(a_max_sample - a_min_sample);
	const int a_next_step = a_step;

	int samples = sample_range + 1;
	bool extra_max_sample = false;
	if (a_step > 1) {
		samples = sample_range / a_step + 1;
		const int overstep = sample_range % a_step;

		if (overstep > 0) {
			extra_max_sample = true;
			samples++;

			// When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
			// distribute first step range evenly between them by reducing first step size.
			if (sample_range > 0)
				a_step -= (a_step - overstep) / 2;
		}
	}

	_Path.resize(_Path.Size + samples);
	ImVec2 *out_ptr = _Path.Data + (_Path.Size - samples);

	int sample_index = a_min_sample;
	if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX) {
		sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
		if (sample_index < 0)
			sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
	}

	if (a_max_sample >= a_min_sample) {
		for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step) {
			// a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
			if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
				sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

			const ImVec2 s = _Data->ArcFastVtx[sample_index];
			out_ptr->x = center.x + s.x * radius;
			out_ptr->y = center.y + s.y * radius;
			out_ptr++;
		}
	} else {
		for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step) {
			// a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
			if (sample_index < 0)
				sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

			const ImVec2 s = _Data->ArcFastVtx[sample_index];
			out_ptr->x = center.x + s.x * radius;
			out_ptr->y = center.y + s.y * radius;
			out_ptr++;
		}
	}

	if (extra_max_sample) {
		int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
		if (normalized_max_sample < 0)
			normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

		const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];
		out_ptr->x = center.x + s.x * radius;
		out_ptr->y = center.y + s.y * radius;
		out_ptr++;
	}

	IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
}

void ImDrawList::_PathArcToN(const ImVec2 &center, float radius, float a_min, float a_max, int num_segments) {
	if (radius < 0.5f) {
		_Path.push_back(center);
		return;
	}

	// Note that we are adding a point at both a_min and a_max.
	// If you are trying to draw a full closed circle you don't want the overlapping points!
	_Path.reserve(_Path.Size + (num_segments + 1));
	for (int i = 0; i <= num_segments; i++) {
		const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
		_Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
	}
}

// 0: East, 3: South, 6: West, 9: North, 12: East
void ImDrawList::PathArcToFast(const ImVec2 &center, float radius, int a_min_of_12, int a_max_of_12) {
	if (radius < 0.5f) {
		_Path.push_back(center);
		return;
	}
	_PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
}

void ImDrawList::PathArcTo(const ImVec2 &center, float radius, float a_min, float a_max, int num_segments) {
	if (radius < 0.5f) {
		_Path.push_back(center);
		return;
	}

	if (num_segments > 0) {
		_PathArcToN(center, radius, a_min, a_max, num_segments);
		return;
	}

	// Automatic segment count
	if (radius <= _Data->ArcFastRadiusCutoff) {
		const bool a_is_reverse = a_max < a_min;

		// We are going to use precomputed values for mid samples.
		// Determine first and last sample in lookup table that belong to the arc.
		const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
		const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);

		const int a_min_sample = a_is_reverse ? (int)ImFloor(a_min_sample_f) : (int)ImCeil(a_min_sample_f);
		const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloor(a_max_sample_f);
		const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);

		const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
		const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
		const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;
		const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;

		_Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));
		if (a_emit_start)
			_Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
		if (a_mid_samples > 0)
			_PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);
		if (a_emit_end)
			_Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
	} else {
		const float arc_length = ImAbs(a_max - a_min);
		const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);
		const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
		_PathArcToN(center, radius, a_min, a_max, arc_segment_count);
	}
}

void ImDrawList::PathEllipticalArcTo(const ImVec2 &center, const ImVec2 &radius, float rot, float a_min, float a_max, int num_segments) {
	if (num_segments <= 0)
		num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.

	_Path.reserve(_Path.Size + (num_segments + 1));

	const float cos_rot = ImCos(rot);
	const float sin_rot = ImSin(rot);
	for (int i = 0; i <= num_segments; i++) {
		const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
		ImVec2 point(ImCos(a) * radius.x, ImSin(a) * radius.y);
		const ImVec2 rel((point.x * cos_rot) - (point.y * sin_rot), (point.x * sin_rot) + (point.y * cos_rot));
		point.x = rel.x + center.x;
		point.y = rel.y + center.y;
		_Path.push_back(point);
	}
}

ImVec2 ImBezierCubicCalc(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, float t) {
	float u = 1.0f - t;
	float w1 = u * u * u;
	float w2 = 3 * u * u * t;
	float w3 = 3 * u * t * t;
	float w4 = t * t * t;
	return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y);
}

ImVec2 ImBezierQuadraticCalc(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, float t) {
	float u = 1.0f - t;
	float w1 = u * u;
	float w2 = 2 * u * t;
	float w3 = t * t;
	return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x, w1 * p1.y + w2 * p2.y + w3 * p3.y);
}

// Closely mimics ImBezierCubicClosestPointCasteljau() in imgui.cpp
static void PathBezierCubicCurveToCasteljau(ImVector<ImVec2> *path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level) {
	float dx = x4 - x1;
	float dy = y4 - y1;
	float d2 = (x2 - x4) * dy - (y2 - y4) * dx;
	float d3 = (x3 - x4) * dy - (y3 - y4) * dx;
	d2 = (d2 >= 0) ? d2 : -d2;
	d3 = (d3 >= 0) ? d3 : -d3;
	if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy)) {
		path->push_back(ImVec2(x4, y4));
	} else if (level < 10) {
		float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
		float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
		float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;
		float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
		float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;
		float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;
		PathBezierCubicCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
		PathBezierCubicCurveToCasteljau(path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
	}
}

static void PathBezierQuadraticCurveToCasteljau(ImVector<ImVec2> *path, float x1, float y1, float x2, float y2, float x3, float y3, float tess_tol, int level) {
	float dx = x3 - x1, dy = y3 - y1;
	float det = (x2 - x3) * dy - (y2 - y3) * dx;
	if (det * det * 4.0f < tess_tol * (dx * dx + dy * dy)) {
		path->push_back(ImVec2(x3, y3));
	} else if (level < 10) {
		float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
		float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
		float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
		PathBezierQuadraticCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, tess_tol, level + 1);
		PathBezierQuadraticCurveToCasteljau(path, x123, y123, x23, y23, x3, y3, tess_tol, level + 1);
	}
}

void ImDrawList::PathBezierCubicCurveTo(const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, int num_segments) {
	ImVec2 p1 = _Path.back();
	if (num_segments == 0) {
		IM_ASSERT(_Data->CurveTessellationTol > 0.0f);
		PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0); // Auto-tessellated
	} else {
		float t_step = 1.0f / (float)num_segments;
		for (int i_step = 1; i_step <= num_segments; i_step++)
			_Path.push_back(ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step));
	}
}

void ImDrawList::PathBezierQuadraticCurveTo(const ImVec2 &p2, const ImVec2 &p3, int num_segments) {
	ImVec2 p1 = _Path.back();
	if (num_segments == 0) {
		IM_ASSERT(_Data->CurveTessellationTol > 0.0f);
		PathBezierQuadraticCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, _Data->CurveTessellationTol, 0); // Auto-tessellated
	} else {
		float t_step = 1.0f / (float)num_segments;
		for (int i_step = 1; i_step <= num_segments; i_step++)
			_Path.push_back(ImBezierQuadraticCalc(p1, p2, p3, t_step * i_step));
	}
}

static inline ImDrawFlags FixRectCornerFlags(ImDrawFlags flags) {
	/*
	IM_STATIC_ASSERT(ImDrawFlags_RoundCornersTopLeft == (1 << 4));
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	// Obsoleted in 1.82 (from February 2021). This code was stripped/simplified and mostly commented in 1.90 (from September 2023)
	// - Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
	if (flags == ~0)                    { return ImDrawFlags_RoundCornersAll; }
	// - Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations). Read details in older version of this code.
	if (flags >= 0x01 && flags <= 0x0F) { return (flags << 4); }
	// We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
#endif
	*/
	// If this assert triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
	// Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc. anyway.
	// See details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08 entries in "API BREAKING CHANGES" section.
	IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");

	if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
		flags |= ImDrawFlags_RoundCornersAll;

	return flags;
}

void ImDrawList::PathRect(const ImVec2 &a, const ImVec2 &b, float rounding, ImDrawFlags flags) {
	if (rounding >= 0.5f) {
		flags = FixRectCornerFlags(flags);
		rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);
		rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);
	}
	if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone) {
		PathLineTo(a);
		PathLineTo(ImVec2(b.x, a.y));
		PathLineTo(b);
		PathLineTo(ImVec2(a.x, b.y));
	} else {
		const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft) ? rounding : 0.0f;
		const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight) ? rounding : 0.0f;
		const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
		const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft) ? rounding : 0.0f;
		PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
		PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
		PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
		PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
	}
}

void ImDrawList::AddLine(const ImVec2 &p1, const ImVec2 &p2, ImU32 col, float thickness) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;
	PathLineTo(p1 + ImVec2(0.5f, 0.5f));
	PathLineTo(p2 + ImVec2(0.5f, 0.5f));
	PathStroke(col, 0, thickness);
}

// p_min = upper-left, p_max = lower-right
// Note we don't render 1 pixels sized rectangles properly.
void ImDrawList::AddRect(const ImVec2 &p_min, const ImVec2 &p_max, ImU32 col, float rounding, ImDrawFlags flags, float thickness) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;
	if (Flags & ImDrawListFlags_AntiAliasedLines)
		PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
	else
		PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
	PathStroke(col, ImDrawFlags_Closed, thickness);
}

void ImDrawList::AddRectFilled(const ImVec2 &p_min, const ImVec2 &p_max, ImU32 col, float rounding, ImDrawFlags flags) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;
	if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone) {
		PrimReserve(6, 4);
		PrimRect(p_min, p_max, col);
	} else {
		PathRect(p_min, p_max, rounding, flags);
		PathFillConvex(col);
	}
}

// p_min = upper-left, p_max = lower-right
void ImDrawList::AddRectFilledMultiColor(const ImVec2 &p_min, const ImVec2 &p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left) {
	if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
		return;

	const ImVec2 uv = _Data->TexUvWhitePixel;
	PrimReserve(6, 4);
	PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx));
	PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 1));
	PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));
	PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx));
	PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));
	PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));
	PrimWriteVtx(p_min, uv, col_upr_left);
	PrimWriteVtx(ImVec2(p_max.x, p_min.y), uv, col_upr_right);
	PrimWriteVtx(p_max, uv, col_bot_right);
	PrimWriteVtx(ImVec2(p_min.x, p_max.y), uv, col_bot_left);
}

void ImDrawList::AddQuad(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, ImU32 col, float thickness) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(p1);
	PathLineTo(p2);
	PathLineTo(p3);
	PathLineTo(p4);
	PathStroke(col, ImDrawFlags_Closed, thickness);
}

void ImDrawList::AddQuadFilled(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, ImU32 col) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(p1);
	PathLineTo(p2);
	PathLineTo(p3);
	PathLineTo(p4);
	PathFillConvex(col);
}

void ImDrawList::AddTriangle(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, ImU32 col, float thickness) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(p1);
	PathLineTo(p2);
	PathLineTo(p3);
	PathStroke(col, ImDrawFlags_Closed, thickness);
}

void ImDrawList::AddTriangleFilled(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, ImU32 col) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(p1);
	PathLineTo(p2);
	PathLineTo(p3);
	PathFillConvex(col);
}

void ImDrawList::AddCircle(const ImVec2 &center, float radius, ImU32 col, int num_segments, float thickness) {
	if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
		return;

	if (num_segments <= 0) {
		// Use arc with automatic segment count
		_PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
		_Path.Size--;
	} else {
		// Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
		num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);

		// Because we are filling a closed shape we remove 1 from the count of segments/points
		const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
		PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);
	}

	PathStroke(col, ImDrawFlags_Closed, thickness);
}

void ImDrawList::AddCircleFilled(const ImVec2 &center, float radius, ImU32 col, int num_segments) {
	if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
		return;

	if (num_segments <= 0) {
		// Use arc with automatic segment count
		_PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
		_Path.Size--;
	} else {
		// Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
		num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);

		// Because we are filling a closed shape we remove 1 from the count of segments/points
		const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
		PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
	}

	PathFillConvex(col);
}

// Guaranteed to honor 'num_segments'
void ImDrawList::AddNgon(const ImVec2 &center, float radius, ImU32 col, int num_segments, float thickness) {
	if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
		return;

	// Because we are filling a closed shape we remove 1 from the count of segments/points
	const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
	PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);
	PathStroke(col, ImDrawFlags_Closed, thickness);
}

// Guaranteed to honor 'num_segments'
void ImDrawList::AddNgonFilled(const ImVec2 &center, float radius, ImU32 col, int num_segments) {
	if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
		return;

	// Because we are filling a closed shape we remove 1 from the count of segments/points
	const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
	PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
	PathFillConvex(col);
}

// Ellipse
void ImDrawList::AddEllipse(const ImVec2 &center, const ImVec2 &radius, ImU32 col, float rot, int num_segments, float thickness) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	if (num_segments <= 0)
		num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.

	// Because we are filling a closed shape we remove 1 from the count of segments/points
	const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
	PathEllipticalArcTo(center, radius, rot, 0.0f, a_max, num_segments - 1);
	PathStroke(col, true, thickness);
}

void ImDrawList::AddEllipseFilled(const ImVec2 &center, const ImVec2 &radius, ImU32 col, float rot, int num_segments) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	if (num_segments <= 0)
		num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.

	// Because we are filling a closed shape we remove 1 from the count of segments/points
	const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
	PathEllipticalArcTo(center, radius, rot, 0.0f, a_max, num_segments - 1);
	PathFillConvex(col);
}

// Cubic Bezier takes 4 controls points
void ImDrawList::AddBezierCubic(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, ImU32 col, float thickness, int num_segments) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(p1);
	PathBezierCubicCurveTo(p2, p3, p4, num_segments);
	PathStroke(col, 0, thickness);
}

// Quadratic Bezier takes 3 controls points
void ImDrawList::AddBezierQuadratic(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, ImU32 col, float thickness, int num_segments) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(p1);
	PathBezierQuadraticCurveTo(p2, p3, num_segments);
	PathStroke(col, 0, thickness);
}

void ImDrawList::AddText(const ImFont *font, float font_size, const ImVec2 &pos, ImU32 col, const char *text_begin, const char *text_end, float wrap_width, const ImVec4 *cpu_fine_clip_rect) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	// Accept null ranges
	if (text_begin == text_end || text_begin[0] == 0)
		return;
	if (text_end == NULL)
		text_end = text_begin + strlen(text_begin);

	// Pull default font/size from the shared ImDrawListSharedData instance
	if (font == NULL)
		font = _Data->Font;
	if (font_size == 0.0f)
		font_size = _Data->FontSize;

	IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId); // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

	ImVec4 clip_rect = _CmdHeader.ClipRect;
	if (cpu_fine_clip_rect) {
		clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
		clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
		clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
		clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
	}
	font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
}

void ImDrawList::AddText(const ImVec2 &pos, ImU32 col, const char *text_begin, const char *text_end) {
	AddText(NULL, 0.0f, pos, col, text_begin, text_end);
}

void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2 &p_min, const ImVec2 &p_max, const ImVec2 &uv_min, const ImVec2 &uv_max, ImU32 col) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
	if (push_texture_id)
		PushTextureID(user_texture_id);

	PrimReserve(6, 4);
	PrimRectUV(p_min, p_max, uv_min, uv_max, col);

	if (push_texture_id)
		PopTextureID();
}

void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, const ImVec2 &uv1, const ImVec2 &uv2, const ImVec2 &uv3, const ImVec2 &uv4, ImU32 col) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
	if (push_texture_id)
		PushTextureID(user_texture_id);

	PrimReserve(6, 4);
	PrimQuadUV(p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);

	if (push_texture_id)
		PopTextureID();
}

void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2 &p_min, const ImVec2 &p_max, const ImVec2 &uv_min, const ImVec2 &uv_max, ImU32 col, float rounding, ImDrawFlags flags) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	flags = FixRectCornerFlags(flags);
	if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone) {
		AddImage(user_texture_id, p_min, p_max, uv_min, uv_max, col);
		return;
	}

	const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
	if (push_texture_id)
		PushTextureID(user_texture_id);

	int vert_start_idx = VtxBuffer.Size;
	PathRect(p_min, p_max, rounding, flags);
	PathFillConvex(col);
	int vert_end_idx = VtxBuffer.Size;
	ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true);

	if (push_texture_id)
		PopTextureID();
}

//-----------------------------------------------------------------------------
// [SECTION] ImTriangulator, ImDrawList concave polygon fill
//-----------------------------------------------------------------------------
// Triangulate concave polygons. Based on "Triangulation by Ear Clipping" paper, O(N^2) complexity.
// Reference: https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
// Provided as a convenience for user but not used by main library.
//-----------------------------------------------------------------------------
// - ImTriangulator [Internal]
// - AddConcavePolyFilled()
//-----------------------------------------------------------------------------

enum ImTriangulatorNodeType {
	ImTriangulatorNodeType_Convex,
	ImTriangulatorNodeType_Ear,
	ImTriangulatorNodeType_Reflex
};

struct ImTriangulatorNode {
	ImTriangulatorNodeType Type;
	int Index;
	ImVec2 Pos;
	ImTriangulatorNode *Next;
	ImTriangulatorNode *Prev;

	void Unlink() {
		Next->Prev = Prev;
		Prev->Next = Next;
	}
};

struct ImTriangulatorNodeSpan {
	ImTriangulatorNode **Data = NULL;
	int Size = 0;

	void push_back(ImTriangulatorNode *node) { Data[Size++] = node; }
	void find_erase_unsorted(int idx) {
		for (int i = Size - 1; i >= 0; i--)
			if (Data[i]->Index == idx) {
				Data[i] = Data[Size - 1];
				Size--;
				return;
			}
	}
};

struct ImTriangulator {
	static int EstimateTriangleCount(int points_count) { return (points_count < 3) ? 0 : points_count - 2; }
	static int EstimateScratchBufferSize(int points_count) { return sizeof(ImTriangulatorNode) * points_count + sizeof(ImTriangulatorNode *) * points_count * 2; }

	void Init(const ImVec2 *points, int points_count, void *scratch_buffer);
	void GetNextTriangle(unsigned int out_triangle[3]); // Return relative indexes for next triangle

	// Internal functions
	void BuildNodes(const ImVec2 *points, int points_count);
	void BuildReflexes();
	void BuildEars();
	void FlipNodeList();
	bool IsEar(int i0, int i1, int i2, const ImVec2 &v0, const ImVec2 &v1, const ImVec2 &v2) const;
	void ReclassifyNode(ImTriangulatorNode *node);

	// Internal members
	int _TrianglesLeft = 0;
	ImTriangulatorNode *_Nodes = NULL;
	ImTriangulatorNodeSpan _Ears;
	ImTriangulatorNodeSpan _Reflexes;
};

// Distribute storage for nodes, ears and reflexes.
// FIXME-OPT: if everything is convex, we could report it to caller and let it switch to an convex renderer
// (this would require first building reflexes to bail to convex if empty, without even building nodes)
void ImTriangulator::Init(const ImVec2 *points, int points_count, void *scratch_buffer) {
	IM_ASSERT(scratch_buffer != NULL && points_count >= 3);
	_TrianglesLeft = EstimateTriangleCount(points_count);
	_Nodes = (ImTriangulatorNode *)scratch_buffer; // points_count x Node
	_Ears.Data = (ImTriangulatorNode **)(_Nodes + points_count); // points_count x Node*
	_Reflexes.Data = (ImTriangulatorNode **)(_Nodes + points_count) + points_count; // points_count x Node*
	BuildNodes(points, points_count);
	BuildReflexes();
	BuildEars();
}

void ImTriangulator::BuildNodes(const ImVec2 *points, int points_count) {
	for (int i = 0; i < points_count; i++) {
		_Nodes[i].Type = ImTriangulatorNodeType_Convex;
		_Nodes[i].Index = i;
		_Nodes[i].Pos = points[i];
		_Nodes[i].Next = _Nodes + i + 1;
		_Nodes[i].Prev = _Nodes + i - 1;
	}
	_Nodes[0].Prev = _Nodes + points_count - 1;
	_Nodes[points_count - 1].Next = _Nodes;
}

void ImTriangulator::BuildReflexes() {
	ImTriangulatorNode *n1 = _Nodes;
	for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next) {
		if (ImTriangleIsClockwise(n1->Prev->Pos, n1->Pos, n1->Next->Pos))
			continue;
		n1->Type = ImTriangulatorNodeType_Reflex;
		_Reflexes.push_back(n1);
	}
}

void ImTriangulator::BuildEars() {
	ImTriangulatorNode *n1 = _Nodes;
	for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next) {
		if (n1->Type != ImTriangulatorNodeType_Convex)
			continue;
		if (!IsEar(n1->Prev->Index, n1->Index, n1->Next->Index, n1->Prev->Pos, n1->Pos, n1->Next->Pos))
			continue;
		n1->Type = ImTriangulatorNodeType_Ear;
		_Ears.push_back(n1);
	}
}

void ImTriangulator::GetNextTriangle(unsigned int out_triangle[3]) {
	if (_Ears.Size == 0) {
		FlipNodeList();

		ImTriangulatorNode *node = _Nodes;
		for (int i = _TrianglesLeft; i >= 0; i--, node = node->Next)
			node->Type = ImTriangulatorNodeType_Convex;
		_Reflexes.Size = 0;
		BuildReflexes();
		BuildEars();

		// If we still don't have ears, it means geometry is degenerated.
		if (_Ears.Size == 0) {
			// Return first triangle available, mimicking the behavior of convex fill.
			IM_ASSERT(_TrianglesLeft > 0); // Geometry is degenerated
			_Ears.Data[0] = _Nodes;
			_Ears.Size = 1;
		}
	}

	ImTriangulatorNode *ear = _Ears.Data[--_Ears.Size];
	out_triangle[0] = ear->Prev->Index;
	out_triangle[1] = ear->Index;
	out_triangle[2] = ear->Next->Index;

	ear->Unlink();
	if (ear == _Nodes)
		_Nodes = ear->Next;

	ReclassifyNode(ear->Prev);
	ReclassifyNode(ear->Next);
	_TrianglesLeft--;
}

void ImTriangulator::FlipNodeList() {
	ImTriangulatorNode *prev = _Nodes;
	ImTriangulatorNode *temp = _Nodes;
	ImTriangulatorNode *current = _Nodes->Next;
	prev->Next = prev;
	prev->Prev = prev;
	while (current != _Nodes) {
		temp = current->Next;

		current->Next = prev;
		prev->Prev = current;
		_Nodes->Next = current;
		current->Prev = _Nodes;

		prev = current;
		current = temp;
	}
	_Nodes = prev;
}

// A triangle is an ear is no other vertex is inside it. We can test reflexes vertices only (see reference algorithm)
bool ImTriangulator::IsEar(int i0, int i1, int i2, const ImVec2 &v0, const ImVec2 &v1, const ImVec2 &v2) const {
	ImTriangulatorNode **p_end = _Reflexes.Data + _Reflexes.Size;
	for (ImTriangulatorNode **p = _Reflexes.Data; p < p_end; p++) {
		ImTriangulatorNode *reflex = *p;
		if (reflex->Index != i0 && reflex->Index != i1 && reflex->Index != i2)
			if (ImTriangleContainsPoint(v0, v1, v2, reflex->Pos))
				return false;
	}
	return true;
}

void ImTriangulator::ReclassifyNode(ImTriangulatorNode *n1) {
	// Classify node
	ImTriangulatorNodeType type;
	const ImTriangulatorNode *n0 = n1->Prev;
	const ImTriangulatorNode *n2 = n1->Next;
	if (!ImTriangleIsClockwise(n0->Pos, n1->Pos, n2->Pos))
		type = ImTriangulatorNodeType_Reflex;
	else if (IsEar(n0->Index, n1->Index, n2->Index, n0->Pos, n1->Pos, n2->Pos))
		type = ImTriangulatorNodeType_Ear;
	else
		type = ImTriangulatorNodeType_Convex;

	// Update lists when a type changes
	if (type == n1->Type)
		return;
	if (n1->Type == ImTriangulatorNodeType_Reflex)
		_Reflexes.find_erase_unsorted(n1->Index);
	else if (n1->Type == ImTriangulatorNodeType_Ear)
		_Ears.find_erase_unsorted(n1->Index);
	if (type == ImTriangulatorNodeType_Reflex)
		_Reflexes.push_back(n1);
	else if (type == ImTriangulatorNodeType_Ear)
		_Ears.push_back(n1);
	n1->Type = type;
}

// Use ear-clipping algorithm to triangulate a simple polygon (no self-interaction, no holes).
// (Reminder: we don't perform any coarse clipping/culling in ImDrawList layer!
// It is up to caller to ensure not making costly calls that will be outside of visible area.
// As concave fill is noticeably more expensive than other primitives, be mindful of this...
// Caller can build AABB of points, and avoid filling if 'draw_list->_CmdHeader.ClipRect.Overlays(points_bb) == false')
void ImDrawList::AddConcavePolyFilled(const ImVec2 *points, const int points_count, ImU32 col) {
	if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
		return;

	const ImVec2 uv = _Data->TexUvWhitePixel;
	ImTriangulator triangulator;
	unsigned int triangle[3];
	if (Flags & ImDrawListFlags_AntiAliasedFill) {
		// Anti-aliased Fill
		const float AA_SIZE = _FringeScale;
		const ImU32 col_trans = col & ~IM_COL32_A_MASK;
		const int idx_count = (points_count - 2) * 3 + points_count * 6;
		const int vtx_count = (points_count * 2);
		PrimReserve(idx_count, vtx_count);

		// Add indexes for fill
		unsigned int vtx_inner_idx = _VtxCurrentIdx;
		unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;

		_Data->TempBuffer.reserve_discard((ImTriangulator::EstimateScratchBufferSize(points_count) + sizeof(ImVec2)) / sizeof(ImVec2));
		triangulator.Init(points, points_count, _Data->TempBuffer.Data);
		while (triangulator._TrianglesLeft > 0) {
			triangulator.GetNextTriangle(triangle);
			_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (triangle[0] << 1));
			_IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (triangle[1] << 1));
			_IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (triangle[2] << 1));
			_IdxWritePtr += 3;
		}

		// Compute normals
		_Data->TempBuffer.reserve_discard(points_count);
		ImVec2 *temp_normals = _Data->TempBuffer.Data;
		for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
			const ImVec2 &p0 = points[i0];
			const ImVec2 &p1 = points[i1];
			float dx = p1.x - p0.x;
			float dy = p1.y - p0.y;
			IM_NORMALIZE2F_OVER_ZERO(dx, dy);
			temp_normals[i0].x = dy;
			temp_normals[i0].y = -dx;
		}

		for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++) {
			// Average normals
			const ImVec2 &n0 = temp_normals[i0];
			const ImVec2 &n1 = temp_normals[i1];
			float dm_x = (n0.x + n1.x) * 0.5f;
			float dm_y = (n0.y + n1.y) * 0.5f;
			IM_FIXNORMAL2F(dm_x, dm_y);
			dm_x *= AA_SIZE * 0.5f;
			dm_y *= AA_SIZE * 0.5f;

			// Add vertices
			_VtxWritePtr[0].pos.x = (points[i1].x - dm_x);
			_VtxWritePtr[0].pos.y = (points[i1].y - dm_y);
			_VtxWritePtr[0].uv = uv;
			_VtxWritePtr[0].col = col; // Inner
			_VtxWritePtr[1].pos.x = (points[i1].x + dm_x);
			_VtxWritePtr[1].pos.y = (points[i1].y + dm_y);
			_VtxWritePtr[1].uv = uv;
			_VtxWritePtr[1].col = col_trans; // Outer
			_VtxWritePtr += 2;

			// Add indexes for fringes
			_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
			_IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1));
			_IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
			_IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
			_IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1));
			_IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
			_IdxWritePtr += 6;
		}
		_VtxCurrentIdx += (ImDrawIdx)vtx_count;
	} else {
		// Non Anti-aliased Fill
		const int idx_count = (points_count - 2) * 3;
		const int vtx_count = points_count;
		PrimReserve(idx_count, vtx_count);
		for (int i = 0; i < vtx_count; i++) {
			_VtxWritePtr[0].pos = points[i];
			_VtxWritePtr[0].uv = uv;
			_VtxWritePtr[0].col = col;
			_VtxWritePtr++;
		}
		_Data->TempBuffer.reserve_discard((ImTriangulator::EstimateScratchBufferSize(points_count) + sizeof(ImVec2)) / sizeof(ImVec2));
		triangulator.Init(points, points_count, _Data->TempBuffer.Data);
		while (triangulator._TrianglesLeft > 0) {
			triangulator.GetNextTriangle(triangle);
			_IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx + triangle[0]);
			_IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + triangle[1]);
			_IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + triangle[2]);
			_IdxWritePtr += 3;
		}
		_VtxCurrentIdx += (ImDrawIdx)vtx_count;
	}
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawListSplitter
//-----------------------------------------------------------------------------
// FIXME: This may be a little confusing, trying to be a little too low-level/optimal instead of just doing vector swap..
//-----------------------------------------------------------------------------

void ImDrawListSplitter::ClearFreeMemory() {
	for (int i = 0; i < _Channels.Size; i++) {
		if (i == _Current)
			memset(&_Channels[i], 0, sizeof(_Channels[i])); // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
		_Channels[i]._CmdBuffer.clear();
		_Channels[i]._IdxBuffer.clear();
	}
	_Current = 0;
	_Count = 1;
	_Channels.clear();
}

void ImDrawListSplitter::Split(ImDrawList *draw_list, int channels_count) {
	IM_UNUSED(draw_list);
	IM_ASSERT(_Current == 0 && _Count <= 1 && "Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter.");
	int old_channels_count = _Channels.Size;
	if (old_channels_count < channels_count) {
		_Channels.reserve(channels_count); // Avoid over reserving since this is likely to stay stable
		_Channels.resize(channels_count);
	}
	_Count = channels_count;

	// Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
	// The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
	// When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
	memset(&_Channels[0], 0, sizeof(ImDrawChannel));
	for (int i = 1; i < channels_count; i++) {
		if (i >= old_channels_count) {
			IM_PLACEMENT_NEW(&_Channels[i])
			ImDrawChannel();
		} else {
			_Channels[i]._CmdBuffer.resize(0);
			_Channels[i]._IdxBuffer.resize(0);
		}
	}
}

void ImDrawListSplitter::Merge(ImDrawList *draw_list) {
	// Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
	if (_Count <= 1)
		return;

	SetCurrentChannel(draw_list, 0);
	draw_list->_PopUnusedDrawCmd();

	// Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
	int new_cmd_buffer_count = 0;
	int new_idx_buffer_count = 0;
	ImDrawCmd *last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;
	int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;
	for (int i = 1; i < _Count; i++) {
		ImDrawChannel &ch = _Channels[i];
		if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
			ch._CmdBuffer.pop_back();

		if (ch._CmdBuffer.Size > 0 && last_cmd != NULL) {
			// Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.
			// Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.
			ImDrawCmd *next_cmd = &ch._CmdBuffer[0];
			if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL) {
				// Merge previous channel last draw command with current channel first draw command if matching.
				last_cmd->ElemCount += next_cmd->ElemCount;
				idx_offset += next_cmd->ElemCount;
				ch._CmdBuffer.erase(ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.
			}
		}
		if (ch._CmdBuffer.Size > 0)
			last_cmd = &ch._CmdBuffer.back();
		new_cmd_buffer_count += ch._CmdBuffer.Size;
		new_idx_buffer_count += ch._IdxBuffer.Size;
		for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++) {
			ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;
			idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;
		}
	}
	draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);
	draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

	// Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)
	ImDrawCmd *cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;
	ImDrawIdx *idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;
	for (int i = 1; i < _Count; i++) {
		ImDrawChannel &ch = _Channels[i];
		if (int sz = ch._CmdBuffer.Size) {
			memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd));
			cmd_write += sz;
		}
		if (int sz = ch._IdxBuffer.Size) {
			memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx));
			idx_write += sz;
		}
	}
	draw_list->_IdxWritePtr = idx_write;

	// Ensure there's always a non-callback draw command trailing the command-buffer
	if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)
		draw_list->AddDrawCmd();

	// If current command is used with different settings we need to add a new command
	ImDrawCmd *curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
	if (curr_cmd->ElemCount == 0)
		ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
	else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
		draw_list->AddDrawCmd();

	_Count = 1;
}

void ImDrawListSplitter::SetCurrentChannel(ImDrawList *draw_list, int idx) {
	IM_ASSERT(idx >= 0 && idx < _Count);
	if (_Current == idx)
		return;

	// Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
	memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));
	memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));
	_Current = idx;
	memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));
	memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));
	draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;

	// If current command is used with different settings we need to add a new command
	ImDrawCmd *curr_cmd = (draw_list->CmdBuffer.Size == 0) ? NULL : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
	if (curr_cmd == NULL)
		draw_list->AddDrawCmd();
	else if (curr_cmd->ElemCount == 0)
		ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
	else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
		draw_list->AddDrawCmd();
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawData
//-----------------------------------------------------------------------------

void ImDrawData::Clear() {
	Valid = false;
	CmdListsCount = TotalIdxCount = TotalVtxCount = 0;
	CmdLists.resize(0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.
	DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);
	OwnerViewport = NULL;
}

// Important: 'out_list' is generally going to be draw_data->CmdLists, but may be another temporary list
// as long at it is expected that the result will be later merged into draw_data->CmdLists[].
void ImGui::AddDrawListToDrawDataEx(ImDrawData *draw_data, ImVector<ImDrawList *> *out_list, ImDrawList *draw_list) {
	if (draw_list->CmdBuffer.Size == 0)
		return;
	if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
		return;

	// Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
	// May trigger for you if you are using PrimXXX functions incorrectly.
	IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
	IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
	if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
		IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

	// Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
	// If this assert triggers because you are drawing lots of stuff manually:
	// - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
	//   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
	// - If you want large meshes with more than 64K vertices, you can either:
	//   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
	//       Most example backends already support this from 1.71. Pre-1.71 backends won't.
	//       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
	//   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
	//       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
	//         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
	//       Your own engine or render API may use different parameters or function calls to specify index sizes.
	//       2 and 4 bytes indices are generally supported by most graphics API.
	// - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
	//   the 64K limit to split your draw commands in multiple draw lists.
	if (sizeof(ImDrawIdx) == 2)
		IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");

	// Add to output list + records state in ImDrawData
	out_list->push_back(draw_list);
	draw_data->CmdListsCount++;
	draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
	draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
}

void ImDrawData::AddDrawList(ImDrawList *draw_list) {
	IM_ASSERT(CmdLists.Size == CmdListsCount);
	draw_list->_PopUnusedDrawCmd();
	ImGui::AddDrawListToDrawDataEx(this, &CmdLists, draw_list);
}

// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
void ImDrawData::DeIndexAllBuffers() {
	ImVector<ImDrawVert> new_vtx_buffer;
	TotalVtxCount = TotalIdxCount = 0;
	for (int i = 0; i < CmdListsCount; i++) {
		ImDrawList *cmd_list = CmdLists[i];
		if (cmd_list->IdxBuffer.empty())
			continue;
		new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);
		for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)
			new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];
		cmd_list->VtxBuffer.swap(new_vtx_buffer);
		cmd_list->IdxBuffer.resize(0);
		TotalVtxCount += cmd_list->VtxBuffer.Size;
	}
}

// Helper to scale the ClipRect field of each ImDrawCmd.
// Use if your final output buffer is at a different scale than draw_data->DisplaySize,
// or if there is a difference between your window resolution and framebuffer resolution.
void ImDrawData::ScaleClipRects(const ImVec2 &fb_scale) {
	for (ImDrawList *draw_list : CmdLists)
		for (ImDrawCmd &cmd : draw_list->CmdBuffer)
			cmd.ClipRect = ImVec4(cmd.ClipRect.x * fb_scale.x, cmd.ClipRect.y * fb_scale.y, cmd.ClipRect.z * fb_scale.x, cmd.ClipRect.w * fb_scale.y);
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers ShadeVertsXXX functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList *draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1) {
	ImVec2 gradient_extent = gradient_p1 - gradient_p0;
	float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);
	ImDrawVert *vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
	ImDrawVert *vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
	const int col0_r = (int)(col0 >> IM_COL32_R_SHIFT) & 0xFF;
	const int col0_g = (int)(col0 >> IM_COL32_G_SHIFT) & 0xFF;
	const int col0_b = (int)(col0 >> IM_COL32_B_SHIFT) & 0xFF;
	const int col_delta_r = ((int)(col1 >> IM_COL32_R_SHIFT) & 0xFF) - col0_r;
	const int col_delta_g = ((int)(col1 >> IM_COL32_G_SHIFT) & 0xFF) - col0_g;
	const int col_delta_b = ((int)(col1 >> IM_COL32_B_SHIFT) & 0xFF) - col0_b;
	for (ImDrawVert *vert = vert_start; vert < vert_end; vert++) {
		float d = ImDot(vert->pos - gradient_p0, gradient_extent);
		float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);
		int r = (int)(col0_r + col_delta_r * t);
		int g = (int)(col0_g + col_delta_g * t);
		int b = (int)(col0_b + col_delta_b * t);
		vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);
	}
}

// Distribute UV over (a, b) rectangle
void ImGui::ShadeVertsLinearUV(ImDrawList *draw_list, int vert_start_idx, int vert_end_idx, const ImVec2 &a, const ImVec2 &b, const ImVec2 &uv_a, const ImVec2 &uv_b, bool clamp) {
	const ImVec2 size = b - a;
	const ImVec2 uv_size = uv_b - uv_a;
	const ImVec2 scale = ImVec2(
			size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
			size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);

	ImDrawVert *vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
	ImDrawVert *vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
	if (clamp) {
		const ImVec2 min = ImMin(uv_a, uv_b);
		const ImVec2 max = ImMax(uv_a, uv_b);
		for (ImDrawVert *vertex = vert_start; vertex < vert_end; ++vertex)
			vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);
	} else {
		for (ImDrawVert *vertex = vert_start; vertex < vert_end; ++vertex)
			vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);
	}
}

void ImGui::ShadeVertsTransformPos(ImDrawList *draw_list, int vert_start_idx, int vert_end_idx, const ImVec2 &pivot_in, float cos_a, float sin_a, const ImVec2 &pivot_out) {
	ImDrawVert *vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
	ImDrawVert *vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
	for (ImDrawVert *vertex = vert_start; vertex < vert_end; ++vertex)
		vertex->pos = ImRotate(vertex->pos - pivot_in, cos_a, sin_a) + pivot_out;
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontConfig
//-----------------------------------------------------------------------------

ImFontConfig::ImFontConfig() {
	memset(this, 0, sizeof(*this));
	FontDataOwnedByAtlas = true;
	OversampleH = 2;
	OversampleV = 1;
	GlyphMaxAdvanceX = FLT_MAX;
	RasterizerMultiply = 1.0f;
	RasterizerDensity = 1.0f;
	EllipsisChar = (ImWchar)-1;
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
// The 2x2 white texels on the top left are the ones we'll use everywhere in Dear ImGui to render filled shapes.
// (This is used when io.MouseDrawCursor = true)
const int FONT_ATLAS_DEFAULT_TEX_DATA_W = 122; // Actual texture will be 2 times that + 1 spacing.
const int FONT_ATLAS_DEFAULT_TEX_DATA_H = 27;
static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] = {
	"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          - XX       XX "
	"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         -X..X     X..X"
	"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         -X...X   X...X"
	"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         - X...X X...X "
	"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         -  X...X...X  "
	"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       -   X.....X   "
	"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    -    X...X    "
	"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  -     X.X     "
	"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X -    X...X    "
	"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X-   X.....X   "
	"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X-  X...X...X  "
	"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X- X...X X...X "
	"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X-X...X   X...X"
	"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X-X..X     X..X"
	"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X- XX       XX "
	"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X--------------"
	"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X -             "
	"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X -             "
	"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X -             "
	"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  -             "
	"      X..X  -       -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  -             "
	"       XX   -       -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  -             "
	"-------------       -    X    -           X           -X.....................X-           -------------------             "
	"                    ----------------------------------- X...XXXXXXXXXXXXX...X -                                           "
	"                                                      -  X..X           X..X  -                                           "
	"                                                      -   X.X           X.X   -                                           "
	"                                                      -    XX           XX    -                                           "
};

static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] = {
	// Pos ........ Size ......... Offset ......
	{ ImVec2(0, 3), ImVec2(12, 19), ImVec2(0, 0) }, // ImGuiMouseCursor_Arrow
	{ ImVec2(13, 0), ImVec2(7, 16), ImVec2(1, 8) }, // ImGuiMouseCursor_TextInput
	{ ImVec2(31, 0), ImVec2(23, 23), ImVec2(11, 11) }, // ImGuiMouseCursor_ResizeAll
	{ ImVec2(21, 0), ImVec2(9, 23), ImVec2(4, 11) }, // ImGuiMouseCursor_ResizeNS
	{ ImVec2(55, 18), ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW
	{ ImVec2(73, 0), ImVec2(17, 17), ImVec2(8, 8) }, // ImGuiMouseCursor_ResizeNESW
	{ ImVec2(55, 0), ImVec2(17, 17), ImVec2(8, 8) }, // ImGuiMouseCursor_ResizeNWSE
	{ ImVec2(91, 0), ImVec2(17, 22), ImVec2(5, 0) }, // ImGuiMouseCursor_Hand
	{ ImVec2(109, 0), ImVec2(13, 15), ImVec2(6, 7) }, // ImGuiMouseCursor_NotAllowed
};

ImFontAtlas::ImFontAtlas() {
	memset(this, 0, sizeof(*this));
	TexGlyphPadding = 1;
	PackIdMouseCursors = PackIdLines = -1;
}

ImFontAtlas::~ImFontAtlas() {
	IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
	Clear();
}

void ImFontAtlas::ClearInputData() {
	IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
	for (ImFontConfig &font_cfg : ConfigData)
		if (font_cfg.FontData && font_cfg.FontDataOwnedByAtlas) {
			IM_FREE(font_cfg.FontData);
			font_cfg.FontData = NULL;
		}

	// When clearing this we lose access to the font name and other information used to build the font.
	for (ImFont *font : Fonts)
		if (font->ConfigData >= ConfigData.Data && font->ConfigData < ConfigData.Data + ConfigData.Size) {
			font->ConfigData = NULL;
			font->ConfigDataCount = 0;
		}
	ConfigData.clear();
	CustomRects.clear();
	PackIdMouseCursors = PackIdLines = -1;
	// Important: we leave TexReady untouched
}

void ImFontAtlas::ClearTexData() {
	IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
	if (TexPixelsAlpha8)
		IM_FREE(TexPixelsAlpha8);
	if (TexPixelsRGBA32)
		IM_FREE(TexPixelsRGBA32);
	TexPixelsAlpha8 = NULL;
	TexPixelsRGBA32 = NULL;
	TexPixelsUseColors = false;
	// Important: we leave TexReady untouched
}

void ImFontAtlas::ClearFonts() {
	IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
	Fonts.clear_delete();
	TexReady = false;
}

void ImFontAtlas::Clear() {
	ClearInputData();
	ClearTexData();
	ClearFonts();
}

void ImFontAtlas::GetTexDataAsAlpha8(unsigned char **out_pixels, int *out_width, int *out_height, int *out_bytes_per_pixel) {
	// Build atlas on demand
	if (TexPixelsAlpha8 == NULL)
		Build();

	*out_pixels = TexPixelsAlpha8;
	if (out_width)
		*out_width = TexWidth;
	if (out_height)
		*out_height = TexHeight;
	if (out_bytes_per_pixel)
		*out_bytes_per_pixel = 1;
}

void ImFontAtlas::GetTexDataAsRGBA32(unsigned char **out_pixels, int *out_width, int *out_height, int *out_bytes_per_pixel) {
	// Convert to RGBA32 format on demand
	// Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
	if (!TexPixelsRGBA32) {
		unsigned char *pixels = NULL;
		GetTexDataAsAlpha8(&pixels, NULL, NULL);
		if (pixels) {
			TexPixelsRGBA32 = (unsigned int *)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
			const unsigned char *src = pixels;
			unsigned int *dst = TexPixelsRGBA32;
			for (int n = TexWidth * TexHeight; n > 0; n--)
				*dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
		}
	}

	*out_pixels = (unsigned char *)TexPixelsRGBA32;
	if (out_width)
		*out_width = TexWidth;
	if (out_height)
		*out_height = TexHeight;
	if (out_bytes_per_pixel)
		*out_bytes_per_pixel = 4;
}

ImFont *ImFontAtlas::AddFont(const ImFontConfig *font_cfg) {
	IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
	IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
	IM_ASSERT(font_cfg->SizePixels > 0.0f);

	// Create new font
	if (!font_cfg->MergeMode)
		Fonts.push_back(IM_NEW(ImFont));
	else
		IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

	ConfigData.push_back(*font_cfg);
	ImFontConfig &new_font_cfg = ConfigData.back();
	if (new_font_cfg.DstFont == NULL)
		new_font_cfg.DstFont = Fonts.back();
	if (!new_font_cfg.FontDataOwnedByAtlas) {
		new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
		new_font_cfg.FontDataOwnedByAtlas = true;
		memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
	}

	if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)
		new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;

	ImFontAtlasUpdateConfigDataPointers(this);

	// Invalidate texture
	TexReady = false;
	ClearTexData();
	return new_font_cfg.DstFont;
}

// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
static unsigned int stb_decompress_length(const unsigned char *input);
static unsigned int stb_decompress(unsigned char *output, const unsigned char *input, unsigned int length);
static const char *GetDefaultCompressedFontDataTTFBase85();
static unsigned int Decode85Byte(char c) {
	return c >= '\\' ? c - 36 : c - 35;
}
static void Decode85(const unsigned char *src, unsigned char *dst) {
	while (*src) {
		unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
		dst[0] = ((tmp >> 0) & 0xFF);
		dst[1] = ((tmp >> 8) & 0xFF);
		dst[2] = ((tmp >> 16) & 0xFF);
		dst[3] = ((tmp >> 24) & 0xFF); // We can't assume little-endianness.
		src += 5;
		dst += 4;
	}
}

// Load embedded ProggyClean.ttf at size 13, disable oversampling
ImFont *ImFontAtlas::AddFontDefault(const ImFontConfig *font_cfg_template) {
	ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
	if (!font_cfg_template) {
		font_cfg.OversampleH = font_cfg.OversampleV = 1;
		font_cfg.PixelSnapH = true;
	}
	if (font_cfg.SizePixels <= 0.0f)
		font_cfg.SizePixels = 13.0f * 1.0f;
	if (font_cfg.Name[0] == '\0')
		ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
	font_cfg.EllipsisChar = (ImWchar)0x0085;
	font_cfg.GlyphOffset.y = 1.0f * IM_TRUNC(font_cfg.SizePixels / 13.0f); // Add +1 offset per 13 units

	const char *ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
	const ImWchar *glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
	ImFont *font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
	return font;
}

ImFont *ImFontAtlas::AddFontFromFileTTF(const char *filename, float size_pixels, const ImFontConfig *font_cfg_template, const ImWchar *glyph_ranges) {
	IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
	size_t data_size = 0;
	void *data = ImFileLoadToMemory(filename, "rb", &data_size, 0);
	if (!data) {
		IM_ASSERT_USER_ERROR(0, "Could not load font file!");
		return NULL;
	}
	ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
	if (font_cfg.Name[0] == '\0') {
		// Store a short copy of filename into into the font name for convenience
		const char *p;
		for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {
		}
		ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);
	}
	return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);
}

// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
ImFont *ImFontAtlas::AddFontFromMemoryTTF(void *font_data, int font_data_size, float size_pixels, const ImFontConfig *font_cfg_template, const ImWchar *glyph_ranges) {
	IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
	ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
	IM_ASSERT(font_cfg.FontData == NULL);
	IM_ASSERT(font_data_size > 100 && "Incorrect value for font_data_size!"); // Heuristic to prevent accidentally passing a wrong value to font_data_size.
	font_cfg.FontData = font_data;
	font_cfg.FontDataSize = font_data_size;
	font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
	if (glyph_ranges)
		font_cfg.GlyphRanges = glyph_ranges;
	return AddFont(&font_cfg);
}

ImFont *ImFontAtlas::AddFontFromMemoryCompressedTTF(const void *compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig *font_cfg_template, const ImWchar *glyph_ranges) {
	const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char *)compressed_ttf_data);
	unsigned char *buf_decompressed_data = (unsigned char *)IM_ALLOC(buf_decompressed_size);
	stb_decompress(buf_decompressed_data, (const unsigned char *)compressed_ttf_data, (unsigned int)compressed_ttf_size);

	ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
	IM_ASSERT(font_cfg.FontData == NULL);
	font_cfg.FontDataOwnedByAtlas = true;
	return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
}

ImFont *ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char *compressed_ttf_data_base85, float size_pixels, const ImFontConfig *font_cfg, const ImWchar *glyph_ranges) {
	int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
	void *compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
	Decode85((const unsigned char *)compressed_ttf_data_base85, (unsigned char *)compressed_ttf);
	ImFont *font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
	IM_FREE(compressed_ttf);
	return font;
}

int ImFontAtlas::AddCustomRectRegular(int width, int height) {
	IM_ASSERT(width > 0 && width <= 0xFFFF);
	IM_ASSERT(height > 0 && height <= 0xFFFF);
	ImFontAtlasCustomRect r;
	r.Width = (unsigned short)width;
	r.Height = (unsigned short)height;
	CustomRects.push_back(r);
	return CustomRects.Size - 1; // Return index
}

int ImFontAtlas::AddCustomRectFontGlyph(ImFont *font, ImWchar id, int width, int height, float advance_x, const ImVec2 &offset) {
#ifdef IMGUI_USE_WCHAR32
	IM_ASSERT(id <= IM_UNICODE_CODEPOINT_MAX);
#endif
	IM_ASSERT(font != NULL);
	IM_ASSERT(width > 0 && width <= 0xFFFF);
	IM_ASSERT(height > 0 && height <= 0xFFFF);
	ImFontAtlasCustomRect r;
	r.Width = (unsigned short)width;
	r.Height = (unsigned short)height;
	r.GlyphID = id;
	r.GlyphAdvanceX = advance_x;
	r.GlyphOffset = offset;
	r.Font = font;
	CustomRects.push_back(r);
	return CustomRects.Size - 1; // Return index
}

void ImFontAtlas::CalcCustomRectUV(const ImFontAtlasCustomRect *rect, ImVec2 *out_uv_min, ImVec2 *out_uv_max) const {
	IM_ASSERT(TexWidth > 0 && TexHeight > 0); // Font atlas needs to be built before we can calculate UV coordinates
	IM_ASSERT(rect->IsPacked()); // Make sure the rectangle has been packed
	*out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);
	*out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);
}

bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2 *out_offset, ImVec2 *out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]) {
	if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)
		return false;
	if (Flags & ImFontAtlasFlags_NoMouseCursors)
		return false;

	IM_ASSERT(PackIdMouseCursors != -1);
	ImFontAtlasCustomRect *r = GetCustomRectByIndex(PackIdMouseCursors);
	ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);
	ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
	*out_size = size;
	*out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
	out_uv_border[0] = (pos)*TexUvScale;
	out_uv_border[1] = (pos + size) * TexUvScale;
	pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
	out_uv_fill[0] = (pos)*TexUvScale;
	out_uv_fill[1] = (pos + size) * TexUvScale;
	return true;
}

bool ImFontAtlas::Build() {
	IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

	// Default font is none are specified
	if (ConfigData.Size == 0)
		AddFontDefault();

	// Select builder
	// - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
	//   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
	//   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
	//   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
	const ImFontBuilderIO *builder_io = FontBuilderIO;
	if (builder_io == NULL) {
#ifdef IMGUI_ENABLE_FREETYPE
		builder_io = ImGuiFreeType::GetBuilderForFreeType();
#elif defined(IMGUI_ENABLE_STB_TRUETYPE)
		builder_io = ImFontAtlasGetBuilderForStbTruetype();
#else
		IM_ASSERT(0); // Invalid Build function
#endif
	}

	// Build
	return builder_io->FontBuilder_Build(this);
}

void ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor) {
	for (unsigned int i = 0; i < 256; i++) {
		unsigned int value = (unsigned int)(i * in_brighten_factor);
		out_table[i] = value > 255 ? 255 : (value & 0xFF);
	}
}

void ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char *pixels, int x, int y, int w, int h, int stride) {
	IM_ASSERT_PARANOID(w <= stride);
	unsigned char *data = pixels + x + y * stride;
	for (int j = h; j > 0; j--, data += stride - w)
		for (int i = w; i > 0; i--, data++)
			*data = table[*data];
}

#ifdef IMGUI_ENABLE_STB_TRUETYPE
// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)
// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)
struct ImFontBuildSrcData {
	stbtt_fontinfo FontInfo;
	stbtt_pack_range PackRange; // Hold the list of codepoints to pack (essentially points to Codepoints.Data)
	stbrp_rect *Rects; // Rectangle to pack. We first fill in their size and the packer will give us their position.
	stbtt_packedchar *PackedChars; // Output glyphs
	const ImWchar *SrcRanges; // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)
	int DstIndex; // Index into atlas->Fonts[] and dst_tmp_array[]
	int GlyphsHighest; // Highest requested codepoint
	int GlyphsCount; // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)
	ImBitVector GlyphsSet; // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)
	ImVector<int> GlyphsList; // Glyph codepoints list (flattened version of GlyphsSet)
};

// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)
struct ImFontBuildDstData {
	int SrcCount; // Number of source fonts targeting this destination font.
	int GlyphsHighest;
	int GlyphsCount;
	ImBitVector GlyphsSet; // This is used to resolve collision when multiple sources are merged into a same destination font.
};

static void UnpackBitVectorToFlatIndexList(const ImBitVector *in, ImVector<int> *out) {
	IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
	const ImU32 *it_begin = in->Storage.begin();
	const ImU32 *it_end = in->Storage.end();
	for (const ImU32 *it = it_begin; it < it_end; it++)
		if (ImU32 entries_32 = *it)
			for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
				if (entries_32 & ((ImU32)1 << bit_n))
					out->push_back((int)(((it - it_begin) << 5) + bit_n));
}

static bool ImFontAtlasBuildWithStbTruetype(ImFontAtlas *atlas) {
	IM_ASSERT(atlas->ConfigData.Size > 0);

	ImFontAtlasBuildInit(atlas);

	// Clear atlas
	atlas->TexID = (ImTextureID)NULL;
	atlas->TexWidth = atlas->TexHeight = 0;
	atlas->TexUvScale = ImVec2(0.0f, 0.0f);
	atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
	atlas->ClearTexData();

	// Temporary storage for building
	ImVector<ImFontBuildSrcData> src_tmp_array;
	ImVector<ImFontBuildDstData> dst_tmp_array;
	src_tmp_array.resize(atlas->ConfigData.Size);
	dst_tmp_array.resize(atlas->Fonts.Size);
	memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
	memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

	// 1. Initialize font loading structure, check font data validity
	for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++) {
		ImFontBuildSrcData &src_tmp = src_tmp_array[src_i];
		ImFontConfig &cfg = atlas->ConfigData[src_i];
		IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

		// Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
		src_tmp.DstIndex = -1;
		for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
			if (cfg.DstFont == atlas->Fonts[output_i])
				src_tmp.DstIndex = output_i;
		if (src_tmp.DstIndex == -1) {
			IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
			return false;
		}
		// Initialize helper structure for font loading and verify that the TTF/OTF data is correct
		const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char *)cfg.FontData, cfg.FontNo);
		IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
		if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char *)cfg.FontData, font_offset)) {
			IM_ASSERT(0 && "stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize.");
			return false;
		}

		// Measure highest codepoints
		ImFontBuildDstData &dst_tmp = dst_tmp_array[src_tmp.DstIndex];
		src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
		for (const ImWchar *src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2) {
			// Check for valid range. This may also help detect *some* dangling pointers, because a common
			// user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent,
			// or to forget to zero-terminate the glyph range array.
			IM_ASSERT(src_range[0] <= src_range[1] && "Invalid range: is your glyph range array persistent? it is zero-terminated?");
			src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
		}
		dst_tmp.SrcCount++;
		dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
	}

	// 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
	int total_glyphs_count = 0;
	for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
		ImFontBuildSrcData &src_tmp = src_tmp_array[src_i];
		ImFontBuildDstData &dst_tmp = dst_tmp_array[src_tmp.DstIndex];
		src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
		if (dst_tmp.GlyphsSet.Storage.empty())
			dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);

		for (const ImWchar *src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
			for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++) {
				if (dst_tmp.GlyphsSet.TestBit(codepoint)) // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
					continue;
				if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint)) // It is actually in the font?
					continue;

				// Add to avail set/counters
				src_tmp.GlyphsCount++;
				dst_tmp.GlyphsCount++;
				src_tmp.GlyphsSet.SetBit(codepoint);
				dst_tmp.GlyphsSet.SetBit(codepoint);
				total_glyphs_count++;
			}
	}

	// 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
	for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
		ImFontBuildSrcData &src_tmp = src_tmp_array[src_i];
		src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
		UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
		src_tmp.GlyphsSet.Clear();
		IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
	}
	for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
		dst_tmp_array[dst_i].GlyphsSet.Clear();
	dst_tmp_array.clear();

	// Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
	// (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
	ImVector<stbrp_rect> buf_rects;
	ImVector<stbtt_packedchar> buf_packedchars;
	buf_rects.resize(total_glyphs_count);
	buf_packedchars.resize(total_glyphs_count);
	memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
	memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

	// 4. Gather glyphs sizes so we can pack them in our virtual canvas.
	int total_surface = 0;
	int buf_rects_out_n = 0;
	int buf_packedchars_out_n = 0;
	for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
		ImFontBuildSrcData &src_tmp = src_tmp_array[src_i];
		if (src_tmp.GlyphsCount == 0)
			continue;

		src_tmp.Rects = &buf_rects[buf_rects_out_n];
		src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
		buf_rects_out_n += src_tmp.GlyphsCount;
		buf_packedchars_out_n += src_tmp.GlyphsCount;

		// Convert our ranges in the format stb_truetype wants
		ImFontConfig &cfg = atlas->ConfigData[src_i];
		src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity;
		src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
		src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
		src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
		src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
		src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
		src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;

		// Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
		const float scale = (cfg.SizePixels > 0.0f) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels * cfg.RasterizerDensity) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity);
		const int padding = atlas->TexGlyphPadding;
		for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++) {
			int x0, y0, x1, y1;
			const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
			IM_ASSERT(glyph_index_in_font != 0);
			stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
			src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
			src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
			total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
		}
	}

	// We need a width for the skyline algorithm, any width!
	// The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
	// User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
	const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
	atlas->TexHeight = 0;
	if (atlas->TexDesiredWidth > 0)
		atlas->TexWidth = atlas->TexDesiredWidth;
	else
		atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048
				: (surface_sqrt >= 1024 * 0.7f)												   ? 1024
																							   : 512;

	// 5. Start packing
	// Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
	const int TEX_HEIGHT_MAX = 1024 * 32;
	stbtt_pack_context spc = {};
	stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
	ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

	// 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
	for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
		ImFontBuildSrcData &src_tmp = src_tmp_array[src_i];
		if (src_tmp.GlyphsCount == 0)
			continue;

		stbrp_pack_rects((stbrp_context *)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

		// Extend texture height and mark missing glyphs as non-packed so we won't render them.
		// FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
		for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
			if (src_tmp.Rects[glyph_i].was_packed)
				atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
	}

	// 7. Allocate texture
	atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
	atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
	atlas->TexPixelsAlpha8 = (unsigned char *)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
	memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
	spc.pixels = atlas->TexPixelsAlpha8;
	spc.height = atlas->TexHeight;

	// 8. Render/rasterize font characters into the texture
	for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
		ImFontConfig &cfg = atlas->ConfigData[src_i];
		ImFontBuildSrcData &src_tmp = src_tmp_array[src_i];
		if (src_tmp.GlyphsCount == 0)
			continue;

		stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);

		// Apply multiply operator
		if (cfg.RasterizerMultiply != 1.0f) {
			unsigned char multiply_table[256];
			ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
			stbrp_rect *r = &src_tmp.Rects[0];
			for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
				if (r->was_packed)
					ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
		}
		src_tmp.Rects = NULL;
	}

	// End packing
	stbtt_PackEnd(&spc);
	buf_rects.clear();

	// 9. Setup ImFont and glyphs for runtime
	for (int src_i = 0; src_i < src_tmp_array.Size; src_i++) {
		// When merging fonts with MergeMode=true:
		// - We can have multiple input fonts writing into a same destination font.
		// - dst_font->ConfigData is != from cfg which is our source configuration.
		ImFontBuildSrcData &src_tmp = src_tmp_array[src_i];
		ImFontConfig &cfg = atlas->ConfigData[src_i];
		ImFont *dst_font = cfg.DstFont;

		const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
		int unscaled_ascent, unscaled_descent, unscaled_line_gap;
		stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

		const float ascent = ImCeil(unscaled_ascent * font_scale);
		const float descent = ImFloor(unscaled_descent * font_scale);
		ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
		const float font_off_x = cfg.GlyphOffset.x;
		const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);

		const float inv_rasterization_scale = 1.0f / cfg.RasterizerDensity;

		for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++) {
			// Register glyph
			const int codepoint = src_tmp.GlyphsList[glyph_i];
			const stbtt_packedchar &pc = src_tmp.PackedChars[glyph_i];
			stbtt_aligned_quad q;
			float unused_x = 0.0f, unused_y = 0.0f;
			stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
			float x0 = q.x0 * inv_rasterization_scale + font_off_x;
			float y0 = q.y0 * inv_rasterization_scale + font_off_y;
			float x1 = q.x1 * inv_rasterization_scale + font_off_x;
			float y1 = q.y1 * inv_rasterization_scale + font_off_y;
			dst_font->AddGlyph(&cfg, (ImWchar)codepoint, x0, y0, x1, y1, q.s0, q.t0, q.s1, q.t1, pc.xadvance * inv_rasterization_scale);
		}
	}

	// Cleanup
	src_tmp_array.clear_destruct();

	ImFontAtlasBuildFinish(atlas);
	return true;
}

const ImFontBuilderIO *ImFontAtlasGetBuilderForStbTruetype() {
	static ImFontBuilderIO io;
	io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
	return &io;
}

#endif // IMGUI_ENABLE_STB_TRUETYPE

void ImFontAtlasUpdateConfigDataPointers(ImFontAtlas *atlas) {
	for (ImFontConfig &font_cfg : atlas->ConfigData) {
		ImFont *font = font_cfg.DstFont;
		if (!font_cfg.MergeMode) {
			font->ConfigData = &font_cfg;
			font->ConfigDataCount = 0;
		}
		font->ConfigDataCount++;
	}
}

void ImFontAtlasBuildSetupFont(ImFontAtlas *atlas, ImFont *font, ImFontConfig *font_config, float ascent, float descent) {
	if (!font_config->MergeMode) {
		font->ClearOutputData();
		font->FontSize = font_config->SizePixels;
		IM_ASSERT(font->ConfigData == font_config);
		font->ContainerAtlas = atlas;
		font->Ascent = ascent;
		font->Descent = descent;
	}
}

void ImFontAtlasBuildPackCustomRects(ImFontAtlas *atlas, void *stbrp_context_opaque) {
	stbrp_context *pack_context = (stbrp_context *)stbrp_context_opaque;
	IM_ASSERT(pack_context != NULL);

	ImVector<ImFontAtlasCustomRect> &user_rects = atlas->CustomRects;
	IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
#ifdef __GNUC__
	if (user_rects.Size < 1) {
		__builtin_unreachable();
	} // Workaround for GCC bug if IM_ASSERT() is defined to conditionally throw (see #5343)
#endif

	ImVector<stbrp_rect> pack_rects;
	pack_rects.resize(user_rects.Size);
	memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
	for (int i = 0; i < user_rects.Size; i++) {
		pack_rects[i].w = user_rects[i].Width;
		pack_rects[i].h = user_rects[i].Height;
	}
	stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
	for (int i = 0; i < pack_rects.Size; i++)
		if (pack_rects[i].was_packed) {
			user_rects[i].X = (unsigned short)pack_rects[i].x;
			user_rects[i].Y = (unsigned short)pack_rects[i].y;
			IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
			atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
		}
}

void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas *atlas, int x, int y, int w, int h, const char *in_str, char in_marker_char, unsigned char in_marker_pixel_value) {
	IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
	IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
	unsigned char *out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
	for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
		for (int off_x = 0; off_x < w; off_x++)
			out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
}

void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas *atlas, int x, int y, int w, int h, const char *in_str, char in_marker_char, unsigned int in_marker_pixel_value) {
	IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
	IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
	unsigned int *out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);
	for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
		for (int off_x = 0; off_x < w; off_x++)
			out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS;
}

static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas *atlas) {
	ImFontAtlasCustomRect *r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
	IM_ASSERT(r->IsPacked());

	const int w = atlas->TexWidth;
	if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors)) {
		// Render/copy pixels
		IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
		const int x_for_white = r->X;
		const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
		if (atlas->TexPixelsAlpha8 != NULL) {
			ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
			ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
		} else {
			ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
			ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
		}
	} else {
		// Render 4 white pixels
		IM_ASSERT(r->Width == 2 && r->Height == 2);
		const int offset = (int)r->X + (int)r->Y * w;
		if (atlas->TexPixelsAlpha8 != NULL) {
			atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
		} else {
			atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
		}
	}
	atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
}

static void ImFontAtlasBuildRenderLinesTexData(ImFontAtlas *atlas) {
	if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
		return;

	// This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
	ImFontAtlasCustomRect *r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
	IM_ASSERT(r->IsPacked());
	for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
	{
		// Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
		unsigned int y = n;
		unsigned int line_width = n;
		unsigned int pad_left = (r->Width - line_width) / 2;
		unsigned int pad_right = r->Width - (pad_left + line_width);

		// Write each slice
		IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
		if (atlas->TexPixelsAlpha8 != NULL) {
			unsigned char *write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
			for (unsigned int i = 0; i < pad_left; i++)
				*(write_ptr + i) = 0x00;

			for (unsigned int i = 0; i < line_width; i++)
				*(write_ptr + pad_left + i) = 0xFF;

			for (unsigned int i = 0; i < pad_right; i++)
				*(write_ptr + pad_left + line_width + i) = 0x00;
		} else {
			unsigned int *write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
			for (unsigned int i = 0; i < pad_left; i++)
				*(write_ptr + i) = IM_COL32(255, 255, 255, 0);

			for (unsigned int i = 0; i < line_width; i++)
				*(write_ptr + pad_left + i) = IM_COL32_WHITE;

			for (unsigned int i = 0; i < pad_right; i++)
				*(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
		}

		// Calculate UVs for this line
		ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
		ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
		float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
		atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
	}
}

// Note: this is called / shared by both the stb_truetype and the FreeType builder
void ImFontAtlasBuildInit(ImFontAtlas *atlas) {
	// Round font size
	// - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.
	// - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.
	// - We may support it better later and remove this rounding.
	for (ImFontConfig &cfg : atlas->ConfigData)
		cfg.SizePixels = ImTrunc(cfg.SizePixels);

	// Register texture region for mouse cursors or standard white pixels
	if (atlas->PackIdMouseCursors < 0) {
		if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
			atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
		else
			atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
	}

	// Register texture region for thick lines
	// The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
	if (atlas->PackIdLines < 0) {
		if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
			atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
	}
}

// This is called/shared by both the stb_truetype and the FreeType builder.
void ImFontAtlasBuildFinish(ImFontAtlas *atlas) {
	// Render into our custom data blocks
	IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
	ImFontAtlasBuildRenderDefaultTexData(atlas);
	ImFontAtlasBuildRenderLinesTexData(atlas);

	// Register custom rectangle glyphs
	for (int i = 0; i < atlas->CustomRects.Size; i++) {
		const ImFontAtlasCustomRect *r = &atlas->CustomRects[i];
		if (r->Font == NULL || r->GlyphID == 0)
			continue;

		// Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
		IM_ASSERT(r->Font->ContainerAtlas == atlas);
		ImVec2 uv0, uv1;
		atlas->CalcCustomRectUV(r, &uv0, &uv1);
		r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
	}

	// Build all fonts lookup tables
	for (ImFont *font : atlas->Fonts)
		if (font->DirtyLookupTables)
			font->BuildLookupTable();

	atlas->TexReady = true;
}

// Retrieve list of range (2 int per range, values are inclusive)
const ImWchar *ImFontAtlas::GetGlyphRangesDefault() {
	static const ImWchar ranges[] = {
		0x0020,
		0x00FF, // Basic Latin + Latin Supplement
		0,
	};
	return &ranges[0];
}

const ImWchar *ImFontAtlas::GetGlyphRangesGreek() {
	static const ImWchar ranges[] = {
		0x0020,
		0x00FF, // Basic Latin + Latin Supplement
		0x0370,
		0x03FF, // Greek and Coptic
		0,
	};
	return &ranges[0];
}

const ImWchar *ImFontAtlas::GetGlyphRangesKorean() {
	static const ImWchar ranges[] = {
		0x0020,
		0x00FF, // Basic Latin + Latin Supplement
		0x3131,
		0x3163, // Korean alphabets
		0xAC00,
		0xD7A3, // Korean characters
		0xFFFD,
		0xFFFD, // Invalid
		0,
	};
	return &ranges[0];
}

const ImWchar *ImFontAtlas::GetGlyphRangesChineseFull() {
	static const ImWchar ranges[] = {
		0x0020,
		0x00FF, // Basic Latin + Latin Supplement
		0x2000,
		0x206F, // General Punctuation
		0x3000,
		0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
		0x31F0,
		0x31FF, // Katakana Phonetic Extensions
		0xFF00,
		0xFFEF, // Half-width characters
		0xFFFD,
		0xFFFD, // Invalid
		0x4e00,
		0x9FAF, // CJK Ideograms
		0,
	};
	return &ranges[0];
}

static void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short *accumulative_offsets, int accumulative_offsets_count, ImWchar *out_ranges) {
	for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2) {
		out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);
		base_codepoint += accumulative_offsets[n];
	}
	out_ranges[0] = 0;
}

//-------------------------------------------------------------------------
// [SECTION] ImFontAtlas glyph ranges helpers
//-------------------------------------------------------------------------

const ImWchar *ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon() {
	// Store 2500 regularly used characters for Simplified Chinese.
	// Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
	// This table covers 97.97% of all characters used during the month in July, 1987.
	// You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
	// (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
	static const short accumulative_offsets_from_0x4E00[] = {
		0, 1, 2, 4, 1, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 1, 1, 1, 1, 1, 5, 2, 1, 2, 3, 3, 3, 2, 2, 4, 1, 1, 1, 2, 1, 5, 2, 3, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 4, 1, 1, 1, 1, 5, 10, 1, 2, 19, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 5, 1, 6, 3, 2, 1, 2, 2, 1, 1, 1, 4, 8, 5, 1, 1, 4, 1, 1, 3, 1, 2, 1, 5, 1, 2, 1, 1, 1, 10, 1, 1, 5, 2, 4, 6, 1, 4, 2, 2, 2, 12, 2, 1, 1, 6, 1, 1, 1, 4, 1, 1, 4, 6, 5, 1, 4, 2, 2, 4, 10, 7, 1, 1, 4, 2, 4,
		2, 1, 4, 3, 6, 10, 12, 5, 7, 2, 14, 2, 9, 1, 1, 6, 7, 10, 4, 7, 13, 1, 5, 4, 8, 4, 1, 1, 2, 28, 5, 6, 1, 1, 5, 2, 5, 20, 2, 2, 9, 8, 11, 2, 9, 17, 1, 8, 6, 8, 27, 4, 6, 9, 20, 11, 27, 6, 68, 2, 2, 1, 1,
		1, 2, 1, 2, 2, 7, 6, 11, 3, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 8, 3, 4, 1, 5, 7, 2, 1, 4, 4, 8, 4, 2, 1, 2, 1, 1, 4, 5, 6, 3, 6, 2, 12, 3, 1, 3, 9, 2, 4, 3, 4, 1, 5, 3, 3, 1, 3, 7, 1, 5, 1, 1, 1, 1, 2,
		3, 4, 5, 2, 3, 2, 6, 1, 1, 2, 1, 7, 1, 7, 3, 4, 5, 15, 2, 2, 1, 5, 3, 22, 19, 2, 1, 1, 1, 1, 2, 5, 1, 1, 1, 6, 1, 1, 12, 8, 2, 9, 18, 22, 4, 1, 1, 5, 1, 16, 1, 2, 7, 10, 15, 1, 1, 6, 2, 4, 1, 2, 4, 1, 6,
		1, 1, 3, 2, 4, 1, 6, 4, 5, 1, 2, 1, 1, 2, 1, 10, 3, 1, 3, 2, 1, 9, 3, 2, 5, 7, 2, 19, 4, 3, 6, 1, 1, 1, 1, 1, 4, 3, 2, 1, 1, 1, 2, 5, 3, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 3, 1, 1, 1, 3, 7, 1, 4, 1, 1, 2, 1,
		1, 2, 1, 2, 4, 4, 3, 8, 1, 1, 1, 2, 1, 3, 5, 1, 3, 1, 3, 4, 6, 2, 2, 14, 4, 6, 6, 11, 9, 1, 15, 3, 1, 28, 5, 2, 5, 5, 3, 1, 3, 4, 5, 4, 6, 14, 3, 2, 3, 5, 21, 2, 7, 20, 10, 1, 2, 19, 2, 4, 28, 28, 2, 3,
		2, 1, 14, 4, 1, 26, 28, 42, 12, 40, 3, 52, 79, 5, 14, 17, 3, 2, 2, 11, 3, 4, 6, 3, 1, 8, 2, 23, 4, 5, 8, 10, 4, 2, 7, 3, 5, 1, 1, 6, 3, 1, 2, 2, 2, 5, 28, 1, 1, 7, 7, 20, 5, 3, 29, 3, 17, 26, 1, 8, 4,
		27, 3, 6, 11, 23, 5, 3, 4, 6, 13, 24, 16, 6, 5, 10, 25, 35, 7, 3, 2, 3, 3, 14, 3, 6, 2, 6, 1, 4, 2, 3, 8, 2, 1, 1, 3, 3, 3, 4, 1, 1, 13, 2, 2, 4, 5, 2, 1, 14, 14, 1, 2, 2, 1, 4, 5, 2, 3, 1, 14, 3, 12,
		3, 17, 2, 16, 5, 1, 2, 1, 8, 9, 3, 19, 4, 2, 2, 4, 17, 25, 21, 20, 28, 75, 1, 10, 29, 103, 4, 1, 2, 1, 1, 4, 2, 4, 1, 2, 3, 24, 2, 2, 2, 1, 1, 2, 1, 3, 8, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 6, 1, 5, 3, 1, 1,
		1, 3, 4, 1, 1, 5, 2, 1, 5, 6, 13, 9, 16, 1, 1, 1, 1, 3, 2, 3, 2, 4, 5, 2, 5, 2, 2, 3, 7, 13, 7, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 1, 6, 4, 9, 2, 1, 14, 2, 14, 2, 1, 18, 3, 4, 14, 4, 11, 41, 15, 23, 15, 23,
		176, 1, 3, 4, 1, 1, 1, 1, 5, 3, 1, 2, 3, 7, 3, 1, 1, 2, 1, 2, 4, 4, 6, 2, 4, 1, 9, 7, 1, 10, 5, 8, 16, 29, 1, 1, 2, 2, 3, 1, 3, 5, 2, 4, 5, 4, 1, 1, 2, 2, 3, 3, 7, 1, 6, 10, 1, 17, 1, 44, 4, 6, 2, 1, 1, 6,
		5, 4, 2, 10, 1, 6, 9, 2, 8, 1, 24, 1, 2, 13, 7, 8, 8, 2, 1, 4, 1, 3, 1, 3, 3, 5, 2, 5, 10, 9, 4, 9, 12, 2, 1, 6, 1, 10, 1, 1, 7, 7, 4, 10, 8, 3, 1, 13, 4, 3, 1, 6, 1, 3, 5, 2, 1, 2, 17, 16, 5, 2, 16, 6,
		1, 4, 2, 1, 3, 3, 6, 8, 5, 11, 11, 1, 3, 3, 2, 4, 6, 10, 9, 5, 7, 4, 7, 4, 7, 1, 1, 4, 2, 1, 3, 6, 8, 7, 1, 6, 11, 5, 5, 3, 24, 9, 4, 2, 7, 13, 5, 1, 8, 82, 16, 61, 1, 1, 1, 4, 2, 2, 16, 10, 3, 8, 1, 1,
		6, 4, 2, 1, 3, 1, 1, 1, 4, 3, 8, 4, 2, 2, 1, 1, 1, 1, 1, 6, 3, 5, 1, 1, 4, 6, 9, 2, 1, 1, 1, 2, 1, 7, 2, 1, 6, 1, 5, 4, 4, 3, 1, 8, 1, 3, 3, 1, 3, 2, 2, 2, 2, 3, 1, 6, 1, 2, 1, 2, 1, 3, 7, 1, 8, 2, 1, 2, 1, 5,
		2, 5, 3, 5, 10, 1, 2, 1, 1, 3, 2, 5, 11, 3, 9, 3, 5, 1, 1, 5, 9, 1, 2, 1, 5, 7, 9, 9, 8, 1, 3, 3, 3, 6, 8, 2, 3, 2, 1, 1, 32, 6, 1, 2, 15, 9, 3, 7, 13, 1, 3, 10, 13, 2, 14, 1, 13, 10, 2, 1, 3, 10, 4, 15,
		2, 15, 15, 10, 1, 3, 9, 6, 9, 32, 25, 26, 47, 7, 3, 2, 3, 1, 6, 3, 4, 3, 2, 8, 5, 4, 1, 9, 4, 2, 2, 19, 10, 6, 2, 3, 8, 1, 2, 2, 4, 2, 1, 9, 4, 4, 4, 6, 4, 8, 9, 2, 3, 1, 1, 1, 1, 3, 5, 5, 1, 3, 8, 4, 6,
		2, 1, 4, 12, 1, 5, 3, 7, 13, 2, 5, 8, 1, 6, 1, 2, 5, 14, 6, 1, 5, 2, 4, 8, 15, 5, 1, 23, 6, 62, 2, 10, 1, 1, 8, 1, 2, 2, 10, 4, 2, 2, 9, 2, 1, 1, 3, 2, 3, 1, 5, 3, 3, 2, 1, 3, 8, 1, 1, 1, 11, 3, 1, 1, 4,
		3, 7, 1, 14, 1, 2, 3, 12, 5, 2, 5, 1, 6, 7, 5, 7, 14, 11, 1, 3, 1, 8, 9, 12, 2, 1, 11, 8, 4, 4, 2, 6, 10, 9, 13, 1, 1, 3, 1, 5, 1, 3, 2, 4, 4, 1, 18, 2, 3, 14, 11, 4, 29, 4, 2, 7, 1, 3, 13, 9, 2, 2, 5,
		3, 5, 20, 7, 16, 8, 5, 72, 34, 6, 4, 22, 12, 12, 28, 45, 36, 9, 7, 39, 9, 191, 1, 1, 1, 4, 11, 8, 4, 9, 2, 3, 22, 1, 1, 1, 1, 4, 17, 1, 7, 7, 1, 11, 31, 10, 2, 4, 8, 2, 3, 2, 1, 4, 2, 16, 4, 32, 2,
		3, 19, 13, 4, 9, 1, 5, 2, 14, 8, 1, 1, 3, 6, 19, 6, 5, 1, 16, 6, 2, 10, 8, 5, 1, 2, 3, 1, 5, 5, 1, 11, 6, 6, 1, 3, 3, 2, 6, 3, 8, 1, 1, 4, 10, 7, 5, 7, 7, 5, 8, 9, 2, 1, 3, 4, 1, 1, 3, 1, 3, 3, 2, 6, 16,
		1, 4, 6, 3, 1, 10, 6, 1, 3, 15, 2, 9, 2, 10, 25, 13, 9, 16, 6, 2, 2, 10, 11, 4, 3, 9, 1, 2, 6, 6, 5, 4, 30, 40, 1, 10, 7, 12, 14, 33, 6, 3, 6, 7, 3, 1, 3, 1, 11, 14, 4, 9, 5, 12, 11, 49, 18, 51, 31,
		140, 31, 2, 2, 1, 5, 1, 8, 1, 10, 1, 4, 4, 3, 24, 1, 10, 1, 3, 6, 6, 16, 3, 4, 5, 2, 1, 4, 2, 57, 10, 6, 22, 2, 22, 3, 7, 22, 6, 10, 11, 36, 18, 16, 33, 36, 2, 5, 5, 1, 1, 1, 4, 10, 1, 4, 13, 2, 7,
		5, 2, 9, 3, 4, 1, 7, 43, 3, 7, 3, 9, 14, 7, 9, 1, 11, 1, 1, 3, 7, 4, 18, 13, 1, 14, 1, 3, 6, 10, 73, 2, 2, 30, 6, 1, 11, 18, 19, 13, 22, 3, 46, 42, 37, 89, 7, 3, 16, 34, 2, 2, 3, 9, 1, 7, 1, 1, 1, 2,
		2, 4, 10, 7, 3, 10, 3, 9, 5, 28, 9, 2, 6, 13, 7, 3, 1, 3, 10, 2, 7, 2, 11, 3, 6, 21, 54, 85, 2, 1, 4, 2, 2, 1, 39, 3, 21, 2, 2, 5, 1, 1, 1, 4, 1, 1, 3, 4, 15, 1, 3, 2, 4, 4, 2, 3, 8, 2, 20, 1, 8, 7, 13,
		4, 1, 26, 6, 2, 9, 34, 4, 21, 52, 10, 4, 4, 1, 5, 12, 2, 11, 1, 7, 2, 30, 12, 44, 2, 30, 1, 1, 3, 6, 16, 9, 17, 39, 82, 2, 2, 24, 7, 1, 7, 3, 16, 9, 14, 44, 2, 1, 2, 1, 2, 3, 5, 2, 4, 1, 6, 7, 5, 3,
		2, 6, 1, 11, 5, 11, 2, 1, 18, 19, 8, 1, 3, 24, 29, 2, 1, 3, 5, 2, 2, 1, 13, 6, 5, 1, 46, 11, 3, 5, 1, 1, 5, 8, 2, 10, 6, 12, 6, 3, 7, 11, 2, 4, 16, 13, 2, 5, 1, 1, 2, 2, 5, 2, 28, 5, 2, 23, 10, 8, 4,
		4, 22, 39, 95, 38, 8, 14, 9, 5, 1, 13, 5, 4, 3, 13, 12, 11, 1, 9, 1, 27, 37, 2, 5, 4, 4, 63, 211, 95, 2, 2, 2, 1, 3, 5, 2, 1, 1, 2, 2, 1, 1, 1, 3, 2, 4, 1, 2, 1, 1, 5, 2, 2, 1, 1, 2, 3, 1, 3, 1, 1, 1,
		3, 1, 4, 2, 1, 3, 6, 1, 1, 3, 7, 15, 5, 3, 2, 5, 3, 9, 11, 4, 2, 22, 1, 6, 3, 8, 7, 1, 4, 28, 4, 16, 3, 3, 25, 4, 4, 27, 27, 1, 4, 1, 2, 2, 7, 1, 3, 5, 2, 28, 8, 2, 14, 1, 8, 6, 16, 25, 3, 3, 3, 14, 3,
		3, 1, 1, 2, 1, 4, 6, 3, 8, 4, 1, 1, 1, 2, 3, 6, 10, 6, 2, 3, 18, 3, 2, 5, 5, 4, 3, 1, 5, 2, 5, 4, 23, 7, 6, 12, 6, 4, 17, 11, 9, 5, 1, 1, 10, 5, 12, 1, 1, 11, 26, 33, 7, 3, 6, 1, 17, 7, 1, 5, 12, 1, 11,
		2, 4, 1, 8, 14, 17, 23, 1, 2, 1, 7, 8, 16, 11, 9, 6, 5, 2, 6, 4, 16, 2, 8, 14, 1, 11, 8, 9, 1, 1, 1, 9, 25, 4, 11, 19, 7, 2, 15, 2, 12, 8, 52, 7, 5, 19, 2, 16, 4, 36, 8, 1, 16, 8, 24, 26, 4, 6, 2, 9,
		5, 4, 36, 3, 28, 12, 25, 15, 37, 27, 17, 12, 59, 38, 5, 32, 127, 1, 2, 9, 17, 14, 4, 1, 2, 1, 1, 8, 11, 50, 4, 14, 2, 19, 16, 4, 17, 5, 4, 5, 26, 12, 45, 2, 23, 45, 104, 30, 12, 8, 3, 10, 2, 2,
		3, 3, 1, 4, 20, 7, 2, 9, 6, 15, 2, 20, 1, 3, 16, 4, 11, 15, 6, 134, 2, 5, 59, 1, 2, 2, 2, 1, 9, 17, 3, 26, 137, 10, 211, 59, 1, 2, 4, 1, 4, 1, 1, 1, 2, 6, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 4, 4, 2, 3, 3,
		1, 4, 3, 1, 7, 2, 2, 3, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 1, 3, 14, 6, 1, 3, 2, 9, 6, 15, 27, 9, 34, 145, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 3, 1, 2, 1, 1, 1, 2, 3, 5, 8, 3, 5, 2, 4, 1, 3, 2, 2, 2, 12,
		4, 1, 1, 1, 10, 4, 5, 1, 20, 4, 16, 1, 15, 9, 5, 12, 2, 9, 2, 5, 4, 2, 26, 19, 7, 1, 26, 4, 30, 12, 15, 42, 1, 6, 8, 172, 1, 1, 4, 2, 1, 1, 11, 2, 2, 4, 2, 1, 2, 1, 10, 8, 1, 2, 1, 4, 5, 1, 2, 5, 1, 8,
		4, 1, 3, 4, 2, 1, 6, 2, 1, 3, 4, 1, 2, 1, 1, 1, 1, 12, 5, 7, 2, 4, 3, 1, 1, 1, 3, 3, 6, 1, 2, 2, 3, 3, 3, 2, 1, 2, 12, 14, 11, 6, 6, 4, 12, 2, 8, 1, 7, 10, 1, 35, 7, 4, 13, 15, 4, 3, 23, 21, 28, 52, 5,
		26, 5, 6, 1, 7, 10, 2, 7, 53, 3, 2, 1, 1, 1, 2, 163, 532, 1, 10, 11, 1, 3, 3, 4, 8, 2, 8, 6, 2, 2, 23, 22, 4, 2, 2, 4, 2, 1, 3, 1, 3, 3, 5, 9, 8, 2, 1, 2, 8, 1, 10, 2, 12, 21, 20, 15, 105, 2, 3, 1, 1,
		3, 2, 3, 1, 1, 2, 5, 1, 4, 15, 11, 19, 1, 1, 1, 1, 5, 4, 5, 1, 1, 2, 5, 3, 5, 12, 1, 2, 5, 1, 11, 1, 1, 15, 9, 1, 4, 5, 3, 26, 8, 2, 1, 3, 1, 1, 15, 19, 2, 12, 1, 2, 5, 2, 7, 2, 19, 2, 20, 6, 26, 7, 5,
		2, 2, 7, 34, 21, 13, 70, 2, 128, 1, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 2, 15, 1, 4, 1, 3, 4, 42, 10, 6, 1, 49, 85, 8, 1, 2, 1, 1, 4, 4, 2, 3, 6, 1, 5, 7, 4, 3, 211, 4, 1, 2, 1, 2, 5, 1, 2, 4, 2, 2, 6, 5, 6,
		10, 3, 4, 48, 100, 6, 2, 16, 296, 5, 27, 387, 2, 2, 3, 7, 16, 8, 5, 38, 15, 39, 21, 9, 10, 3, 7, 59, 13, 27, 21, 47, 5, 21, 6
	};
	static ImWchar base_ranges[] = // not zero-terminated
			{
				0x0020, 0x00FF, // Basic Latin + Latin Supplement
				0x2000, 0x206F, // General Punctuation
				0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
				0x31F0, 0x31FF, // Katakana Phonetic Extensions
				0xFF00, 0xFFEF, // Half-width characters
				0xFFFD, 0xFFFD // Invalid
			};
	static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
	if (!full_ranges[0]) {
		memcpy(full_ranges, base_ranges, sizeof(base_ranges));
		UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
	}
	return &full_ranges[0];
}

const ImWchar *ImFontAtlas::GetGlyphRangesJapanese() {
	// 2999 ideograms code points for Japanese
	// - 2136 Joyo (meaning "for regular use" or "for common use") Kanji code points
	// - 863 Jinmeiyo (meaning "for personal name") Kanji code points
	// - Sourced from official information provided by the government agencies of Japan:
	//   - List of Joyo Kanji by the Agency for Cultural Affairs
	//     - https://www.bunka.go.jp/kokugo_nihongo/sisaku/joho/joho/kijun/naikaku/kanji/
	//   - List of Jinmeiyo Kanji by the Ministry of Justice
	//     - http://www.moj.go.jp/MINJI/minji86.html
	//   - Available under the terms of the Creative Commons Attribution 4.0 International (CC BY 4.0).
	//     - https://creativecommons.org/licenses/by/4.0/legalcode
	// - You can generate this code by the script at:
	//   - https://github.com/vaiorabbit/everyday_use_kanji
	// - References:
	//   - List of Joyo Kanji
	//     - (Wikipedia) https://en.wikipedia.org/wiki/List_of_j%C5%8Dy%C5%8D_kanji
	//   - List of Jinmeiyo Kanji
	//     - (Wikipedia) https://en.wikipedia.org/wiki/Jinmeiy%C5%8D_kanji
	// - Missing 1 Joyo Kanji: U+20B9F (Kun'yomi: Shikaru, On'yomi: Shitsu,shichi), see https://github.com/ocornut/imgui/pull/3627 for details.
	// You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
	// (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
	static const short accumulative_offsets_from_0x4E00[] = {
		0,
		1,
		2,
		4,
		1,
		1,
		1,
		1,
		2,
		1,
		3,
		3,
		2,
		2,
		1,
		5,
		3,
		5,
		7,
		5,
		6,
		1,
		2,
		1,
		7,
		2,
		6,
		3,
		1,
		8,
		1,
		1,
		4,
		1,
		1,
		18,
		2,
		11,
		2,
		6,
		2,
		1,
		2,
		1,
		5,
		1,
		2,
		1,
		3,
		1,
		2,
		1,
		2,
		3,
		3,
		1,
		1,
		2,
		3,
		1,
		1,
		1,
		12,
		7,
		9,
		1,
		4,
		5,
		1,
		1,
		2,
		1,
		10,
		1,
		1,
		9,
		2,
		2,
		4,
		5,
		6,
		9,
		3,
		1,
		1,
		1,
		1,
		9,
		3,
		18,
		5,
		2,
		2,
		2,
		2,
		1,
		6,
		3,
		7,
		1,
		1,
		1,
		1,
		2,
		2,
		4,
		2,
		1,
		23,
		2,
		10,
		4,
		3,
		5,
		2,
		4,
		10,
		2,
		4,
		13,
		1,
		6,
		1,
		9,
		3,
		1,
		1,
		6,
		6,
		7,
		6,
		3,
		1,
		2,
		11,
		3,
		2,
		2,
		3,
		2,
		15,
		2,
		2,
		5,
		4,
		3,
		6,
		4,
		1,
		2,
		5,
		2,
		12,
		16,
		6,
		13,
		9,
		13,
		2,
		1,
		1,
		7,
		16,
		4,
		7,
		1,
		19,
		1,
		5,
		1,
		2,
		2,
		7,
		7,
		8,
		2,
		6,
		5,
		4,
		9,
		18,
		7,
		4,
		5,
		9,
		13,
		11,
		8,
		15,
		2,
		1,
		1,
		1,
		2,
		1,
		2,
		2,
		1,
		2,
		2,
		8,
		2,
		9,
		3,
		3,
		1,
		1,
		4,
		4,
		1,
		1,
		1,
		4,
		9,
		1,
		4,
		3,
		5,
		5,
		2,
		7,
		5,
		3,
		4,
		8,
		2,
		1,
		13,
		2,
		3,
		3,
		1,
		14,
		1,
		1,
		4,
		5,
		1,
		3,
		6,
		1,
		5,
		2,
		1,
		1,
		3,
		3,
		3,
		3,
		1,
		1,
		2,
		7,
		6,
		6,
		7,
		1,
		4,
		7,
		6,
		1,
		1,
		1,
		1,
		1,
		12,
		3,
		3,
		9,
		5,
		2,
		6,
		1,
		5,
		6,
		1,
		2,
		3,
		18,
		2,
		4,
		14,
		4,
		1,
		3,
		6,
		1,
		1,
		6,
		3,
		5,
		5,
		3,
		2,
		2,
		2,
		2,
		12,
		3,
		1,
		4,
		2,
		3,
		2,
		3,
		11,
		1,
		7,
		4,
		1,
		2,
		1,
		3,
		17,
		1,
		9,
		1,
		24,
		1,
		1,
		4,
		2,
		2,
		4,
		1,
		2,
		7,
		1,
		1,
		1,
		3,
		1,
		2,
		2,
		4,
		15,
		1,
		1,
		2,
		1,
		1,
		2,
		1,
		5,
		2,
		5,
		20,
		2,
		5,
		9,
		1,
		10,
		8,
		7,
		6,
		1,
		1,
		1,
		1,
		1,
		1,
		6,
		2,
		1,
		2,
		8,
		1,
		1,
		1,
		1,
		5,
		1,
		1,
		3,
		1,
		1,
		1,
		1,
		3,
		1,
		1,
		12,
		4,
		1,
		3,
		1,
		1,
		1,
		1,
		1,
		10,
		3,
		1,
		7,
		5,
		13,
		1,
		2,
		3,
		4,
		6,
		1,
		1,
		30,
		2,
		9,
		9,
		1,
		15,
		38,
		11,
		3,
		1,
		8,
		24,
		7,
		1,
		9,
		8,
		10,
		2,
		1,
		9,
		31,
		2,
		13,
		6,
		2,
		9,
		4,
		49,
		5,
		2,
		15,
		2,
		1,
		10,
		2,
		1,
		1,
		1,
		2,
		2,
		6,
		15,
		30,
		35,
		3,
		14,
		18,
		8,
		1,
		16,
		10,
		28,
		12,
		19,
		45,
		38,
		1,
		3,
		2,
		3,
		13,
		2,
		1,
		7,
		3,
		6,
		5,
		3,
		4,
		3,
		1,
		5,
		7,
		8,
		1,
		5,
		3,
		18,
		5,
		3,
		6,
		1,
		21,
		4,
		24,
		9,
		24,
		40,
		3,
		14,
		3,
		21,
		3,
		2,
		1,
		2,
		4,
		2,
		3,
		1,
		15,
		15,
		6,
		5,
		1,
		1,
		3,
		1,
		5,
		6,
		1,
		9,
		7,
		3,
		3,
		2,
		1,
		4,
		3,
		8,
		21,
		5,
		16,
		4,
		5,
		2,
		10,
		11,
		11,
		3,
		6,
		3,
		2,
		9,
		3,
		6,
		13,
		1,
		2,
		1,
		1,
		1,
		1,
		11,
		12,
		6,
		6,
		1,
		4,
		2,
		6,
		5,
		2,
		1,
		1,
		3,
		3,
		6,
		13,
		3,
		1,
		1,
		5,
		1,
		2,
		3,
		3,
		14,
		2,
		1,
		2,
		2,
		2,
		5,
		1,
		9,
		5,
		1,
		1,
		6,
		12,
		3,
		12,
		3,
		4,
		13,
		2,
		14,
		2,
		8,
		1,
		17,
		5,
		1,
		16,
		4,
		2,
		2,
		21,
		8,
		9,
		6,
		23,
		20,
		12,
		25,
		19,
		9,
		38,
		8,
		3,
		21,
		40,
		25,
		33,
		13,
		4,
		3,
		1,
		4,
		1,
		2,
		4,
		1,
		2,
		5,
		26,
		2,
		1,
		1,
		2,
		1,
		3,
		6,
		2,
		1,
		1,
		1,
		1,
		1,
		1,
		2,
		3,
		1,
		1,
		1,
		9,
		2,
		3,
		1,
		1,
		1,
		3,
		6,
		3,
		2,
		1,
		1,
		6,
		6,
		1,
		8,
		2,
		2,
		2,
		1,
		4,
		1,
		2,
		3,
		2,
		7,
		3,
		2,
		4,
		1,
		2,
		1,
		2,
		2,
		1,
		1,
		1,
		1,
		1,
		3,
		1,
		2,
		5,
		4,
		10,
		9,
		4,
		9,
		1,
		1,
		1,
		1,
		1,
		1,
		5,
		3,
		2,
		1,
		6,
		4,
		9,
		6,
		1,
		10,
		2,
		31,
		17,
		8,
		3,
		7,
		5,
		40,
		1,
		7,
		7,
		1,
		6,
		5,
		2,
		10,
		7,
		8,
		4,
		15,
		39,
		25,
		6,
		28,
		47,
		18,
		10,
		7,
		1,
		3,
		1,
		1,
		2,
		1,
		1,
		1,
		3,
		3,
		3,
		1,
		1,
		1,
		3,
		4,
		2,
		1,
		4,
		1,
		3,
		6,
		10,
		7,
		8,
		6,
		2,
		2,
		1,
		3,
		3,
		2,
		5,
		8,
		7,
		9,
		12,
		2,
		15,
		1,
		1,
		4,
		1,
		2,
		1,
		1,
		1,
		3,
		2,
		1,
		3,
		3,
		5,
		6,
		2,
		3,
		2,
		10,
		1,
		4,
		2,
		8,
		1,
		1,
		1,
		11,
		6,
		1,
		21,
		4,
		16,
		3,
		1,
		3,
		1,
		4,
		2,
		3,
		6,
		5,
		1,
		3,
		1,
		1,
		3,
		3,
		4,
		6,
		1,
		1,
		10,
		4,
		2,
		7,
		10,
		4,
		7,
		4,
		2,
		9,
		4,
		3,
		1,
		1,
		1,
		4,
		1,
		8,
		3,
		4,
		1,
		3,
		1,
		6,
		1,
		4,
		2,
		1,
		4,
		7,
		2,
		1,
		8,
		1,
		4,
		5,
		1,
		1,
		2,
		2,
		4,
		6,
		2,
		7,
		1,
		10,
		1,
		1,
		3,
		4,
		11,
		10,
		8,
		21,
		4,
		6,
		1,
		3,
		5,
		2,
		1,
		2,
		28,
		5,
		5,
		2,
		3,
		13,
		1,
		2,
		3,
		1,
		4,
		2,
		1,
		5,
		20,
		3,
		8,
		11,
		1,
		3,
		3,
		3,
		1,
		8,
		10,
		9,
		2,
		10,
		9,
		2,
		3,
		1,
		1,
		2,
		4,
		1,
		8,
		3,
		6,
		1,
		7,
		8,
		6,
		11,
		1,
		4,
		29,
		8,
		4,
		3,
		1,
		2,
		7,
		13,
		1,
		4,
		1,
		6,
		2,
		6,
		12,
		12,
		2,
		20,
		3,
		2,
		3,
		6,
		4,
		8,
		9,
		2,
		7,
		34,
		5,
		1,
		18,
		6,
		1,
		1,
		4,
		4,
		5,
		7,
		9,
		1,
		2,
		2,
		4,
		3,
		4,
		1,
		7,
		2,
		2,
		2,
		6,
		2,
		3,
		25,
		5,
		3,
		6,
		1,
		4,
		6,
		7,
		4,
		2,
		1,
		4,
		2,
		13,
		6,
		4,
		4,
		3,
		1,
		5,
		3,
		4,
		4,
		3,
		2,
		1,
		1,
		4,
		1,
		2,
		1,
		1,
		3,
		1,
		11,
		1,
		6,
		3,
		1,
		7,
		3,
		6,
		2,
		8,
		8,
		6,
		9,
		3,
		4,
		11,
		3,
		2,
		10,
		12,
		2,
		5,
		11,
		1,
		6,
		4,
		5,
		3,
		1,
		8,
		5,
		4,
		6,
		6,
		3,
		5,
		1,
		1,
		3,
		2,
		1,
		2,
		2,
		6,
		17,
		12,
		1,
		10,
		1,
		6,
		12,
		1,
		6,
		6,
		19,
		9,
		6,
		16,
		1,
		13,
		4,
		4,
		15,
		7,
		17,
		6,
		11,
		9,
		15,
		12,
		6,
		7,
		2,
		1,
		2,
		2,
		15,
		9,
		3,
		21,
		4,
		6,
		49,
		18,
		7,
		3,
		2,
		3,
		1,
		6,
		8,
		2,
		2,
		6,
		2,
		9,
		1,
		3,
		6,
		4,
		4,
		1,
		2,
		16,
		2,
		5,
		2,
		1,
		6,
		2,
		3,
		5,
		3,
		1,
		2,
		5,
		1,
		2,
		1,
		9,
		3,
		1,
		8,
		6,
		4,
		8,
		11,
		3,
		1,
		1,
		1,
		1,
		3,
		1,
		13,
		8,
		4,
		1,
		3,
		2,
		2,
		1,
		4,
		1,
		11,
		1,
		5,
		2,
		1,
		5,
		2,
		5,
		8,
		6,
		1,
		1,
		7,
		4,
		3,
		8,
		3,
		2,
		7,
		2,
		1,
		5,
		1,
		5,
		2,
		4,
		7,
		6,
		2,
		8,
		5,
		1,
		11,
		4,
		5,
		3,
		6,
		18,
		1,
		2,
		13,
		3,
		3,
		1,
		21,
		1,
		1,
		4,
		1,
		4,
		1,
		1,
		1,
		8,
		1,
		2,
		2,
		7,
		1,
		2,
		4,
		2,
		2,
		9,
		2,
		1,
		1,
		1,
		4,
		3,
		6,
		3,
		12,
		5,
		1,
		1,
		1,
		5,
		6,
		3,
		2,
		4,
		8,
		2,
		2,
		4,
		2,
		7,
		1,
		8,
		9,
		5,
		2,
		3,
		2,
		1,
		3,
		2,
		13,
		7,
		14,
		6,
		5,
		1,
		1,
		2,
		1,
		4,
		2,
		23,
		2,
		1,
		1,
		6,
		3,
		1,
		4,
		1,
		15,
		3,
		1,
		7,
		3,
		9,
		14,
		1,
		3,
		1,
		4,
		1,
		1,
		5,
		8,
		1,
		3,
		8,
		3,
		8,
		15,
		11,
		4,
		14,
		4,
		4,
		2,
		5,
		5,
		1,
		7,
		1,
		6,
		14,
		7,
		7,
		8,
		5,
		15,
		4,
		8,
		6,
		5,
		6,
		2,
		1,
		13,
		1,
		20,
		15,
		11,
		9,
		2,
		5,
		6,
		2,
		11,
		2,
		6,
		2,
		5,
		1,
		5,
		8,
		4,
		13,
		19,
		25,
		4,
		1,
		1,
		11,
		1,
		34,
		2,
		5,
		9,
		14,
		6,
		2,
		2,
		6,
		1,
		1,
		14,
		1,
		3,
		14,
		13,
		1,
		6,
		12,
		21,
		14,
		14,
		6,
		32,
		17,
		8,
		32,
		9,
		28,
		1,
		2,
		4,
		11,
		8,
		3,
		1,
		14,
		2,
		5,
		15,
		1,
		1,
		1,
		1,
		3,
		6,
		4,
		1,
		3,
		4,
		11,
		3,
		1,
		1,
		11,
		30,
		1,
		5,
		1,
		4,
		1,
		5,
		8,
		1,
		1,
		3,
		2,
		4,
		3,
		17,
		35,
		2,
		6,
		12,
		17,
		3,
		1,
		6,
		2,
		1,
		1,
		12,
		2,
		7,
		3,
		3,
		2,
		1,
		16,
		2,
		8,
		3,
		6,
		5,
		4,
		7,
		3,
		3,
		8,
		1,
		9,
		8,
		5,
		1,
		2,
		1,
		3,
		2,
		8,
		1,
		2,
		9,
		12,
		1,
		1,
		2,
		3,
		8,
		3,
		24,
		12,
		4,
		3,
		7,
		5,
		8,
		3,
		3,
		3,
		3,
		3,
		3,
		1,
		23,
		10,
		3,
		1,
		2,
		2,
		6,
		3,
		1,
		16,
		1,
		16,
		22,
		3,
		10,
		4,
		11,
		6,
		9,
		7,
		7,
		3,
		6,
		2,
		2,
		2,
		4,
		10,
		2,
		1,
		1,
		2,
		8,
		7,
		1,
		6,
		4,
		1,
		3,
		3,
		3,
		5,
		10,
		12,
		12,
		2,
		3,
		12,
		8,
		15,
		1,
		1,
		16,
		6,
		6,
		1,
		5,
		9,
		11,
		4,
		11,
		4,
		2,
		6,
		12,
		1,
		17,
		5,
		13,
		1,
		4,
		9,
		5,
		1,
		11,
		2,
		1,
		8,
		1,
		5,
		7,
		28,
		8,
		3,
		5,
		10,
		2,
		17,
		3,
		38,
		22,
		1,
		2,
		18,
		12,
		10,
		4,
		38,
		18,
		1,
		4,
		44,
		19,
		4,
		1,
		8,
		4,
		1,
		12,
		1,
		4,
		31,
		12,
		1,
		14,
		7,
		75,
		7,
		5,
		10,
		6,
		6,
		13,
		3,
		2,
		11,
		11,
		3,
		2,
		5,
		28,
		15,
		6,
		18,
		18,
		5,
		6,
		4,
		3,
		16,
		1,
		7,
		18,
		7,
		36,
		3,
		5,
		3,
		1,
		7,
		1,
		9,
		1,
		10,
		7,
		2,
		4,
		2,
		6,
		2,
		9,
		7,
		4,
		3,
		32,
		12,
		3,
		7,
		10,
		2,
		23,
		16,
		3,
		1,
		12,
		3,
		31,
		4,
		11,
		1,
		3,
		8,
		9,
		5,
		1,
		30,
		15,
		6,
		12,
		3,
		2,
		2,
		11,
		19,
		9,
		14,
		2,
		6,
		2,
		3,
		19,
		13,
		17,
		5,
		3,
		3,
		25,
		3,
		14,
		1,
		1,
		1,
		36,
		1,
		3,
		2,
		19,
		3,
		13,
		36,
		9,
		13,
		31,
		6,
		4,
		16,
		34,
		2,
		5,
		4,
		2,
		3,
		3,
		5,
		1,
		1,
		1,
		4,
		3,
		1,
		17,
		3,
		2,
		3,
		5,
		3,
		1,
		3,
		2,
		3,
		5,
		6,
		3,
		12,
		11,
		1,
		3,
		1,
		2,
		26,
		7,
		12,
		7,
		2,
		14,
		3,
		3,
		7,
		7,
		11,
		25,
		25,
		28,
		16,
		4,
		36,
		1,
		2,
		1,
		6,
		2,
		1,
		9,
		3,
		27,
		17,
		4,
		3,
		4,
		13,
		4,
		1,
		3,
		2,
		2,
		1,
		10,
		4,
		2,
		4,
		6,
		3,
		8,
		2,
		1,
		18,
		1,
		1,
		24,
		2,
		2,
		4,
		33,
		2,
		3,
		63,
		7,
		1,
		6,
		40,
		7,
		3,
		4,
		4,
		2,
		4,
		15,
		18,
		1,
		16,
		1,
		1,
		11,
		2,
		41,
		14,
		1,
		3,
		18,
		13,
		3,
		2,
		4,
		16,
		2,
		17,
		7,
		15,
		24,
		7,
		18,
		13,
		44,
		2,
		2,
		3,
		6,
		1,
		1,
		7,
		5,
		1,
		7,
		1,
		4,
		3,
		3,
		5,
		10,
		8,
		2,
		3,
		1,
		8,
		1,
		1,
		27,
		4,
		2,
		1,
		12,
		1,
		2,
		1,
		10,
		6,
		1,
		6,
		7,
		5,
		2,
		3,
		7,
		11,
		5,
		11,
		3,
		6,
		6,
		2,
		3,
		15,
		4,
		9,
		1,
		1,
		2,
		1,
		2,
		11,
		2,
		8,
		12,
		8,
		5,
		4,
		2,
		3,
		1,
		5,
		2,
		2,
		1,
		14,
		1,
		12,
		11,
		4,
		1,
		11,
		17,
		17,
		4,
		3,
		2,
		5,
		5,
		7,
		3,
		1,
		5,
		9,
		9,
		8,
		2,
		5,
		6,
		6,
		13,
		13,
		2,
		1,
		2,
		6,
		1,
		2,
		2,
		49,
		4,
		9,
		1,
		2,
		10,
		16,
		7,
		8,
		4,
		3,
		2,
		23,
		4,
		58,
		3,
		29,
		1,
		14,
		19,
		19,
		11,
		11,
		2,
		7,
		5,
		1,
		3,
		4,
		6,
		2,
		18,
		5,
		12,
		12,
		17,
		17,
		3,
		3,
		2,
		4,
		1,
		6,
		2,
		3,
		4,
		3,
		1,
		1,
		1,
		1,
		5,
		1,
		1,
		9,
		1,
		3,
		1,
		3,
		6,
		1,
		8,
		1,
		1,
		2,
		6,
		4,
		14,
		3,
		1,
		4,
		11,
		4,
		1,
		3,
		32,
		1,
		2,
		4,
		13,
		4,
		1,
		2,
		4,
		2,
		1,
		3,
		1,
		11,
		1,
		4,
		2,
		1,
		4,
		4,
		6,
		3,
		5,
		1,
		6,
		5,
		7,
		6,
		3,
		23,
		3,
		5,
		3,
		5,
		3,
		3,
		13,
		3,
		9,
		10,
		1,
		12,
		10,
		2,
		3,
		18,
		13,
		7,
		160,
		52,
		4,
		2,
		2,
		3,
		2,
		14,
		5,
		4,
		12,
		4,
		6,
		4,
		1,
		20,
		4,
		11,
		6,
		2,
		12,
		27,
		1,
		4,
		1,
		2,
		2,
		7,
		4,
		5,
		2,
		28,
		3,
		7,
		25,
		8,
		3,
		19,
		3,
		6,
		10,
		2,
		2,
		1,
		10,
		2,
		5,
		4,
		1,
		3,
		4,
		1,
		5,
		3,
		2,
		6,
		9,
		3,
		6,
		2,
		16,
		3,
		3,
		16,
		4,
		5,
		5,
		3,
		2,
		1,
		2,
		16,
		15,
		8,
		2,
		6,
		21,
		2,
		4,
		1,
		22,
		5,
		8,
		1,
		1,
		21,
		11,
		2,
		1,
		11,
		11,
		19,
		13,
		12,
		4,
		2,
		3,
		2,
		3,
		6,
		1,
		8,
		11,
		1,
		4,
		2,
		9,
		5,
		2,
		1,
		11,
		2,
		9,
		1,
		1,
		2,
		14,
		31,
		9,
		3,
		4,
		21,
		14,
		4,
		8,
		1,
		7,
		2,
		2,
		2,
		5,
		1,
		4,
		20,
		3,
		3,
		4,
		10,
		1,
		11,
		9,
		8,
		2,
		1,
		4,
		5,
		14,
		12,
		14,
		2,
		17,
		9,
		6,
		31,
		4,
		14,
		1,
		20,
		13,
		26,
		5,
		2,
		7,
		3,
		6,
		13,
		2,
		4,
		2,
		19,
		6,
		2,
		2,
		18,
		9,
		3,
		5,
		12,
		12,
		14,
		4,
		6,
		2,
		3,
		6,
		9,
		5,
		22,
		4,
		5,
		25,
		6,
		4,
		8,
		5,
		2,
		6,
		27,
		2,
		35,
		2,
		16,
		3,
		7,
		8,
		8,
		6,
		6,
		5,
		9,
		17,
		2,
		20,
		6,
		19,
		2,
		13,
		3,
		1,
		1,
		1,
		4,
		17,
		12,
		2,
		14,
		7,
		1,
		4,
		18,
		12,
		38,
		33,
		2,
		10,
		1,
		1,
		2,
		13,
		14,
		17,
		11,
		50,
		6,
		33,
		20,
		26,
		74,
		16,
		23,
		45,
		50,
		13,
		38,
		33,
		6,
		6,
		7,
		4,
		4,
		2,
		1,
		3,
		2,
		5,
		8,
		7,
		8,
		9,
		3,
		11,
		21,
		9,
		13,
		1,
		3,
		10,
		6,
		7,
		1,
		2,
		2,
		18,
		5,
		5,
		1,
		9,
		9,
		2,
		68,
		9,
		19,
		13,
		2,
		5,
		1,
		4,
		4,
		7,
		4,
		13,
		3,
		9,
		10,
		21,
		17,
		3,
		26,
		2,
		1,
		5,
		2,
		4,
		5,
		4,
		1,
		7,
		4,
		7,
		3,
		4,
		2,
		1,
		6,
		1,
		1,
		20,
		4,
		1,
		9,
		2,
		2,
		1,
		3,
		3,
		2,
		3,
		2,
		1,
		1,
		1,
		20,
		2,
		3,
		1,
		6,
		2,
		3,
		6,
		2,
		4,
		8,
		1,
		3,
		2,
		10,
		3,
		5,
		3,
		4,
		4,
		3,
		4,
		16,
		1,
		6,
		1,
		10,
		2,
		4,
		2,
		1,
		1,
		2,
		10,
		11,
		2,
		2,
		3,
		1,
		24,
		31,
		4,
		10,
		10,
		2,
		5,
		12,
		16,
		164,
		15,
		4,
		16,
		7,
		9,
		15,
		19,
		17,
		1,
		2,
		1,
		1,
		5,
		1,
		1,
		1,
		1,
		1,
		3,
		1,
		4,
		3,
		1,
		3,
		1,
		3,
		1,
		2,
		1,
		1,
		3,
		3,
		7,
		2,
		8,
		1,
		2,
		2,
		2,
		1,
		3,
		4,
		3,
		7,
		8,
		12,
		92,
		2,
		10,
		3,
		1,
		3,
		14,
		5,
		25,
		16,
		42,
		4,
		7,
		7,
		4,
		2,
		21,
		5,
		27,
		26,
		27,
		21,
		25,
		30,
		31,
		2,
		1,
		5,
		13,
		3,
		22,
		5,
		6,
		6,
		11,
		9,
		12,
		1,
		5,
		9,
		7,
		5,
		5,
		22,
		60,
		3,
		5,
		13,
		1,
		1,
		8,
		1,
		1,
		3,
		3,
		2,
		1,
		9,
		3,
		3,
		18,
		4,
		1,
		2,
		3,
		7,
		6,
		3,
		1,
		2,
		3,
		9,
		1,
		3,
		1,
		3,
		2,
		1,
		3,
		1,
		1,
		1,
		2,
		1,
		11,
		3,
		1,
		6,
		9,
		1,
		3,
		2,
		3,
		1,
		2,
		1,
		5,
		1,
		1,
		4,
		3,
		4,
		1,
		2,
		2,
		4,
		4,
		1,
		7,
		2,
		1,
		2,
		2,
		3,
		5,
		13,
		18,
		3,
		4,
		14,
		9,
		9,
		4,
		16,
		3,
		7,
		5,
		8,
		2,
		6,
		48,
		28,
		3,
		1,
		1,
		4,
		2,
		14,
		8,
		2,
		9,
		2,
		1,
		15,
		2,
		4,
		3,
		2,
		10,
		16,
		12,
		8,
		7,
		1,
		1,
		3,
		1,
		1,
		1,
		2,
		7,
		4,
		1,
		6,
		4,
		38,
		39,
		16,
		23,
		7,
		15,
		15,
		3,
		2,
		12,
		7,
		21,
		37,
		27,
		6,
		5,
		4,
		8,
		2,
		10,
		8,
		8,
		6,
		5,
		1,
		2,
		1,
		3,
		24,
		1,
		16,
		17,
		9,
		23,
		10,
		17,
		6,
		1,
		51,
		55,
		44,
		13,
		294,
		9,
		3,
		6,
		2,
		4,
		2,
		2,
		15,
		1,
		1,
		1,
		13,
		21,
		17,
		68,
		14,
		8,
		9,
		4,
		1,
		4,
		9,
		3,
		11,
		7,
		1,
		1,
		1,
		5,
		6,
		3,
		2,
		1,
		1,
		1,
		2,
		3,
		8,
		1,
		2,
		2,
		4,
		1,
		5,
		5,
		2,
		1,
		4,
		3,
		7,
		13,
		4,
		1,
		4,
		1,
		3,
		1,
		1,
		1,
		5,
		5,
		10,
		1,
		6,
		1,
		5,
		2,
		1,
		5,
		2,
		4,
		1,
		4,
		5,
		7,
		3,
		18,
		2,
		9,
		11,
		32,
		4,
		3,
		3,
		2,
		4,
		7,
		11,
		16,
		9,
		11,
		8,
		13,
		38,
		32,
		8,
		4,
		2,
		1,
		1,
		2,
		1,
		2,
		4,
		4,
		1,
		1,
		1,
		4,
		1,
		21,
		3,
		11,
		1,
		16,
		1,
		1,
		6,
		1,
		3,
		2,
		4,
		9,
		8,
		57,
		7,
		44,
		1,
		3,
		3,
		13,
		3,
		10,
		1,
		1,
		7,
		5,
		2,
		7,
		21,
		47,
		63,
		3,
		15,
		4,
		7,
		1,
		16,
		1,
		1,
		2,
		8,
		2,
		3,
		42,
		15,
		4,
		1,
		29,
		7,
		22,
		10,
		3,
		78,
		16,
		12,
		20,
		18,
		4,
		67,
		11,
		5,
		1,
		3,
		15,
		6,
		21,
		31,
		32,
		27,
		18,
		13,
		71,
		35,
		5,
		142,
		4,
		10,
		1,
		2,
		50,
		19,
		33,
		16,
		35,
		37,
		16,
		19,
		27,
		7,
		1,
		133,
		19,
		1,
		4,
		8,
		7,
		20,
		1,
		4,
		4,
		1,
		10,
		3,
		1,
		6,
		1,
		2,
		51,
		5,
		40,
		15,
		24,
		43,
		22928,
		11,
		1,
		13,
		154,
		70,
		3,
		1,
		1,
		7,
		4,
		10,
		1,
		2,
		1,
		1,
		2,
		1,
		2,
		1,
		2,
		2,
		1,
		1,
		2,
		1,
		1,
		1,
		1,
		1,
		2,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		2,
		1,
		1,
		1,
		3,
		2,
		1,
		1,
		1,
		1,
		2,
		1,
		1,
	};
	static ImWchar base_ranges[] = // not zero-terminated
			{
				0x0020, 0x00FF, // Basic Latin + Latin Supplement
				0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
				0x31F0, 0x31FF, // Katakana Phonetic Extensions
				0xFF00, 0xFFEF, // Half-width characters
				0xFFFD, 0xFFFD // Invalid
			};
	static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
	if (!full_ranges[0]) {
		memcpy(full_ranges, base_ranges, sizeof(base_ranges));
		UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
	}
	return &full_ranges[0];
}

const ImWchar *ImFontAtlas::GetGlyphRangesCyrillic() {
	static const ImWchar ranges[] = {
		0x0020,
		0x00FF, // Basic Latin + Latin Supplement
		0x0400,
		0x052F, // Cyrillic + Cyrillic Supplement
		0x2DE0,
		0x2DFF, // Cyrillic Extended-A
		0xA640,
		0xA69F, // Cyrillic Extended-B
		0,
	};
	return &ranges[0];
}

const ImWchar *ImFontAtlas::GetGlyphRangesThai() {
	static const ImWchar ranges[] = {
		0x0020,
		0x00FF, // Basic Latin
		0x2010,
		0x205E, // Punctuations
		0x0E00,
		0x0E7F, // Thai
		0,
	};
	return &ranges[0];
}

const ImWchar *ImFontAtlas::GetGlyphRangesVietnamese() {
	static const ImWchar ranges[] = {
		0x0020,
		0x00FF, // Basic Latin
		0x0102,
		0x0103,
		0x0110,
		0x0111,
		0x0128,
		0x0129,
		0x0168,
		0x0169,
		0x01A0,
		0x01A1,
		0x01AF,
		0x01B0,
		0x1EA0,
		0x1EF9,
		0,
	};
	return &ranges[0];
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontGlyphRangesBuilder
//-----------------------------------------------------------------------------

void ImFontGlyphRangesBuilder::AddText(const char *text, const char *text_end) {
	while (text_end ? (text < text_end) : *text) {
		unsigned int c = 0;
		int c_len = ImTextCharFromUtf8(&c, text, text_end);
		text += c_len;
		if (c_len == 0)
			break;
		AddChar((ImWchar)c);
	}
}

void ImFontGlyphRangesBuilder::AddRanges(const ImWchar *ranges) {
	for (; ranges[0]; ranges += 2)
		for (unsigned int c = ranges[0]; c <= ranges[1] && c <= IM_UNICODE_CODEPOINT_MAX; c++) //-V560
			AddChar((ImWchar)c);
}

void ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar> *out_ranges) {
	const int max_codepoint = IM_UNICODE_CODEPOINT_MAX;
	for (int n = 0; n <= max_codepoint; n++)
		if (GetBit(n)) {
			out_ranges->push_back((ImWchar)n);
			while (n < max_codepoint && GetBit(n + 1))
				n++;
			out_ranges->push_back((ImWchar)n);
		}
	out_ranges->push_back(0);
}

//-----------------------------------------------------------------------------
// [SECTION] ImFont
//-----------------------------------------------------------------------------

ImFont::ImFont() {
	FontSize = 0.0f;
	FallbackAdvanceX = 0.0f;
	FallbackChar = (ImWchar)-1;
	EllipsisChar = (ImWchar)-1;
	EllipsisWidth = EllipsisCharStep = 0.0f;
	EllipsisCharCount = 0;
	FallbackGlyph = NULL;
	ContainerAtlas = NULL;
	ConfigData = NULL;
	ConfigDataCount = 0;
	DirtyLookupTables = false;
	Scale = 1.0f;
	Ascent = Descent = 0.0f;
	MetricsTotalSurface = 0;
	memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
}

ImFont::~ImFont() {
	ClearOutputData();
}

void ImFont::ClearOutputData() {
	FontSize = 0.0f;
	FallbackAdvanceX = 0.0f;
	Glyphs.clear();
	IndexAdvanceX.clear();
	IndexLookup.clear();
	FallbackGlyph = NULL;
	ContainerAtlas = NULL;
	DirtyLookupTables = true;
	Ascent = Descent = 0.0f;
	MetricsTotalSurface = 0;
}

static ImWchar FindFirstExistingGlyph(ImFont *font, const ImWchar *candidate_chars, int candidate_chars_count) {
	for (int n = 0; n < candidate_chars_count; n++)
		if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
			return candidate_chars[n];
	return (ImWchar)-1;
}

void ImFont::BuildLookupTable() {
	int max_codepoint = 0;
	for (int i = 0; i != Glyphs.Size; i++)
		max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

	// Build lookup table
	IM_ASSERT(Glyphs.Size > 0 && "Font has not loaded glyph!");
	IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
	IndexAdvanceX.clear();
	IndexLookup.clear();
	DirtyLookupTables = false;
	memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
	GrowIndex(max_codepoint + 1);
	for (int i = 0; i < Glyphs.Size; i++) {
		int codepoint = (int)Glyphs[i].Codepoint;
		IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
		IndexLookup[codepoint] = (ImWchar)i;

		// Mark 4K page as used
		const int page_n = codepoint / 4096;
		Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
	}

	// Create a glyph to handle TAB
	// FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
	if (FindGlyph((ImWchar)' ')) {
		if (Glyphs.back().Codepoint != '\t') // So we can call this function multiple times (FIXME: Flaky)
			Glyphs.resize(Glyphs.Size + 1);
		ImFontGlyph &tab_glyph = Glyphs.back();
		tab_glyph = *FindGlyph((ImWchar)' ');
		tab_glyph.Codepoint = '\t';
		tab_glyph.AdvanceX *= IM_TABSIZE;
		IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
		IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);
	}

	// Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
	SetGlyphVisible((ImWchar)' ', false);
	SetGlyphVisible((ImWchar)'\t', false);

	// Setup Fallback character
	const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
	FallbackGlyph = FindGlyphNoFallback(FallbackChar);
	if (FallbackGlyph == NULL) {
		FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
		FallbackGlyph = FindGlyphNoFallback(FallbackChar);
		if (FallbackGlyph == NULL) {
			FallbackGlyph = &Glyphs.back();
			FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
		}
	}
	FallbackAdvanceX = FallbackGlyph->AdvanceX;
	for (int i = 0; i < max_codepoint + 1; i++)
		if (IndexAdvanceX[i] < 0.0f)
			IndexAdvanceX[i] = FallbackAdvanceX;

	// Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
	// However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
	// FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
	const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };
	const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
	if (EllipsisChar == (ImWchar)-1)
		EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
	const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
	if (EllipsisChar != (ImWchar)-1) {
		EllipsisCharCount = 1;
		EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
	} else if (dot_char != (ImWchar)-1) {
		const ImFontGlyph *glyph = FindGlyph(dot_char);
		EllipsisChar = dot_char;
		EllipsisCharCount = 3;
		EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;
		EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;
	}
}

// API is designed this way to avoid exposing the 4K page size
// e.g. use with IsGlyphRangeUnused(0, 255)
bool ImFont::IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last) {
	unsigned int page_begin = (c_begin / 4096);
	unsigned int page_last = (c_last / 4096);
	for (unsigned int page_n = page_begin; page_n <= page_last; page_n++)
		if ((page_n >> 3) < sizeof(Used4kPagesMap))
			if (Used4kPagesMap[page_n >> 3] & (1 << (page_n & 7)))
				return false;
	return true;
}

void ImFont::SetGlyphVisible(ImWchar c, bool visible) {
	if (ImFontGlyph *glyph = (ImFontGlyph *)(void *)FindGlyph((ImWchar)c))
		glyph->Visible = visible ? 1 : 0;
}

void ImFont::GrowIndex(int new_size) {
	IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
	if (new_size <= IndexLookup.Size)
		return;
	IndexAdvanceX.resize(new_size, -1.0f);
	IndexLookup.resize(new_size, (ImWchar)-1);
}

// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
// 'cfg' is not necessarily == 'this->ConfigData' because multiple source fonts+configs can be used to build one target font.
void ImFont::AddGlyph(const ImFontConfig *cfg, ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x) {
	if (cfg != NULL) {
		// Clamp & recenter if needed
		const float advance_x_original = advance_x;
		advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
		if (advance_x != advance_x_original) {
			float char_off_x = cfg->PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
			x0 += char_off_x;
			x1 += char_off_x;
		}

		// Snap to pixel
		if (cfg->PixelSnapH)
			advance_x = IM_ROUND(advance_x);

		// Bake spacing
		advance_x += cfg->GlyphExtraSpacing.x;
	}

	Glyphs.resize(Glyphs.Size + 1);
	ImFontGlyph &glyph = Glyphs.back();
	glyph.Codepoint = (unsigned int)codepoint;
	glyph.Visible = (x0 != x1) && (y0 != y1);
	glyph.Colored = false;
	glyph.X0 = x0;
	glyph.Y0 = y0;
	glyph.X1 = x1;
	glyph.Y1 = y1;
	glyph.U0 = u0;
	glyph.V0 = v0;
	glyph.U1 = u1;
	glyph.V1 = v1;
	glyph.AdvanceX = advance_x;

	// Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
	// We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
	float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
	DirtyLookupTables = true;
	MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
}

void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst) {
	IM_ASSERT(IndexLookup.Size > 0); // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
	unsigned int index_size = (unsigned int)IndexLookup.Size;

	if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists
		return;
	if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op
		return;

	GrowIndex(dst + 1);
	IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;
	IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
}

const ImFontGlyph *ImFont::FindGlyph(ImWchar c) const {
	if (c >= (size_t)IndexLookup.Size)
		return FallbackGlyph;
	const ImWchar i = IndexLookup.Data[c];
	if (i == (ImWchar)-1)
		return FallbackGlyph;
	return &Glyphs.Data[i];
}

const ImFontGlyph *ImFont::FindGlyphNoFallback(ImWchar c) const {
	if (c >= (size_t)IndexLookup.Size)
		return NULL;
	const ImWchar i = IndexLookup.Data[c];
	if (i == (ImWchar)-1)
		return NULL;
	return &Glyphs.Data[i];
}

// Wrapping skips upcoming blanks
static inline const char *CalcWordWrapNextLineStartA(const char *text, const char *text_end) {
	while (text < text_end && ImCharIsBlankA(*text))
		text++;
	if (*text == '\n')
		text++;
	return text;
}

// Simple word-wrapping for English, not full-featured. Please submit failing cases!
// This will return the next location to wrap from. If no wrapping if necessary, this will fast-forward to e.g. text_end.
// FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
const char *ImFont::CalcWordWrapPositionA(float scale, const char *text, const char *text_end, float wrap_width) const {
	// For references, possible wrap point marked with ^
	//  "aaa bbb, ccc,ddd. eee   fff. ggg!"
	//      ^    ^    ^   ^   ^__    ^    ^

	// List of hardcoded separators: .,;!?'"

	// Skip extra blanks after a line returns (that includes not counting them in width computation)
	// e.g. "Hello    world" --> "Hello" "World"

	// Cut words that cannot possibly fit within one line.
	// e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
	float line_width = 0.0f;
	float word_width = 0.0f;
	float blank_width = 0.0f;
	wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

	const char *word_end = text;
	const char *prev_word_end = NULL;
	bool inside_word = true;

	const char *s = text;
	IM_ASSERT(text_end != NULL);
	while (s < text_end) {
		unsigned int c = (unsigned int)*s;
		const char *next_s;
		if (c < 0x80)
			next_s = s + 1;
		else
			next_s = s + ImTextCharFromUtf8(&c, s, text_end);

		if (c < 32) {
			if (c == '\n') {
				line_width = word_width = blank_width = 0.0f;
				inside_word = true;
				s = next_s;
				continue;
			}
			if (c == '\r') {
				s = next_s;
				continue;
			}
		}

		const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);
		if (ImCharIsBlankW(c)) {
			if (inside_word) {
				line_width += blank_width;
				blank_width = 0.0f;
				word_end = s;
			}
			blank_width += char_width;
			inside_word = false;
		} else {
			word_width += char_width;
			if (inside_word) {
				word_end = next_s;
			} else {
				prev_word_end = word_end;
				line_width += word_width + blank_width;
				word_width = blank_width = 0.0f;
			}

			// Allow wrapping after punctuation.
			inside_word = (c != '.' && c != ',' && c != ';' && c != '!' && c != '?' && c != '\"');
		}

		// We ignore blank width at the end of the line (they can be skipped)
		if (line_width + word_width > wrap_width) {
			// Words that cannot possibly fit within an entire line will be cut anywhere.
			if (word_width < wrap_width)
				s = prev_word_end ? prev_word_end : word_end;
			break;
		}

		s = next_s;
	}

	// Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
	// +1 may not be a character start point in UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).
	if (s == text && text < text_end)
		return s + 1;
	return s;
}

ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char *text_begin, const char *text_end, const char **remaining) const {
	if (!text_end)
		text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

	const float line_height = size;
	const float scale = size / FontSize;

	ImVec2 text_size = ImVec2(0, 0);
	float line_width = 0.0f;

	const bool word_wrap_enabled = (wrap_width > 0.0f);
	const char *word_wrap_eol = NULL;

	const char *s = text_begin;
	while (s < text_end) {
		if (word_wrap_enabled) {
			// Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
			if (!word_wrap_eol)
				word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);

			if (s >= word_wrap_eol) {
				if (text_size.x < line_width)
					text_size.x = line_width;
				text_size.y += line_height;
				line_width = 0.0f;
				word_wrap_eol = NULL;
				s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
				continue;
			}
		}

		// Decode and advance source
		const char *prev_s = s;
		unsigned int c = (unsigned int)*s;
		if (c < 0x80)
			s += 1;
		else
			s += ImTextCharFromUtf8(&c, s, text_end);

		if (c < 32) {
			if (c == '\n') {
				text_size.x = ImMax(text_size.x, line_width);
				text_size.y += line_height;
				line_width = 0.0f;
				continue;
			}
			if (c == '\r')
				continue;
		}

		const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
		if (line_width + char_width >= max_width) {
			s = prev_s;
			break;
		}

		line_width += char_width;
	}

	if (text_size.x < line_width)
		text_size.x = line_width;

	if (line_width > 0 || text_size.y == 0.0f)
		text_size.y += line_height;

	if (remaining)
		*remaining = s;

	return text_size;
}

// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
void ImFont::RenderChar(ImDrawList *draw_list, float size, const ImVec2 &pos, ImU32 col, ImWchar c) const {
	const ImFontGlyph *glyph = FindGlyph(c);
	if (!glyph || !glyph->Visible)
		return;
	if (glyph->Colored)
		col |= ~IM_COL32_A_MASK;
	float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;
	float x = IM_TRUNC(pos.x);
	float y = IM_TRUNC(pos.y);
	draw_list->PrimReserve(6, 4);
	draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
}

// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
void ImFont::RenderText(ImDrawList *draw_list, float size, const ImVec2 &pos, ImU32 col, const ImVec4 &clip_rect, const char *text_begin, const char *text_end, float wrap_width, bool cpu_fine_clip) const {
	if (!text_end)
		text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.

	// Align to be pixel perfect
	float x = IM_TRUNC(pos.x);
	float y = IM_TRUNC(pos.y);
	if (y > clip_rect.w)
		return;

	const float start_x = x;
	const float scale = size / FontSize;
	const float line_height = FontSize * scale;
	const bool word_wrap_enabled = (wrap_width > 0.0f);

	// Fast-forward to first visible line
	const char *s = text_begin;
	if (y + line_height < clip_rect.y)
		while (y + line_height < clip_rect.y && s < text_end) {
			const char *line_end = (const char *)memchr(s, '\n', text_end - s);
			if (word_wrap_enabled) {
				// FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
				// If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
				// However it is still better than nothing performing the fast-forward!
				s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);
				s = CalcWordWrapNextLineStartA(s, text_end);
			} else {
				s = line_end ? line_end + 1 : text_end;
			}
			y += line_height;
		}

	// For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
	// Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
	if (text_end - s > 10000 && !word_wrap_enabled) {
		const char *s_end = s;
		float y_end = y;
		while (y_end < clip_rect.w && s_end < text_end) {
			s_end = (const char *)memchr(s_end, '\n', text_end - s_end);
			s_end = s_end ? s_end + 1 : text_end;
			y_end += line_height;
		}
		text_end = s_end;
	}
	if (s == text_end)
		return;

	// Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
	const int vtx_count_max = (int)(text_end - s) * 4;
	const int idx_count_max = (int)(text_end - s) * 6;
	const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
	draw_list->PrimReserve(idx_count_max, vtx_count_max);
	ImDrawVert *vtx_write = draw_list->_VtxWritePtr;
	ImDrawIdx *idx_write = draw_list->_IdxWritePtr;
	unsigned int vtx_index = draw_list->_VtxCurrentIdx;

	const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
	const char *word_wrap_eol = NULL;

	while (s < text_end) {
		if (word_wrap_enabled) {
			// Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
			if (!word_wrap_eol)
				word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));

			if (s >= word_wrap_eol) {
				x = start_x;
				y += line_height;
				if (y > clip_rect.w)
					break; // break out of main loop
				word_wrap_eol = NULL;
				s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
				continue;
			}
		}

		// Decode and advance source
		unsigned int c = (unsigned int)*s;
		if (c < 0x80)
			s += 1;
		else
			s += ImTextCharFromUtf8(&c, s, text_end);

		if (c < 32) {
			if (c == '\n') {
				x = start_x;
				y += line_height;
				if (y > clip_rect.w)
					break; // break out of main loop
				continue;
			}
			if (c == '\r')
				continue;
		}

		const ImFontGlyph *glyph = FindGlyph((ImWchar)c);
		if (glyph == NULL)
			continue;

		float char_width = glyph->AdvanceX * scale;
		if (glyph->Visible) {
			// We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
			float x1 = x + glyph->X0 * scale;
			float x2 = x + glyph->X1 * scale;
			float y1 = y + glyph->Y0 * scale;
			float y2 = y + glyph->Y1 * scale;
			if (x1 <= clip_rect.z && x2 >= clip_rect.x) {
				// Render a character
				float u1 = glyph->U0;
				float v1 = glyph->V0;
				float u2 = glyph->U1;
				float v2 = glyph->V1;

				// CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
				if (cpu_fine_clip) {
					if (x1 < clip_rect.x) {
						u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
						x1 = clip_rect.x;
					}
					if (y1 < clip_rect.y) {
						v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
						y1 = clip_rect.y;
					}
					if (x2 > clip_rect.z) {
						u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
						x2 = clip_rect.z;
					}
					if (y2 > clip_rect.w) {
						v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
						y2 = clip_rect.w;
					}
					if (y1 >= y2) {
						x += char_width;
						continue;
					}
				}

				// Support for untinted glyphs
				ImU32 glyph_col = glyph->Colored ? col_untinted : col;

				// We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
				{
					vtx_write[0].pos.x = x1;
					vtx_write[0].pos.y = y1;
					vtx_write[0].col = glyph_col;
					vtx_write[0].uv.x = u1;
					vtx_write[0].uv.y = v1;
					vtx_write[1].pos.x = x2;
					vtx_write[1].pos.y = y1;
					vtx_write[1].col = glyph_col;
					vtx_write[1].uv.x = u2;
					vtx_write[1].uv.y = v1;
					vtx_write[2].pos.x = x2;
					vtx_write[2].pos.y = y2;
					vtx_write[2].col = glyph_col;
					vtx_write[2].uv.x = u2;
					vtx_write[2].uv.y = v2;
					vtx_write[3].pos.x = x1;
					vtx_write[3].pos.y = y2;
					vtx_write[3].col = glyph_col;
					vtx_write[3].uv.x = u1;
					vtx_write[3].uv.y = v2;
					idx_write[0] = (ImDrawIdx)(vtx_index);
					idx_write[1] = (ImDrawIdx)(vtx_index + 1);
					idx_write[2] = (ImDrawIdx)(vtx_index + 2);
					idx_write[3] = (ImDrawIdx)(vtx_index);
					idx_write[4] = (ImDrawIdx)(vtx_index + 2);
					idx_write[5] = (ImDrawIdx)(vtx_index + 3);
					vtx_write += 4;
					vtx_index += 4;
					idx_write += 6;
				}
			}
		}
		x += char_width;
	}

	// Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
	draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
	draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
	draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
	draw_list->_VtxWritePtr = vtx_write;
	draw_list->_IdxWritePtr = idx_write;
	draw_list->_VtxCurrentIdx = vtx_index;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGui Internal Render Helpers
//-----------------------------------------------------------------------------
// Vaguely redesigned to stop accessing ImGui global state:
// - RenderArrow()
// - RenderBullet()
// - RenderCheckMark()
// - RenderArrowPointingAt()
// - RenderRectFilledRangeH()
// - RenderRectFilledWithHole()
//-----------------------------------------------------------------------------
// Function in need of a redesign (legacy mess)
// - RenderColorRectWithAlphaCheckerboard()
//-----------------------------------------------------------------------------

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
void ImGui::RenderArrow(ImDrawList *draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale) {
	const float h = draw_list->_Data->FontSize * 1.00f;
	float r = h * 0.40f * scale;
	ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);

	ImVec2 a, b, c;
	switch (dir) {
		case ImGuiDir_Up:
		case ImGuiDir_Down:
			if (dir == ImGuiDir_Up)
				r = -r;
			a = ImVec2(+0.000f, +0.750f) * r;
			b = ImVec2(-0.866f, -0.750f) * r;
			c = ImVec2(+0.866f, -0.750f) * r;
			break;
		case ImGuiDir_Left:
		case ImGuiDir_Right:
			if (dir == ImGuiDir_Left)
				r = -r;
			a = ImVec2(+0.750f, +0.000f) * r;
			b = ImVec2(-0.750f, +0.866f) * r;
			c = ImVec2(-0.750f, -0.866f) * r;
			break;
		case ImGuiDir_None:
		case ImGuiDir_COUNT:
			IM_ASSERT(0);
			break;
	}
	draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
}

void ImGui::RenderBullet(ImDrawList *draw_list, ImVec2 pos, ImU32 col) {
	// FIXME-OPT: This should be baked in font.
	draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);
}

void ImGui::RenderCheckMark(ImDrawList *draw_list, ImVec2 pos, ImU32 col, float sz) {
	float thickness = ImMax(sz / 5.0f, 1.0f);
	sz -= thickness * 0.5f;
	pos += ImVec2(thickness * 0.25f, thickness * 0.25f);

	float third = sz / 3.0f;
	float bx = pos.x + third;
	float by = pos.y + sz - third * 0.5f;
	draw_list->PathLineTo(ImVec2(bx - third, by - third));
	draw_list->PathLineTo(ImVec2(bx, by));
	draw_list->PathLineTo(ImVec2(bx + third * 2.0f, by - third * 2.0f));
	draw_list->PathStroke(col, 0, thickness);
}

// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
void ImGui::RenderArrowPointingAt(ImDrawList *draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col) {
	switch (direction) {
		case ImGuiDir_Left:
			draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col);
			return;
		case ImGuiDir_Right:
			draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col);
			return;
		case ImGuiDir_Up:
			draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col);
			return;
		case ImGuiDir_Down:
			draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col);
			return;
		case ImGuiDir_None:
		case ImGuiDir_COUNT:
			break; // Fix warnings
	}
}

static inline float ImAcos01(float x) {
	if (x <= 0.0f)
		return IM_PI * 0.5f;
	if (x >= 1.0f)
		return 0.0f;
	return ImAcos(x);
	//return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
}

// FIXME: Cleanup and move code to ImDrawList.
void ImGui::RenderRectFilledRangeH(ImDrawList *draw_list, const ImRect &rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding) {
	if (x_end_norm == x_start_norm)
		return;
	if (x_start_norm > x_end_norm)
		ImSwap(x_start_norm, x_end_norm);

	ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
	ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
	if (rounding == 0.0f) {
		draw_list->AddRectFilled(p0, p1, col, 0.0f);
		return;
	}

	rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);
	const float inv_rounding = 1.0f / rounding;
	const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);
	const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);
	const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.
	const float x0 = ImMax(p0.x, rect.Min.x + rounding);
	if (arc0_b == arc0_e) {
		draw_list->PathLineTo(ImVec2(x0, p1.y));
		draw_list->PathLineTo(ImVec2(x0, p0.y));
	} else if (arc0_b == 0.0f && arc0_e == half_pi) {
		draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL
		draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR
	} else {
		draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b); // BL
		draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e); // TR
	}
	if (p1.x > rect.Min.x + rounding) {
		const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);
		const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);
		const float x1 = ImMin(p1.x, rect.Max.x - rounding);
		if (arc1_b == arc1_e) {
			draw_list->PathLineTo(ImVec2(x1, p0.y));
			draw_list->PathLineTo(ImVec2(x1, p1.y));
		} else if (arc1_b == 0.0f && arc1_e == half_pi) {
			draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR
			draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3); // BR
		} else {
			draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b); // TR
			draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e); // BR
		}
	}
	draw_list->PathFillConvex(col);
}

void ImGui::RenderRectFilledWithHole(ImDrawList *draw_list, const ImRect &outer, const ImRect &inner, ImU32 col, float rounding) {
	const bool fill_L = (inner.Min.x > outer.Min.x);
	const bool fill_R = (inner.Max.x < outer.Max.x);
	const bool fill_U = (inner.Min.y > outer.Min.y);
	const bool fill_D = (inner.Max.y < outer.Max.y);
	if (fill_L)
		draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft) | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));
	if (fill_R)
		draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight) | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));
	if (fill_U)
		draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));
	if (fill_D)
		draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));
	if (fill_L && fill_U)
		draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);
	if (fill_R && fill_U)
		draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);
	if (fill_L && fill_D)
		draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);
	if (fill_R && fill_D)
		draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);
}

// Helper for ColorPicker4()
// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// Spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding altogether.
// FIXME: uses ImGui::GetColorU32
void ImGui::RenderColorRectWithAlphaCheckerboard(ImDrawList *draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, ImDrawFlags flags) {
	if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
		flags = ImDrawFlags_RoundCornersDefault_;
	if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF) {
		ImU32 col_bg1 = GetColorU32(ImAlphaBlendColors(IM_COL32(204, 204, 204, 255), col));
		ImU32 col_bg2 = GetColorU32(ImAlphaBlendColors(IM_COL32(128, 128, 128, 255), col));
		draw_list->AddRectFilled(p_min, p_max, col_bg1, rounding, flags);

		int yi = 0;
		for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++) {
			float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);
			if (y2 <= y1)
				continue;
			for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f) {
				float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);
				if (x2 <= x1)
					continue;
				ImDrawFlags cell_flags = ImDrawFlags_RoundCornersNone;
				if (y1 <= p_min.y) {
					if (x1 <= p_min.x)
						cell_flags |= ImDrawFlags_RoundCornersTopLeft;
					if (x2 >= p_max.x)
						cell_flags |= ImDrawFlags_RoundCornersTopRight;
				}
				if (y2 >= p_max.y) {
					if (x1 <= p_min.x)
						cell_flags |= ImDrawFlags_RoundCornersBottomLeft;
					if (x2 >= p_max.x)
						cell_flags |= ImDrawFlags_RoundCornersBottomRight;
				}

				// Combine flags
				cell_flags = (flags == ImDrawFlags_RoundCornersNone || cell_flags == ImDrawFlags_RoundCornersNone) ? ImDrawFlags_RoundCornersNone : (cell_flags & flags);
				draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding, cell_flags);
			}
		}
	} else {
		draw_list->AddRectFilled(p_min, p_max, col, rounding, flags);
	}
}

//-----------------------------------------------------------------------------
// [SECTION] Decompression code
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array and encoded as base85.
// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

static unsigned int stb_decompress_length(const unsigned char *input) {
	return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
}

static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
static const unsigned char *stb__barrier_in_b;
static unsigned char *stb__dout;
static void stb__match(const unsigned char *data, unsigned int length) {
	// INVERSE of memmove... write each byte before copying the next...
	IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
	if (stb__dout + length > stb__barrier_out_e) {
		stb__dout += length;
		return;
	}
	if (data < stb__barrier_out_b) {
		stb__dout = stb__barrier_out_e + 1;
		return;
	}
	while (length--)
		*stb__dout++ = *data++;
}

static void stb__lit(const unsigned char *data, unsigned int length) {
	IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
	if (stb__dout + length > stb__barrier_out_e) {
		stb__dout += length;
		return;
	}
	if (data < stb__barrier_in_b) {
		stb__dout = stb__barrier_out_e + 1;
		return;
	}
	memcpy(stb__dout, data, length);
	stb__dout += length;
}

#define stb__in2(x) ((i[x] << 8) + i[(x) + 1])
#define stb__in3(x) ((i[x] << 16) + stb__in2((x) + 1))
#define stb__in4(x) ((i[x] << 24) + stb__in3((x) + 1))

static const unsigned char *stb_decompress_token(const unsigned char *i) {
	if (*i >= 0x20) { // use fewer if's for cases that expand small
		if (*i >= 0x80)
			stb__match(stb__dout - i[1] - 1, i[0] - 0x80 + 1), i += 2;
		else if (*i >= 0x40)
			stb__match(stb__dout - (stb__in2(0) - 0x4000 + 1), i[2] + 1), i += 3;
		else /* *i >= 0x20 */
			stb__lit(i + 1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
	} else { // more ifs for cases that expand large, since overhead is amortized
		if (*i >= 0x18)
			stb__match(stb__dout - (stb__in3(0) - 0x180000 + 1), i[3] + 1), i += 4;
		else if (*i >= 0x10)
			stb__match(stb__dout - (stb__in3(0) - 0x100000 + 1), stb__in2(3) + 1), i += 5;
		else if (*i >= 0x08)
			stb__lit(i + 2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
		else if (*i == 0x07)
			stb__lit(i + 3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
		else if (*i == 0x06)
			stb__match(stb__dout - (stb__in3(1) + 1), i[4] + 1), i += 5;
		else if (*i == 0x04)
			stb__match(stb__dout - (stb__in3(1) + 1), stb__in2(4) + 1), i += 6;
	}
	return i;
}

static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen) {
	const unsigned long ADLER_MOD = 65521;
	unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
	unsigned long blocklen = buflen % 5552;

	unsigned long i;
	while (buflen) {
		for (i = 0; i + 7 < blocklen; i += 8) {
			s1 += buffer[0], s2 += s1;
			s1 += buffer[1], s2 += s1;
			s1 += buffer[2], s2 += s1;
			s1 += buffer[3], s2 += s1;
			s1 += buffer[4], s2 += s1;
			s1 += buffer[5], s2 += s1;
			s1 += buffer[6], s2 += s1;
			s1 += buffer[7], s2 += s1;

			buffer += 8;
		}

		for (; i < blocklen; ++i)
			s1 += *buffer++, s2 += s1;

		s1 %= ADLER_MOD, s2 %= ADLER_MOD;
		buflen -= blocklen;
		blocklen = 5552;
	}
	return (unsigned int)(s2 << 16) + (unsigned int)s1;
}

static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/) {
	if (stb__in4(0) != 0x57bC0000)
		return 0;
	if (stb__in4(4) != 0)
		return 0; // error! stream is > 4GB
	const unsigned int olen = stb_decompress_length(i);
	stb__barrier_in_b = i;
	stb__barrier_out_e = output + olen;
	stb__barrier_out_b = output;
	i += 16;

	stb__dout = output;
	for (;;) {
		const unsigned char *old_i = i;
		i = stb_decompress_token(i);
		if (i == old_i) {
			if (*i == 0x05 && i[1] == 0xfa) {
				IM_ASSERT(stb__dout == output + olen);
				if (stb__dout != output + olen)
					return 0;
				if (stb_adler32(1, output, olen) != (unsigned int)stb__in4(2))
					return 0;
				return olen;
			} else {
				IM_ASSERT(0); /* NOTREACHED */
				return 0;
			}
		}
		IM_ASSERT(stb__dout <= output + olen);
		if (stb__dout > output + olen)
			return 0;
	}
}

//-----------------------------------------------------------------------------
// [SECTION] Default font data (ProggyClean.ttf)
//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.proggyfonts.net/index.php?menu=download)
// Download and more information at http://www.proggyfonts.net or http://upperboundsinteractive.com/fonts.php
//-----------------------------------------------------------------------------
// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression + base85 string encoding).
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
//-----------------------------------------------------------------------------
static const char proggy_clean_ttf_compressed_data_base85[11980 + 1] =
		"7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
		"2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
		"`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
		"i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
		"kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
		"*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
		"tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
		"ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
		"x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
		"CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
		"U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
		"'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
		"_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
		"Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
		"/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
		"%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
		"OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
		"h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
		"o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
		"j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
		"sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
		"eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
		"M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
		"LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
		"%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
		"Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
		"a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
		"$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
		"nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
		"7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
		")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
		"D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
		"P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
		"bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
		"h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
		"V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
		"sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
		".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
		"$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
		"hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
		"@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
		"w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
		"u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
		"d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
		"6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
		"b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
		":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
		"tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
		"$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
		":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
		"7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
		"u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
		"LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
		":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
		"_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
		"hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
		"^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
		"+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
		"9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
		"CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
		"hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
		"8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
		"S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
		"0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
		"+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
		"M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
		"?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
		"Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
		">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
		"[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
		"wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
		"Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
		"MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
		"i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
		"1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
		"iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
		"URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
		";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
		"w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
		"d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
		"A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
		"/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
		"m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
		"TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
		"GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
		"O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";

static const char *GetDefaultCompressedFontDataTTFBase85() {
	return proggy_clean_ttf_compressed_data_base85;
}

#endif // #ifndef IMGUI_DISABLE
#line 0

#line 1 "sfw/render_gui/imgui_impl_glfw.h"
// dear imgui: Platform Backend for GLFW
// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan, WebGPU..)
// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)

// Implemented features:
//  [X] Platform: Clipboard support.
//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen (Windows only).
//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy GLFW_KEY_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]
//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange' (note: the resizing cursors requires GLFW 3.4+).

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// Learn about Dear ImGui:
// - FAQ                  https://dearimgui.com/faq
// - Getting Started      https://dearimgui.com/getting-started
// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
// - Introduction, links and more at the top of imgui.cpp

#ifndef IMGUI_DISABLE

struct GLFWwindow;
struct GLFWmonitor;

// Follow "Getting Started" link and check examples/ folder to learn about using backends!
IMGUI_IMPL_API bool ImGui_ImplGlfw_InitForOpenGL(GLFWwindow *window, bool install_callbacks);
IMGUI_IMPL_API bool ImGui_ImplGlfw_InitForVulkan(GLFWwindow *window, bool install_callbacks);
IMGUI_IMPL_API bool ImGui_ImplGlfw_InitForOther(GLFWwindow *window, bool install_callbacks);
IMGUI_IMPL_API void ImGui_ImplGlfw_Shutdown();
IMGUI_IMPL_API void ImGui_ImplGlfw_NewFrame();

// Emscripten related initialization phase methods (call after ImGui_ImplGlfw_InitForOpenGL)
#ifdef __EMSCRIPTEN__
IMGUI_IMPL_API void ImGui_ImplGlfw_InstallEmscriptenCallbacks(GLFWwindow *window, const char *canvas_selector);
//static inline void    ImGui_ImplGlfw_InstallEmscriptenCanvasResizeCallback(const char* canvas_selector) { ImGui_ImplGlfw_InstallEmscriptenCallbacks(nullptr, canvas_selector); } } // Renamed in 1.91.0
#endif

// GLFW callbacks install
// - When calling Init with 'install_callbacks=true': ImGui_ImplGlfw_InstallCallbacks() is called. GLFW callbacks will be installed for you. They will chain-call user's previously installed callbacks, if any.
// - When calling Init with 'install_callbacks=false': GLFW callbacks won't be installed. You will need to call individual function yourself from your own GLFW callbacks.
IMGUI_IMPL_API void ImGui_ImplGlfw_InstallCallbacks(GLFWwindow *window);
IMGUI_IMPL_API void ImGui_ImplGlfw_RestoreCallbacks(GLFWwindow *window);

// GFLW callbacks options:
// - Set 'chain_for_all_windows=true' to enable chaining callbacks for all windows (including secondary viewports created by backends or by user)
IMGUI_IMPL_API void ImGui_ImplGlfw_SetCallbacksChainForAllWindows(bool chain_for_all_windows);

// GLFW callbacks (individual callbacks to call yourself if you didn't install callbacks)
IMGUI_IMPL_API void ImGui_ImplGlfw_WindowFocusCallback(GLFWwindow *window, int focused); // Since 1.84
IMGUI_IMPL_API void ImGui_ImplGlfw_CursorEnterCallback(GLFWwindow *window, int entered); // Since 1.84
IMGUI_IMPL_API void ImGui_ImplGlfw_CursorPosCallback(GLFWwindow *window, double x, double y); // Since 1.87
IMGUI_IMPL_API void ImGui_ImplGlfw_MouseButtonCallback(GLFWwindow *window, int button, int action, int mods);
IMGUI_IMPL_API void ImGui_ImplGlfw_ScrollCallback(GLFWwindow *window, double xoffset, double yoffset);
IMGUI_IMPL_API void ImGui_ImplGlfw_KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);
IMGUI_IMPL_API void ImGui_ImplGlfw_CharCallback(GLFWwindow *window, unsigned int c);
IMGUI_IMPL_API void ImGui_ImplGlfw_MonitorCallback(GLFWmonitor *monitor, int event);

// GLFW helpers
IMGUI_IMPL_API void ImGui_ImplGlfw_Sleep(int milliseconds);

#endif // #ifndef IMGUI_DISABLE
#line 0

#line 1 "sfw/render_gui/imgui_impl_glfw.cpp"
// dear imgui: Platform Backend for GLFW
// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan, WebGPU..)
// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)
// (Requires: GLFW 3.1+. Prefer GLFW 3.3+ or GLFW 3.4+ for full feature support.)

// Implemented features:
//  [X] Platform: Clipboard support.
//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen (Windows only).
//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy GLFW_KEY_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]
//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange' (note: the resizing cursors requires GLFW 3.4+).

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// Learn about Dear ImGui:
// - FAQ                  https://dearimgui.com/faq
// - Getting Started      https://dearimgui.com/getting-started
// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
// - Introduction, links and more at the top of imgui.cpp

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2024-08-22: moved some OS/backend related function pointers from ImGuiIO to ImGuiPlatformIO:
//               - io.GetClipboardTextFn    -> platform_io.Platform_GetClipboardTextFn
//               - io.SetClipboardTextFn    -> platform_io.Platform_SetClipboardTextFn
//               - io.PlatformOpenInShellFn -> platform_io.Platform_OpenInShellFn
//  2024-07-31: Added ImGui_ImplGlfw_Sleep() helper function for usage by our examples app, since GLFW doesn't provide one.
//  2024-07-08: *BREAKING* Renamed ImGui_ImplGlfw_InstallEmscriptenCanvasResizeCallback to ImGui_ImplGlfw_InstallEmscriptenCallbacks(), added GLFWWindow* parameter.
//  2024-07-08: Emscripten: Added support for GLFW3 contrib port (GLFW 3.4.0 features + bug fixes): to enable, replace -sUSE_GLFW=3 with --use-port=contrib.glfw3 (requires emscripten 3.1.59+) (https://github.com/pongasoft/emscripten-glfw)
//  2024-07-02: Emscripten: Added io.PlatformOpenInShellFn() handler for Emscripten versions.
//  2023-12-19: Emscripten: Added ImGui_ImplGlfw_InstallEmscriptenCanvasResizeCallback() to register canvas selector and auto-resize GLFW window.
//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys.
//  2023-07-18: Inputs: Revert ignoring mouse data on GLFW_CURSOR_DISABLED as it can be used differently. User may set ImGuiConfigFLags_NoMouse if desired. (#5625, #6609)
//  2023-06-12: Accept glfwGetTime() not returning a monotonically increasing value. This seems to happens on some Windows setup when peripherals disconnect, and is likely to also happen on browser + Emscripten. (#6491)
//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen on Windows ONLY, using a custom WndProc hook. (#2702)
//  2023-03-16: Inputs: Fixed key modifiers handling on secondary viewports (docking branch). Broken on 2023/01/04. (#6248, #6034)
//  2023-03-14: Emscripten: Avoid using glfwGetError() and glfwGetGamepadState() which are not correctly implemented in Emscripten emulation. (#6240)
//  2023-02-03: Emscripten: Registering custom low-level mouse wheel handler to get more accurate scrolling impulses on Emscripten. (#4019, #6096)
//  2023-01-04: Inputs: Fixed mods state on Linux when using Alt-GR text input (e.g. German keyboard layout), could lead to broken text input. Revert a 2022/01/17 change were we resumed using mods provided by GLFW, turns out they were faulty.
//  2022-11-22: Perform a dummy glfwGetError() read to cancel missing names with glfwGetKeyName(). (#5908)
//  2022-10-18: Perform a dummy glfwGetError() read to cancel missing mouse cursors errors. Using GLFW_VERSION_COMBINED directly. (#5785)
//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.
//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).
//  2022-09-01: Inputs: Honor GLFW_CURSOR_DISABLED by not setting mouse position *EDIT* Reverted 2023-07-18.
//  2022-04-30: Inputs: Fixed ImGui_ImplGlfw_TranslateUntranslatedKey() for lower case letters on OSX.
//  2022-03-23: Inputs: Fixed a regression in 1.87 which resulted in keyboard modifiers events being reported incorrectly on Linux/X11.
//  2022-02-07: Added ImGui_ImplGlfw_InstallCallbacks()/ImGui_ImplGlfw_RestoreCallbacks() helpers to facilitate user installing callbacks after initializing backend.
//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.
//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].
//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).
//  2022-01-17: Inputs: always update key mods next and before key event (not in NewFrame) to fix input queue with very low framerates.
//  2022-01-12: *BREAKING CHANGE*: Now using glfwSetCursorPosCallback(). If you called ImGui_ImplGlfw_InitXXX() with install_callbacks = false, you MUST install glfwSetCursorPosCallback() and forward it to the backend via ImGui_ImplGlfw_CursorPosCallback().
//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.
//  2022-01-05: Inputs: Converting GLFW untranslated keycodes back to translated keycodes (in the ImGui_ImplGlfw_KeyCallback() function) in order to match the behavior of every other backend, and facilitate the use of GLFW with lettered-shortcuts API.
//  2021-08-17: *BREAKING CHANGE*: Now using glfwSetWindowFocusCallback() to calling io.AddFocusEvent(). If you called ImGui_ImplGlfw_InitXXX() with install_callbacks = false, you MUST install glfwSetWindowFocusCallback() and forward it to the backend via ImGui_ImplGlfw_WindowFocusCallback().
//  2021-07-29: *BREAKING CHANGE*: Now using glfwSetCursorEnterCallback(). MousePos is correctly reported when the host platform window is hovered but not focused. If you called ImGui_ImplGlfw_InitXXX() with install_callbacks = false, you MUST install glfwSetWindowFocusCallback() callback and forward it to the backend via ImGui_ImplGlfw_CursorEnterCallback().
//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).
//  2020-01-17: Inputs: Disable error callback while assigning mouse cursors because some X11 setup don't have them and it generates errors.
//  2019-12-05: Inputs: Added support for new mouse cursors added in GLFW 3.4+ (resizing cursors, not allowed cursor).
//  2019-10-18: Misc: Previously installed user callbacks are now restored on shutdown.
//  2019-07-21: Inputs: Added mapping for ImGuiKey_KeyPadEnter.
//  2019-05-11: Inputs: Don't filter value from character callback before calling AddInputCharacter().
//  2019-03-12: Misc: Preserve DisplayFramebufferScale when main window is minimized.
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-11-07: Inputs: When installing our GLFW callbacks, we save user's previously installed ones - if any - and chain call them.
//  2018-08-01: Inputs: Workaround for Emscripten which doesn't seem to handle focus related calls.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-08: Misc: Extracted imgui_impl_glfw.cpp/.h away from the old combined GLFW+OpenGL/Vulkan examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors flag + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value, passed to glfwSetCursor()).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-01-25: Inputs: Added gamepad support if ImGuiConfigFlags_NavEnableGamepad is set.
//  2018-01-25: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-18: Inputs: Added mapping for ImGuiKey_Insert.
//  2017-08-25: Inputs: MousePos set to -FLT_MAX,-FLT_MAX when mouse is unavailable/missing (instead of -1,-1).
//  2016-10-15: Misc: Added a void* user_data parameter to Clipboard function handlers.

#ifndef IMGUI_DISABLE

// Clang warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast" // warning: use of old-style cast
#pragma clang diagnostic ignored "-Wsign-conversion" // warning: implicit conversion changes signedness
#endif

// GLFW

#ifndef _WIN32
#include <unistd.h> // for usleep()
#endif

/*
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#include <emscripten/html5.h>
#ifdef EMSCRIPTEN_USE_PORT_CONTRIB_GLFW3
#include <GLFW/emscripten_glfw3.h>
#else
#define EMSCRIPTEN_USE_EMBEDDED_GLFW3
#endif
#endif
*/

// We gather version tests as define in order to easily see which features are version-dependent.
#define GLFW_VERSION_COMBINED (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 + GLFW_VERSION_REVISION)
#ifdef GLFW_RESIZE_NESW_CURSOR // Let's be nice to people who pulled GLFW between 2019-04-16 (3.4 define) and 2019-11-29 (cursors defines) // FIXME: Remove when GLFW 3.4 is released?
#define GLFW_HAS_NEW_CURSORS (GLFW_VERSION_COMBINED >= 3400) // 3.4+ GLFW_RESIZE_ALL_CURSOR, GLFW_RESIZE_NESW_CURSOR, GLFW_RESIZE_NWSE_CURSOR, GLFW_NOT_ALLOWED_CURSOR
#else
#define GLFW_HAS_NEW_CURSORS (0)
#endif
#define GLFW_HAS_GAMEPAD_API (GLFW_VERSION_COMBINED >= 3300) // 3.3+ glfwGetGamepadState() new api
#define GLFW_HAS_GETKEYNAME (GLFW_VERSION_COMBINED >= 3200) // 3.2+ glfwGetKeyName()
#define GLFW_HAS_GETERROR (GLFW_VERSION_COMBINED >= 3300) // 3.3+ glfwGetError()

// GLFW data
enum GlfwClientApi {
	GlfwClientApi_Unknown,
	GlfwClientApi_OpenGL,
	GlfwClientApi_Vulkan,
};

struct ImGui_ImplGlfw_Data {
	GLFWwindow *Window;
	GlfwClientApi ClientApi;
	double Time;
	GLFWwindow *MouseWindow;
	GLFWcursor *MouseCursors[ImGuiMouseCursor_COUNT];
	ImVec2 LastValidMousePos;
	bool InstalledCallbacks;
	bool CallbacksChainForAllWindows;
#ifdef EMSCRIPTEN_USE_EMBEDDED_GLFW3
	const char *CanvasSelector;
#endif

	// Chain GLFW callbacks: our callbacks will call the user's previously installed callbacks, if any.
	GLFWwindowfocusfun PrevUserCallbackWindowFocus;
	GLFWcursorposfun PrevUserCallbackCursorPos;
	GLFWcursorenterfun PrevUserCallbackCursorEnter;
	GLFWmousebuttonfun PrevUserCallbackMousebutton;
	GLFWscrollfun PrevUserCallbackScroll;
	GLFWkeyfun PrevUserCallbackKey;
	GLFWcharfun PrevUserCallbackChar;
	GLFWmonitorfun PrevUserCallbackMonitor;
#ifdef _WIN32
	WNDPROC PrevWndProc;
#endif

	ImGui_ImplGlfw_Data() { memset((void *)this, 0, sizeof(*this)); }
};

// Backend data stored in io.BackendPlatformUserData to allow support for multiple Dear ImGui contexts
// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
// FIXME: multi-context support is not well tested and probably dysfunctional in this backend.
// - Because glfwPollEvents() process all windows and some events may be called outside of it, you will need to register your own callbacks
//   (passing install_callbacks=false in ImGui_ImplGlfw_InitXXX functions), set the current dear imgui context and then call our callbacks.
// - Otherwise we may need to store a GLFWWindow* -> ImGuiContext* map and handle this in the backend, adding a little bit of extra complexity to it.
// FIXME: some shared resources (mouse cursor shape, gamepad) are mishandled when using multi-context.
static ImGui_ImplGlfw_Data *ImGui_ImplGlfw_GetBackendData() {
	return ImGui::GetCurrentContext() ? (ImGui_ImplGlfw_Data *)ImGui::GetIO().BackendPlatformUserData : nullptr;
}

// Functions
static ImGuiKey ImGui_ImplGlfw_KeyToImGuiKey(int key) {
	switch (key) {
		case GLFW_KEY_TAB:
			return ImGuiKey_Tab;
		case GLFW_KEY_LEFT:
			return ImGuiKey_LeftArrow;
		case GLFW_KEY_RIGHT:
			return ImGuiKey_RightArrow;
		case GLFW_KEY_UP:
			return ImGuiKey_UpArrow;
		case GLFW_KEY_DOWN:
			return ImGuiKey_DownArrow;
		case GLFW_KEY_PAGE_UP:
			return ImGuiKey_PageUp;
		case GLFW_KEY_PAGE_DOWN:
			return ImGuiKey_PageDown;
		case GLFW_KEY_HOME:
			return ImGuiKey_Home;
		case GLFW_KEY_END:
			return ImGuiKey_End;
		case GLFW_KEY_INSERT:
			return ImGuiKey_Insert;
		case GLFW_KEY_DELETE:
			return ImGuiKey_Delete;
		case GLFW_KEY_BACKSPACE:
			return ImGuiKey_Backspace;
		case GLFW_KEY_SPACE:
			return ImGuiKey_Space;
		case GLFW_KEY_ENTER:
			return ImGuiKey_Enter;
		case GLFW_KEY_ESCAPE:
			return ImGuiKey_Escape;
		case GLFW_KEY_APOSTROPHE:
			return ImGuiKey_Apostrophe;
		case GLFW_KEY_COMMA:
			return ImGuiKey_Comma;
		case GLFW_KEY_MINUS:
			return ImGuiKey_Minus;
		case GLFW_KEY_PERIOD:
			return ImGuiKey_Period;
		case GLFW_KEY_SLASH:
			return ImGuiKey_Slash;
		case GLFW_KEY_SEMICOLON:
			return ImGuiKey_Semicolon;
		case GLFW_KEY_EQUAL:
			return ImGuiKey_Equal;
		case GLFW_KEY_LEFT_BRACKET:
			return ImGuiKey_LeftBracket;
		case GLFW_KEY_BACKSLASH:
			return ImGuiKey_Backslash;
		case GLFW_KEY_RIGHT_BRACKET:
			return ImGuiKey_RightBracket;
		case GLFW_KEY_GRAVE_ACCENT:
			return ImGuiKey_GraveAccent;
		case GLFW_KEY_CAPS_LOCK:
			return ImGuiKey_CapsLock;
		case GLFW_KEY_SCROLL_LOCK:
			return ImGuiKey_ScrollLock;
		case GLFW_KEY_NUM_LOCK:
			return ImGuiKey_NumLock;
		case GLFW_KEY_PRINT_SCREEN:
			return ImGuiKey_PrintScreen;
		case GLFW_KEY_PAUSE:
			return ImGuiKey_Pause;
		case GLFW_KEY_KP_0:
			return ImGuiKey_Keypad0;
		case GLFW_KEY_KP_1:
			return ImGuiKey_Keypad1;
		case GLFW_KEY_KP_2:
			return ImGuiKey_Keypad2;
		case GLFW_KEY_KP_3:
			return ImGuiKey_Keypad3;
		case GLFW_KEY_KP_4:
			return ImGuiKey_Keypad4;
		case GLFW_KEY_KP_5:
			return ImGuiKey_Keypad5;
		case GLFW_KEY_KP_6:
			return ImGuiKey_Keypad6;
		case GLFW_KEY_KP_7:
			return ImGuiKey_Keypad7;
		case GLFW_KEY_KP_8:
			return ImGuiKey_Keypad8;
		case GLFW_KEY_KP_9:
			return ImGuiKey_Keypad9;
		case GLFW_KEY_KP_DECIMAL:
			return ImGuiKey_KeypadDecimal;
		case GLFW_KEY_KP_DIVIDE:
			return ImGuiKey_KeypadDivide;
		case GLFW_KEY_KP_MULTIPLY:
			return ImGuiKey_KeypadMultiply;
		case GLFW_KEY_KP_SUBTRACT:
			return ImGuiKey_KeypadSubtract;
		case GLFW_KEY_KP_ADD:
			return ImGuiKey_KeypadAdd;
		case GLFW_KEY_KP_ENTER:
			return ImGuiKey_KeypadEnter;
		case GLFW_KEY_KP_EQUAL:
			return ImGuiKey_KeypadEqual;
		case GLFW_KEY_LEFT_SHIFT:
			return ImGuiKey_LeftShift;
		case GLFW_KEY_LEFT_CONTROL:
			return ImGuiKey_LeftCtrl;
		case GLFW_KEY_LEFT_ALT:
			return ImGuiKey_LeftAlt;
		case GLFW_KEY_LEFT_SUPER:
			return ImGuiKey_LeftSuper;
		case GLFW_KEY_RIGHT_SHIFT:
			return ImGuiKey_RightShift;
		case GLFW_KEY_RIGHT_CONTROL:
			return ImGuiKey_RightCtrl;
		case GLFW_KEY_RIGHT_ALT:
			return ImGuiKey_RightAlt;
		case GLFW_KEY_RIGHT_SUPER:
			return ImGuiKey_RightSuper;
		case GLFW_KEY_MENU:
			return ImGuiKey_Menu;
		case GLFW_KEY_0:
			return ImGuiKey_0;
		case GLFW_KEY_1:
			return ImGuiKey_1;
		case GLFW_KEY_2:
			return ImGuiKey_2;
		case GLFW_KEY_3:
			return ImGuiKey_3;
		case GLFW_KEY_4:
			return ImGuiKey_4;
		case GLFW_KEY_5:
			return ImGuiKey_5;
		case GLFW_KEY_6:
			return ImGuiKey_6;
		case GLFW_KEY_7:
			return ImGuiKey_7;
		case GLFW_KEY_8:
			return ImGuiKey_8;
		case GLFW_KEY_9:
			return ImGuiKey_9;
		case GLFW_KEY_A:
			return ImGuiKey_A;
		case GLFW_KEY_B:
			return ImGuiKey_B;
		case GLFW_KEY_C:
			return ImGuiKey_C;
		case GLFW_KEY_D:
			return ImGuiKey_D;
		case GLFW_KEY_E:
			return ImGuiKey_E;
		case GLFW_KEY_F:
			return ImGuiKey_F;
		case GLFW_KEY_G:
			return ImGuiKey_G;
		case GLFW_KEY_H:
			return ImGuiKey_H;
		case GLFW_KEY_I:
			return ImGuiKey_I;
		case GLFW_KEY_J:
			return ImGuiKey_J;
		case GLFW_KEY_K:
			return ImGuiKey_K;
		case GLFW_KEY_L:
			return ImGuiKey_L;
		case GLFW_KEY_M:
			return ImGuiKey_M;
		case GLFW_KEY_N:
			return ImGuiKey_N;
		case GLFW_KEY_O:
			return ImGuiKey_O;
		case GLFW_KEY_P:
			return ImGuiKey_P;
		case GLFW_KEY_Q:
			return ImGuiKey_Q;
		case GLFW_KEY_R:
			return ImGuiKey_R;
		case GLFW_KEY_S:
			return ImGuiKey_S;
		case GLFW_KEY_T:
			return ImGuiKey_T;
		case GLFW_KEY_U:
			return ImGuiKey_U;
		case GLFW_KEY_V:
			return ImGuiKey_V;
		case GLFW_KEY_W:
			return ImGuiKey_W;
		case GLFW_KEY_X:
			return ImGuiKey_X;
		case GLFW_KEY_Y:
			return ImGuiKey_Y;
		case GLFW_KEY_Z:
			return ImGuiKey_Z;
		case GLFW_KEY_F1:
			return ImGuiKey_F1;
		case GLFW_KEY_F2:
			return ImGuiKey_F2;
		case GLFW_KEY_F3:
			return ImGuiKey_F3;
		case GLFW_KEY_F4:
			return ImGuiKey_F4;
		case GLFW_KEY_F5:
			return ImGuiKey_F5;
		case GLFW_KEY_F6:
			return ImGuiKey_F6;
		case GLFW_KEY_F7:
			return ImGuiKey_F7;
		case GLFW_KEY_F8:
			return ImGuiKey_F8;
		case GLFW_KEY_F9:
			return ImGuiKey_F9;
		case GLFW_KEY_F10:
			return ImGuiKey_F10;
		case GLFW_KEY_F11:
			return ImGuiKey_F11;
		case GLFW_KEY_F12:
			return ImGuiKey_F12;
		case GLFW_KEY_F13:
			return ImGuiKey_F13;
		case GLFW_KEY_F14:
			return ImGuiKey_F14;
		case GLFW_KEY_F15:
			return ImGuiKey_F15;
		case GLFW_KEY_F16:
			return ImGuiKey_F16;
		case GLFW_KEY_F17:
			return ImGuiKey_F17;
		case GLFW_KEY_F18:
			return ImGuiKey_F18;
		case GLFW_KEY_F19:
			return ImGuiKey_F19;
		case GLFW_KEY_F20:
			return ImGuiKey_F20;
		case GLFW_KEY_F21:
			return ImGuiKey_F21;
		case GLFW_KEY_F22:
			return ImGuiKey_F22;
		case GLFW_KEY_F23:
			return ImGuiKey_F23;
		case GLFW_KEY_F24:
			return ImGuiKey_F24;
		default:
			return ImGuiKey_None;
	}
}

// X11 does not include current pressed/released modifier key in 'mods' flags submitted by GLFW
// See https://github.com/ocornut/imgui/issues/6034 and https://github.com/glfw/glfw/issues/1630
static void ImGui_ImplGlfw_UpdateKeyModifiers(GLFWwindow *window) {
	ImGuiIO &io = ImGui::GetIO();
	io.AddKeyEvent(ImGuiMod_Ctrl, (glfwGetKey(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS) || (glfwGetKey(window, GLFW_KEY_RIGHT_CONTROL) == GLFW_PRESS));
	io.AddKeyEvent(ImGuiMod_Shift, (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS) || (glfwGetKey(window, GLFW_KEY_RIGHT_SHIFT) == GLFW_PRESS));
	io.AddKeyEvent(ImGuiMod_Alt, (glfwGetKey(window, GLFW_KEY_LEFT_ALT) == GLFW_PRESS) || (glfwGetKey(window, GLFW_KEY_RIGHT_ALT) == GLFW_PRESS));
	io.AddKeyEvent(ImGuiMod_Super, (glfwGetKey(window, GLFW_KEY_LEFT_SUPER) == GLFW_PRESS) || (glfwGetKey(window, GLFW_KEY_RIGHT_SUPER) == GLFW_PRESS));
}

static bool ImGui_ImplGlfw_ShouldChainCallback(GLFWwindow *window) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	return bd->CallbacksChainForAllWindows ? true : (window == bd->Window);
}

void ImGui_ImplGlfw_MouseButtonCallback(GLFWwindow *window, int button, int action, int mods) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	if (bd->PrevUserCallbackMousebutton != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))
		bd->PrevUserCallbackMousebutton(window, button, action, mods);

	ImGui_ImplGlfw_UpdateKeyModifiers(window);

	ImGuiIO &io = ImGui::GetIO();
	if (button >= 0 && button < ImGuiMouseButton_COUNT)
		io.AddMouseButtonEvent(button, action == GLFW_PRESS);
}

void ImGui_ImplGlfw_ScrollCallback(GLFWwindow *window, double xoffset, double yoffset) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	if (bd->PrevUserCallbackScroll != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))
		bd->PrevUserCallbackScroll(window, xoffset, yoffset);

#ifdef EMSCRIPTEN_USE_EMBEDDED_GLFW3
	// Ignore GLFW events: will be processed in ImGui_ImplEmscripten_WheelCallback().
	return;
#endif

	ImGuiIO &io = ImGui::GetIO();
	io.AddMouseWheelEvent((float)xoffset, (float)yoffset);
}

static int ImGui_ImplGlfw_TranslateUntranslatedKey(int key, int scancode) {
#if GLFW_HAS_GETKEYNAME && !defined(EMSCRIPTEN_USE_EMBEDDED_GLFW3)
	// GLFW 3.1+ attempts to "untranslate" keys, which goes the opposite of what every other framework does, making using lettered shortcuts difficult.
	// (It had reasons to do so: namely GLFW is/was more likely to be used for WASD-type game controls rather than lettered shortcuts, but IHMO the 3.1 change could have been done differently)
	// See https://github.com/glfw/glfw/issues/1502 for details.
	// Adding a workaround to undo this (so our keys are translated->untranslated->translated, likely a lossy process).
	// This won't cover edge cases but this is at least going to cover common cases.
	if (key >= GLFW_KEY_KP_0 && key <= GLFW_KEY_KP_EQUAL)
		return key;
	GLFWerrorfun prev_error_callback = glfwSetErrorCallback(nullptr);
	const char *key_name = glfwGetKeyName(key, scancode);
	glfwSetErrorCallback(prev_error_callback);
#if GLFW_HAS_GETERROR && !defined(EMSCRIPTEN_USE_EMBEDDED_GLFW3) // Eat errors (see #5908)
	(void)glfwGetError(nullptr);
#endif
	if (key_name && key_name[0] != 0 && key_name[1] == 0) {
		const char char_names[] = "`-=[]\\,;\'./";
		const int char_keys[] = { GLFW_KEY_GRAVE_ACCENT, GLFW_KEY_MINUS, GLFW_KEY_EQUAL, GLFW_KEY_LEFT_BRACKET, GLFW_KEY_RIGHT_BRACKET, GLFW_KEY_BACKSLASH, GLFW_KEY_COMMA, GLFW_KEY_SEMICOLON, GLFW_KEY_APOSTROPHE, GLFW_KEY_PERIOD, GLFW_KEY_SLASH, 0 };
		IM_ASSERT(IM_ARRAYSIZE(char_names) == IM_ARRAYSIZE(char_keys));
		if (key_name[0] >= '0' && key_name[0] <= '9') {
			key = GLFW_KEY_0 + (key_name[0] - '0');
		} else if (key_name[0] >= 'A' && key_name[0] <= 'Z') {
			key = GLFW_KEY_A + (key_name[0] - 'A');
		} else if (key_name[0] >= 'a' && key_name[0] <= 'z') {
			key = GLFW_KEY_A + (key_name[0] - 'a');
		} else if (const char *p = strchr(char_names, key_name[0])) {
			key = char_keys[p - char_names];
		}
	}
	// if (action == GLFW_PRESS) printf("key %d scancode %d name '%s'\n", key, scancode, key_name);
#else
	IM_UNUSED(scancode);
#endif
	return key;
}

void ImGui_ImplGlfw_KeyCallback(GLFWwindow *window, int keycode, int scancode, int action, int mods) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	if (bd->PrevUserCallbackKey != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))
		bd->PrevUserCallbackKey(window, keycode, scancode, action, mods);

	if (action != GLFW_PRESS && action != GLFW_RELEASE)
		return;

	ImGui_ImplGlfw_UpdateKeyModifiers(window);

	keycode = ImGui_ImplGlfw_TranslateUntranslatedKey(keycode, scancode);

	ImGuiIO &io = ImGui::GetIO();
	ImGuiKey imgui_key = ImGui_ImplGlfw_KeyToImGuiKey(keycode);
	io.AddKeyEvent(imgui_key, (action == GLFW_PRESS));
	io.SetKeyEventNativeData(imgui_key, keycode, scancode); // To support legacy indexing (<1.87 user code)
}

void ImGui_ImplGlfw_WindowFocusCallback(GLFWwindow *window, int focused) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	if (bd->PrevUserCallbackWindowFocus != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))
		bd->PrevUserCallbackWindowFocus(window, focused);

	ImGuiIO &io = ImGui::GetIO();
	io.AddFocusEvent(focused != 0);
}

void ImGui_ImplGlfw_CursorPosCallback(GLFWwindow *window, double x, double y) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	if (bd->PrevUserCallbackCursorPos != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))
		bd->PrevUserCallbackCursorPos(window, x, y);

	ImGuiIO &io = ImGui::GetIO();
	io.AddMousePosEvent((float)x, (float)y);
	bd->LastValidMousePos = ImVec2((float)x, (float)y);
}

// Workaround: X11 seems to send spurious Leave/Enter events which would make us lose our position,
// so we back it up and restore on Leave/Enter (see https://github.com/ocornut/imgui/issues/4984)
void ImGui_ImplGlfw_CursorEnterCallback(GLFWwindow *window, int entered) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	if (bd->PrevUserCallbackCursorEnter != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))
		bd->PrevUserCallbackCursorEnter(window, entered);

	ImGuiIO &io = ImGui::GetIO();
	if (entered) {
		bd->MouseWindow = window;
		io.AddMousePosEvent(bd->LastValidMousePos.x, bd->LastValidMousePos.y);
	} else if (!entered && bd->MouseWindow == window) {
		bd->LastValidMousePos = io.MousePos;
		bd->MouseWindow = nullptr;
		io.AddMousePosEvent(-FLT_MAX, -FLT_MAX);
	}
}

void ImGui_ImplGlfw_CharCallback(GLFWwindow *window, unsigned int c) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	if (bd->PrevUserCallbackChar != nullptr && ImGui_ImplGlfw_ShouldChainCallback(window))
		bd->PrevUserCallbackChar(window, c);

	ImGuiIO &io = ImGui::GetIO();
	io.AddInputCharacter(c);
}

void ImGui_ImplGlfw_MonitorCallback(GLFWmonitor *, int) {
	// Unused in 'master' branch but 'docking' branch will use this, so we declare it ahead of it so if you have to install callbacks you can install this one too.
}

#ifdef EMSCRIPTEN_USE_EMBEDDED_GLFW3
static EM_BOOL ImGui_ImplEmscripten_WheelCallback(int, const EmscriptenWheelEvent *ev, void *) {
	// Mimic Emscripten_HandleWheel() in SDL.
	// Corresponding equivalent in GLFW JS emulation layer has incorrect quantizing preventing small values. See #6096
	float multiplier = 0.0f;
	if (ev->deltaMode == DOM_DELTA_PIXEL) {
		multiplier = 1.0f / 100.0f;
	} // 100 pixels make up a step.
	else if (ev->deltaMode == DOM_DELTA_LINE) {
		multiplier = 1.0f / 3.0f;
	} // 3 lines make up a step.
	else if (ev->deltaMode == DOM_DELTA_PAGE) {
		multiplier = 80.0f;
	} // A page makes up 80 steps.
	float wheel_x = ev->deltaX * -multiplier;
	float wheel_y = ev->deltaY * -multiplier;
	ImGuiIO &io = ImGui::GetIO();
	io.AddMouseWheelEvent(wheel_x, wheel_y);
	//IMGUI_DEBUG_LOG("[Emsc] mode %d dx: %.2f, dy: %.2f, dz: %.2f --> feed %.2f %.2f\n", (int)ev->deltaMode, ev->deltaX, ev->deltaY, ev->deltaZ, wheel_x, wheel_y);
	return EM_TRUE;
}
#endif

#ifdef _WIN32
// GLFW doesn't allow to distinguish Mouse vs TouchScreen vs Pen.
// Add support for Win32 (based on imgui_impl_win32), because we rely on _TouchScreen info to trickle inputs differently.
static ImGuiMouseSource GetMouseSourceFromMessageExtraInfo() {
	LPARAM extra_info = ::GetMessageExtraInfo();
	if ((extra_info & 0xFFFFFF80) == 0xFF515700)
		return ImGuiMouseSource_Pen;
	if ((extra_info & 0xFFFFFF80) == 0xFF515780)
		return ImGuiMouseSource_TouchScreen;
	return ImGuiMouseSource_Mouse;
}
static LRESULT CALLBACK ImGui_ImplGlfw_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	switch (msg) {
		case WM_MOUSEMOVE:
		case WM_NCMOUSEMOVE:
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
		case WM_RBUTTONUP:
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
		case WM_MBUTTONUP:
		case WM_XBUTTONDOWN:
		case WM_XBUTTONDBLCLK:
		case WM_XBUTTONUP:
			ImGui::GetIO().AddMouseSourceEvent(GetMouseSourceFromMessageExtraInfo());
			break;
	}
	return ::CallWindowProcW(bd->PrevWndProc, hWnd, msg, wParam, lParam);
}
#endif

void ImGui_ImplGlfw_InstallCallbacks(GLFWwindow *window) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	IM_ASSERT(bd->InstalledCallbacks == false && "Callbacks already installed!");
	IM_ASSERT(bd->Window == window);

	bd->PrevUserCallbackWindowFocus = glfwSetWindowFocusCallback(window, ImGui_ImplGlfw_WindowFocusCallback);
	bd->PrevUserCallbackCursorEnter = glfwSetCursorEnterCallback(window, ImGui_ImplGlfw_CursorEnterCallback);
	bd->PrevUserCallbackCursorPos = glfwSetCursorPosCallback(window, ImGui_ImplGlfw_CursorPosCallback);
	bd->PrevUserCallbackMousebutton = glfwSetMouseButtonCallback(window, ImGui_ImplGlfw_MouseButtonCallback);
	bd->PrevUserCallbackScroll = glfwSetScrollCallback(window, ImGui_ImplGlfw_ScrollCallback);
	bd->PrevUserCallbackKey = glfwSetKeyCallback(window, ImGui_ImplGlfw_KeyCallback);
	bd->PrevUserCallbackChar = glfwSetCharCallback(window, ImGui_ImplGlfw_CharCallback);
	bd->PrevUserCallbackMonitor = glfwSetMonitorCallback(ImGui_ImplGlfw_MonitorCallback);
	bd->InstalledCallbacks = true;
}

void ImGui_ImplGlfw_RestoreCallbacks(GLFWwindow *window) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	IM_ASSERT(bd->InstalledCallbacks == true && "Callbacks not installed!");
	IM_ASSERT(bd->Window == window);

	glfwSetWindowFocusCallback(window, bd->PrevUserCallbackWindowFocus);
	glfwSetCursorEnterCallback(window, bd->PrevUserCallbackCursorEnter);
	glfwSetCursorPosCallback(window, bd->PrevUserCallbackCursorPos);
	glfwSetMouseButtonCallback(window, bd->PrevUserCallbackMousebutton);
	glfwSetScrollCallback(window, bd->PrevUserCallbackScroll);
	glfwSetKeyCallback(window, bd->PrevUserCallbackKey);
	glfwSetCharCallback(window, bd->PrevUserCallbackChar);
	glfwSetMonitorCallback(bd->PrevUserCallbackMonitor);
	bd->InstalledCallbacks = false;
	bd->PrevUserCallbackWindowFocus = nullptr;
	bd->PrevUserCallbackCursorEnter = nullptr;
	bd->PrevUserCallbackCursorPos = nullptr;
	bd->PrevUserCallbackMousebutton = nullptr;
	bd->PrevUserCallbackScroll = nullptr;
	bd->PrevUserCallbackKey = nullptr;
	bd->PrevUserCallbackChar = nullptr;
	bd->PrevUserCallbackMonitor = nullptr;
}

// Set to 'true' to enable chaining installed callbacks for all windows (including secondary viewports created by backends or by user.
// This is 'false' by default meaning we only chain callbacks for the main viewport.
// We cannot set this to 'true' by default because user callbacks code may be not testing the 'window' parameter of their callback.
// If you set this to 'true' your user callback code will need to make sure you are testing the 'window' parameter.
void ImGui_ImplGlfw_SetCallbacksChainForAllWindows(bool chain_for_all_windows) {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	bd->CallbacksChainForAllWindows = chain_for_all_windows;
}

#ifdef __EMSCRIPTEN__
#if EMSCRIPTEN_USE_PORT_CONTRIB_GLFW3 >= 3'4'0'20240817
void ImGui_ImplGlfw_EmscriptenOpenURL(const char *url) {
	if (url)
		emscripten::glfw3::OpenURL(url);
}
#else
EM_JS(void, ImGui_ImplGlfw_EmscriptenOpenURL, (const char *url), { url = url ? UTF8ToString(url) : null; if (url) window.open(url, '_blank'); });
#endif
#endif

static bool ImGui_ImplGlfw_Init(GLFWwindow *window, bool install_callbacks, GlfwClientApi client_api) {
	ImGuiIO &io = ImGui::GetIO();
	IMGUI_CHECKVERSION();
	IM_ASSERT(io.BackendPlatformUserData == nullptr && "Already initialized a platform backend!");
	//printf("GLFW_VERSION: %d.%d.%d (%d)", GLFW_VERSION_MAJOR, GLFW_VERSION_MINOR, GLFW_VERSION_REVISION, GLFW_VERSION_COMBINED);

	// Setup backend capabilities flags
	ImGui_ImplGlfw_Data *bd = IM_NEW(ImGui_ImplGlfw_Data)();
	io.BackendPlatformUserData = (void *)bd;
	io.BackendPlatformName = "imgui_impl_glfw";
	io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors; // We can honor GetMouseCursor() values (optional)
	io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos; // We can honor io.WantSetMousePos requests (optional, rarely used)

	bd->Window = window;
	bd->Time = 0.0;

	ImGuiPlatformIO &platform_io = ImGui::GetPlatformIO();
	platform_io.Platform_SetClipboardTextFn = [](ImGuiContext *, const char *text) { glfwSetClipboardString(NULL, text); };
	platform_io.Platform_GetClipboardTextFn = [](ImGuiContext *) { return glfwGetClipboardString(NULL); };
#ifdef __EMSCRIPTEN__
	platform_io.Platform_OpenInShellFn = [](ImGuiContext *, const char *url) { ImGui_ImplGlfw_EmscriptenOpenURL(url); return true; };
#endif

	// Create mouse cursors
	// (By design, on X11 cursors are user configurable and some cursors may be missing. When a cursor doesn't exist,
	// GLFW will emit an error which will often be printed by the app, so we temporarily disable error reporting.
	// Missing cursors will return nullptr and our _UpdateMouseCursor() function will use the Arrow cursor instead.)
	GLFWerrorfun prev_error_callback = glfwSetErrorCallback(nullptr);
	bd->MouseCursors[ImGuiMouseCursor_Arrow] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_TextInput] = glfwCreateStandardCursor(GLFW_IBEAM_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_ResizeNS] = glfwCreateStandardCursor(GLFW_VRESIZE_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_ResizeEW] = glfwCreateStandardCursor(GLFW_HRESIZE_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_Hand] = glfwCreateStandardCursor(GLFW_HAND_CURSOR);
#if GLFW_HAS_NEW_CURSORS
	bd->MouseCursors[ImGuiMouseCursor_ResizeAll] = glfwCreateStandardCursor(GLFW_RESIZE_ALL_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_ResizeNESW] = glfwCreateStandardCursor(GLFW_RESIZE_NESW_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_ResizeNWSE] = glfwCreateStandardCursor(GLFW_RESIZE_NWSE_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_NotAllowed] = glfwCreateStandardCursor(GLFW_NOT_ALLOWED_CURSOR);
#else
	bd->MouseCursors[ImGuiMouseCursor_ResizeAll] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_ResizeNESW] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_ResizeNWSE] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
	bd->MouseCursors[ImGuiMouseCursor_NotAllowed] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);
#endif
	glfwSetErrorCallback(prev_error_callback);
#if GLFW_HAS_GETERROR && !defined(__EMSCRIPTEN__) // Eat errors (see #5908)
	(void)glfwGetError(nullptr);
#endif

	// Chain GLFW callbacks: our callbacks will call the user's previously installed callbacks, if any.
	if (install_callbacks)
		ImGui_ImplGlfw_InstallCallbacks(window);

	// Set platform dependent data in viewport
	ImGuiViewport *main_viewport = ImGui::GetMainViewport();
	main_viewport->PlatformHandle = (void *)bd->Window;
#ifdef _WIN32
	//main_viewport->PlatformHandleRaw = glfwGetWin32Window(bd->Window);
	main_viewport->PlatformHandleRaw = glfwGetNativeWindowHandleAsVPTR(bd->Window);
#elif defined(__APPLE__)
	//main_viewport->PlatformHandleRaw = (void*)glfwGetCocoaWindow(bd->Window);
	main_viewport->PlatformHandleRaw = glfwGetNativeWindowHandleAsVPTR(bd->Window);
#else
	IM_UNUSED(main_viewport);
#endif

	// Windows: register a WndProc hook so we can intercept some messages.
#ifdef _WIN32
	bd->PrevWndProc = (WNDPROC)::GetWindowLongPtrW((HWND)main_viewport->PlatformHandleRaw, GWLP_WNDPROC);
	IM_ASSERT(bd->PrevWndProc != nullptr);
	::SetWindowLongPtrW((HWND)main_viewport->PlatformHandleRaw, GWLP_WNDPROC, (LONG_PTR)ImGui_ImplGlfw_WndProc);
#endif

	bd->ClientApi = client_api;
	return true;
}

bool ImGui_ImplGlfw_InitForOpenGL(GLFWwindow *window, bool install_callbacks) {
	return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_OpenGL);
}

bool ImGui_ImplGlfw_InitForVulkan(GLFWwindow *window, bool install_callbacks) {
	return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_Vulkan);
}

bool ImGui_ImplGlfw_InitForOther(GLFWwindow *window, bool install_callbacks) {
	return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_Unknown);
}

void ImGui_ImplGlfw_Shutdown() {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	IM_ASSERT(bd != nullptr && "No platform backend to shutdown, or already shutdown?");
	ImGuiIO &io = ImGui::GetIO();

	if (bd->InstalledCallbacks)
		ImGui_ImplGlfw_RestoreCallbacks(bd->Window);
#ifdef EMSCRIPTEN_USE_EMBEDDED_GLFW3
	if (bd->CanvasSelector)
		emscripten_set_wheel_callback(bd->CanvasSelector, nullptr, false, nullptr);
#endif

	for (ImGuiMouseCursor cursor_n = 0; cursor_n < ImGuiMouseCursor_COUNT; cursor_n++)
		glfwDestroyCursor(bd->MouseCursors[cursor_n]);

	// Windows: restore our WndProc hook
#ifdef _WIN32
	ImGuiViewport *main_viewport = ImGui::GetMainViewport();
	::SetWindowLongPtrW((HWND)main_viewport->PlatformHandleRaw, GWLP_WNDPROC, (LONG_PTR)bd->PrevWndProc);
	bd->PrevWndProc = nullptr;
#endif

	io.BackendPlatformName = nullptr;
	io.BackendPlatformUserData = nullptr;
	io.BackendFlags &= ~(ImGuiBackendFlags_HasMouseCursors | ImGuiBackendFlags_HasSetMousePos | ImGuiBackendFlags_HasGamepad);
	IM_DELETE(bd);
}

static void ImGui_ImplGlfw_UpdateMouseData() {
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	ImGuiIO &io = ImGui::GetIO();

	// (those braces are here to reduce diff with multi-viewports support in 'docking' branch)
	{
		GLFWwindow *window = bd->Window;
#ifdef EMSCRIPTEN_USE_EMBEDDED_GLFW3
		const bool is_window_focused = true;
#else
		const bool is_window_focused = glfwGetWindowAttrib(window, GLFW_FOCUSED) != 0;
#endif
		if (is_window_focused) {
			// (Optional) Set OS mouse position from Dear ImGui if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
			if (io.WantSetMousePos)
				glfwSetCursorPos(window, (double)io.MousePos.x, (double)io.MousePos.y);

			// (Optional) Fallback to provide mouse position when focused (ImGui_ImplGlfw_CursorPosCallback already provides this when hovered or captured)
			if (bd->MouseWindow == nullptr) {
				double mouse_x, mouse_y;
				glfwGetCursorPos(window, &mouse_x, &mouse_y);
				bd->LastValidMousePos = ImVec2((float)mouse_x, (float)mouse_y);
				io.AddMousePosEvent((float)mouse_x, (float)mouse_y);
			}
		}
	}
}

static void ImGui_ImplGlfw_UpdateMouseCursor() {
	ImGuiIO &io = ImGui::GetIO();
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	if ((io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange) || glfwGetInputMode(bd->Window, GLFW_CURSOR) == GLFW_CURSOR_DISABLED)
		return;

	ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
	// (those braces are here to reduce diff with multi-viewports support in 'docking' branch)
	{
		GLFWwindow *window = bd->Window;
		if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor) {
			// Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
			glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
		} else {
			// Show OS mouse cursor
			// FIXME-PLATFORM: Unfocused windows seems to fail changing the mouse cursor with GLFW 3.2, but 3.3 works here.
			glfwSetCursor(window, bd->MouseCursors[imgui_cursor] ? bd->MouseCursors[imgui_cursor] : bd->MouseCursors[ImGuiMouseCursor_Arrow]);
			glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
		}
	}
}

// Update gamepad inputs
static inline float Saturate(float v) {
	return v < 0.0f ? 0.0f : v > 1.0f ? 1.0f
									  : v;
}
static void ImGui_ImplGlfw_UpdateGamepads() {
	ImGuiIO &io = ImGui::GetIO();
	if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0) // FIXME: Technically feeding gamepad shouldn't depend on this now that they are regular inputs.
		return;

	io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;
#if GLFW_HAS_GAMEPAD_API && !defined(EMSCRIPTEN_USE_EMBEDDED_GLFW3)
	GLFWgamepadstate gamepad;
	if (!glfwGetGamepadState(GLFW_JOYSTICK_1, &gamepad))
		return;
#define MAP_BUTTON(KEY_NO, BUTTON_NO, _UNUSED)                   \
	do {                                                         \
		io.AddKeyEvent(KEY_NO, gamepad.buttons[BUTTON_NO] != 0); \
	} while (0)
#define MAP_ANALOG(KEY_NO, AXIS_NO, _UNUSED, V0, V1)          \
	do {                                                      \
		float v = gamepad.axes[AXIS_NO];                      \
		v = (v - V0) / (V1 - V0);                             \
		io.AddKeyAnalogEvent(KEY_NO, v > 0.10f, Saturate(v)); \
	} while (0)
#else
	int axes_count = 0, buttons_count = 0;
	const float *axes = glfwGetJoystickAxes(GLFW_JOYSTICK_1, &axes_count);
	const unsigned char *buttons = glfwGetJoystickButtons(GLFW_JOYSTICK_1, &buttons_count);
	if (axes_count == 0 || buttons_count == 0)
		return;
#define MAP_BUTTON(KEY_NO, _UNUSED, BUTTON_NO)                                                   \
	do {                                                                                         \
		io.AddKeyEvent(KEY_NO, (buttons_count > BUTTON_NO && buttons[BUTTON_NO] == GLFW_PRESS)); \
	} while (0)
#define MAP_ANALOG(KEY_NO, _UNUSED, AXIS_NO, V0, V1)           \
	do {                                                       \
		float v = (axes_count > AXIS_NO) ? axes[AXIS_NO] : V0; \
		v = (v - V0) / (V1 - V0);                              \
		io.AddKeyAnalogEvent(KEY_NO, v > 0.10f, Saturate(v));  \
	} while (0)
#endif
	io.BackendFlags |= ImGuiBackendFlags_HasGamepad;
	MAP_BUTTON(ImGuiKey_GamepadStart, GLFW_GAMEPAD_BUTTON_START, 7);
	MAP_BUTTON(ImGuiKey_GamepadBack, GLFW_GAMEPAD_BUTTON_BACK, 6);
	MAP_BUTTON(ImGuiKey_GamepadFaceLeft, GLFW_GAMEPAD_BUTTON_X, 2); // Xbox X, PS Square
	MAP_BUTTON(ImGuiKey_GamepadFaceRight, GLFW_GAMEPAD_BUTTON_B, 1); // Xbox B, PS Circle
	MAP_BUTTON(ImGuiKey_GamepadFaceUp, GLFW_GAMEPAD_BUTTON_Y, 3); // Xbox Y, PS Triangle
	MAP_BUTTON(ImGuiKey_GamepadFaceDown, GLFW_GAMEPAD_BUTTON_A, 0); // Xbox A, PS Cross
	MAP_BUTTON(ImGuiKey_GamepadDpadLeft, GLFW_GAMEPAD_BUTTON_DPAD_LEFT, 13);
	MAP_BUTTON(ImGuiKey_GamepadDpadRight, GLFW_GAMEPAD_BUTTON_DPAD_RIGHT, 11);
	MAP_BUTTON(ImGuiKey_GamepadDpadUp, GLFW_GAMEPAD_BUTTON_DPAD_UP, 10);
	MAP_BUTTON(ImGuiKey_GamepadDpadDown, GLFW_GAMEPAD_BUTTON_DPAD_DOWN, 12);
	MAP_BUTTON(ImGuiKey_GamepadL1, GLFW_GAMEPAD_BUTTON_LEFT_BUMPER, 4);
	MAP_BUTTON(ImGuiKey_GamepadR1, GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER, 5);
	MAP_ANALOG(ImGuiKey_GamepadL2, GLFW_GAMEPAD_AXIS_LEFT_TRIGGER, 4, -0.75f, +1.0f);
	MAP_ANALOG(ImGuiKey_GamepadR2, GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER, 5, -0.75f, +1.0f);
	MAP_BUTTON(ImGuiKey_GamepadL3, GLFW_GAMEPAD_BUTTON_LEFT_THUMB, 8);
	MAP_BUTTON(ImGuiKey_GamepadR3, GLFW_GAMEPAD_BUTTON_RIGHT_THUMB, 9);
	MAP_ANALOG(ImGuiKey_GamepadLStickLeft, GLFW_GAMEPAD_AXIS_LEFT_X, 0, -0.25f, -1.0f);
	MAP_ANALOG(ImGuiKey_GamepadLStickRight, GLFW_GAMEPAD_AXIS_LEFT_X, 0, +0.25f, +1.0f);
	MAP_ANALOG(ImGuiKey_GamepadLStickUp, GLFW_GAMEPAD_AXIS_LEFT_Y, 1, -0.25f, -1.0f);
	MAP_ANALOG(ImGuiKey_GamepadLStickDown, GLFW_GAMEPAD_AXIS_LEFT_Y, 1, +0.25f, +1.0f);
	MAP_ANALOG(ImGuiKey_GamepadRStickLeft, GLFW_GAMEPAD_AXIS_RIGHT_X, 2, -0.25f, -1.0f);
	MAP_ANALOG(ImGuiKey_GamepadRStickRight, GLFW_GAMEPAD_AXIS_RIGHT_X, 2, +0.25f, +1.0f);
	MAP_ANALOG(ImGuiKey_GamepadRStickUp, GLFW_GAMEPAD_AXIS_RIGHT_Y, 3, -0.25f, -1.0f);
	MAP_ANALOG(ImGuiKey_GamepadRStickDown, GLFW_GAMEPAD_AXIS_RIGHT_Y, 3, +0.25f, +1.0f);
#undef MAP_BUTTON
#undef MAP_ANALOG
}

void ImGui_ImplGlfw_NewFrame() {
	ImGuiIO &io = ImGui::GetIO();
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	IM_ASSERT(bd != nullptr && "Context or backend not initialized! Did you call ImGui_ImplGlfw_InitForXXX()?");

	// Setup display size (every frame to accommodate for window resizing)
	int w, h;
	int display_w, display_h;
	glfwGetWindowSize(bd->Window, &w, &h);
	glfwGetFramebufferSize(bd->Window, &display_w, &display_h);
	io.DisplaySize = ImVec2((float)w, (float)h);
	if (w > 0 && h > 0)
		io.DisplayFramebufferScale = ImVec2((float)display_w / (float)w, (float)display_h / (float)h);

	// Setup time step
	// (Accept glfwGetTime() not returning a monotonically increasing value. Seems to happens on disconnecting peripherals and probably on VMs and Emscripten, see #6491, #6189, #6114, #3644)
	double current_time = glfwGetTime();
	if (current_time <= bd->Time)
		current_time = bd->Time + 0.00001f;
	io.DeltaTime = bd->Time > 0.0 ? (float)(current_time - bd->Time) : (float)(1.0f / 60.0f);
	bd->Time = current_time;

	ImGui_ImplGlfw_UpdateMouseData();
	ImGui_ImplGlfw_UpdateMouseCursor();

	// Update game controllers (if enabled and available)
	ImGui_ImplGlfw_UpdateGamepads();
}

// GLFW doesn't provide a portable sleep function
void ImGui_ImplGlfw_Sleep(int milliseconds) {
#ifdef _WIN32
	::Sleep(milliseconds);
#else
	usleep(milliseconds * 1000);
#endif
}

#ifdef EMSCRIPTEN_USE_EMBEDDED_GLFW3
static EM_BOOL ImGui_ImplGlfw_OnCanvasSizeChange(int event_type, const EmscriptenUiEvent *event, void *user_data) {
	ImGui_ImplGlfw_Data *bd = (ImGui_ImplGlfw_Data *)user_data;
	double canvas_width, canvas_height;
	emscripten_get_element_css_size(bd->CanvasSelector, &canvas_width, &canvas_height);
	glfwSetWindowSize(bd->Window, (int)canvas_width, (int)canvas_height);
	return true;
}

static EM_BOOL ImGui_ImplEmscripten_FullscreenChangeCallback(int event_type, const EmscriptenFullscreenChangeEvent *event, void *user_data) {
	ImGui_ImplGlfw_Data *bd = (ImGui_ImplGlfw_Data *)user_data;
	double canvas_width, canvas_height;
	emscripten_get_element_css_size(bd->CanvasSelector, &canvas_width, &canvas_height);
	glfwSetWindowSize(bd->Window, (int)canvas_width, (int)canvas_height);
	return true;
}

// 'canvas_selector' is a CSS selector. The event listener is applied to the first element that matches the query.
// STRING MUST PERSIST FOR THE APPLICATION DURATION. PLEASE USE A STRING LITERAL OR ENSURE POINTER WILL STAY VALID.
void ImGui_ImplGlfw_InstallEmscriptenCallbacks(GLFWwindow *, const char *canvas_selector) {
	IM_ASSERT(canvas_selector != nullptr);
	ImGui_ImplGlfw_Data *bd = ImGui_ImplGlfw_GetBackendData();
	IM_ASSERT(bd != nullptr && "Context or backend not initialized! Did you call ImGui_ImplGlfw_InitForXXX()?");

	bd->CanvasSelector = canvas_selector;
	emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, bd, false, ImGui_ImplGlfw_OnCanvasSizeChange);
	emscripten_set_fullscreenchange_callback(EMSCRIPTEN_EVENT_TARGET_DOCUMENT, bd, false, ImGui_ImplEmscripten_FullscreenChangeCallback);

	// Change the size of the GLFW window according to the size of the canvas
	ImGui_ImplGlfw_OnCanvasSizeChange(EMSCRIPTEN_EVENT_RESIZE, {}, bd);

	// Register Emscripten Wheel callback to workaround issue in Emscripten GLFW Emulation (#6096)
	// We intentionally do not check 'if (install_callbacks)' here, as some users may set it to false and call GLFW callback themselves.
	// FIXME: May break chaining in case user registered their own Emscripten callback?
	emscripten_set_wheel_callback(bd->CanvasSelector, nullptr, false, ImGui_ImplEmscripten_WheelCallback);
}
#elif defined(EMSCRIPTEN_USE_PORT_CONTRIB_GLFW3)
// When using --use-port=contrib.glfw3 for the GLFW implementation, you can override the behavior of this call
// by invoking emscripten_glfw_make_canvas_resizable afterward.
// See https://github.com/pongasoft/emscripten-glfw/blob/master/docs/Usage.md#how-to-make-the-canvas-resizable-by-the-user for an explanation
void ImGui_ImplGlfw_InstallEmscriptenCallbacks(GLFWwindow *window, const char *canvas_selector) {
	GLFWwindow *w = (GLFWwindow *)(EM_ASM_INT({ return Module.glfwGetWindow(UTF8ToString($0)); }, canvas_selector));
	IM_ASSERT(window == w); // Sanity check
	IM_UNUSED(w);
	emscripten_glfw_make_canvas_resizable(window, "window", nullptr);
}
#endif // #ifdef EMSCRIPTEN_USE_PORT_CONTRIB_GLFW3

//-----------------------------------------------------------------------------

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#endif // #ifndef IMGUI_DISABLE
#line 0

#line 1 "sfw/render_gui/imgui_impl_opengl3.h"
// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline
// - Desktop GL: 2.x 3.x 4.x
// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)
// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!
//  [x] Renderer: Large meshes support (64k+ vertices) with 16-bit indices (Desktop OpenGL only).

// About WebGL/ES:
// - You need to '#define IMGUI_IMPL_OPENGL_ES2' or '#define IMGUI_IMPL_OPENGL_ES3' to use WebGL or OpenGL ES.
// - This is done automatically on iOS, Android and Emscripten targets.
// - For other targets, the define needs to be visible from the imgui_impl_opengl3.cpp compilation unit. If unsure, define globally or in imconfig.h.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// Learn about Dear ImGui:
// - FAQ                  https://dearimgui.com/faq
// - Getting Started      https://dearimgui.com/getting-started
// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
// - Introduction, links and more at the top of imgui.cpp

// About GLSL version:
//  The 'glsl_version' initialization parameter should be nullptr (default) or a "#version XXX" string.
//  On computer platform the GLSL version default to "#version 130". On OpenGL ES 3 platform it defaults to "#version 300 es"
//  Only override if your GL version doesn't handle this GLSL version. See GLSL version table at the top of imgui_impl_opengl3.cpp.

#ifndef IMGUI_DISABLE

// Follow "Getting Started" link and check examples/ folder to learn about using backends!
IMGUI_IMPL_API bool ImGui_ImplOpenGL3_Init(const char *glsl_version = nullptr);
IMGUI_IMPL_API void ImGui_ImplOpenGL3_Shutdown();
IMGUI_IMPL_API void ImGui_ImplOpenGL3_NewFrame();
IMGUI_IMPL_API void ImGui_ImplOpenGL3_RenderDrawData(ImDrawData *draw_data);

// (Optional) Called by Init/NewFrame/Shutdown
IMGUI_IMPL_API bool ImGui_ImplOpenGL3_CreateFontsTexture();
IMGUI_IMPL_API void ImGui_ImplOpenGL3_DestroyFontsTexture();
IMGUI_IMPL_API bool ImGui_ImplOpenGL3_CreateDeviceObjects();
IMGUI_IMPL_API void ImGui_ImplOpenGL3_DestroyDeviceObjects();

// Configuration flags to add in your imconfig file:
//#define IMGUI_IMPL_OPENGL_ES2     // Enable ES 2 (Auto-detected on Emscripten)
//#define IMGUI_IMPL_OPENGL_ES3     // Enable ES 3 (Auto-detected on iOS/Android)

// You can explicitly select GLES2 or GLES3 API by using one of the '#define IMGUI_IMPL_OPENGL_LOADER_XXX' in imconfig.h or compiler command-line.
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3)

// Try to detect GLES on matching platforms
#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif
#if (defined(__APPLE__) && (TARGET_OS_IOS || TARGET_OS_TV)) || (defined(__ANDROID__))
#define IMGUI_IMPL_OPENGL_ES3 // iOS, Android  -> GL ES 3, "#version 300 es"
#elif defined(__EMSCRIPTEN__) || defined(__amigaos4__)
#define IMGUI_IMPL_OPENGL_ES2 // Emscripten    -> GL ES 2, "#version 100"
#else
// Otherwise imgui_impl_opengl3_loader.h will be used.
#endif

#endif

#endif // #ifndef IMGUI_DISABLE
#line 0

#line 1 "sfw/render_gui/imgui.cpp"
// dear imgui, v1.91.1
// (main code and documentation)

// Help:
// - See links below.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
// - Read top of imgui.cpp for more details, links and comments.

// Resources:
// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)
// - Homepage ................... https://github.com/ocornut/imgui
// - Releases & changelog ....... https://github.com/ocornut/imgui/releases
// - Gallery .................... https://github.com/ocornut/imgui/issues/7503 (please post your screenshots/video there!)
// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)
//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)
//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)
//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)
//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary
//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools
//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui
// - Issues & support ........... https://github.com/ocornut/imgui/issues
// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)

// For first-time users having issues compiling/linking/running/loading fonts:
// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.
// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.

// Copyright (c) 2014-2024 Omar Cornut
// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but needs your support to sustain development and maintenance.
// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.
// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding
// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- CONTROLS GUIDE
- PROGRAMMER GUIDE
  - READ FIRST
  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
  - HOW A SIMPLE APPLICATION MAY LOOK LIKE
  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ)
  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] INCLUDES
// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
// [SECTION] MISC HELPERS/UTILITIES (File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
// [SECTION] ImGuiListClipper
// [SECTION] STYLING
// [SECTION] RENDER HELPERS
// [SECTION] INITIALIZATION, SHUTDOWN
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] ID STACK
// [SECTION] INPUTS
// [SECTION] ERROR CHECKING
// [SECTION] ITEM SUBMISSION
// [SECTION] LAYOUT
// [SECTION] SCROLLING
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] LOCALIZATION
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUGGER WINDOW
// [SECTION] DEBUG LOG WINDOW
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Minimize state synchronization.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption.

 Designed primarily for developers and content-creators, not the typical end-user!
 Some of the current weaknesses (which we aim to address in the future) includes:

 - Doesn't look fancy.
 - Limited layout features, intricate layouts are typically crafted in code.


 CONTROLS GUIDE
 ==============

 - MOUSE CONTROLS
   - Mouse wheel:                   Scroll vertically.
   - SHIFT+Mouse wheel:             Scroll horizontally.
   - Click [X]:                     Close a window, available when 'bool* p_open' is passed to ImGui::Begin().
   - Click ^, Double-Click title:   Collapse window.
   - Drag on corner/border:         Resize window (double-click to auto fit window to its contents).
   - Drag on any empty space:       Move window (unless io.ConfigWindowsMoveFromTitleBarOnly = true).
   - Left-click outside popup:      Close popup stack (right-click over underlying popup: Partially close popup stack).

 - TEXT EDITOR
   - Hold SHIFT or Drag Mouse:      Select text.
   - CTRL+Left/Right:               Word jump.
   - CTRL+Shift+Left/Right:         Select words.
   - CTRL+A or Double-Click:        Select All.
   - CTRL+X, CTRL+C, CTRL+V:        Use OS clipboard.
   - CTRL+Z, CTRL+Y:                Undo, Redo.
   - ESCAPE:                        Revert text to its original value.
   - On OSX, controls are automatically adjusted to match standard OSX text editing 2ts and behaviors.

 - KEYBOARD CONTROLS
   - Basic:
	 - Tab, SHIFT+Tab               Cycle through text editable fields.
	 - CTRL+Tab, CTRL+Shift+Tab     Cycle through windows.
	 - CTRL+Click                   Input text into a Slider or Drag widget.
   - Extended features with `io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard`:
	 - Tab, SHIFT+Tab:              Cycle through every items.
	 - Arrow keys                   Move through items using directional navigation. Tweak value.
	 - Arrow keys + Alt, Shift      Tweak slower, tweak faster (when using arrow keys).
	 - Enter                        Activate item (prefer text input when possible).
	 - Space                        Activate item (prefer tweaking with arrows when possible).
	 - Escape                       Deactivate item, leave child window, close popup.
	 - Page Up, Page Down           Previous page, next page.
	 - Home, End                    Scroll to top, scroll to bottom.
	 - Alt                          Toggle between scrolling layer and menu layer.
	 - CTRL+Tab then Ctrl+Arrows    Move window. Hold SHIFT to resize instead of moving.
   - Output when ImGuiConfigFlags_NavEnableKeyboard set,
	 - io.WantCaptureKeyboard flag is set when keyboard is claimed.
	 - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
	 - io.NavVisible: true when the navigation cursor is visible (usually goes to back false when mouse is used).

 - GAMEPAD CONTROLS
   - Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
   - Particularly useful to use Dear ImGui on a console system (e.g. PlayStation, Switch, Xbox) without a mouse!
   - Download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets
   - Backend support: backend needs to:
	  - Set 'io.BackendFlags |= ImGuiBackendFlags_HasGamepad' + call io.AddKeyEvent/AddKeyAnalogEvent() with ImGuiKey_Gamepad_XXX keys.
	  - For analog values (0.0f to 1.0f), backend is responsible to handling a dead-zone and rescaling inputs accordingly.
		Backend code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
	  - BEFORE 1.87, BACKENDS USED TO WRITE TO io.NavInputs[]. This is now obsolete. Please call io functions instead!
   - If you need to share inputs between your game and the Dear ImGui interface, the easiest approach is to go all-or-nothing,
	 with a buttons combo to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.

 - REMOTE INPUTS SHARING & MOUSE EMULATION
   - PS4/PS5 users: Consider emulating a mouse cursor with DualShock touch pad or a spare analog stick as a mouse-emulation fallback.
   - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + run examples/libs/synergy/uSynergy.c (on your console/tablet/phone app)
	 in order to share your PC mouse/keyboard.
   - See https://github.com/ocornut/imgui/wiki/Useful-Extensions#remoting for other remoting solutions.
   - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.
	 Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs Dear ImGui to move your mouse cursor along with navigation movements.
	 When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
	 When that happens your backend NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the backends in examples/ do that.
	 (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, Dear ImGui will misbehave as it will see your mouse moving back & forth!)
	 (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
	 to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 PROGRAMMER GUIDE
 ================

 READ FIRST
 ----------
 - Remember to check the wonderful Wiki (https://github.com/ocornut/imgui/wiki)
 - Your code creates the UI every frame of your application loop, if your code doesn't run the UI is gone!
   The UI can be highly dynamic, there are no construction or destruction steps, less superfluous
   data retention on your side, less state duplication, less state synchronization, fewer bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
   Or browse https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html for interactive web version.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links in Wiki.
 - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
   For every application frame, your UI code will be called only once. This is in contrast to e.g. Unity's implementation of an IMGUI,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin is on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - This codebase aims to be highly optimized:
   - A typical idle frame should never call malloc/free.
   - We rely on a maximum of constant-time or O(N) algorithms. Limiting searches/scans as much as possible.
   - We put particular energy in making sure performances are decent with typical "Debug" build settings as well.
	 Which mean we tend to avoid over-relying on "zero-cost abstraction" as they aren't zero-cost at all.
 - This codebase aims to be both highly opinionated and highly flexible:
   - This code works because of the things it choose to solve or not solve.
   - C++: this is a pragmatic C-ish codebase: we don't use fancy C++ features, we don't include C++ headers,
	 and ImGui:: is a namespace. We rarely use member functions (and when we did, I am mostly regretting it now).
	 This is to increase compatibility, increase maintainability and facilitate use from other languages.
   - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
	 See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
	 We can can optionally export math operators for ImVec2/ImVec4 using IMGUI_DEFINE_MATH_OPERATORS, which we use internally.
   - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction
	 (so don't use ImVector in your code or at our own risk!).
   - Building: We don't use nor mandate a build system for the main library.
	 This is in an effort to ensure that it works in the real world aka with any esoteric build setup.
	 This is also because providing a build system for the main library would be of little-value.
	 The build problems are almost never coming from the main library but from specific backends.


 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
 ----------------------------------------------
 - Update submodule or copy/overwrite every file.
 - About imconfig.h:
   - You may modify your copy of imconfig.h, in this case don't overwrite it.
   - or you may locally branch to modify imconfig.h and merge/rebase latest.
   - or you may '#define IMGUI_USER_CONFIG "my_config_file.h"' globally from your build system to
	 specify a custom path for your imconfig.h file and instead not have to modify the default one.

 - Overwrite all the sources files except for imconfig.h (if you have modified your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified as a top-most commit which you can regularly rebase over "master".
 - You can also use '#define IMGUI_USER_CONFIG "my_config_file.h" to redirect configuration to your own file.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - To find out usage of old API, you can add '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in your configuration file.
 - Try to keep your copy of Dear ImGui reasonably up to date!


 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
 ---------------------------------------------------------------
 - See https://github.com/ocornut/imgui/wiki/Getting-Started.
 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - In the majority of cases you should be able to use unmodified backends files available in the backends/ folder.
 - Add the Dear ImGui source files + selected backend source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and NOT as a shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating Dear ImGui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering information is stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the backends and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.


 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 --------------------------------------
 EXHIBIT 1: USING THE EXAMPLE BACKENDS (= imgui_impl_XXX.cpp files from the backends/ folder).
 The sub-folders in examples/ contain examples applications following this structure.

	 // Application init: create a dear imgui context, setup some options, load fonts
	 ImGui::CreateContext();
	 ImGuiIO& io = ImGui::GetIO();
	 // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
	 // TODO: Fill optional fields of the io structure later.
	 // TODO: Load TTF/OTF fonts if you don't want to use the default font.

	 // Initialize helper Platform and Renderer backends (here we are using imgui_impl_win32.cpp and imgui_impl_dx11.cpp)
	 ImGui_ImplWin32_Init(hwnd);
	 ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

	 // Application main loop
	 while (true)
	 {
		 // Feed inputs to dear imgui, start new frame
		 ImGui_ImplDX11_NewFrame();
		 ImGui_ImplWin32_NewFrame();
		 ImGui::NewFrame();

		 // Any application code here
		 ImGui::Text("Hello, world!");

		 // Render dear imgui into screen
		 ImGui::Render();
		 ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
		 g_pSwapChain->Present(1, 0);
	 }

	 // Shutdown
	 ImGui_ImplDX11_Shutdown();
	 ImGui_ImplWin32_Shutdown();
	 ImGui::DestroyContext();

 EXHIBIT 2: IMPLEMENTING CUSTOM BACKEND / CUSTOM ENGINE

	 // Application init: create a dear imgui context, setup some options, load fonts
	 ImGui::CreateContext();
	 ImGuiIO& io = ImGui::GetIO();
	 // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
	 // TODO: Fill optional fields of the io structure later.
	 // TODO: Load TTF/OTF fonts if you don't want to use the default font.

	 // Build and load the texture atlas into a texture
	 // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
	 int width, height;
	 unsigned char* pixels = nullptr;
	 io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

	 // At this point you've got the texture data and you need to upload that to your graphic system:
	 // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
	 // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ for details about ImTextureID.
	 MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
	 io.Fonts->SetTexID((void*)texture);

	 // Application main loop
	 while (true)
	 {
		// Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
		// (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform Backends)
		io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
		io.DisplaySize.x = 1920.0f;             // set the current display width
		io.DisplaySize.y = 1280.0f;             // set the current display height here
		io.AddMousePosEvent(mouse_x, mouse_y);  // update mouse position
		io.AddMouseButtonEvent(0, mouse_b[0]);  // update mouse button states
		io.AddMouseButtonEvent(1, mouse_b[1]);  // update mouse button states

		// Call NewFrame(), after this point you can use ImGui::* functions anytime
		// (So you want to try calling NewFrame() as early as you can in your main loop to be able to use Dear ImGui everywhere)
		ImGui::NewFrame();

		// Most of your application code here
		ImGui::Text("Hello, world!");
		MyGameUpdate(); // may use any Dear ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
		MyGameRender(); // may use any Dear ImGui functions as well!

		// Render dear imgui, swap buffers
		// (You want to try calling EndFrame/Render as late as you can, to be able to use Dear ImGui in your own game rendering code)
		ImGui::EndFrame();
		ImGui::Render();
		ImDrawData* draw_data = ImGui::GetDrawData();
		MyImGuiRenderFunction(draw_data);
		SwapBuffers();
	 }

	 // Shutdown
	 ImGui::DestroyContext();

 To decide whether to dispatch mouse/keyboard inputs to Dear ImGui to the rest of your application,
 you should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 Please read the FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" about this.


 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
 ---------------------------------------------
 The backends in impl_impl_XXX.cpp files contain many working implementations of a rendering function.

	void MyImGuiRenderFunction(ImDrawData* draw_data)
	{
	   // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
	   // TODO: Setup texture sampling state: sample with bilinear filtering (NOT point/nearest filtering). Use 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines;' to allow point/nearest filtering.
	   // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
	   // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
	   // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
	   ImVec2 clip_off = draw_data->DisplayPos;
	   for (int n = 0; n < draw_data->CmdListsCount; n++)
	   {
		  const ImDrawList* cmd_list = draw_data->CmdLists[n];
		  const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
		  const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui
		  for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		  {
			 const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
			 if (pcmd->UserCallback)
			 {
				 pcmd->UserCallback(cmd_list, pcmd);
			 }
			 else
			 {
				 // Project scissor/clipping rectangles into framebuffer space
				 ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
				 ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
				 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
					 continue;

				 // We are using scissoring to clip some objects. All low-level graphics API should support it.
				 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
				 //   (some elements visible outside their bounds) but you can fix that once everything else works!
				 // - Clipping coordinates are provided in imgui coordinates space:
				 //   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size
				 //   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
				 //   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
				 //     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
				 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
				 MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);

				 // The texture for the draw call is specified by pcmd->GetTexID().
				 // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
				 MyEngineBindTexture((MyTexture*)pcmd->GetTexID());

				 // Render 'pcmd->ElemCount/3' indexed triangles.
				 // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
				 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd->IdxOffset, vtx_buffer, pcmd->VtxOffset);
			 }
		  }
	   }
	}


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about an old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

 - 2024/08/23 (1.91.1) - renamed ImGuiChildFlags_Border to ImGuiChildFlags_Borders for consistency. kept inline redirection flag.
 - 2024/08/22 (1.91.1) - moved some functions from ImGuiIO to ImGuiPlatformIO structure:
							- io.GetClipboardTextFn         -> platform_io.Platform_GetClipboardTextFn + changed 'void* user_data' to 'ImGuiContext* ctx'. Pull your user data from platform_io.ClipboardUserData.
							- io.SetClipboardTextFn         -> platform_io.Platform_SetClipboardTextFn + same as above line.
							- io.PlatformOpenInShellFn      -> platform_io.Platform_OpenInShellFn (#7660)
							- io.PlatformSetImeDataFn       -> platform_io.Platform_SetImeDataFn
							- io.PlatformLocaleDecimalPoint -> platform_io.Platform_LocaleDecimalPoint (#7389, #6719, #2278)
							- access those via GetPlatformIO() instead of GetIO().
						 some were introduced very recently and often automatically setup by core library and backends, so for those we are exceptionally not maintaining a legacy redirection symbol.
					   - commented the old ImageButton() signature obsoleted in 1.89 (~August 2022). As a reminder:
							- old ImageButton() before 1.89 used ImTextureId as item id (created issue with e.g. multiple buttons in same scope, transient texture id values, opaque computation of ID)
							- new ImageButton() since 1.89 requires an explicit 'const char* str_id'
							- old ImageButton() before 1.89 had frame_padding' override argument.
							- new ImageButton() since 1.89 always use style.FramePadding, which you can freely override with PushStyleVar()/PopStyleVar().
 - 2024/07/25 (1.91.0) - obsoleted GetContentRegionMax(), GetWindowContentRegionMin() and GetWindowContentRegionMax(). (see #7838 on GitHub for more info)
						 you should never need those functions. you can do everything with GetCursorScreenPos() and GetContentRegionAvail() in a more simple way.
							- instead of:  GetWindowContentRegionMax().x - GetCursorPos().x
							- you can use: GetContentRegionAvail().x
							- instead of:  GetWindowContentRegionMax().x + GetWindowPos().x
							- you can use: GetCursorScreenPos().x + GetContentRegionAvail().x // when called from left edge of window
							- instead of:  GetContentRegionMax()
							- you can use: GetContentRegionAvail() + GetCursorScreenPos() - GetWindowPos() // right edge in local coordinates
							- instead of:  GetWindowContentRegionMax().x - GetWindowContentRegionMin().x
							- you can use: GetContentRegionAvail() // when called from left edge of window
 - 2024/07/15 (1.91.0) - renamed ImGuiSelectableFlags_DontClosePopups to ImGuiSelectableFlags_NoAutoClosePopups. (#1379, #1468, #2200, #4936, #5216, #7302, #7573)
						 (internals: also renamed ImGuiItemFlags_SelectableDontClosePopup into ImGuiItemFlags_AutoClosePopups with inverted behaviors)
 - 2024/07/15 (1.91.0) - obsoleted PushButtonRepeat()/PopButtonRepeat() in favor of using new PushItemFlag(ImGuiItemFlags_ButtonRepeat, ...)/PopItemFlag().
 - 2024/07/02 (1.91.0) - commented out obsolete ImGuiModFlags (renamed to ImGuiKeyChord in 1.89). (#4921, #456)
					   - commented out obsolete ImGuiModFlags_XXX values (renamed to ImGuiMod_XXX in 1.89). (#4921, #456)
							- ImGuiModFlags_Ctrl -> ImGuiMod_Ctrl, ImGuiModFlags_Shift -> ImGuiMod_Shift etc.
 - 2024/07/02 (1.91.0) - IO, IME: renamed platform IME hook and added explicit context for consistency and future-proofness.
							- old: io.SetPlatformImeDataFn(ImGuiViewport* viewport, ImGuiPlatformImeData* data);
							- new: io.PlatformSetImeDataFn(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);
 - 2024/06/21 (1.90.9) - BeginChild: added ImGuiChildFlags_NavFlattened as a replacement for the window flag ImGuiWindowFlags_NavFlattened: the feature only ever made sense for BeginChild() anyhow.
							- old: BeginChild("Name", size, 0, ImGuiWindowFlags_NavFlattened);
							- new: BeginChild("Name", size, ImGuiChildFlags_NavFlattened, 0);
 - 2024/06/21 (1.90.9) - io: ClearInputKeys() (first exposed in 1.89.8) doesn't clear mouse data, newly added ClearInputMouse() does.
 - 2024/06/20 (1.90.9) - renamed ImGuiDragDropFlags_SourceAutoExpirePayload to ImGuiDragDropFlags_PayloadAutoExpire.
 - 2024/06/18 (1.90.9) - style: renamed ImGuiCol_TabActive -> ImGuiCol_TabSelected, ImGuiCol_TabUnfocused -> ImGuiCol_TabDimmed, ImGuiCol_TabUnfocusedActive -> ImGuiCol_TabDimmedSelected.
 - 2024/06/10 (1.90.9) - removed old nested structure: renaming ImGuiStorage::ImGuiStoragePair type to ImGuiStoragePair (simpler for many languages).
 - 2024/06/06 (1.90.8) - reordered ImGuiInputTextFlags values. This should not be breaking unless you are using generated headers that have values not matching the main library.
 - 2024/06/06 (1.90.8) - removed 'ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft', was mostly unused and misleading.
 - 2024/05/27 (1.90.7) - commented out obsolete symbols marked obsolete in 1.88 (May 2022):
							- old: CaptureKeyboardFromApp(bool)
							- new: SetNextFrameWantCaptureKeyboard(bool)
							- old: CaptureMouseFromApp(bool)
							- new: SetNextFrameWantCaptureMouse(bool)
 - 2024/05/22 (1.90.7) - inputs (internals): renamed ImGuiKeyOwner_None to ImGuiKeyOwner_NoOwner, to make use more explicit and reduce confusion with the default it is a non-zero value and cannot be the default value (never made public, but disclosing as I expect a few users caught on owner-aware inputs).
					   - inputs (internals): renamed ImGuiInputFlags_RouteGlobalLow -> ImGuiInputFlags_RouteGlobal, ImGuiInputFlags_RouteGlobal -> ImGuiInputFlags_RouteGlobalOverFocused, ImGuiInputFlags_RouteGlobalHigh -> ImGuiInputFlags_RouteGlobalHighest.
					   - inputs (internals): Shortcut(), SetShortcutRouting(): swapped last two parameters order in function signatures:
							- old: Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);
							- new: Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0, ImGuiID owner_id = 0);
					   - inputs (internals): owner-aware versions of IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(): swapped last two parameters order in function signatures.
							- old: IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
							- new: IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id = 0);
							- old: IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags flags = 0);
							- new: IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id = 0);
						 for various reasons those changes makes sense. They are being made because making some of those API public.
						 only past users of imgui_internal.h with the extra parameters will be affected. Added asserts for valid flags in various functions to detect _some_ misuses, BUT NOT ALL.
 - 2024/05/16 (1.90.7) - inputs: on macOS X, Cmd and Ctrl keys are now automatically swapped by io.AddKeyEvent() as this naturally align with how macOS X uses those keys.
						   - it shouldn't really affect you unless you had custom shortcut swapping in place for macOS X apps.
						   - removed ImGuiMod_Shortcut which was previously dynamically remapping to Ctrl or Cmd/Super. It is now unnecessary to specific cross-platform idiomatic shortcuts. (#2343, #4084, #5923, #456)
 - 2024/05/14 (1.90.7) - backends: SDL_Renderer2 and SDL_Renderer3 backend now take a SDL_Renderer* in their RenderDrawData() functions.
 - 2024/04/18 (1.90.6) - TreeNode: Fixed a layout inconsistency when using an empty/hidden label followed by a SameLine() call. (#7505, #282)
						   - old: TreeNode("##Hidden"); SameLine(); Text("Hello");     // <-- This was actually incorrect! BUT appeared to look ok with the default style where ItemSpacing.x == FramePadding.x * 2 (it didn't look aligned otherwise).
						   - new: TreeNode("##Hidden"); SameLine(0, 0); Text("Hello"); // <-- This is correct for all styles values.
						 with the fix, IF you were successfully using TreeNode("")+SameLine(); you will now have extra spacing between your TreeNode and the following item.
						 You'll need to change the SameLine() call to SameLine(0,0) to remove this extraneous spacing. This seemed like the more sensible fix that's not making things less consistent.
						 (Note: when using this idiom you are likely to also use ImGuiTreeNodeFlags_SpanAvailWidth).
 - 2024/03/18 (1.90.5) - merged the radius_x/radius_y parameters in ImDrawList::AddEllipse(), AddEllipseFilled() and PathEllipticalArcTo() into a single ImVec2 parameter. Exceptionally, because those functions were added in 1.90, we are not adding inline redirection functions. The transition is easy and should affect few users. (#2743, #7417)
 - 2024/03/08 (1.90.5) - inputs: more formally obsoleted GetKeyIndex() when IMGUI_DISABLE_OBSOLETE_FUNCTIONS is set. It has been unnecessary and a no-op since 1.87 (it returns the same value as passed when used with a 1.87+ backend using io.AddKeyEvent() function). (#4921)
						   - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX)) -> use IsKeyPressed(ImGuiKey_XXX)
 - 2024/01/15 (1.90.2) - commented out obsolete ImGuiIO::ImeWindowHandle marked obsolete in 1.87, favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.
 - 2023/12/19 (1.90.1) - commented out obsolete ImGuiKey_KeyPadEnter redirection to ImGuiKey_KeypadEnter.
 - 2023/11/06 (1.90.1) - removed CalcListClipping() marked obsolete in 1.86. Prefer using ImGuiListClipper which can return non-contiguous ranges.
 - 2023/11/05 (1.90.1) - imgui_freetype: commented out ImGuiFreeType::BuildFontAtlas() obsoleted in 1.81. prefer using #define IMGUI_ENABLE_FREETYPE or see commented code for manual calls.
 - 2023/11/05 (1.90.1) - internals,columns: commented out legacy ImGuiColumnsFlags_XXX symbols redirecting to ImGuiOldColumnsFlags_XXX, obsoleted from imgui_internal.h in 1.80.
 - 2023/11/09 (1.90.0) - removed IM_OFFSETOF() macro in favor of using offsetof() available in C++11. Kept redirection define (will obsolete).
 - 2023/11/07 (1.90.0) - removed BeginChildFrame()/EndChildFrame() in favor of using BeginChild() with the ImGuiChildFlags_FrameStyle flag. kept inline redirection function (will obsolete).
						 those functions were merely PushStyle/PopStyle helpers, the removal isn't so much motivated by needing to add the feature in BeginChild(), but by the necessity to avoid BeginChildFrame() signature mismatching BeginChild() signature and features.
 - 2023/11/02 (1.90.0) - BeginChild: upgraded 'bool border = true' parameter to 'ImGuiChildFlags flags' type, added ImGuiChildFlags_Border equivalent. As with our prior "bool-to-flags" API updates, the ImGuiChildFlags_Border value is guaranteed to be == true forever to ensure a smoother transition, meaning all existing calls will still work.
						   - old: BeginChild("Name", size, true)
						   - new: BeginChild("Name", size, ImGuiChildFlags_Border)
						   - old: BeginChild("Name", size, false)
						   - new: BeginChild("Name", size) or BeginChild("Name", 0) or BeginChild("Name", size, ImGuiChildFlags_None)
						 **AMEND FROM THE FUTURE: from 1.91.1, 'ImGuiChildFlags_Border' is called 'ImGuiChildFlags_Borders'**
 - 2023/11/02 (1.90.0) - BeginChild: added child-flag ImGuiChildFlags_AlwaysUseWindowPadding as a replacement for the window-flag ImGuiWindowFlags_AlwaysUseWindowPadding: the feature only ever made sense for BeginChild() anyhow.
						   - old: BeginChild("Name", size, 0, ImGuiWindowFlags_AlwaysUseWindowPadding);
						   - new: BeginChild("Name", size, ImGuiChildFlags_AlwaysUseWindowPadding, 0);
 - 2023/09/27 (1.90.0) - io: removed io.MetricsActiveAllocations introduced in 1.63. Same as 'g.DebugMemAllocCount - g.DebugMemFreeCount' (still displayed in Metrics, unlikely to be accessed by end-user).
 - 2023/09/26 (1.90.0) - debug tools: Renamed ShowStackToolWindow() ("Stack Tool") to ShowIDStackToolWindow() ("ID Stack Tool"), as earlier name was misleading. Kept inline redirection function. (#4631)
 - 2023/09/15 (1.90.0) - ListBox, Combo: changed signature of "name getter" callback in old one-liner ListBox()/Combo() apis. kept inline redirection function (will obsolete).
						   - old: bool Combo(const char* label, int* current_item, bool (*getter)(void* user_data, int idx, const char** out_text), ...)
						   - new: bool Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);
						   - old: bool ListBox(const char* label, int* current_item, bool (*getting)(void* user_data, int idx, const char** out_text), ...);
						   - new: bool ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);
 - 2023/09/08 (1.90.0) - commented out obsolete redirecting functions:
						   - GetWindowContentRegionWidth()  -> use GetWindowContentRegionMax().x - GetWindowContentRegionMin().x. Consider that generally 'GetContentRegionAvail().x' is more useful.
						   - ImDrawCornerFlags_XXX          -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details + grep commented names in sources.
					   - commented out runtime support for hardcoded ~0 or 0x01..0x0F rounding flags values for AddRect()/AddRectFilled()/PathRect()/AddImageRounded() -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details
 - 2023/08/25 (1.89.9) - clipper: Renamed IncludeRangeByIndices() (also called ForceDisplayRangeByIndices() before 1.89.6) to IncludeItemsByIndex(). Kept inline redirection function. Sorry!
 - 2023/07/12 (1.89.8) - ImDrawData: CmdLists now owned, changed from ImDrawList** to ImVector<ImDrawList*>. Majority of users shouldn't be affected, but you cannot compare to NULL nor reassign manually anymore. Instead use AddDrawList(). (#6406, #4879, #1878)
 - 2023/06/28 (1.89.7) - overlapping items: obsoleted 'SetItemAllowOverlap()' (called after item) in favor of calling 'SetNextItemAllowOverlap()' (called before item). 'SetItemAllowOverlap()' didn't and couldn't work reliably since 1.89 (2022-11-15).
 - 2023/06/28 (1.89.7) - overlapping items: renamed 'ImGuiTreeNodeFlags_AllowItemOverlap' to 'ImGuiTreeNodeFlags_AllowOverlap', 'ImGuiSelectableFlags_AllowItemOverlap' to 'ImGuiSelectableFlags_AllowOverlap'. Kept redirecting enums (will obsolete).
 - 2023/06/28 (1.89.7) - overlapping items: IsItemHovered() now by default return false when querying an item using AllowOverlap mode which is being overlapped. Use ImGuiHoveredFlags_AllowWhenOverlappedByItem to revert to old behavior.
 - 2023/06/28 (1.89.7) - overlapping items: Selectable and TreeNode don't allow overlap when active so overlapping widgets won't appear as hovered. While this fixes a common small visual issue, it also means that calling IsItemHovered() after a non-reactive elements - e.g. Text() - overlapping an active one may fail if you don't use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem). (#6610)
 - 2023/06/20 (1.89.7) - moved io.HoverDelayShort/io.HoverDelayNormal to style.HoverDelayShort/style.HoverDelayNormal. As the fields were added in 1.89 and expected to be left unchanged by most users, or only tweaked once during app initialization, we are exceptionally accepting the breakage.
 - 2023/05/30 (1.89.6) - backends: renamed "imgui_impl_sdlrenderer.cpp" to "imgui_impl_sdlrenderer2.cpp" and "imgui_impl_sdlrenderer.h" to "imgui_impl_sdlrenderer2.h". This is in prevision for the future release of SDL3.
 - 2023/05/22 (1.89.6) - listbox: commented out obsolete/redirecting functions that were marked obsolete more than two years ago:
						   - ListBoxHeader()  -> use BeginListBox() (note how two variants of ListBoxHeader() existed. Check commented versions in imgui.h for reference)
						   - ListBoxFooter()  -> use EndListBox()
 - 2023/05/15 (1.89.6) - clipper: commented out obsolete redirection constructor 'ImGuiListClipper(int items_count, float items_height = -1.0f)' that was marked obsolete in 1.79. Use default constructor + clipper.Begin().
 - 2023/05/15 (1.89.6) - clipper: renamed ImGuiListClipper::ForceDisplayRangeByIndices() to ImGuiListClipper::IncludeRangeByIndices().
 - 2023/03/14 (1.89.4) - commented out redirecting enums/functions names that were marked obsolete two years ago:
						   - ImGuiSliderFlags_ClampOnInput        -> use ImGuiSliderFlags_AlwaysClamp
						   - ImGuiInputTextFlags_AlwaysInsertMode -> use ImGuiInputTextFlags_AlwaysOverwrite
						   - ImDrawList::AddBezierCurve()         -> use ImDrawList::AddBezierCubic()
						   - ImDrawList::PathBezierCurveTo()      -> use ImDrawList::PathBezierCubicCurveTo()
 - 2023/03/09 (1.89.4) - renamed PushAllowKeyboardFocus()/PopAllowKeyboardFocus() to PushTabStop()/PopTabStop(). Kept inline redirection functions (will obsolete).
 - 2023/03/09 (1.89.4) - tooltips: Added 'bool' return value to BeginTooltip() for API consistency. Please only submit contents and call EndTooltip() if BeginTooltip() returns true. In reality the function will _currently_ always return true, but further changes down the line may change this, best to clarify API sooner.
 - 2023/02/15 (1.89.4) - moved the optional "courtesy maths operators" implementation from imgui_internal.h in imgui.h.
						 Even though we encourage using your own maths types and operators by setting up IM_VEC2_CLASS_EXTRA,
						 it has been frequently requested by people to use our own. We had an opt-in define which was
						 previously fulfilled in imgui_internal.h. It is now fulfilled in imgui.h. (#6164)
						   - OK:     #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui.h" / #include "imgui_internal.h"
						   - Error:  #include "imgui.h" / #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui_internal.h"
 - 2023/02/07 (1.89.3) - backends: renamed "imgui_impl_sdl.cpp" to "imgui_impl_sdl2.cpp" and "imgui_impl_sdl.h" to "imgui_impl_sdl2.h". (#6146) This is in prevision for the future release of SDL3.
 - 2022/10/26 (1.89)   - commented out redirecting OpenPopupContextItem() which was briefly the name of OpenPopupOnItemClick() from 1.77 to 1.79.
 - 2022/10/12 (1.89)   - removed runtime patching of invalid "%f"/"%0.f" format strings for DragInt()/SliderInt(). This was obsoleted in 1.61 (May 2018). See 1.61 changelog for details.
 - 2022/09/26 (1.89)   - renamed and merged keyboard modifiers key enums and flags into a same set. Kept inline redirection enums (will obsolete).
						   - ImGuiKey_ModCtrl  and ImGuiModFlags_Ctrl  -> ImGuiMod_Ctrl
						   - ImGuiKey_ModShift and ImGuiModFlags_Shift -> ImGuiMod_Shift
						   - ImGuiKey_ModAlt   and ImGuiModFlags_Alt   -> ImGuiMod_Alt
						   - ImGuiKey_ModSuper and ImGuiModFlags_Super -> ImGuiMod_Super
						 the ImGuiKey_ModXXX were introduced in 1.87 and mostly used by backends.
						 the ImGuiModFlags_XXX have been exposed in imgui.h but not really used by any public api only by third-party extensions.
						 exceptionally commenting out the older ImGuiKeyModFlags_XXX names ahead of obsolescence schedule to reduce confusion and because they were not meant to be used anyway.
 - 2022/09/20 (1.89)   - ImGuiKey is now a typed enum, allowing ImGuiKey_XXX symbols to be named in debuggers.
						 this will require uses of legacy backend-dependent indices to be casted, e.g.
							- with imgui_impl_glfw:  IsKeyPressed(GLFW_KEY_A) -> IsKeyPressed((ImGuiKey)GLFW_KEY_A);
							- with imgui_impl_win32: IsKeyPressed('A')        -> IsKeyPressed((ImGuiKey)'A')
							- etc. However if you are upgrading code you might well use the better, backend-agnostic IsKeyPressed(ImGuiKey_A) now!
 - 2022/09/12 (1.89) - removed the bizarre legacy default argument for 'TreePush(const void* ptr = NULL)', always pass a pointer value explicitly. NULL/nullptr is ok but require cast, e.g. TreePush((void*)nullptr);
 - 2022/09/05 (1.89) - commented out redirecting functions/enums names that were marked obsolete in 1.77 and 1.78 (June 2020):
						 - DragScalar(), DragScalarN(), DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.
						 - SliderScalar(), SliderScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.
						 - BeginPopupContextWindow(const char*, ImGuiMouseButton, bool) -> use BeginPopupContextWindow(const char*, ImGuiPopupFlags)
 - 2022/09/02 (1.89) - obsoleted using SetCursorPos()/SetCursorScreenPos() to extend parent window/cell boundaries.
					   this relates to when moving the cursor position beyond current boundaries WITHOUT submitting an item.
						 - previously this would make the window content size ~200x200:
							  Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + End();
						 - instead, please submit an item:
							  Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + Dummy(ImVec2(0,0)) + End();
						 - alternative:
							  Begin(...) + Dummy(ImVec2(200,200)) + End();
						 - content size is now only extended when submitting an item!
						 - with '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will now be detected and assert.
						 - without '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will silently be fixed until we obsolete it.
 - 2022/08/03 (1.89) - changed signature of ImageButton() function. Kept redirection function (will obsolete).
						- added 'const char* str_id' parameter + removed 'int frame_padding = -1' parameter.
						- old signature: bool ImageButton(ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2(0,0), ImVec2 uv1 = ImVec2(1,1), int frame_padding = -1, ImVec4 bg_col = ImVec4(0,0,0,0), ImVec4 tint_col = ImVec4(1,1,1,1));
						  - used the ImTextureID value to create an ID. This was inconsistent with other functions, led to ID conflicts, and caused problems with engines using transient ImTextureID values.
						  - had a FramePadding override which was inconsistent with other functions and made the already-long signature even longer.
						- new signature: bool ImageButton(const char* str_id, ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2(0,0), ImVec2 uv1 = ImVec2(1,1), ImVec4 bg_col = ImVec4(0,0,0,0), ImVec4 tint_col = ImVec4(1,1,1,1));
						  - requires an explicit identifier. You may still use e.g. PushID() calls and then pass an empty identifier.
						  - always uses style.FramePadding for padding, to be consistent with other buttons. You may use PushStyleVar() to alter this.
 - 2022/07/08 (1.89) - inputs: removed io.NavInputs[] and ImGuiNavInput enum (following 1.87 changes).
						- Official backends from 1.87+                  -> no issue.
						- Official backends from 1.60 to 1.86           -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need updating!
						- Custom backends not writing to io.NavInputs[] -> no issue.
						- Custom backends writing to io.NavInputs[]     -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need fixing!
						- TL;DR: Backends should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values instead of filling io.NavInput[].
 - 2022/06/15 (1.88) - renamed IMGUI_DISABLE_METRICS_WINDOW to IMGUI_DISABLE_DEBUG_TOOLS for correctness. kept support for old define (will obsolete).
 - 2022/05/03 (1.88) - backends: osx: removed ImGui_ImplOSX_HandleEvent() from backend API in favor of backend automatically handling event capture. All ImGui_ImplOSX_HandleEvent() calls should be removed as they are now unnecessary.
 - 2022/04/05 (1.88) - inputs: renamed ImGuiKeyModFlags to ImGuiModFlags. Kept inline redirection enums (will obsolete). This was never used in public API functions but technically present in imgui.h and ImGuiIO.
 - 2022/01/20 (1.87) - inputs: reworded gamepad IO.
						- Backend writing to io.NavInputs[]            -> backend should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values.
 - 2022/01/19 (1.87) - sliders, drags: removed support for legacy arithmetic operators (+,+-,*,/) when inputing text. This doesn't break any api/code but a feature that used to be accessible by end-users (which seemingly no one used).
 - 2022/01/17 (1.87) - inputs: reworked mouse IO.
						- Backend writing to io.MousePos               -> backend should call io.AddMousePosEvent()
						- Backend writing to io.MouseDown[]            -> backend should call io.AddMouseButtonEvent()
						- Backend writing to io.MouseWheel             -> backend should call io.AddMouseWheelEvent()
						- Backend writing to io.MouseHoveredViewport   -> backend should call io.AddMouseViewportEvent() [Docking branch w/ multi-viewports only]
					   note: for all calls to IO new functions, the Dear ImGui context should be bound/current.
					   read https://github.com/ocornut/imgui/issues/4921 for details.
 - 2022/01/10 (1.87) - inputs: reworked keyboard IO. Removed io.KeyMap[], io.KeysDown[] in favor of calling io.AddKeyEvent(). Removed GetKeyIndex(), now unnecessary. All IsKeyXXX() functions now take ImGuiKey values. All features are still functional until IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Read Changelog and Release Notes for details.
						- IsKeyPressed(MY_NATIVE_KEY_XXX)              -> use IsKeyPressed(ImGuiKey_XXX)
						- IsKeyPressed(GetKeyIndex(ImGuiKey_XXX))      -> use IsKeyPressed(ImGuiKey_XXX)
						- Backend writing to io.KeyMap[],io.KeysDown[] -> backend should call io.AddKeyEvent() (+ call io.SetKeyEventNativeData() if you want legacy user code to stil function with legacy key codes).
						- Backend writing to io.KeyCtrl, io.KeyShift.. -> backend should call io.AddKeyEvent() with ImGuiMod_XXX values. *IF YOU PULLED CODE BETWEEN 2021/01/10 and 2021/01/27: We used to have a io.AddKeyModsEvent() function which was now replaced by io.AddKeyEvent() with ImGuiMod_XXX values.*
					 - one case won't work with backward compatibility: if your custom backend used ImGuiKey as mock native indices (e.g. "io.KeyMap[ImGuiKey_A] = ImGuiKey_A") because those values are now larger than the legacy KeyDown[] array. Will assert.
					 - inputs: added ImGuiKey_ModCtrl/ImGuiKey_ModShift/ImGuiKey_ModAlt/ImGuiKey_ModSuper values to submit keyboard modifiers using io.AddKeyEvent(), instead of writing directly to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper.
 - 2022/01/05 (1.87) - inputs: renamed ImGuiKey_KeyPadEnter to ImGuiKey_KeypadEnter to align with new symbols. Kept redirection enum.
 - 2022/01/05 (1.87) - removed io.ImeSetInputScreenPosFn() in favor of more flexible io.SetPlatformImeDataFn(). Removed 'void* io.ImeWindowHandle' in favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.
 - 2022/01/01 (1.87) - commented out redirecting functions/enums names that were marked obsolete in 1.69, 1.70, 1.71, 1.72 (March-July 2019)
						- ImGui::SetNextTreeNodeOpen()        -> use ImGui::SetNextItemOpen()
						- ImGui::GetContentRegionAvailWidth() -> use ImGui::GetContentRegionAvail().x
						- ImGui::TreeAdvanceToLabelPos()      -> use ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetTreeNodeToLabelSpacing());
						- ImFontAtlas::CustomRect             -> use ImFontAtlasCustomRect
						- ImGuiColorEditFlags_RGB/HSV/HEX     -> use ImGuiColorEditFlags_DisplayRGB/HSV/Hex
 - 2021/12/20 (1.86) - backends: removed obsolete Marmalade backend (imgui_impl_marmalade.cpp) + example. Find last supported version at https://github.com/ocornut/imgui/wiki/Bindings
 - 2021/11/04 (1.86) - removed CalcListClipping() function. Prefer using ImGuiListClipper which can return non-contiguous ranges. Please open an issue if you think you really need this function.
 - 2021/08/23 (1.85) - removed GetWindowContentRegionWidth() function. keep inline redirection helper. can use 'GetWindowContentRegionMax().x - GetWindowContentRegionMin().x' instead for generally 'GetContentRegionAvail().x' is more useful.
 - 2021/07/26 (1.84) - commented out redirecting functions/enums names that were marked obsolete in 1.67 and 1.69 (March 2019):
						- ImGui::GetOverlayDrawList() -> use ImGui::GetForegroundDrawList()
						- ImFont::GlyphRangesBuilder  -> use ImFontGlyphRangesBuilder
 - 2021/05/19 (1.83) - backends: obsoleted direct access to ImDrawCmd::TextureId in favor of calling ImDrawCmd::GetTexID().
						- if you are using official backends from the source tree: you have nothing to do.
						- if you have copied old backend code or using your own: change access to draw_cmd->TextureId to draw_cmd->GetTexID().
 - 2021/03/12 (1.82) - upgraded ImDrawList::AddRect(), AddRectFilled(), PathRect() to use ImDrawFlags instead of ImDrawCornersFlags.
						- ImDrawCornerFlags_TopLeft  -> use ImDrawFlags_RoundCornersTopLeft
						- ImDrawCornerFlags_BotRight -> use ImDrawFlags_RoundCornersBottomRight
						- ImDrawCornerFlags_None     -> use ImDrawFlags_RoundCornersNone etc.
					   flags now sanely defaults to 0 instead of 0x0F, consistent with all other flags in the API.
					   breaking: the default with rounding > 0.0f is now "round all corners" vs old implicit "round no corners":
						- rounding == 0.0f + flags == 0 --> meant no rounding  --> unchanged (common use)
						- rounding  > 0.0f + flags != 0 --> meant rounding     --> unchanged (common use)
						- rounding == 0.0f + flags != 0 --> meant no rounding  --> unchanged (unlikely use)
						- rounding  > 0.0f + flags == 0 --> meant no rounding  --> BREAKING (unlikely use): will now round all corners --> use ImDrawFlags_RoundCornersNone or rounding == 0.0f.
					   this ONLY matters for hard coded use of 0 + rounding > 0.0f. Use of named ImDrawFlags_RoundCornersNone (new) or ImDrawCornerFlags_None (old) are ok.
					   the old ImDrawCornersFlags used awkward default values of ~0 or 0xF (4 lower bits set) to signify "round all corners" and we sometimes encouraged using them as shortcuts.
					   legacy path still support use of hard coded ~0 or any value from 0x1 or 0xF. They will behave the same with legacy paths enabled (will assert otherwise).
 - 2021/03/11 (1.82) - removed redirecting functions/enums names that were marked obsolete in 1.66 (September 2018):
						- ImGui::SetScrollHere()              -> use ImGui::SetScrollHereY()
 - 2021/03/11 (1.82) - clarified that ImDrawList::PathArcTo(), ImDrawList::PathArcToFast() won't render with radius < 0.0f. Previously it sorts of accidentally worked but would generally lead to counter-clockwise paths and have an effect on anti-aliasing.
 - 2021/03/10 (1.82) - upgraded ImDrawList::AddPolyline() and PathStroke() "bool closed" parameter to "ImDrawFlags flags". The matching ImDrawFlags_Closed value is guaranteed to always stay == 1 in the future.
 - 2021/02/22 (1.82) - (*undone in 1.84*) win32+mingw: Re-enabled IME functions by default even under MinGW. In July 2016, issue #738 had me incorrectly disable those default functions for MinGW. MinGW users should: either link with -limm32, either set their imconfig file  with '#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS'.
 - 2021/02/17 (1.82) - renamed rarely used style.CircleSegmentMaxError (old default = 1.60f) to style.CircleTessellationMaxError (new default = 0.30f) as the meaning of the value changed.
 - 2021/02/03 (1.81) - renamed ListBoxHeader(const char* label, ImVec2 size) to BeginListBox(). Kept inline redirection function (will obsolete).
					 - removed ListBoxHeader(const char* label, int items_count, int height_in_items = -1) in favor of specifying size. Kept inline redirection function (will obsolete).
					 - renamed ListBoxFooter() to EndListBox(). Kept inline redirection function (will obsolete).
 - 2021/01/26 (1.81) - removed ImGuiFreeType::BuildFontAtlas(). Kept inline redirection function. Prefer using '#define IMGUI_ENABLE_FREETYPE', but there's a runtime selection path available too. The shared extra flags parameters (very rarely used) are now stored in ImFontAtlas::FontBuilderFlags.
					 - renamed ImFontConfig::RasterizerFlags (used by FreeType) to ImFontConfig::FontBuilderFlags.
					 - renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.63 (August 2018):
						- ImGui::IsItemDeactivatedAfterChange() -> use ImGui::IsItemDeactivatedAfterEdit().
						- ImGuiCol_ModalWindowDarkening       -> use ImGuiCol_ModalWindowDimBg
						- ImGuiInputTextCallback              -> use ImGuiTextEditCallback
						- ImGuiInputTextCallbackData          -> use ImGuiTextEditCallbackData
 - 2020/12/21 (1.80) - renamed ImDrawList::AddBezierCurve() to AddBezierCubic(), and PathBezierCurveTo() to PathBezierCubicCurveTo(). Kept inline redirection function (will obsolete).
 - 2020/12/04 (1.80) - added imgui_tables.cpp file! Manually constructed project files will need the new file added!
 - 2020/11/18 (1.80) - renamed undocumented/internals ImGuiColumnsFlags_* to ImGuiOldColumnFlags_* in prevision of incoming Tables API.
 - 2020/11/03 (1.80) - renamed io.ConfigWindowsMemoryCompactTimer to io.ConfigMemoryCompactTimer as the feature will apply to other data structures
 - 2020/10/14 (1.80) - backends: moved all backends files (imgui_impl_XXXX.cpp, imgui_impl_XXXX.h) from examples/ to backends/.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.60 (April 2018):
						- io.RenderDrawListsFn pointer        -> use ImGui::GetDrawData() value and call the render function of your backend
						- ImGui::IsAnyWindowFocused()         -> use ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow)
						- ImGui::IsAnyWindowHovered()         -> use ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
						- ImGuiStyleVar_Count_                -> use ImGuiStyleVar_COUNT
						- ImGuiMouseCursor_Count_             -> use ImGuiMouseCursor_COUNT
					  - removed redirecting functions names that were marked obsolete in 1.61 (May 2018):
						- InputFloat (... int decimal_precision ...) -> use InputFloat (... const char* format ...) with format = "%.Xf" where X is your value for decimal_precision.
						- same for InputFloat2()/InputFloat3()/InputFloat4() variants taking a `int decimal_precision` parameter.
 - 2020/10/05 (1.79) - removed ImGuiListClipper: Renamed constructor parameters which created an ambiguous alternative to using the ImGuiListClipper::Begin() function, with misleading edge cases (note: imgui_memory_editor <0.40 from imgui_club/ used this old clipper API. Update your copy if needed).
 - 2020/09/25 (1.79) - renamed ImGuiSliderFlags_ClampOnInput to ImGuiSliderFlags_AlwaysClamp. Kept redirection enum (will obsolete sooner because previous name was added recently).
 - 2020/09/25 (1.79) - renamed style.TabMinWidthForUnselectedCloseButton to style.TabMinWidthForCloseButton.
 - 2020/09/21 (1.79) - renamed OpenPopupContextItem() back to OpenPopupOnItemClick(), reverting the change from 1.77. For varieties of reason this is more self-explanatory.
 - 2020/09/21 (1.79) - removed return value from OpenPopupOnItemClick() - returned true on mouse release on an item - because it is inconsistent with other popup APIs and makes others misleading. It's also and unnecessary: you can use IsWindowAppearing() after BeginPopup() for a similar result.
 - 2020/09/17 (1.79) - removed ImFont::DisplayOffset in favor of ImFontConfig::GlyphOffset. DisplayOffset was applied after scaling and not very meaningful/useful outside of being needed by the default ProggyClean font. If you scaled this value after calling AddFontDefault(), this is now done automatically. It was also getting in the way of better font scaling, so let's get rid of it now!
 - 2020/08/17 (1.78) - obsoleted use of the trailing 'float power=1.0f' parameter for DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(), DragFloatRange2(), DragScalar(), DragScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(), SliderScalar(), SliderScalarN(), VSliderFloat() and VSliderScalar().
					   replaced the 'float power=1.0f' argument with integer-based flags defaulting to 0 (as with all our flags).
					   worked out a backward-compatibility scheme so hopefully most C++ codebase should not be affected. in short, when calling those functions:
					   - if you omitted the 'power' parameter (likely!), you are not affected.
					   - if you set the 'power' parameter to 1.0f (same as previous default value): 1/ your compiler may warn on float>int conversion, 2/ everything else will work. 3/ you can replace the 1.0f value with 0 to fix the warning, and be technically correct.
					   - if you set the 'power' parameter to >1.0f (to enable non-linear editing): 1/ your compiler may warn on float>int conversion, 2/ code will assert at runtime, 3/ in case asserts are disabled, the code will not crash and enable the _Logarithmic flag. 4/ you can replace the >1.0f value with ImGuiSliderFlags_Logarithmic to fix the warning/assert and get a _similar_ effect as previous uses of power >1.0f.
					   see https://github.com/ocornut/imgui/issues/3361 for all details.
					   kept inline redirection functions (will obsolete) apart for: DragFloatRange2(), VSliderFloat(), VSliderScalar(). For those three the 'float power=1.0f' version was removed directly as they were most unlikely ever used.
					   for shared code, you can version check at compile-time with `#if IMGUI_VERSION_NUM >= 17704`.
					 - obsoleted use of v_min > v_max in DragInt, DragFloat, DragScalar to lock edits (introduced in 1.73, was not demoed nor documented very), will be replaced by a more generic ReadOnly feature. You may use the ImGuiSliderFlags_ReadOnly internal flag in the meantime.
 - 2020/06/23 (1.77) - removed BeginPopupContextWindow(const char*, int mouse_button, bool also_over_items) in favor of BeginPopupContextWindow(const char*, ImGuiPopupFlags flags) with ImGuiPopupFlags_NoOverItems.
 - 2020/06/15 (1.77) - renamed OpenPopupOnItemClick() to OpenPopupContextItem(). Kept inline redirection function (will obsolete). [NOTE: THIS WAS REVERTED IN 1.79]
 - 2020/06/15 (1.77) - removed CalcItemRectClosestPoint() entry point which was made obsolete and asserting in December 2017.
 - 2020/04/23 (1.77) - removed unnecessary ID (first arg) of ImFontAtlas::AddCustomRectRegular().
 - 2020/01/22 (1.75) - ImDrawList::AddCircle()/AddCircleFilled() functions don't accept negative radius any more.
 - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64 columns by asserting above that limit. While the current code technically supports it, future code may not so we're putting the restriction ahead.
 - 2019/12/13 (1.75) - [imgui_internal.h] changed ImRect() default constructor initializes all fields to 0.0f instead of (FLT_MAX,FLT_MAX,-FLT_MAX,-FLT_MAX). If you used ImRect::Add() to create bounding boxes by adding multiple points into it, you may need to fix your initial value.
 - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked obsolete in 1.53 (December 2017):
					   - ShowTestWindow()                    -> use ShowDemoWindow()
					   - IsRootWindowFocused()               -> use IsWindowFocused(ImGuiFocusedFlags_RootWindow)
					   - IsRootWindowOrAnyChildFocused()     -> use IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows)
					   - SetNextWindowContentWidth(w)        -> use SetNextWindowContentSize(ImVec2(w, 0.0f)
					   - GetItemsLineHeightWithSpacing()     -> use GetFrameHeightWithSpacing()
					   - ImGuiCol_ChildWindowBg              -> use ImGuiCol_ChildBg
					   - ImGuiStyleVar_ChildWindowRounding   -> use ImGuiStyleVar_ChildRounding
					   - ImGuiTreeNodeFlags_AllowOverlapMode -> use ImGuiTreeNodeFlags_AllowItemOverlap
					   - IMGUI_DISABLE_TEST_WINDOWS          -> use IMGUI_DISABLE_DEMO_WINDOWS
 - 2019/12/08 (1.75) - obsoleted calling ImDrawList::PrimReserve() with a negative count (which was vaguely documented and rarely if ever used). Instead, we added an explicit PrimUnreserve() API.
 - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int button = 0) to be consistent with other mouse functions (none of the other functions have it).
 - 2019/11/21 (1.74) - ImFontAtlas::AddCustomRectRegular() now requires an ID larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode planes 1-16 in a future update. ID below 0x110000 will now assert.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS to IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_MATH_FUNCTIONS to IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.
 - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked obsolete in 1.52 (October 2017):
					   - Begin() [old 5 args version]        -> use Begin() [3 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed
					   - IsRootWindowOrAnyChildHovered()     -> use IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
					   - AlignFirstTextHeightToWidgets()     -> use AlignTextToFramePadding()
					   - SetNextWindowPosCenter()            -> use SetNextWindowPos() with a pivot of (0.5f, 0.5f)
					   - ImFont::Glyph                       -> use ImFontGlyph
 - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse "typematic" repeat delay/rate calculation, used by keys and e.g. repeating mouse buttons as well as the GetKeyPressedAmount() function.
					   if you were using a non-default value for io.KeyRepeatRate (previous default was 0.250), you can add +io.KeyRepeatDelay to it to compensate for the fix.
					   The function was triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to (io.KeyRepeatRate + io.KeyRepeatDelay).
					   If you never altered io.KeyRepeatRate nor used GetKeyPressedAmount() this won't affect you.
 - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept redirection function (will obsolete).
 - 2019/07/12 (1.72) - renamed ImFontAtlas::CustomRect to ImFontAtlasCustomRect. Kept redirection typedef (will obsolete).
 - 2019/06/14 (1.72) - removed redirecting functions/enums names that were marked obsolete in 1.51 (June 2017): ImGuiCol_Column*, ImGuiSetCond_*, IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(), IsMouseHoveringWindow(), IMGUI_ONCE_UPON_A_FRAME. Grep this log for details and new names, or see how they were implemented until 1.71.
 - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color, border, scrollbars) is now performed as part of the parent window. If you have
					   overlapping child windows in a same parent, and relied on their relative z-order to be mapped to their submission order, this will affect your rendering.
					   This optimization is disabled if the parent window has no visual output, because it appears to be the most common situation leading to the creation of overlapping child windows.
					   Please reach out if you are affected.
 - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept inline redirection function (will obsolete).
 - 2019/05/11 (1.71) - changed io.AddInputCharacter(unsigned short c) signature to io.AddInputCharacter(unsigned int c).
 - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.
 - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).
 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with an arbitrarily small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Kept redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
					   If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
					   NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
					   Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the imgui_impl_XXX files have been split to separate platform (Win32, GLFW, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
					   old backends will still work as is, however prefer using the separated backends as they will be updated to support multi-viewports.
					   when adopting new backends follow the main.cpp code of your preferred examples/ folder to know which functions to call.
					   in particular, note that old backends called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
					   If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
					   To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
					   If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
					   consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some backend ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
					   - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
					   - removed Shutdown() function, as DestroyContext() serve this purpose.
					   - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
					   - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
					   - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
					 - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
					   Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
					   removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
						 IsItemHoveredRect()        --> IsItemHovered(ImGuiHoveredFlags_RectOnly)
						 IsMouseHoveringAnyWindow() --> IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
						 IsMouseHoveringWindow()    --> IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Kept redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your backend if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
					 - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
					 - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame type.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Column to ImGuiCol_Separator, ImGuiCol_ColumnHovered to ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive to ImGuiCol_SeparatorActive. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_Always to ImGuiCond_Always, ImGuiSetCond_Once to ImGuiCond_Once, ImGuiSetCond_FirstUseEver to ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing to ImGuiCond_Appearing. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
					 - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
					 - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0, 0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetID() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully, breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
					   If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you, otherwise if <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
					   This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color:
					   ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col) { float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a; return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a); }
					   If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref GitHub issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
					   GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
					   GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
					   you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
					   this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
					 - if you are using a vanilla copy of one of the imgui_impl_XXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
					 - the signature of the io.RenderDrawListsFn handler has changed!
					   old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
					   new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
						 parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
						 ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
						 ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
					 - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
					 - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
					 - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
 - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
					   - old:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); [..Upload texture to GPU..];
					   - new:  unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to GPU..]; io.Fonts->SetTexID(YourTexIdentifier);
					   you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs. It is now recommended that you sample the font texture with bilinear interpolation.
 - 2015/01/11 (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to call io.Fonts->SetTexID()
 - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
 - 2015/01/11 (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ)
 ================================

 Read all answers online:
   https://www.dearimgui.com/faq or https://github.com/ocornut/imgui/blob/master/docs/FAQ.md (same url)
 Read all answers locally (with a text editor or ideally a Markdown viewer):
   docs/FAQ.md
 Some answers are copied down here to facilitate searching in code.

 Q&A: Basics
 ===========

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects the user to be acquainted with C/C++.
	- Run the examples/ applications and explore them.
	- Read Getting Started (https://github.com/ocornut/imgui/wiki/Getting-Started) guide.
	- See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function.
	- The demo covers most features of Dear ImGui, so you can read the code and see its output.
	- See documentation and comments at the top of imgui.cpp + effectively imgui.h.
	- 20+ standalone example applications using e.g. OpenGL/DirectX are provided in the
	  examples/ folder to explain how to integrate Dear ImGui with your own engine/application.
	- The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and links.
	- The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also may be useful.
	- Your programming IDE is your friend, find the type or function declaration to find comments
	  associated with it.

 Q: What is this library called?
 Q: Which version should I get?
 >> This library is called "Dear ImGui", please don't call it "ImGui" :)
 >> See https://www.dearimgui.com/faq for details.

 Q&A: Integration
 ================

 Q: How to get started?
 A: Read https://github.com/ocornut/imgui/wiki/Getting-Started. Read 'PROGRAMMER GUIDE' above. Read examples/README.txt.

 Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?
 A: You should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 >> See https://www.dearimgui.com/faq for a fully detailed answer. You really want to read this.

 Q. How can I enable keyboard or gamepad controls?
 Q: How can I use this on a machine without mouse, keyboard or screen? (input share, remote display)
 Q: I integrated Dear ImGui in my engine and little squares are showing instead of text...
 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around...
 Q: I integrated Dear ImGui in my engine and some elements are displaying outside their expected windows boundaries...
 >> See https://www.dearimgui.com/faq

 Q&A: Usage
 ----------

 Q: About the ID Stack system..
   - Why is my widget not reacting when I click on it?
   - How can I have widgets with an empty label?
   - How can I have multiple widgets with the same label?
   - How can I have multiple windows with the same label?
 Q: How can I display an image? What is ImTextureID, how does it work?
 Q: How can I use my own math types instead of ImVec2?
 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 Q: How can I display custom shapes? (using low-level ImDrawList API)
 >> See https://www.dearimgui.com/faq

 Q&A: Fonts, Text
 ================

 Q: How should I handle DPI in my application?
 Q: How can I load a different font than the default?
 Q: How can I easily use icons in my application?
 Q: How can I load multiple fonts?
 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 >> See https://www.dearimgui.com/faq and https://github.com/ocornut/imgui/blob/master/docs/FONTS.md

 Q&A: Concerns
 =============

 Q: Who uses Dear ImGui?
 Q: Can you create elaborate/serious tools with Dear ImGui?
 Q: Can you reskin the look of Dear ImGui?
 Q: Why using C++ (as opposed to C)?
 >> See https://www.dearimgui.com/faq

 Q&A: Community
 ==============

 Q: How can I help?
 A: - Businesses: please reach out to "omar AT dearimgui DOT com" if you work in a place using Dear ImGui!
	  We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts.
	  This is among the most useful thing you can do for Dear ImGui. With increased funding, we sustain and grow work on this project.
	  >>> See https://github.com/ocornut/imgui/wiki/Funding
	- Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.
	- If you are experienced with Dear ImGui and C++, look at the GitHub issues, look at the Wiki, and see how you want to help and can help!
	- Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
	  You may post screenshot or links in the gallery threads. Visuals are ideal as they inspire other programmers.
	  But even without visuals, disclosing your use of dear imgui helps the library grow credibility, and help other teams and programmers with taking decisions.
	- If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on GitHub or privately).

*/

//-------------------------------------------------------------------------
// [SECTION] INCLUDES
//-------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif

#ifndef IMGUI_DISABLE

// System includes
#include <stdint.h> // intptr_t
#include <stdio.h> // vsnprintf, sscanf, printf

// [Windows] On non-Visual Studio compilers, we default to IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS unless explicitly enabled
#if defined(_WIN32) && !defined(_MSC_VER) && !defined(IMGUI_ENABLE_WIN32_DEFAULT_IME_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)
#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
#endif

// [Windows] OS specific includes (optional)
#if defined(_WIN32) && defined(IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) && defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS) && defined(IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
#define IMGUI_DISABLE_WIN32_FUNCTIONS
#endif
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef __MINGW32__
#include <Windows.h> // _wfopen, OpenClipboard
#else
#include <windows.h>
#endif
#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP || WINAPI_FAMILY == WINAPI_FAMILY_GAMES)
// The UWP and GDK Win32 API subsets don't support clipboard nor IME functions
#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS
#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
#endif
#endif

// [Apple] OS specific includes
#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning(disable : 4127) // condition expression is constant
#pragma warning(disable : 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning(disable : 5054) // operator '|': deprecated between enumerations of different types
#endif
#pragma warning(disable : 26451) // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to an 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning(disable : 26495) // [Static Analyzer] Variable 'XXX' is uninitialized. Always initialize a member variable (type.6).
#pragma warning(disable : 26812) // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option" // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas" // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast" // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal" // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral" // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors" // warning: declaration requires an exit-time destructor     // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors" // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wformat-pedantic" // warning: format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast" // warning: cast to 'void *' from smaller integer type 'int'
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant" // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion" // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion" // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage" // warning: 'xxx' is an unsafe pointer used for buffer access
#elif defined(__GNUC__)
// We disable -Wpragmas because GCC doesn't provide a has_warning equivalent and some forks/patches may not follow the warning/version association.
#pragma GCC diagnostic ignored "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wunused-function" // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast" // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat" // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion" // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion" // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral" // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow" // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#pragma GCC diagnostic ignored "-Wclass-memaccess" // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

// Debug options
#define IMGUI_DEBUG_NAV_SCORING 0 // Display navigation scoring preview when hovering items. Hold CTRL to display for all candidates. CTRL+Arrow to change last direction.
#define IMGUI_DEBUG_NAV_RECTS 0 // Display the reference navigation rectangle for each window

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY = 0.20f; // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY = 0.15f; // Time before the window list starts to appear

static const float NAV_ACTIVATE_HIGHLIGHT_TIMER = 0.10f; // Time to highlight an item activated by a shortcut.

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by backend)
static const float WINDOWS_HOVER_PADDING = 4.0f; // Extend outside window for hovering/resizing (maxxed with TouchPadding) and inside windows for borders. Affect FindHoveredWindow().
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f; // Reduce visual noise by only highlighting the border after a certain time.
static const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER = 0.70f; // Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.

// Tooltip offset
static const ImVec2 TOOLTIP_DEFAULT_OFFSET = ImVec2(16, 10); // Multiplied by g.Style.MouseCursorScale

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

static void SetCurrentWindow(ImGuiWindow *window);
static ImGuiWindow *CreateNewWindow(const char *name, ImGuiWindowFlags flags);
static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow *window);

static void AddWindowToSortBuffer(ImVector<ImGuiWindow *> *out_sorted_windows, ImGuiWindow *window);

// Settings
static void WindowSettingsHandler_ClearAll(ImGuiContext *, ImGuiSettingsHandler *);
static void *WindowSettingsHandler_ReadOpen(ImGuiContext *, ImGuiSettingsHandler *, const char *name);
static void WindowSettingsHandler_ReadLine(ImGuiContext *, ImGuiSettingsHandler *, void *entry, const char *line);
static void WindowSettingsHandler_ApplyAll(ImGuiContext *, ImGuiSettingsHandler *);
static void WindowSettingsHandler_WriteAll(ImGuiContext *, ImGuiSettingsHandler *, ImGuiTextBuffer *buf);

// Platform Dependents default implementation for ImGuiPlatformIO functions
static const char *Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext *ctx);
static void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext *ctx, const char *text);
static void Platform_SetImeDataFn_DefaultImpl(ImGuiContext *ctx, ImGuiViewport *viewport, ImGuiPlatformImeData *data);
static bool Platform_OpenInShellFn_DefaultImpl(ImGuiContext *ctx, const char *path);

namespace ImGui {
// Item
static void ItemHandleShortcut(ImGuiID id);

// Navigation
static void NavUpdate();
static void NavUpdateWindowing();
static void NavUpdateWindowingOverlay();
static void NavUpdateCancelRequest();
static void NavUpdateCreateMoveRequest();
static void NavUpdateCreateTabbingRequest();
static float NavUpdatePageUpPageDown();
static inline void NavUpdateAnyRequestFlag();
static void NavUpdateCreateWrappingRequest();
static void NavEndFrame();
static bool NavScoreItem(ImGuiNavItemData *result);
static void NavApplyItemToResult(ImGuiNavItemData *result);
static void NavProcessItem();
static void NavProcessItemForTabbingRequest(ImGuiID id, ImGuiItemFlags item_flags, ImGuiNavMoveFlags move_flags);
static ImVec2 NavCalcPreferredRefPos();
static void NavSaveLastChildNavWindowIntoParent(ImGuiWindow *nav_window);
static ImGuiWindow *NavRestoreLastChildNavWindow(ImGuiWindow *window);
static void NavRestoreLayer(ImGuiNavLayer layer);
static int FindWindowFocusIndex(ImGuiWindow *window);

// Error Checking and Debug Tools
static void ErrorCheckNewFrameSanityChecks();
static void ErrorCheckEndFrameSanityChecks();
static void UpdateDebugToolItemPicker();
static void UpdateDebugToolStackQueries();
static void UpdateDebugToolFlashStyleColor();

// Inputs
static void UpdateKeyboardInputs();
static void UpdateMouseInputs();
static void UpdateMouseWheel();
static void UpdateKeyRoutingTable(ImGuiKeyRoutingTable *rt);

// Misc
static void UpdateSettings();
static int UpdateWindowManualResize(ImGuiWindow *window, const ImVec2 &size_auto_fit, int *border_hovered, int *border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect &visibility_rect);
static void RenderWindowOuterBorders(ImGuiWindow *window);
static void RenderWindowDecorations(ImGuiWindow *window, const ImRect &title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size);
static void RenderWindowTitleBarContents(ImGuiWindow *window, const ImRect &title_bar_rect, const char *name, bool *p_open);
static void RenderDimmedBackgroundBehindWindow(ImGuiWindow *window, ImU32 col);
static void RenderDimmedBackgrounds();
static void SetLastItemDataForWindow(ImGuiWindow *window, const ImRect &rect);

// Viewports
const ImGuiID IMGUI_VIEWPORT_DEFAULT_ID = 0x11111111; // Using an arbitrary constant instead of e.g. ImHashStr("ViewportDefault", 0); so it's easier to spot in the debugger. The exact value doesn't matter.
static void UpdateViewportsNewFrame();

} //namespace ImGui

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// DLL users:
// - Heaps and globals are not shared across DLL boundaries!
// - You will need to call SetCurrentContext() + SetAllocatorFunctions() for each static/DLL boundary you are calling from.
// - Same applies for hot-reloading mechanisms that are reliant on reloading DLL (note that many hot-reloading mechanisms work without DLL).
// - Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
// - Confused? In a debugger: add GImGui to your watch window and notice how its value changes depending on your current location (which DLL boundary you are in).

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// - ImGui::CreateContext() will automatically set this pointer if it is NULL.
//   Change to a different context by calling ImGui::SetCurrentContext().
// - Important: Dear ImGui functions are not thread-safe because of this pointer.
//   If you want thread-safety to allow N threads to access N different contexts:
//   - Change this variable to use thread local storage so each thread can refer to a different context, in your imconfig.h:
//         struct ImGuiContext;
//         extern thread_local ImGuiContext* MyImGuiTLS;
//         #define GImGui MyImGuiTLS
//     And then define MyImGuiTLS in one of your cpp files. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//   - Future development aims to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
//   - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from a different namespace.
// - DLL users: read comments above.
#ifndef GImGui
ImGuiContext *GImGui = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
// - DLL users: read comments above.
#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
static void *MallocWrapper(size_t size, void *user_data) {
	IM_UNUSED(user_data);
	return malloc(size);
}
static void FreeWrapper(void *ptr, void *user_data) {
	IM_UNUSED(user_data);
	free(ptr);
}
#else
static void *MallocWrapper(size_t size, void *user_data) {
	IM_UNUSED(user_data);
	IM_UNUSED(size);
	IM_ASSERT(0);
	return NULL;
}
static void FreeWrapper(void *ptr, void *user_data) {
	IM_UNUSED(user_data);
	IM_UNUSED(ptr);
	IM_ASSERT(0);
}
#endif
static ImGuiMemAllocFunc GImAllocatorAllocFunc = MallocWrapper;
static ImGuiMemFreeFunc GImAllocatorFreeFunc = FreeWrapper;
static void *GImAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
//-----------------------------------------------------------------------------

ImGuiStyle::ImGuiStyle() {
	Alpha = 1.0f; // Global alpha applies to everything in Dear ImGui.
	DisabledAlpha = 0.60f; // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
	WindowPadding = ImVec2(8, 8); // Padding within a window
	WindowRounding = 0.0f; // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
	WindowBorderSize = 1.0f; // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	WindowMinSize = ImVec2(32, 32); // Minimum window size
	WindowTitleAlign = ImVec2(0.0f, 0.5f); // Alignment for title bar text
	WindowMenuButtonPosition = ImGuiDir_Left; // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
	ChildRounding = 0.0f; // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
	ChildBorderSize = 1.0f; // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	PopupRounding = 0.0f; // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
	PopupBorderSize = 1.0f; // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	FramePadding = ImVec2(4, 3); // Padding within a framed rectangle (used by most widgets)
	FrameRounding = 0.0f; // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
	FrameBorderSize = 0.0f; // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
	ItemSpacing = ImVec2(8, 4); // Horizontal and vertical spacing between widgets/lines
	ItemInnerSpacing = ImVec2(4, 4); // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
	CellPadding = ImVec2(4, 2); // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
	TouchExtraPadding = ImVec2(0, 0); // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	IndentSpacing = 21.0f; // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	ColumnsMinSpacing = 6.0f; // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
	ScrollbarSize = 14.0f; // Width of the vertical scrollbar, Height of the horizontal scrollbar
	ScrollbarRounding = 9.0f; // Radius of grab corners rounding for scrollbar
	GrabMinSize = 12.0f; // Minimum width/height of a grab box for slider/scrollbar
	GrabRounding = 0.0f; // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	LogSliderDeadzone = 4.0f; // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
	TabRounding = 4.0f; // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
	TabBorderSize = 0.0f; // Thickness of border around tabs.
	TabMinWidthForCloseButton = 0.0f; // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
	TabBarBorderSize = 1.0f; // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
	TabBarOverlineSize = 2.0f; // Thickness of tab-bar overline, which highlights the selected tab-bar.
	TableAngledHeadersAngle = 35.0f * (IM_PI / 180.0f); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).
	TableAngledHeadersTextAlign = ImVec2(0.5f, 0.0f); // Alignment of angled headers within the cell
	ColorButtonPosition = ImGuiDir_Right; // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
	ButtonTextAlign = ImVec2(0.5f, 0.5f); // Alignment of button text when button is larger than text.
	SelectableTextAlign = ImVec2(0.0f, 0.0f); // Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
	SeparatorTextBorderSize = 3.0f; // Thickness of border in SeparatorText()
	SeparatorTextAlign = ImVec2(0.0f, 0.5f); // Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
	SeparatorTextPadding = ImVec2(20.0f, 3.f); // Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
	DisplayWindowPadding = ImVec2(19, 19); // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
	DisplaySafeAreaPadding = ImVec2(3, 3); // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
	MouseCursorScale = 1.0f; // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
	AntiAliasedLines = true; // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
	AntiAliasedLinesUseTex = true; // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
	AntiAliasedFill = true; // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
	CurveTessellationTol = 1.25f; // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
	CircleTessellationMaxError = 0.30f; // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.

	// Behaviors
	HoverStationaryDelay = 0.15f; // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
	HoverDelayShort = 0.15f; // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
	HoverDelayNormal = 0.40f; // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
	HoverFlagsForTooltipMouse = ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_AllowWhenDisabled; // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
	HoverFlagsForTooltipNav = ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_AllowWhenDisabled; // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.

	// Default theme
	ImGui::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
void ImGuiStyle::ScaleAllSizes(float scale_factor) {
	WindowPadding = ImTrunc(WindowPadding * scale_factor);
	WindowRounding = ImTrunc(WindowRounding * scale_factor);
	WindowMinSize = ImTrunc(WindowMinSize * scale_factor);
	ChildRounding = ImTrunc(ChildRounding * scale_factor);
	PopupRounding = ImTrunc(PopupRounding * scale_factor);
	FramePadding = ImTrunc(FramePadding * scale_factor);
	FrameRounding = ImTrunc(FrameRounding * scale_factor);
	ItemSpacing = ImTrunc(ItemSpacing * scale_factor);
	ItemInnerSpacing = ImTrunc(ItemInnerSpacing * scale_factor);
	CellPadding = ImTrunc(CellPadding * scale_factor);
	TouchExtraPadding = ImTrunc(TouchExtraPadding * scale_factor);
	IndentSpacing = ImTrunc(IndentSpacing * scale_factor);
	ColumnsMinSpacing = ImTrunc(ColumnsMinSpacing * scale_factor);
	ScrollbarSize = ImTrunc(ScrollbarSize * scale_factor);
	ScrollbarRounding = ImTrunc(ScrollbarRounding * scale_factor);
	GrabMinSize = ImTrunc(GrabMinSize * scale_factor);
	GrabRounding = ImTrunc(GrabRounding * scale_factor);
	LogSliderDeadzone = ImTrunc(LogSliderDeadzone * scale_factor);
	TabRounding = ImTrunc(TabRounding * scale_factor);
	TabMinWidthForCloseButton = (TabMinWidthForCloseButton != FLT_MAX) ? ImTrunc(TabMinWidthForCloseButton * scale_factor) : FLT_MAX;
	TabBarOverlineSize = ImTrunc(TabBarOverlineSize * scale_factor);
	SeparatorTextPadding = ImTrunc(SeparatorTextPadding * scale_factor);
	DisplayWindowPadding = ImTrunc(DisplayWindowPadding * scale_factor);
	DisplaySafeAreaPadding = ImTrunc(DisplaySafeAreaPadding * scale_factor);
	MouseCursorScale = ImTrunc(MouseCursorScale * scale_factor);
}

ImGuiIO::ImGuiIO() {
	// Most fields are initialized with zero
	memset(this, 0, sizeof(*this));
	IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);

	// Settings
	ConfigFlags = ImGuiConfigFlags_None;
	BackendFlags = ImGuiBackendFlags_None;
	DisplaySize = ImVec2(-1.0f, -1.0f);
	DeltaTime = 1.0f / 60.0f;
	IniSavingRate = 5.0f;
	IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
	LogFilename = "imgui_log.txt";
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
	for (int i = 0; i < ImGuiKey_COUNT; i++)
		KeyMap[i] = -1;
#endif
	UserData = NULL;

	Fonts = NULL;
	FontGlobalScale = 1.0f;
	FontDefault = NULL;
	FontAllowUserScaling = false;
	DisplayFramebufferScale = ImVec2(1.0f, 1.0f);

	// Miscellaneous options
	MouseDrawCursor = false;
#ifdef __APPLE__
	ConfigMacOSXBehaviors = true; // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
	ConfigMacOSXBehaviors = false;
#endif
	ConfigNavSwapGamepadButtons = false;
	ConfigInputTrickleEventQueue = true;
	ConfigInputTextCursorBlink = true;
	ConfigInputTextEnterKeepActive = false;
	ConfigDragClickToInputText = false;
	ConfigWindowsResizeFromEdges = true;
	ConfigWindowsMoveFromTitleBarOnly = false;
	ConfigMemoryCompactTimer = 60.0f;
	ConfigDebugBeginReturnValueOnce = false;
	ConfigDebugBeginReturnValueLoop = false;

	// Inputs Behaviors
	MouseDoubleClickTime = 0.30f;
	MouseDoubleClickMaxDist = 6.0f;
	MouseDragThreshold = 6.0f;
	KeyRepeatDelay = 0.275f;
	KeyRepeatRate = 0.050f;

	// Platform Functions
	// Note: Initialize() will setup default clipboard/ime handlers.
	BackendPlatformName = BackendRendererName = NULL;
	BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;

	// Input (NB: we already have memset zero the entire structure!)
	MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
	MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
	MouseSource = ImGuiMouseSource_Mouse;
	for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++)
		MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
	for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) {
		KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f;
	}
	AppAcceptingEvents = true;
	BackendUsingLegacyKeyArrays = (ImS8)-1;
	BackendUsingLegacyNavInputArray = true; // assume using legacy array until proven wrong
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
// FIXME: Should in theory be called "AddCharacterEvent()" to be consistent with new API
void ImGuiIO::AddInputCharacter(unsigned int c) {
	IM_ASSERT(Ctx != NULL);
	ImGuiContext &g = *Ctx;
	if (c == 0 || !AppAcceptingEvents)
		return;

	ImGuiInputEvent e;
	e.Type = ImGuiInputEventType_Text;
	e.Source = ImGuiInputSource_Keyboard;
	e.EventId = g.InputEventsNextEventId++;
	e.Text.Char = c;
	g.InputEventsQueue.push_back(e);
}

// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
// we should save the high surrogate.
void ImGuiIO::AddInputCharacterUTF16(ImWchar16 c) {
	if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
		return;

	if ((c & 0xFC00) == 0xD800) // High surrogate, must save
	{
		if (InputQueueSurrogate != 0)
			AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
		InputQueueSurrogate = c;
		return;
	}

	ImWchar cp = c;
	if (InputQueueSurrogate != 0) {
		if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
		{
			AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
		} else {
#if IM_UNICODE_CODEPOINT_MAX == 0xFFFF
			cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
#else
			cp = (ImWchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);
#endif
		}

		InputQueueSurrogate = 0;
	}
	AddInputCharacter((unsigned)cp);
}

void ImGuiIO::AddInputCharactersUTF8(const char *utf8_chars) {
	if (!AppAcceptingEvents)
		return;
	while (*utf8_chars != 0) {
		unsigned int c = 0;
		utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
		AddInputCharacter(c);
	}
}

// Clear all incoming events.
void ImGuiIO::ClearEventsQueue() {
	IM_ASSERT(Ctx != NULL);
	ImGuiContext &g = *Ctx;
	g.InputEventsQueue.clear();
}

// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
void ImGuiIO::ClearInputKeys() {
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
	memset(KeysDown, 0, sizeof(KeysDown));
#endif
	for (int n = 0; n < IM_ARRAYSIZE(KeysData); n++) {
		if (ImGui::IsMouseKey((ImGuiKey)(n + ImGuiKey_KeysData_OFFSET)))
			continue;
		KeysData[n].Down = false;
		KeysData[n].DownDuration = -1.0f;
		KeysData[n].DownDurationPrev = -1.0f;
	}
	KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
	KeyMods = ImGuiMod_None;
	InputQueueCharacters.resize(0); // Behavior of old ClearInputCharacters().
}

void ImGuiIO::ClearInputMouse() {
	for (ImGuiKey key = ImGuiKey_Mouse_BEGIN; key < ImGuiKey_Mouse_END; key = (ImGuiKey)(key + 1)) {
		ImGuiKeyData *key_data = &KeysData[key - ImGuiKey_KeysData_OFFSET];
		key_data->Down = false;
		key_data->DownDuration = -1.0f;
		key_data->DownDurationPrev = -1.0f;
	}
	MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
	for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++) {
		MouseDown[n] = false;
		MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
	}
	MouseWheel = MouseWheelH = 0.0f;
}

// Removed this as it is ambiguous/misleading and generally incorrect to use with the existence of a higher-level input queue.
// Current frame character buffer is now also cleared by ClearInputKeys().
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
void ImGuiIO::ClearInputCharacters() {
	InputQueueCharacters.resize(0);
}
#endif

static ImGuiInputEvent *FindLatestInputEvent(ImGuiContext *ctx, ImGuiInputEventType type, int arg = -1) {
	ImGuiContext &g = *ctx;
	for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--) {
		ImGuiInputEvent *e = &g.InputEventsQueue[n];
		if (e->Type != type)
			continue;
		if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
			continue;
		if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
			continue;
		return e;
	}
	return NULL;
}

// Queue a new key down/up event.
// - ImGuiKey key:       Translated key (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
// - bool down:          Is the key down? use false to signify a key release.
// - float analog_value: 0.0f..1.0f
// IMPORTANT: THIS FUNCTION AND OTHER "ADD" GRABS THE CONTEXT FROM OUR INSTANCE.
// WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULFILLING THIS, WHICH IS WHY GetKeyData() HAS AN EXPLICIT CONTEXT.
void ImGuiIO::AddKeyAnalogEvent(ImGuiKey key, bool down, float analog_value) {
	//if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
	IM_ASSERT(Ctx != NULL);
	if (key == ImGuiKey_None || !AppAcceptingEvents)
		return;
	ImGuiContext &g = *Ctx;
	IM_ASSERT(ImGui::IsNamedKeyOrMod(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
	IM_ASSERT(ImGui::IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.

	// MacOS: swap Cmd(Super) and Ctrl
	if (g.IO.ConfigMacOSXBehaviors) {
		if (key == ImGuiMod_Super) {
			key = ImGuiMod_Ctrl;
		} else if (key == ImGuiMod_Ctrl) {
			key = ImGuiMod_Super;
		} else if (key == ImGuiKey_LeftSuper) {
			key = ImGuiKey_LeftCtrl;
		} else if (key == ImGuiKey_RightSuper) {
			key = ImGuiKey_RightCtrl;
		} else if (key == ImGuiKey_LeftCtrl) {
			key = ImGuiKey_LeftSuper;
		} else if (key == ImGuiKey_RightCtrl) {
			key = ImGuiKey_RightSuper;
		}
	}

	// Verify that backend isn't mixing up using new io.AddKeyEvent() api and old io.KeysDown[] + io.KeyMap[] data.
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
	IM_ASSERT((BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
	if (BackendUsingLegacyKeyArrays == -1)
		for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
			IM_ASSERT(KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
	BackendUsingLegacyKeyArrays = 0;
#endif
	if (ImGui::IsGamepadKey(key))
		BackendUsingLegacyNavInputArray = false;

	// Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
	const ImGuiInputEvent *latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)key);
	const ImGuiKeyData *key_data = ImGui::GetKeyData(&g, key);
	const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
	const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
	if (latest_key_down == down && latest_key_analog == analog_value)
		return;

	// Add event
	ImGuiInputEvent e;
	e.Type = ImGuiInputEventType_Key;
	e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
	e.EventId = g.InputEventsNextEventId++;
	e.Key.Key = key;
	e.Key.Down = down;
	e.Key.AnalogValue = analog_value;
	g.InputEventsQueue.push_back(e);
}

void ImGuiIO::AddKeyEvent(ImGuiKey key, bool down) {
	if (!AppAcceptingEvents)
		return;
	AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
}

// [Optional] Call after AddKeyEvent().
// Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX() functions with native indices.
// If you are writing a backend in 2022 or don't use IsKeyXXX() with native values that are not ImGuiKey values, you can avoid calling this.
void ImGuiIO::SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index) {
	if (key == ImGuiKey_None)
		return;
	IM_ASSERT(ImGui::IsNamedKey(key)); // >= 512
	IM_ASSERT(native_legacy_index == -1 || ImGui::IsLegacyKey((ImGuiKey)native_legacy_index)); // >= 0 && <= 511
	IM_UNUSED(native_keycode); // Yet unused
	IM_UNUSED(native_scancode); // Yet unused

	// Build native->imgui map so old user code can still call key functions with native 0..511 values.
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
	const int legacy_key = (native_legacy_index != -1) ? native_legacy_index : native_keycode;
	if (!ImGui::IsLegacyKey((ImGuiKey)legacy_key))
		return;
	KeyMap[legacy_key] = key;
	KeyMap[key] = legacy_key;
#else
	IM_UNUSED(key);
	IM_UNUSED(native_legacy_index);
#endif
}

// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
void ImGuiIO::SetAppAcceptingEvents(bool accepting_events) {
	AppAcceptingEvents = accepting_events;
}

// Queue a mouse move event
void ImGuiIO::AddMousePosEvent(float x, float y) {
	IM_ASSERT(Ctx != NULL);
	ImGuiContext &g = *Ctx;
	if (!AppAcceptingEvents)
		return;

	// Apply same flooring as UpdateMouseInputs()
	ImVec2 pos((x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y);

	// Filter duplicate
	const ImGuiInputEvent *latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MousePos);
	const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
	if (latest_pos.x == pos.x && latest_pos.y == pos.y)
		return;

	ImGuiInputEvent e;
	e.Type = ImGuiInputEventType_MousePos;
	e.Source = ImGuiInputSource_Mouse;
	e.EventId = g.InputEventsNextEventId++;
	e.MousePos.PosX = pos.x;
	e.MousePos.PosY = pos.y;
	e.MousePos.MouseSource = g.InputEventsNextMouseSource;
	g.InputEventsQueue.push_back(e);
}

void ImGuiIO::AddMouseButtonEvent(int mouse_button, bool down) {
	IM_ASSERT(Ctx != NULL);
	ImGuiContext &g = *Ctx;
	IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);
	if (!AppAcceptingEvents)
		return;

	// On MacOS X: Convert Ctrl(Super)+Left click into Right-click: handle held button.
	if (ConfigMacOSXBehaviors && mouse_button == 0 && MouseCtrlLeftAsRightClick) {
		// Order of both statements matterns: this event will still release mouse button 1
		mouse_button = 1;
		if (!down)
			MouseCtrlLeftAsRightClick = false;
	}

	// Filter duplicate
	const ImGuiInputEvent *latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseButton, (int)mouse_button);
	const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
	if (latest_button_down == down)
		return;

	// On MacOS X: Convert Ctrl(Super)+Left click into Right-click.
	// - Note that this is actual physical Ctrl which is ImGuiMod_Super for us.
	// - At this point we want from !down to down, so this is handling the initial press.
	if (ConfigMacOSXBehaviors && mouse_button == 0 && down) {
		const ImGuiInputEvent *latest_super_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)ImGuiMod_Super);
		if (latest_super_event ? latest_super_event->Key.Down : g.IO.KeySuper) {
			IMGUI_DEBUG_LOG_IO("[io] Super+Left Click aliased into Right Click\n");
			MouseCtrlLeftAsRightClick = true;
			AddMouseButtonEvent(1, true); // This is just quicker to write that passing through, as we need to filter duplicate again.
			return;
		}
	}

	ImGuiInputEvent e;
	e.Type = ImGuiInputEventType_MouseButton;
	e.Source = ImGuiInputSource_Mouse;
	e.EventId = g.InputEventsNextEventId++;
	e.MouseButton.Button = mouse_button;
	e.MouseButton.Down = down;
	e.MouseButton.MouseSource = g.InputEventsNextMouseSource;
	g.InputEventsQueue.push_back(e);
}

// Queue a mouse wheel event (some mouse/API may only have a Y component)
void ImGuiIO::AddMouseWheelEvent(float wheel_x, float wheel_y) {
	IM_ASSERT(Ctx != NULL);
	ImGuiContext &g = *Ctx;

	// Filter duplicate (unlike most events, wheel values are relative and easy to filter)
	if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))
		return;

	ImGuiInputEvent e;
	e.Type = ImGuiInputEventType_MouseWheel;
	e.Source = ImGuiInputSource_Mouse;
	e.EventId = g.InputEventsNextEventId++;
	e.MouseWheel.WheelX = wheel_x;
	e.MouseWheel.WheelY = wheel_y;
	e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;
	g.InputEventsQueue.push_back(e);
}

// This is not a real event, the data is latched in order to be stored in actual Mouse events.
// This is so that duplicate events (e.g. Windows sending extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source changes.
void ImGuiIO::AddMouseSourceEvent(ImGuiMouseSource source) {
	IM_ASSERT(Ctx != NULL);
	ImGuiContext &g = *Ctx;
	g.InputEventsNextMouseSource = source;
}

void ImGuiIO::AddFocusEvent(bool focused) {
	IM_ASSERT(Ctx != NULL);
	ImGuiContext &g = *Ctx;

	// Filter duplicate
	const ImGuiInputEvent *latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Focus);
	const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
	if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))
		return;

	ImGuiInputEvent e;
	e.Type = ImGuiInputEventType_Focus;
	e.EventId = g.InputEventsNextEventId++;
	e.AppFocused.Focused = focused;
	g.InputEventsQueue.push_back(e);
}

ImGuiPlatformIO::ImGuiPlatformIO() {
	// Most fields are initialized with zero
	memset(this, 0, sizeof(*this));
	Platform_LocaleDecimalPoint = '.';
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
//-----------------------------------------------------------------------------

ImVec2 ImBezierCubicClosestPoint(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, const ImVec2 &p, int num_segments) {
	IM_ASSERT(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()
	ImVec2 p_last = p1;
	ImVec2 p_closest;
	float p_closest_dist2 = FLT_MAX;
	float t_step = 1.0f / (float)num_segments;
	for (int i_step = 1; i_step <= num_segments; i_step++) {
		ImVec2 p_current = ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step);
		ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
		float dist2 = ImLengthSqr(p - p_line);
		if (dist2 < p_closest_dist2) {
			p_closest = p_line;
			p_closest_dist2 = dist2;
		}
		p_last = p_current;
	}
	return p_closest;
}

// Closely mimics PathBezierToCasteljau() in imgui_draw.cpp
static void ImBezierCubicClosestPointCasteljauStep(const ImVec2 &p, ImVec2 &p_closest, ImVec2 &p_last, float &p_closest_dist2, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level) {
	float dx = x4 - x1;
	float dy = y4 - y1;
	float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
	float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
	d2 = (d2 >= 0) ? d2 : -d2;
	d3 = (d3 >= 0) ? d3 : -d3;
	if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy)) {
		ImVec2 p_current(x4, y4);
		ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
		float dist2 = ImLengthSqr(p - p_line);
		if (dist2 < p_closest_dist2) {
			p_closest = p_line;
			p_closest_dist2 = dist2;
		}
		p_last = p_current;
	} else if (level < 10) {
		float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
		float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
		float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;
		float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
		float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;
		float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;
		ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
		ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
	}
}

// tess_tol is generally the same value you would find in ImGui::GetStyle().CurveTessellationTol
// Because those ImXXX functions are lower-level than ImGui:: we cannot access this value automatically.
ImVec2 ImBezierCubicClosestPointCasteljau(const ImVec2 &p1, const ImVec2 &p2, const ImVec2 &p3, const ImVec2 &p4, const ImVec2 &p, float tess_tol) {
	IM_ASSERT(tess_tol > 0.0f);
	ImVec2 p_last = p1;
	ImVec2 p_closest;
	float p_closest_dist2 = FLT_MAX;
	ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0);
	return p_closest;
}

ImVec2 ImLineClosestPoint(const ImVec2 &a, const ImVec2 &b, const ImVec2 &p) {
	ImVec2 ap = p - a;
	ImVec2 ab_dir = b - a;
	float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
	if (dot < 0.0f)
		return a;
	float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
	if (dot > ab_len_sqr)
		return b;
	return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c, const ImVec2 &p) {
	bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
	bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
	bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
	return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c, const ImVec2 &p, float &out_u, float &out_v, float &out_w) {
	ImVec2 v0 = b - a;
	ImVec2 v1 = c - a;
	ImVec2 v2 = p - a;
	const float denom = v0.x * v1.y - v1.x * v0.y;
	out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
	out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
	out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint(const ImVec2 &a, const ImVec2 &b, const ImVec2 &c, const ImVec2 &p) {
	ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
	ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
	ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
	float dist2_ab = ImLengthSqr(p - proj_ab);
	float dist2_bc = ImLengthSqr(p - proj_bc);
	float dist2_ca = ImLengthSqr(p - proj_ca);
	float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
	if (m == dist2_ab)
		return proj_ab;
	if (m == dist2_bc)
		return proj_bc;
	return proj_ca;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
//-----------------------------------------------------------------------------

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
int ImStricmp(const char *str1, const char *str2) {
	int d;
	while ((d = ImToUpper(*str2) - ImToUpper(*str1)) == 0 && *str1) {
		str1++;
		str2++;
	}
	return d;
}

int ImStrnicmp(const char *str1, const char *str2, size_t count) {
	int d = 0;
	while (count > 0 && (d = ImToUpper(*str2) - ImToUpper(*str1)) == 0 && *str1) {
		str1++;
		str2++;
		count--;
	}
	return d;
}

void ImStrncpy(char *dst, const char *src, size_t count) {
	if (count < 1)
		return;
	if (count > 1)
		strncpy(dst, src, count - 1);
	dst[count - 1] = 0;
}

char *ImStrdup(const char *str) {
	size_t len = strlen(str);
	void *buf = IM_ALLOC(len + 1);
	return (char *)memcpy(buf, (const void *)str, len + 1);
}

char *ImStrdupcpy(char *dst, size_t *p_dst_size, const char *src) {
	size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
	size_t src_size = strlen(src) + 1;
	if (dst_buf_size < src_size) {
		IM_FREE(dst);
		dst = (char *)IM_ALLOC(src_size);
		if (p_dst_size)
			*p_dst_size = src_size;
	}
	return (char *)memcpy(dst, (const void *)src, src_size);
}

const char *ImStrchrRange(const char *str, const char *str_end, char c) {
	const char *p = (const char *)memchr(str, (int)c, str_end - str);
	return p;
}

int ImStrlenW(const ImWchar *str) {
	//return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
	int n = 0;
	while (*str++)
		n++;
	return n;
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
const char *ImStreolRange(const char *str, const char *str_end) {
	const char *p = (const char *)memchr(str, '\n', str_end - str);
	return p ? p : str_end;
}

const ImWchar *ImStrbolW(const ImWchar *buf_mid_line, const ImWchar *buf_begin) // find beginning-of-line
{
	while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
		buf_mid_line--;
	return buf_mid_line;
}

const char *ImStristr(const char *haystack, const char *haystack_end, const char *needle, const char *needle_end) {
	if (!needle_end)
		needle_end = needle + strlen(needle);

	const char un0 = (char)ImToUpper(*needle);
	while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end)) {
		if (ImToUpper(*haystack) == un0) {
			const char *b = needle + 1;
			for (const char *a = haystack + 1; b < needle_end; a++, b++)
				if (ImToUpper(*a) != ImToUpper(*b))
					break;
			if (b == needle_end)
				return haystack;
		}
		haystack++;
	}
	return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
void ImStrTrimBlanks(char *buf) {
	char *p = buf;
	while (p[0] == ' ' || p[0] == '\t') // Leading blanks
		p++;
	char *p_start = p;
	while (*p != 0) // Find end of string
		p++;
	while (p > p_start && (p[-1] == ' ' || p[-1] == '\t')) // Trailing blanks
		p--;
	if (p_start != buf) // Copy memory if we had leading blanks
		memmove(buf, p_start, p - p_start);
	buf[p - p_start] = 0; // Zero terminate
}

const char *ImStrSkipBlank(const char *str) {
	while (str[0] == ' ' || str[0] == '\t')
		str++;
	return str;
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

// We support stb_sprintf which is much faster (see: https://github.com/nothings/stb/blob/master/stb_sprintf.h)
// You may set IMGUI_USE_STB_SPRINTF to use our default wrapper, or set IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
// and setup the wrapper yourself. (FIXME-OPT: Some of our high-level operations such as ImGuiTextBuffer::appendfv() are
// designed using two-passes worst case, which probably could be improved using the stbsp_vsprintfcb() function.)
#ifdef IMGUI_USE_STB_SPRINTF
#ifndef IMGUI_DISABLE_STB_SPRINTF_IMPLEMENTATION
#define STB_SPRINTF_IMPLEMENTATION
#endif
#ifdef IMGUI_STB_SPRINTF_FILENAME
#include IMGUI_STB_SPRINTF_FILENAME
#else
#include "stb_sprintf.h"
#endif
#endif // #ifdef IMGUI_USE_STB_SPRINTF

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

int ImFormatString(char *buf, size_t buf_size, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
#ifdef IMGUI_USE_STB_SPRINTF
	int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
	int w = vsnprintf(buf, buf_size, fmt, args);
#endif
	va_end(args);
	if (buf == NULL)
		return w;
	if (w == -1 || w >= (int)buf_size)
		w = (int)buf_size - 1;
	buf[w] = 0;
	return w;
}

int ImFormatStringV(char *buf, size_t buf_size, const char *fmt, va_list args) {
#ifdef IMGUI_USE_STB_SPRINTF
	int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
	int w = vsnprintf(buf, buf_size, fmt, args);
#endif
	if (buf == NULL)
		return w;
	if (w == -1 || w >= (int)buf_size)
		w = (int)buf_size - 1;
	buf[w] = 0;
	return w;
}
#endif // #ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

void ImFormatStringToTempBuffer(const char **out_buf, const char **out_buf_end, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	ImFormatStringToTempBufferV(out_buf, out_buf_end, fmt, args);
	va_end(args);
}

// FIXME: Should rework API toward allowing multiple in-flight temp buffers (easier and safer for caller)
// by making the caller acquire a temp buffer token, with either explicit or destructor release, e.g.
//  ImGuiTempBufferToken token;
//  ImFormatStringToTempBuffer(token, ...);
void ImFormatStringToTempBufferV(const char **out_buf, const char **out_buf_end, const char *fmt, va_list args) {
	ImGuiContext &g = *GImGui;
	if (fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0) {
		const char *buf = va_arg(args, const char *); // Skip formatting when using "%s"
		if (buf == NULL)
			buf = "(null)";
		*out_buf = buf;
		if (out_buf_end) {
			*out_buf_end = buf + strlen(buf);
		}
	} else if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '*' && fmt[3] == 's' && fmt[4] == 0) {
		int buf_len = va_arg(args, int); // Skip formatting when using "%.*s"
		const char *buf = va_arg(args, const char *);
		if (buf == NULL) {
			buf = "(null)";
			buf_len = ImMin(buf_len, 6);
		}
		*out_buf = buf;
		*out_buf_end = buf + buf_len; // Disallow not passing 'out_buf_end' here. User is expected to use it.
	} else {
		int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
		*out_buf = g.TempBuffer.Data;
		if (out_buf_end) {
			*out_buf_end = g.TempBuffer.Data + buf_len;
		}
	}
}

// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
static const ImU32 GCrc32LookupTable[256] = {
	0x00000000,
	0x77073096,
	0xEE0E612C,
	0x990951BA,
	0x076DC419,
	0x706AF48F,
	0xE963A535,
	0x9E6495A3,
	0x0EDB8832,
	0x79DCB8A4,
	0xE0D5E91E,
	0x97D2D988,
	0x09B64C2B,
	0x7EB17CBD,
	0xE7B82D07,
	0x90BF1D91,
	0x1DB71064,
	0x6AB020F2,
	0xF3B97148,
	0x84BE41DE,
	0x1ADAD47D,
	0x6DDDE4EB,
	0xF4D4B551,
	0x83D385C7,
	0x136C9856,
	0x646BA8C0,
	0xFD62F97A,
	0x8A65C9EC,
	0x14015C4F,
	0x63066CD9,
	0xFA0F3D63,
	0x8D080DF5,
	0x3B6E20C8,
	0x4C69105E,
	0xD56041E4,
	0xA2677172,
	0x3C03E4D1,
	0x4B04D447,
	0xD20D85FD,
	0xA50AB56B,
	0x35B5A8FA,
	0x42B2986C,
	0xDBBBC9D6,
	0xACBCF940,
	0x32D86CE3,
	0x45DF5C75,
	0xDCD60DCF,
	0xABD13D59,
	0x26D930AC,
	0x51DE003A,
	0xC8D75180,
	0xBFD06116,
	0x21B4F4B5,
	0x56B3C423,
	0xCFBA9599,
	0xB8BDA50F,
	0x2802B89E,
	0x5F058808,
	0xC60CD9B2,
	0xB10BE924,
	0x2F6F7C87,
	0x58684C11,
	0xC1611DAB,
	0xB6662D3D,
	0x76DC4190,
	0x01DB7106,
	0x98D220BC,
	0xEFD5102A,
	0x71B18589,
	0x06B6B51F,
	0x9FBFE4A5,
	0xE8B8D433,
	0x7807C9A2,
	0x0F00F934,
	0x9609A88E,
	0xE10E9818,
	0x7F6A0DBB,
	0x086D3D2D,
	0x91646C97,
	0xE6635C01,
	0x6B6B51F4,
	0x1C6C6162,
	0x856530D8,
	0xF262004E,
	0x6C0695ED,
	0x1B01A57B,
	0x8208F4C1,
	0xF50FC457,
	0x65B0D9C6,
	0x12B7E950,
	0x8BBEB8EA,
	0xFCB9887C,
	0x62DD1DDF,
	0x15DA2D49,
	0x8CD37CF3,
	0xFBD44C65,
	0x4DB26158,
	0x3AB551CE,
	0xA3BC0074,
	0xD4BB30E2,
	0x4ADFA541,
	0x3DD895D7,
	0xA4D1C46D,
	0xD3D6F4FB,
	0x4369E96A,
	0x346ED9FC,
	0xAD678846,
	0xDA60B8D0,
	0x44042D73,
	0x33031DE5,
	0xAA0A4C5F,
	0xDD0D7CC9,
	0x5005713C,
	0x270241AA,
	0xBE0B1010,
	0xC90C2086,
	0x5768B525,
	0x206F85B3,
	0xB966D409,
	0xCE61E49F,
	0x5EDEF90E,
	0x29D9C998,
	0xB0D09822,
	0xC7D7A8B4,
	0x59B33D17,
	0x2EB40D81,
	0xB7BD5C3B,
	0xC0BA6CAD,
	0xEDB88320,
	0x9ABFB3B6,
	0x03B6E20C,
	0x74B1D29A,
	0xEAD54739,
	0x9DD277AF,
	0x04DB2615,
	0x73DC1683,
	0xE3630B12,
	0x94643B84,
	0x0D6D6A3E,
	0x7A6A5AA8,
	0xE40ECF0B,
	0x9309FF9D,
	0x0A00AE27,
	0x7D079EB1,
	0xF00F9344,
	0x8708A3D2,
	0x1E01F268,
	0x6906C2FE,
	0xF762575D,
	0x806567CB,
	0x196C3671,
	0x6E6B06E7,
	0xFED41B76,
	0x89D32BE0,
	0x10DA7A5A,
	0x67DD4ACC,
	0xF9B9DF6F,
	0x8EBEEFF9,
	0x17B7BE43,
	0x60B08ED5,
	0xD6D6A3E8,
	0xA1D1937E,
	0x38D8C2C4,
	0x4FDFF252,
	0xD1BB67F1,
	0xA6BC5767,
	0x3FB506DD,
	0x48B2364B,
	0xD80D2BDA,
	0xAF0A1B4C,
	0x36034AF6,
	0x41047A60,
	0xDF60EFC3,
	0xA867DF55,
	0x316E8EEF,
	0x4669BE79,
	0xCB61B38C,
	0xBC66831A,
	0x256FD2A0,
	0x5268E236,
	0xCC0C7795,
	0xBB0B4703,
	0x220216B9,
	0x5505262F,
	0xC5BA3BBE,
	0xB2BD0B28,
	0x2BB45A92,
	0x5CB36A04,
	0xC2D7FFA7,
	0xB5D0CF31,
	0x2CD99E8B,
	0x5BDEAE1D,
	0x9B64C2B0,
	0xEC63F226,
	0x756AA39C,
	0x026D930A,
	0x9C0906A9,
	0xEB0E363F,
	0x72076785,
	0x05005713,
	0x95BF4A82,
	0xE2B87A14,
	0x7BB12BAE,
	0x0CB61B38,
	0x92D28E9B,
	0xE5D5BE0D,
	0x7CDCEFB7,
	0x0BDBDF21,
	0x86D3D2D4,
	0xF1D4E242,
	0x68DDB3F8,
	0x1FDA836E,
	0x81BE16CD,
	0xF6B9265B,
	0x6FB077E1,
	0x18B74777,
	0x88085AE6,
	0xFF0F6A70,
	0x66063BCA,
	0x11010B5C,
	0x8F659EFF,
	0xF862AE69,
	0x616BFFD3,
	0x166CCF45,
	0xA00AE278,
	0xD70DD2EE,
	0x4E048354,
	0x3903B3C2,
	0xA7672661,
	0xD06016F7,
	0x4969474D,
	0x3E6E77DB,
	0xAED16A4A,
	0xD9D65ADC,
	0x40DF0B66,
	0x37D83BF0,
	0xA9BCAE53,
	0xDEBB9EC5,
	0x47B2CF7F,
	0x30B5FFE9,
	0xBDBDF21C,
	0xCABAC28A,
	0x53B39330,
	0x24B4A3A6,
	0xBAD03605,
	0xCDD70693,
	0x54DE5729,
	0x23D967BF,
	0xB3667A2E,
	0xC4614AB8,
	0x5D681B02,
	0x2A6F2B94,
	0xB40BBE37,
	0xC30C8EA1,
	0x5A05DF1B,
	0x2D02EF8D,
};

// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImGuiID ImHashData(const void *data_p, size_t data_size, ImGuiID seed) {
	ImU32 crc = ~seed;
	const unsigned char *data = (const unsigned char *)data_p;
	const ImU32 *crc32_lut = GCrc32LookupTable;
	while (data_size-- != 0)
		crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
	return ~crc;
}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImGuiID ImHashStr(const char *data_p, size_t data_size, ImGuiID seed) {
	seed = ~seed;
	ImU32 crc = seed;
	const unsigned char *data = (const unsigned char *)data_p;
	const ImU32 *crc32_lut = GCrc32LookupTable;
	if (data_size != 0) {
		while (data_size-- != 0) {
			unsigned char c = *data++;
			if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
				crc = seed;
			crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
		}
	} else {
		while (unsigned char c = *data++) {
			if (c == '#' && data[0] == '#' && data[1] == '#')
				crc = seed;
			crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
		}
	}
	return ~crc;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (File functions)
//-----------------------------------------------------------------------------

// Default file functions
#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

ImFileHandle ImFileOpen(const char *filename, const char *mode) {
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(__CYGWIN__) && !defined(__GNUC__)
	// We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames.
	// Previously we used ImTextCountCharsFromUtf8/ImTextStrFromUtf8 here but we now need to support ImWchar16 and ImWchar32!
	const int filename_wsize = ::MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);
	const int mode_wsize = ::MultiByteToWideChar(CP_UTF8, 0, mode, -1, NULL, 0);

	// Use stack buffer if possible, otherwise heap buffer. Sizes include zero terminator.
	// We don't rely on current ImGuiContext as this is implied to be a helper function which doesn't depend on it (see #7314).
	wchar_t local_temp_stack[FILENAME_MAX];
	ImVector<wchar_t> local_temp_heap;
	if (filename_wsize + mode_wsize > IM_ARRAYSIZE(local_temp_stack))
		local_temp_heap.resize(filename_wsize + mode_wsize);
	wchar_t *filename_wbuf = local_temp_heap.Data ? local_temp_heap.Data : local_temp_stack;
	wchar_t *mode_wbuf = filename_wbuf + filename_wsize;
	::MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_wbuf, filename_wsize);
	::MultiByteToWideChar(CP_UTF8, 0, mode, -1, mode_wbuf, mode_wsize);
	return ::_wfopen(filename_wbuf, mode_wbuf);
#else
	return fopen(filename, mode);
#endif
}

// We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
bool ImFileClose(ImFileHandle f) {
	return fclose(f) == 0;
}
ImU64 ImFileGetSize(ImFileHandle f) {
	long off = 0, sz = 0;
	return ((off = ftell(f)) != -1 && !fseek(f, 0, SEEK_END) && (sz = ftell(f)) != -1 && !fseek(f, off, SEEK_SET)) ? (ImU64)sz : (ImU64)-1;
}
ImU64 ImFileRead(void *data, ImU64 sz, ImU64 count, ImFileHandle f) {
	return fread(data, (size_t)sz, (size_t)count, f);
}
ImU64 ImFileWrite(const void *data, ImU64 sz, ImU64 count, ImFileHandle f) {
	return fwrite(data, (size_t)sz, (size_t)count, f);
}
#endif // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

// Helper: Load file content into memory
// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
// This can't really be used with "rt" because fseek size won't match read size.
void *ImFileLoadToMemory(const char *filename, const char *mode, size_t *out_file_size, int padding_bytes) {
	IM_ASSERT(filename && mode);
	if (out_file_size)
		*out_file_size = 0;

	ImFileHandle f;
	if ((f = ImFileOpen(filename, mode)) == NULL)
		return NULL;

	size_t file_size = (size_t)ImFileGetSize(f);
	if (file_size == (size_t)-1) {
		ImFileClose(f);
		return NULL;
	}

	void *file_data = IM_ALLOC(file_size + padding_bytes);
	if (file_data == NULL) {
		ImFileClose(f);
		return NULL;
	}
	if (ImFileRead(file_data, 1, file_size, f) != file_size) {
		ImFileClose(f);
		IM_FREE(file_data);
		return NULL;
	}
	if (padding_bytes > 0)
		memset((void *)(((char *)file_data) + file_size), 0, (size_t)padding_bytes);

	ImFileClose(f);
	if (out_file_size)
		*out_file_size = file_size;

	return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------

IM_MSVC_RUNTIME_CHECKS_OFF

// Convert UTF-8 to 32-bit character, process single character input.
// A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons (https://github.com/skeeto/branchless-utf8).
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8(unsigned int *out_char, const char *in_text, const char *in_text_end) {
	static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
	static const int masks[] = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
	static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
	static const int shiftc[] = { 0, 18, 12, 6, 0 };
	static const int shifte[] = { 0, 6, 4, 2, 0 };
	int len = lengths[*(const unsigned char *)in_text >> 3];
	int wanted = len + (len ? 0 : 1);

	if (in_text_end == NULL)
		in_text_end = in_text + wanted; // Max length, nulls will be taken into account.

	// Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
	// so it is fast even with excessive branching.
	unsigned char s[4];
	s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
	s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
	s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
	s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;

	// Assume a four-byte character and load four bytes. Unused bits are shifted out.
	*out_char = (uint32_t)(s[0] & masks[len]) << 18;
	*out_char |= (uint32_t)(s[1] & 0x3f) << 12;
	*out_char |= (uint32_t)(s[2] & 0x3f) << 6;
	*out_char |= (uint32_t)(s[3] & 0x3f) << 0;
	*out_char >>= shiftc[len];

	// Accumulate the various error conditions.
	int e = 0;
	e = (*out_char < mins[len]) << 6; // non-canonical encoding
	e |= ((*out_char >> 11) == 0x1b) << 7; // surrogate half?
	e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8; // out of range?
	e |= (s[1] & 0xc0) >> 2;
	e |= (s[2] & 0xc0) >> 4;
	e |= (s[3]) >> 6;
	e ^= 0x2a; // top two bits of each tail byte correct?
	e >>= shifte[len];

	if (e) {
		// No bytes are consumed when *in_text == 0 || in_text == in_text_end.
		// One byte is consumed in case of invalid first byte of in_text.
		// All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
		// Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
		wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
		*out_char = IM_UNICODE_CODEPOINT_INVALID;
	}

	return wanted;
}

int ImTextStrFromUtf8(ImWchar *buf, int buf_size, const char *in_text, const char *in_text_end, const char **in_text_remaining) {
	ImWchar *buf_out = buf;
	ImWchar *buf_end = buf + buf_size;
	while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text) {
		unsigned int c;
		in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
		*buf_out++ = (ImWchar)c;
	}
	*buf_out = 0;
	if (in_text_remaining)
		*in_text_remaining = in_text;
	return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char *in_text, const char *in_text_end) {
	int char_count = 0;
	while ((!in_text_end || in_text < in_text_end) && *in_text) {
		unsigned int c;
		in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
		char_count++;
	}
	return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8_inline(char *buf, int buf_size, unsigned int c) {
	if (c < 0x80) {
		buf[0] = (char)c;
		return 1;
	}
	if (c < 0x800) {
		if (buf_size < 2)
			return 0;
		buf[0] = (char)(0xc0 + (c >> 6));
		buf[1] = (char)(0x80 + (c & 0x3f));
		return 2;
	}
	if (c < 0x10000) {
		if (buf_size < 3)
			return 0;
		buf[0] = (char)(0xe0 + (c >> 12));
		buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
		buf[2] = (char)(0x80 + ((c) & 0x3f));
		return 3;
	}
	if (c <= 0x10FFFF) {
		if (buf_size < 4)
			return 0;
		buf[0] = (char)(0xf0 + (c >> 18));
		buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
		buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
		buf[3] = (char)(0x80 + ((c) & 0x3f));
		return 4;
	}
	// Invalid code point, the max unicode is 0x10FFFF
	return 0;
}

const char *ImTextCharToUtf8(char out_buf[5], unsigned int c) {
	int count = ImTextCharToUtf8_inline(out_buf, 5, c);
	out_buf[count] = 0;
	return out_buf;
}

// Not optimal but we very rarely use this function.
int ImTextCountUtf8BytesFromChar(const char *in_text, const char *in_text_end) {
	unsigned int unused = 0;
	return ImTextCharFromUtf8(&unused, in_text, in_text_end);
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c) {
	if (c < 0x80)
		return 1;
	if (c < 0x800)
		return 2;
	if (c < 0x10000)
		return 3;
	if (c <= 0x10FFFF)
		return 4;
	return 3;
}

int ImTextStrToUtf8(char *out_buf, int out_buf_size, const ImWchar *in_text, const ImWchar *in_text_end) {
	char *buf_p = out_buf;
	const char *buf_end = out_buf + out_buf_size;
	while (buf_p < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text) {
		unsigned int c = (unsigned int)(*in_text++);
		if (c < 0x80)
			*buf_p++ = (char)c;
		else
			buf_p += ImTextCharToUtf8_inline(buf_p, (int)(buf_end - buf_p - 1), c);
	}
	*buf_p = 0;
	return (int)(buf_p - out_buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar *in_text, const ImWchar *in_text_end) {
	int bytes_count = 0;
	while ((!in_text_end || in_text < in_text_end) && *in_text) {
		unsigned int c = (unsigned int)(*in_text++);
		if (c < 0x80)
			bytes_count++;
		else
			bytes_count += ImTextCountUtf8BytesFromChar(c);
	}
	return bytes_count;
}

const char *ImTextFindPreviousUtf8Codepoint(const char *in_text_start, const char *in_text_curr) {
	while (in_text_curr > in_text_start) {
		in_text_curr--;
		if ((*in_text_curr & 0xC0) != 0x80)
			return in_text_curr;
	}
	return in_text_start;
}

int ImTextCountLines(const char *in_text, const char *in_text_end) {
	if (in_text_end == NULL)
		in_text_end = in_text + strlen(in_text); // FIXME-OPT: Not optimal approach, discourage use for now.
	int count = 0;
	while (in_text < in_text_end) {
		const char *line_end = (const char *)memchr(in_text, '\n', in_text_end - in_text);
		in_text = line_end ? line_end + 1 : in_text_end;
		count++;
	}
	return count;
}

IM_MSVC_RUNTIME_CHECKS_RESTORE

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

IMGUI_API ImU32 ImAlphaBlendColors(ImU32 col_a, ImU32 col_b) {
	float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;
	int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
	int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
	int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
	return IM_COL32(r, g, b, 0xFF);
}

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in) {
	float s = 1.0f / 255.0f;
	return ImVec4(
			((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
			((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
}

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4 &in) {
	ImU32 out;
	out = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
	return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float &out_h, float &out_s, float &out_v) {
	float K = 0.f;
	if (g < b) {
		ImSwap(g, b);
		K = -1.f;
	}
	if (r < g) {
		ImSwap(r, g);
		K = -2.f / 6.f - K;
	}

	const float chroma = r - (g < b ? g : b);
	out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));
	out_s = chroma / (r + 1e-20f);
	out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float &out_r, float &out_g, float &out_b) {
	if (s == 0.0f) {
		// gray
		out_r = out_g = out_b = v;
		return;
	}

	h = ImFmod(h, 1.0f) / (60.0f / 360.0f);
	int i = (int)h;
	float f = h - (float)i;
	float p = v * (1.0f - s);
	float q = v * (1.0f - s * f);
	float t = v * (1.0f - s * (1.0f - f));

	switch (i) {
		case 0:
			out_r = v;
			out_g = t;
			out_b = p;
			break;
		case 1:
			out_r = q;
			out_g = v;
			out_b = p;
			break;
		case 2:
			out_r = p;
			out_g = v;
			out_b = t;
			break;
		case 3:
			out_r = p;
			out_g = q;
			out_b = v;
			break;
		case 4:
			out_r = t;
			out_g = p;
			out_b = v;
			break;
		case 5:
		default:
			out_r = v;
			out_g = p;
			out_b = q;
			break;
	}
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
ImGuiStoragePair *ImLowerBound(ImGuiStoragePair *in_begin, ImGuiStoragePair *in_end, ImGuiID key) {
	ImGuiStoragePair *in_p = in_begin;
	for (size_t count = (size_t)(in_end - in_p); count > 0;) {
		size_t count2 = count >> 1;
		ImGuiStoragePair *mid = in_p + count2;
		if (mid->key < key) {
			in_p = ++mid;
			count -= count2 + 1;
		} else {
			count = count2;
		}
	}
	return in_p;
}

IM_MSVC_RUNTIME_CHECKS_OFF
static int IMGUI_CDECL PairComparerByID(const void *lhs, const void *rhs) {
	// We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
	ImGuiID lhs_v = ((const ImGuiStoragePair *)lhs)->key;
	ImGuiID rhs_v = ((const ImGuiStoragePair *)rhs)->key;
	return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1
											   : 0);
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
void ImGuiStorage::BuildSortByKey() {
	ImQsort(Data.Data, (size_t)Data.Size, sizeof(ImGuiStoragePair), PairComparerByID);
}

int ImGuiStorage::GetInt(ImGuiID key, int default_val) const {
	ImGuiStoragePair *it = ImLowerBound(const_cast<ImGuiStoragePair *>(Data.Data), const_cast<ImGuiStoragePair *>(Data.Data + Data.Size), key);
	if (it == Data.Data + Data.Size || it->key != key)
		return default_val;
	return it->val_i;
}

bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const {
	return GetInt(key, default_val ? 1 : 0) != 0;
}

float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const {
	ImGuiStoragePair *it = ImLowerBound(const_cast<ImGuiStoragePair *>(Data.Data), const_cast<ImGuiStoragePair *>(Data.Data + Data.Size), key);
	if (it == Data.Data + Data.Size || it->key != key)
		return default_val;
	return it->val_f;
}

void *ImGuiStorage::GetVoidPtr(ImGuiID key) const {
	ImGuiStoragePair *it = ImLowerBound(const_cast<ImGuiStoragePair *>(Data.Data), const_cast<ImGuiStoragePair *>(Data.Data + Data.Size), key);
	if (it == Data.Data + Data.Size || it->key != key)
		return NULL;
	return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int *ImGuiStorage::GetIntRef(ImGuiID key, int default_val) {
	ImGuiStoragePair *it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
	if (it == Data.Data + Data.Size || it->key != key)
		it = Data.insert(it, ImGuiStoragePair(key, default_val));
	return &it->val_i;
}

bool *ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val) {
	return (bool *)GetIntRef(key, default_val ? 1 : 0);
}

float *ImGuiStorage::GetFloatRef(ImGuiID key, float default_val) {
	ImGuiStoragePair *it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
	if (it == Data.Data + Data.Size || it->key != key)
		it = Data.insert(it, ImGuiStoragePair(key, default_val));
	return &it->val_f;
}

void **ImGuiStorage::GetVoidPtrRef(ImGuiID key, void *default_val) {
	ImGuiStoragePair *it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
	if (it == Data.Data + Data.Size || it->key != key)
		it = Data.insert(it, ImGuiStoragePair(key, default_val));
	return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void ImGuiStorage::SetInt(ImGuiID key, int val) {
	ImGuiStoragePair *it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
	if (it == Data.Data + Data.Size || it->key != key)
		Data.insert(it, ImGuiStoragePair(key, val));
	else
		it->val_i = val;
}

void ImGuiStorage::SetBool(ImGuiID key, bool val) {
	SetInt(key, val ? 1 : 0);
}

void ImGuiStorage::SetFloat(ImGuiID key, float val) {
	ImGuiStoragePair *it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
	if (it == Data.Data + Data.Size || it->key != key)
		Data.insert(it, ImGuiStoragePair(key, val));
	else
		it->val_f = val;
}

void ImGuiStorage::SetVoidPtr(ImGuiID key, void *val) {
	ImGuiStoragePair *it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
	if (it == Data.Data + Data.Size || it->key != key)
		Data.insert(it, ImGuiStoragePair(key, val));
	else
		it->val_p = val;
}

void ImGuiStorage::SetAllInt(int v) {
	for (int i = 0; i < Data.Size; i++)
		Data[i].val_i = v;
}
IM_MSVC_RUNTIME_CHECKS_RESTORE

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter::ImGuiTextFilter(const char *default_filter) //-V1077
{
	InputBuf[0] = 0;
	CountGrep = 0;
	if (default_filter) {
		ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
		Build();
	}
}

bool ImGuiTextFilter::Draw(const char *label, float width) {
	if (width != 0.0f)
		ImGui::SetNextItemWidth(width);
	bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
	if (value_changed)
		Build();
	return value_changed;
}

void ImGuiTextFilter::ImGuiTextRange::split(char separator, ImVector<ImGuiTextRange> *out) const {
	out->resize(0);
	const char *wb = b;
	const char *we = wb;
	while (we < e) {
		if (*we == separator) {
			out->push_back(ImGuiTextRange(wb, we));
			wb = we + 1;
		}
		we++;
	}
	if (wb != we)
		out->push_back(ImGuiTextRange(wb, we));
}

void ImGuiTextFilter::Build() {
	Filters.resize(0);
	ImGuiTextRange input_range(InputBuf, InputBuf + strlen(InputBuf));
	input_range.split(',', &Filters);

	CountGrep = 0;
	for (ImGuiTextRange &f : Filters) {
		while (f.b < f.e && ImCharIsBlankA(f.b[0]))
			f.b++;
		while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
			f.e--;
		if (f.empty())
			continue;
		if (f.b[0] != '-')
			CountGrep += 1;
	}
}

bool ImGuiTextFilter::PassFilter(const char *text, const char *text_end) const {
	if (Filters.Size == 0)
		return true;

	if (text == NULL)
		text = text_end = "";

	for (const ImGuiTextRange &f : Filters) {
		if (f.b == f.e)
			continue;
		if (f.b[0] == '-') {
			// Subtract
			if (ImStristr(text, text_end, f.b + 1, f.e) != NULL)
				return false;
		} else {
			// Grep
			if (ImStristr(text, text_end, f.b, f.e) != NULL)
				return true;
		}
	}

	// Implicit * grep
	if (CountGrep == 0)
		return true;

	return false;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

char ImGuiTextBuffer::EmptyString[1] = { 0 };

void ImGuiTextBuffer::append(const char *str, const char *str_end) {
	int len = str_end ? (int)(str_end - str) : (int)strlen(str);

	// Add zero-terminator the first time
	const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
	const int needed_sz = write_off + len;
	if (write_off + len >= Buf.Capacity) {
		int new_capacity = Buf.Capacity * 2;
		Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
	}

	Buf.resize(needed_sz);
	memcpy(&Buf[write_off - 1], str, (size_t)len);
	Buf[write_off - 1 + len] = 0;
}

void ImGuiTextBuffer::appendf(const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	appendfv(fmt, args);
	va_end(args);
}

// Helper: Text buffer for logging/accumulating text
void ImGuiTextBuffer::appendfv(const char *fmt, va_list args) {
	va_list args_copy;
	va_copy(args_copy, args);

	int len = ImFormatStringV(NULL, 0, fmt, args); // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
	if (len <= 0) {
		va_end(args_copy);
		return;
	}

	// Add zero-terminator the first time
	const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
	const int needed_sz = write_off + len;
	if (write_off + len >= Buf.Capacity) {
		int new_capacity = Buf.Capacity * 2;
		Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
	}

	Buf.resize(needed_sz);
	ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
	va_end(args_copy);
}

void ImGuiTextIndex::append(const char *base, int old_size, int new_size) {
	IM_ASSERT(old_size >= 0 && new_size >= old_size && new_size >= EndOffset);
	if (old_size == new_size)
		return;
	if (EndOffset == 0 || base[EndOffset - 1] == '\n')
		LineOffsets.push_back(EndOffset);
	const char *base_end = base + new_size;
	for (const char *p = base + old_size; (p = (const char *)memchr(p, '\n', base_end - p)) != 0;)
		if (++p < base_end) // Don't push a trailing offset on last \n
			LineOffsets.push_back((int)(intptr_t)(p - base));
	EndOffset = ImMax(EndOffset, new_size);
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
//-----------------------------------------------------------------------------

// FIXME-TABLE: This prevents us from using ImGuiListClipper _inside_ a table cell.
// The problem we have is that without a Begin/End scheme for rows using the clipper is ambiguous.
static bool GetSkipItemForListClipping() {
	ImGuiContext &g = *GImGui;
	return (g.CurrentTable ? g.CurrentTable->HostSkipItems : g.CurrentWindow->SkipItems);
}

static void ImGuiListClipper_SortAndFuseRanges(ImVector<ImGuiListClipperRange> &ranges, int offset = 0) {
	if (ranges.Size - offset <= 1)
		return;

	// Helper to order ranges and fuse them together if possible (bubble sort is fine as we are only sorting 2-3 entries)
	for (int sort_end = ranges.Size - offset - 1; sort_end > 0; --sort_end)
		for (int i = offset; i < sort_end + offset; ++i)
			if (ranges[i].Min > ranges[i + 1].Min)
				ImSwap(ranges[i], ranges[i + 1]);

	// Now fuse ranges together as much as possible.
	for (int i = 1 + offset; i < ranges.Size; i++) {
		IM_ASSERT(!ranges[i].PosToIndexConvert && !ranges[i - 1].PosToIndexConvert);
		if (ranges[i - 1].Max < ranges[i].Min)
			continue;
		ranges[i - 1].Min = ImMin(ranges[i - 1].Min, ranges[i].Min);
		ranges[i - 1].Max = ImMax(ranges[i - 1].Max, ranges[i].Max);
		ranges.erase(ranges.Data + i);
		i--;
	}
}

static void ImGuiListClipper_SeekCursorAndSetupPrevLine(float pos_y, float line_height) {
	// Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
	// FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
	// The clipper should probably have a final step to display the last item in a regular manner, maybe with an opt-out flag for data sets which may have costly seek?
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	float off_y = pos_y - window->DC.CursorPos.y;
	window->DC.CursorPos.y = pos_y;
	window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, pos_y - g.Style.ItemSpacing.y);
	window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height; // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
	window->DC.PrevLineSize.y = (line_height - g.Style.ItemSpacing.y); // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
	if (ImGuiOldColumns *columns = window->DC.CurrentColumns)
		columns->LineMinY = window->DC.CursorPos.y; // Setting this so that cell Y position are set properly
	if (ImGuiTable *table = g.CurrentTable) {
		if (table->IsInsideRow)
			ImGui::TableEndRow(table);
		table->RowPosY2 = window->DC.CursorPos.y;
		const int row_increase = (int)((off_y / line_height) + 0.5f);
		//table->CurrentRow += row_increase; // Can't do without fixing TableEndRow()
		table->RowBgColorCounter += row_increase;
	}
}

ImGuiListClipper::ImGuiListClipper() {
	memset(this, 0, sizeof(*this));
}

ImGuiListClipper::~ImGuiListClipper() {
	End();
}

void ImGuiListClipper::Begin(int items_count, float items_height) {
	if (Ctx == NULL)
		Ctx = ImGui::GetCurrentContext();

	ImGuiContext &g = *Ctx;
	ImGuiWindow *window = g.CurrentWindow;
	IMGUI_DEBUG_LOG_CLIPPER("Clipper: Begin(%d,%.2f) in '%s'\n", items_count, items_height, window->Name);

	if (ImGuiTable *table = g.CurrentTable)
		if (table->IsInsideRow)
			ImGui::TableEndRow(table);

	StartPosY = window->DC.CursorPos.y;
	ItemsHeight = items_height;
	ItemsCount = items_count;
	DisplayStart = -1;
	DisplayEnd = 0;

	// Acquire temporary buffer
	if (++g.ClipperTempDataStacked > g.ClipperTempData.Size)
		g.ClipperTempData.resize(g.ClipperTempDataStacked, ImGuiListClipperData());
	ImGuiListClipperData *data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
	data->Reset(this);
	data->LossynessOffset = window->DC.CursorStartPosLossyness.y;
	TempData = data;
	StartSeekOffsetY = data->LossynessOffset;
}

void ImGuiListClipper::End() {
	if (ImGuiListClipperData *data = (ImGuiListClipperData *)TempData) {
		// In theory here we should assert that we are already at the right position, but it seems saner to just seek at the end and not assert/crash the user.
		ImGuiContext &g = *Ctx;
		IMGUI_DEBUG_LOG_CLIPPER("Clipper: End() in '%s'\n", g.CurrentWindow->Name);
		if (ItemsCount >= 0 && ItemsCount < INT_MAX && DisplayStart >= 0)
			SeekCursorForItem(ItemsCount);

		// Restore temporary buffer and fix back pointers which may be invalidated when nesting
		IM_ASSERT(data->ListClipper == this);
		data->StepNo = data->Ranges.Size;
		if (--g.ClipperTempDataStacked > 0) {
			data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
			data->ListClipper->TempData = data;
		}
		TempData = NULL;
	}
	ItemsCount = -1;
}

void ImGuiListClipper::IncludeItemsByIndex(int item_begin, int item_end) {
	ImGuiListClipperData *data = (ImGuiListClipperData *)TempData;
	IM_ASSERT(DisplayStart < 0); // Only allowed after Begin() and if there has not been a specified range yet.
	IM_ASSERT(item_begin <= item_end);
	if (item_begin < item_end)
		data->Ranges.push_back(ImGuiListClipperRange::FromIndices(item_begin, item_end));
}

// This is already called while stepping.
// The ONLY reason you may want to call this is if you passed INT_MAX to ImGuiListClipper::Begin() because you couldn't step item count beforehand.
void ImGuiListClipper::SeekCursorForItem(int item_n) {
	// - Perform the add and multiply with double to allow seeking through larger ranges.
	// - StartPosY starts from ItemsFrozen, by adding SeekOffsetY we generally cancel that out (SeekOffsetY == LossynessOffset - ItemsFrozen * ItemsHeight).
	// - The reason we store SeekOffsetY instead of inferring it, is because we want to allow user to perform Seek after the last step, where ImGuiListClipperData is already done.
	float pos_y = (float)((double)StartPosY + StartSeekOffsetY + (double)item_n * ItemsHeight);
	ImGuiListClipper_SeekCursorAndSetupPrevLine(pos_y, ItemsHeight);
}

static bool ImGuiListClipper_StepInternal(ImGuiListClipper *clipper) {
	ImGuiContext &g = *clipper->Ctx;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiListClipperData *data = (ImGuiListClipperData *)clipper->TempData;
	IM_ASSERT(data != NULL && "Called ImGuiListClipper::Step() too many times, or before ImGuiListClipper::Begin() ?");

	ImGuiTable *table = g.CurrentTable;
	if (table && table->IsInsideRow)
		ImGui::TableEndRow(table);

	// No items
	if (clipper->ItemsCount == 0 || GetSkipItemForListClipping())
		return false;

	// While we are in frozen row state, keep displaying items one by one, unclipped
	// FIXME: Could be stored as a table-agnostic state.
	if (data->StepNo == 0 && table != NULL && !table->IsUnfrozenRows) {
		clipper->DisplayStart = data->ItemsFrozen;
		clipper->DisplayEnd = ImMin(data->ItemsFrozen + 1, clipper->ItemsCount);
		if (clipper->DisplayStart < clipper->DisplayEnd)
			data->ItemsFrozen++;
		return true;
	}

	// Step 0: Let you process the first element (regardless of it being visible or not, so we can measure the element height)
	bool calc_clipping = false;
	if (data->StepNo == 0) {
		clipper->StartPosY = window->DC.CursorPos.y;
		if (clipper->ItemsHeight <= 0.0f) {
			// Submit the first item (or range) so we can measure its height (generally the first range is 0..1)
			data->Ranges.push_front(ImGuiListClipperRange::FromIndices(data->ItemsFrozen, data->ItemsFrozen + 1));
			clipper->DisplayStart = ImMax(data->Ranges[0].Min, data->ItemsFrozen);
			clipper->DisplayEnd = ImMin(data->Ranges[0].Max, clipper->ItemsCount);
			data->StepNo = 1;
			return true;
		}
		calc_clipping = true; // If on the first step with known item height, calculate clipping.
	}

	// Step 1: Let the clipper infer height from first range
	if (clipper->ItemsHeight <= 0.0f) {
		IM_ASSERT(data->StepNo == 1);
		if (table)
			IM_ASSERT(table->RowPosY1 == clipper->StartPosY && table->RowPosY2 == window->DC.CursorPos.y);

		clipper->ItemsHeight = (window->DC.CursorPos.y - clipper->StartPosY) / (float)(clipper->DisplayEnd - clipper->DisplayStart);
		bool affected_by_floating_point_precision = ImIsFloatAboveGuaranteedIntegerPrecision(clipper->StartPosY) || ImIsFloatAboveGuaranteedIntegerPrecision(window->DC.CursorPos.y);
		if (affected_by_floating_point_precision)
			clipper->ItemsHeight = window->DC.PrevLineSize.y + g.Style.ItemSpacing.y; // FIXME: Technically wouldn't allow multi-line entries.
		if (clipper->ItemsHeight == 0.0f && clipper->ItemsCount == INT_MAX) // Accept that no item have been submitted if in indeterminate mode.
			return false;
		IM_ASSERT(clipper->ItemsHeight > 0.0f && "Unable to calculate item height! First item hasn't moved the cursor vertically!");
		calc_clipping = true; // If item height had to be calculated, calculate clipping afterwards.
	}

	// Step 0 or 1: Calculate the actual ranges of visible elements.
	const int already_submitted = clipper->DisplayEnd;
	if (calc_clipping) {
		// Record seek offset, this is so ImGuiListClipper::Seek() can be called after ImGuiListClipperData is done
		clipper->StartSeekOffsetY = (double)data->LossynessOffset - data->ItemsFrozen * (double)clipper->ItemsHeight;

		if (g.LogEnabled) {
			// If logging is active, do not perform any clipping
			data->Ranges.push_back(ImGuiListClipperRange::FromIndices(0, clipper->ItemsCount));
		} else {
			// Add range selected to be included for navigation
			const bool is_nav_request = (g.NavMoveScoringItems && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
			if (is_nav_request)
				data->Ranges.push_back(ImGuiListClipperRange::FromPositions(g.NavScoringNoClipRect.Min.y, g.NavScoringNoClipRect.Max.y, 0, 0));
			if (is_nav_request && (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && g.NavTabbingDir == -1)
				data->Ranges.push_back(ImGuiListClipperRange::FromIndices(clipper->ItemsCount - 1, clipper->ItemsCount));

			// Add focused/active item
			ImRect nav_rect_abs = ImGui::WindowRectRelToAbs(window, window->NavRectRel[0]);
			if (g.NavId != 0 && window->NavLastIds[0] == g.NavId)
				data->Ranges.push_back(ImGuiListClipperRange::FromPositions(nav_rect_abs.Min.y, nav_rect_abs.Max.y, 0, 0));

			// Add visible range
			float min_y = window->ClipRect.Min.y;
			float max_y = window->ClipRect.Max.y;

			// Add box selection range
			ImGuiBoxSelectState *bs = &g.BoxSelectState;
			if (bs->IsActive && bs->Window == window) {
				// FIXME: Selectable() use of half-ItemSpacing isn't consistent in matter of layout, as ItemAdd(bb) stray above ItemSize()'s CursorPos.
				// RangeSelect's BoxSelect relies on comparing overlap of previous and current rectangle and is sensitive to that.
				// As a workaround we currently half ItemSpacing worth on each side.
				min_y -= g.Style.ItemSpacing.y;
				max_y += g.Style.ItemSpacing.y;

				// Box-select on 2D area requires different clipping.
				if (bs->UnclipMode)
					data->Ranges.push_back(ImGuiListClipperRange::FromPositions(bs->UnclipRect.Min.y, bs->UnclipRect.Max.y, 0, 0));
			}

			const int off_min = (is_nav_request && g.NavMoveClipDir == ImGuiDir_Up) ? -1 : 0;
			const int off_max = (is_nav_request && g.NavMoveClipDir == ImGuiDir_Down) ? 1 : 0;
			data->Ranges.push_back(ImGuiListClipperRange::FromPositions(min_y, max_y, off_min, off_max));
		}

		// Convert position ranges to item index ranges
		// - Very important: when a starting position is after our maximum item, we set Min to (ItemsCount - 1). This allows us to handle most forms of wrapping.
		// - Due to how Selectable extra padding they tend to be "unaligned" with exact unit in the item list,
		//   which with the flooring/ceiling tend to lead to 2 items instead of one being submitted.
		for (ImGuiListClipperRange &range : data->Ranges)
			if (range.PosToIndexConvert) {
				int m1 = (int)(((double)range.Min - window->DC.CursorPos.y - data->LossynessOffset) / clipper->ItemsHeight);
				int m2 = (int)((((double)range.Max - window->DC.CursorPos.y - data->LossynessOffset) / clipper->ItemsHeight) + 0.999999f);
				range.Min = ImClamp(already_submitted + m1 + range.PosToIndexOffsetMin, already_submitted, clipper->ItemsCount - 1);
				range.Max = ImClamp(already_submitted + m2 + range.PosToIndexOffsetMax, range.Min + 1, clipper->ItemsCount);
				range.PosToIndexConvert = false;
			}
		ImGuiListClipper_SortAndFuseRanges(data->Ranges, data->StepNo);
	}

	// Step 0+ (if item height is given in advance) or 1+: Display the next range in line.
	while (data->StepNo < data->Ranges.Size) {
		clipper->DisplayStart = ImMax(data->Ranges[data->StepNo].Min, already_submitted);
		clipper->DisplayEnd = ImMin(data->Ranges[data->StepNo].Max, clipper->ItemsCount);
		if (clipper->DisplayStart > already_submitted) //-V1051
			clipper->SeekCursorForItem(clipper->DisplayStart);
		data->StepNo++;
		if (clipper->DisplayStart == clipper->DisplayEnd && data->StepNo < data->Ranges.Size)
			continue;
		return true;
	}

	// After the last step: Let the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd),
	// Advance the cursor to the end of the list and then returns 'false' to end the loop.
	if (clipper->ItemsCount < INT_MAX)
		clipper->SeekCursorForItem(clipper->ItemsCount);

	return false;
}

bool ImGuiListClipper::Step() {
	ImGuiContext &g = *Ctx;
	bool need_items_height = (ItemsHeight <= 0.0f);
	bool ret = ImGuiListClipper_StepInternal(this);
	if (ret && (DisplayStart == DisplayEnd))
		ret = false;
	if (g.CurrentTable && g.CurrentTable->IsUnfrozenRows == false)
		IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): inside frozen table row.\n");
	if (need_items_height && ItemsHeight > 0.0f)
		IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): computed ItemsHeight: %.2f.\n", ItemsHeight);
	if (ret) {
		IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): display %d to %d.\n", DisplayStart, DisplayEnd);
	} else {
		IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): End.\n");
		End();
	}
	return ret;
}

//-----------------------------------------------------------------------------
// [SECTION] STYLING
//-----------------------------------------------------------------------------

ImGuiStyle &ImGui::GetStyle() {
	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
	return GImGui->Style;
}

ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul) {
	ImGuiStyle &style = GImGui->Style;
	ImVec4 c = style.Colors[idx];
	c.w *= style.Alpha * alpha_mul;
	return ColorConvertFloat4ToU32(c);
}

ImU32 ImGui::GetColorU32(const ImVec4 &col) {
	ImGuiStyle &style = GImGui->Style;
	ImVec4 c = col;
	c.w *= style.Alpha;
	return ColorConvertFloat4ToU32(c);
}

const ImVec4 &ImGui::GetStyleColorVec4(ImGuiCol idx) {
	ImGuiStyle &style = GImGui->Style;
	return style.Colors[idx];
}

ImU32 ImGui::GetColorU32(ImU32 col, float alpha_mul) {
	ImGuiStyle &style = GImGui->Style;
	alpha_mul *= style.Alpha;
	if (alpha_mul >= 1.0f)
		return col;
	ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
	a = (ImU32)(a * alpha_mul); // We don't need to clamp 0..255 because alpha is in 0..1 range.
	return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col) {
	ImGuiContext &g = *GImGui;
	ImGuiColorMod backup;
	backup.Col = idx;
	backup.BackupValue = g.Style.Colors[idx];
	g.ColorStack.push_back(backup);
	if (g.DebugFlashStyleColorIdx != idx)
		g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4 &col) {
	ImGuiContext &g = *GImGui;
	ImGuiColorMod backup;
	backup.Col = idx;
	backup.BackupValue = g.Style.Colors[idx];
	g.ColorStack.push_back(backup);
	if (g.DebugFlashStyleColorIdx != idx)
		g.Style.Colors[idx] = col;
}

void ImGui::PopStyleColor(int count) {
	ImGuiContext &g = *GImGui;
	if (g.ColorStack.Size < count) {
		IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times!");
		count = g.ColorStack.Size;
	}
	while (count > 0) {
		ImGuiColorMod &backup = g.ColorStack.back();
		g.Style.Colors[backup.Col] = backup.BackupValue;
		g.ColorStack.pop_back();
		count--;
	}
}

static const ImGuiDataVarInfo GStyleVarInfo[] = {
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, Alpha) }, // ImGuiStyleVar_Alpha
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, DisabledAlpha) }, // ImGuiStyleVar_DisabledAlpha
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowPadding) }, // ImGuiStyleVar_WindowPadding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, WindowRounding) }, // ImGuiStyleVar_WindowRounding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, WindowBorderSize) }, // ImGuiStyleVar_WindowBorderSize
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowMinSize) }, // ImGuiStyleVar_WindowMinSize
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, WindowTitleAlign) }, // ImGuiStyleVar_WindowTitleAlign
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ChildRounding) }, // ImGuiStyleVar_ChildRounding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ChildBorderSize) }, // ImGuiStyleVar_ChildBorderSize
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, PopupRounding) }, // ImGuiStyleVar_PopupRounding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, PopupBorderSize) }, // ImGuiStyleVar_PopupBorderSize
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, FramePadding) }, // ImGuiStyleVar_FramePadding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, FrameRounding) }, // ImGuiStyleVar_FrameRounding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, FrameBorderSize) }, // ImGuiStyleVar_FrameBorderSize
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ItemSpacing) }, // ImGuiStyleVar_ItemSpacing
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ItemInnerSpacing) }, // ImGuiStyleVar_ItemInnerSpacing
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, IndentSpacing) }, // ImGuiStyleVar_IndentSpacing
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, CellPadding) }, // ImGuiStyleVar_CellPadding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ScrollbarSize) }, // ImGuiStyleVar_ScrollbarSize
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, ScrollbarRounding) }, // ImGuiStyleVar_ScrollbarRounding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, GrabMinSize) }, // ImGuiStyleVar_GrabMinSize
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, GrabRounding) }, // ImGuiStyleVar_GrabRounding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabRounding) }, // ImGuiStyleVar_TabRounding
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBorderSize) }, // ImGuiStyleVar_TabBorderSize
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBarBorderSize) }, // ImGuiStyleVar_TabBarBorderSize
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TabBarOverlineSize) }, // ImGuiStyleVar_TabBarOverlineSize
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, TableAngledHeadersAngle) }, // ImGuiStyleVar_TableAngledHeadersAngle
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, TableAngledHeadersTextAlign) }, // ImGuiStyleVar_TableAngledHeadersTextAlign
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, ButtonTextAlign) }, // ImGuiStyleVar_ButtonTextAlign
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SelectableTextAlign) }, // ImGuiStyleVar_SelectableTextAlign
	{ ImGuiDataType_Float, 1, (ImU32)offsetof(ImGuiStyle, SeparatorTextBorderSize) }, // ImGuiStyleVar_SeparatorTextBorderSize
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextAlign) }, // ImGuiStyleVar_SeparatorTextAlign
	{ ImGuiDataType_Float, 2, (ImU32)offsetof(ImGuiStyle, SeparatorTextPadding) }, // ImGuiStyleVar_SeparatorTextPadding
};

const ImGuiDataVarInfo *ImGui::GetStyleVarInfo(ImGuiStyleVar idx) {
	IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
	IM_STATIC_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
	return &GStyleVarInfo[idx];
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, float val) {
	ImGuiContext &g = *GImGui;
	const ImGuiDataVarInfo *var_info = GetStyleVarInfo(idx);
	if (var_info->Type != ImGuiDataType_Float || var_info->Count != 1) {
		IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
		return;
	}
	float *pvar = (float *)var_info->GetVarPtr(&g.Style);
	g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
	*pvar = val;
}

void ImGui::PushStyleVarX(ImGuiStyleVar idx, float val_x) {
	ImGuiContext &g = *GImGui;
	const ImGuiDataVarInfo *var_info = GetStyleVarInfo(idx);
	if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2) {
		IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
		return;
	}
	ImVec2 *pvar = (ImVec2 *)var_info->GetVarPtr(&g.Style);
	g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
	pvar->x = val_x;
}

void ImGui::PushStyleVarY(ImGuiStyleVar idx, float val_y) {
	ImGuiContext &g = *GImGui;
	const ImGuiDataVarInfo *var_info = GetStyleVarInfo(idx);
	if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2) {
		IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
		return;
	}
	ImVec2 *pvar = (ImVec2 *)var_info->GetVarPtr(&g.Style);
	g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
	pvar->y = val_y;
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2 &val) {
	ImGuiContext &g = *GImGui;
	const ImGuiDataVarInfo *var_info = GetStyleVarInfo(idx);
	if (var_info->Type != ImGuiDataType_Float || var_info->Count != 2) {
		IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
		return;
	}
	ImVec2 *pvar = (ImVec2 *)var_info->GetVarPtr(&g.Style);
	g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
	*pvar = val;
}

void ImGui::PopStyleVar(int count) {
	ImGuiContext &g = *GImGui;
	if (g.StyleVarStack.Size < count) {
		IM_ASSERT_USER_ERROR(g.StyleVarStack.Size > count, "Calling PopStyleVar() too many times!");
		count = g.StyleVarStack.Size;
	}
	while (count > 0) {
		// We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
		ImGuiStyleMod &backup = g.StyleVarStack.back();
		const ImGuiDataVarInfo *info = GetStyleVarInfo(backup.VarIdx);
		void *data = info->GetVarPtr(&g.Style);
		if (info->Type == ImGuiDataType_Float && info->Count == 1) {
			((float *)data)[0] = backup.BackupFloat[0];
		} else if (info->Type == ImGuiDataType_Float && info->Count == 2) {
			((float *)data)[0] = backup.BackupFloat[0];
			((float *)data)[1] = backup.BackupFloat[1];
		}
		g.StyleVarStack.pop_back();
		count--;
	}
}

const char *ImGui::GetStyleColorName(ImGuiCol idx) {
	// Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
	switch (idx) {
		case ImGuiCol_Text:
			return "Text";
		case ImGuiCol_TextDisabled:
			return "TextDisabled";
		case ImGuiCol_WindowBg:
			return "WindowBg";
		case ImGuiCol_ChildBg:
			return "ChildBg";
		case ImGuiCol_PopupBg:
			return "PopupBg";
		case ImGuiCol_Border:
			return "Border";
		case ImGuiCol_BorderShadow:
			return "BorderShadow";
		case ImGuiCol_FrameBg:
			return "FrameBg";
		case ImGuiCol_FrameBgHovered:
			return "FrameBgHovered";
		case ImGuiCol_FrameBgActive:
			return "FrameBgActive";
		case ImGuiCol_TitleBg:
			return "TitleBg";
		case ImGuiCol_TitleBgActive:
			return "TitleBgActive";
		case ImGuiCol_TitleBgCollapsed:
			return "TitleBgCollapsed";
		case ImGuiCol_MenuBarBg:
			return "MenuBarBg";
		case ImGuiCol_ScrollbarBg:
			return "ScrollbarBg";
		case ImGuiCol_ScrollbarGrab:
			return "ScrollbarGrab";
		case ImGuiCol_ScrollbarGrabHovered:
			return "ScrollbarGrabHovered";
		case ImGuiCol_ScrollbarGrabActive:
			return "ScrollbarGrabActive";
		case ImGuiCol_CheckMark:
			return "CheckMark";
		case ImGuiCol_SliderGrab:
			return "SliderGrab";
		case ImGuiCol_SliderGrabActive:
			return "SliderGrabActive";
		case ImGuiCol_Button:
			return "Button";
		case ImGuiCol_ButtonHovered:
			return "ButtonHovered";
		case ImGuiCol_ButtonActive:
			return "ButtonActive";
		case ImGuiCol_Header:
			return "Header";
		case ImGuiCol_HeaderHovered:
			return "HeaderHovered";
		case ImGuiCol_HeaderActive:
			return "HeaderActive";
		case ImGuiCol_Separator:
			return "Separator";
		case ImGuiCol_SeparatorHovered:
			return "SeparatorHovered";
		case ImGuiCol_SeparatorActive:
			return "SeparatorActive";
		case ImGuiCol_ResizeGrip:
			return "ResizeGrip";
		case ImGuiCol_ResizeGripHovered:
			return "ResizeGripHovered";
		case ImGuiCol_ResizeGripActive:
			return "ResizeGripActive";
		case ImGuiCol_TabHovered:
			return "TabHovered";
		case ImGuiCol_Tab:
			return "Tab";
		case ImGuiCol_TabSelected:
			return "TabSelected";
		case ImGuiCol_TabSelectedOverline:
			return "TabSelectedOverline";
		case ImGuiCol_TabDimmed:
			return "TabDimmed";
		case ImGuiCol_TabDimmedSelected:
			return "TabDimmedSelected";
		case ImGuiCol_TabDimmedSelectedOverline:
			return "TabDimmedSelectedOverline";
		case ImGuiCol_PlotLines:
			return "PlotLines";
		case ImGuiCol_PlotLinesHovered:
			return "PlotLinesHovered";
		case ImGuiCol_PlotHistogram:
			return "PlotHistogram";
		case ImGuiCol_PlotHistogramHovered:
			return "PlotHistogramHovered";
		case ImGuiCol_TableHeaderBg:
			return "TableHeaderBg";
		case ImGuiCol_TableBorderStrong:
			return "TableBorderStrong";
		case ImGuiCol_TableBorderLight:
			return "TableBorderLight";
		case ImGuiCol_TableRowBg:
			return "TableRowBg";
		case ImGuiCol_TableRowBgAlt:
			return "TableRowBgAlt";
		case ImGuiCol_TextLink:
			return "TextLink";
		case ImGuiCol_TextSelectedBg:
			return "TextSelectedBg";
		case ImGuiCol_DragDropTarget:
			return "DragDropTarget";
		case ImGuiCol_NavHighlight:
			return "NavHighlight";
		case ImGuiCol_NavWindowingHighlight:
			return "NavWindowingHighlight";
		case ImGuiCol_NavWindowingDimBg:
			return "NavWindowingDimBg";
		case ImGuiCol_ModalWindowDimBg:
			return "ModalWindowDimBg";
	}
	IM_ASSERT(0);
	return "Unknown";
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
// we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
//-----------------------------------------------------------------------------

const char *ImGui::FindRenderedTextEnd(const char *text, const char *text_end) {
	const char *text_display_end = text;
	if (!text_end)
		text_end = (const char *)-1;

	while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
		text_display_end++;
	return text_display_end;
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void ImGui::RenderText(ImVec2 pos, const char *text, const char *text_end, bool hide_text_after_hash) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	// Hide anything after a '##' string
	const char *text_display_end;
	if (hide_text_after_hash) {
		text_display_end = FindRenderedTextEnd(text, text_end);
	} else {
		if (!text_end)
			text_end = text + strlen(text); // FIXME-OPT
		text_display_end = text_end;
	}

	if (text != text_display_end) {
		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
		if (g.LogEnabled)
			LogRenderedText(&pos, text, text_display_end);
	}
}

void ImGui::RenderTextWrapped(ImVec2 pos, const char *text, const char *text_end, float wrap_width) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	if (!text_end)
		text_end = text + strlen(text); // FIXME-OPT

	if (text != text_end) {
		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
		if (g.LogEnabled)
			LogRenderedText(&pos, text, text_end);
	}
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
// FIXME-OPT: Since we have or calculate text_size we could coarse clip whole block immediately, especally for text above draw_list->DrawList.
// Effectively as this is called from widget doing their own coarse clipping it's not very valuable presently. Next time function will take
// better advantage of the render function taking size into account for coarse clipping.
void ImGui::RenderTextClippedEx(ImDrawList *draw_list, const ImVec2 &pos_min, const ImVec2 &pos_max, const char *text, const char *text_display_end, const ImVec2 *text_size_if_known, const ImVec2 &align, const ImRect *clip_rect) {
	// Perform CPU side clipping for single clipped element to avoid using scissor state
	ImVec2 pos = pos_min;
	const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

	const ImVec2 *clip_min = clip_rect ? &clip_rect->Min : &pos_min;
	const ImVec2 *clip_max = clip_rect ? &clip_rect->Max : &pos_max;
	bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
	if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
		need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

	// Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
	if (align.x > 0.0f)
		pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
	if (align.y > 0.0f)
		pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

	// Render
	if (need_clipping) {
		ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
		draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
	} else {
		draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
	}
}

void ImGui::RenderTextClipped(const ImVec2 &pos_min, const ImVec2 &pos_max, const char *text, const char *text_end, const ImVec2 *text_size_if_known, const ImVec2 &align, const ImRect *clip_rect) {
	// Hide anything after a '##' string
	const char *text_display_end = FindRenderedTextEnd(text, text_end);
	const int text_len = (int)(text_display_end - text);
	if (text_len == 0)
		return;

	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
	if (g.LogEnabled)
		LogRenderedText(&pos_min, text, text_display_end);
}

// Another overly complex function until we reorganize everything into a nice all-in-one helper.
// This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
// This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
void ImGui::RenderTextEllipsis(ImDrawList *draw_list, const ImVec2 &pos_min, const ImVec2 &pos_max, float clip_max_x, float ellipsis_max_x, const char *text, const char *text_end_full, const ImVec2 *text_size_if_known) {
	ImGuiContext &g = *GImGui;
	if (text_end_full == NULL)
		text_end_full = FindRenderedTextEnd(text);
	const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_end_full, false, 0.0f);

	//draw_list->AddLine(ImVec2(pos_max.x, pos_min.y - 4), ImVec2(pos_max.x, pos_max.y + 4), IM_COL32(0, 0, 255, 255));
	//draw_list->AddLine(ImVec2(ellipsis_max_x, pos_min.y-2), ImVec2(ellipsis_max_x, pos_max.y+2), IM_COL32(0, 255, 0, 255));
	//draw_list->AddLine(ImVec2(clip_max_x, pos_min.y), ImVec2(clip_max_x, pos_max.y), IM_COL32(255, 0, 0, 255));
	// FIXME: We could technically remove (last_glyph->AdvanceX - last_glyph->X1) from text_size.x here and save a few pixels.
	if (text_size.x > pos_max.x - pos_min.x) {
		// Hello wo...
		// |       |   |
		// min   max   ellipsis_max
		//          <-> this is generally some padding value

		const ImFont *font = draw_list->_Data->Font;
		const float font_size = draw_list->_Data->FontSize;
		const float font_scale = draw_list->_Data->FontScale;
		const char *text_end_ellipsis = NULL;
		const float ellipsis_width = font->EllipsisWidth * font_scale;

		// We can now claim the space between pos_max.x and ellipsis_max.x
		const float text_avail_width = ImMax((ImMax(pos_max.x, ellipsis_max_x) - ellipsis_width) - pos_min.x, 1.0f);
		float text_size_clipped_x = font->CalcTextSizeA(font_size, text_avail_width, 0.0f, text, text_end_full, &text_end_ellipsis).x;
		if (text == text_end_ellipsis && text_end_ellipsis < text_end_full) {
			// Always display at least 1 character if there's no room for character + ellipsis
			text_end_ellipsis = text + ImTextCountUtf8BytesFromChar(text, text_end_full);
			text_size_clipped_x = font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text, text_end_ellipsis).x;
		}
		while (text_end_ellipsis > text && ImCharIsBlankA(text_end_ellipsis[-1])) {
			// Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks would be nice, for this we need a function to backtrack in UTF-8 text)
			text_end_ellipsis--;
			text_size_clipped_x -= font->CalcTextSizeA(font_size, FLT_MAX, 0.0f, text_end_ellipsis, text_end_ellipsis + 1).x; // Ascii blanks are always 1 byte
		}

		// Render text, render ellipsis
		RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_ellipsis, &text_size, ImVec2(0.0f, 0.0f));
		ImVec2 ellipsis_pos = ImTrunc(ImVec2(pos_min.x + text_size_clipped_x, pos_min.y));
		if (ellipsis_pos.x + ellipsis_width <= ellipsis_max_x)
			for (int i = 0; i < font->EllipsisCharCount; i++, ellipsis_pos.x += font->EllipsisCharStep * font_scale)
				font->RenderChar(draw_list, font_size, ellipsis_pos, GetColorU32(ImGuiCol_Text), font->EllipsisChar);
	} else {
		RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_full, &text_size, ImVec2(0.0f, 0.0f));
	}

	if (g.LogEnabled)
		LogRenderedText(&pos_min, text, text_end_full);
}

// Render a rectangle shaped with optional rounding and borders
void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool borders, float rounding) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
	const float border_size = g.Style.FrameBorderSize;
	if (borders && border_size > 0.0f) {
		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
	}
}

void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	const float border_size = g.Style.FrameBorderSize;
	if (border_size > 0.0f) {
		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
	}
}

void ImGui::RenderNavHighlight(const ImRect &bb, ImGuiID id, ImGuiNavHighlightFlags flags) {
	ImGuiContext &g = *GImGui;
	if (id != g.NavId)
		return;
	if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
		return;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->DC.NavHideHighlightOneFrame)
		return;

	float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
	ImRect display_rect = bb;
	display_rect.ClipWith(window->ClipRect);
	const float thickness = 2.0f;
	if (flags & ImGuiNavHighlightFlags_Compact) {
		window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, thickness);
	} else {
		const float distance = 3.0f + thickness * 0.5f;
		display_rect.Expand(ImVec2(distance, distance));
		bool fully_visible = window->ClipRect.Contains(display_rect);
		if (!fully_visible)
			window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
		window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, thickness);
		if (!fully_visible)
			window->DrawList->PopClipRect();
	}
}

void ImGui::RenderMouseCursor(ImVec2 base_pos, float base_scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);
	ImFontAtlas *font_atlas = g.DrawListSharedData.Font->ContainerAtlas;
	for (ImGuiViewportP *viewport : g.Viewports) {
		// We scale cursor with current viewport/monitor, however Windows 10 for its own hardware cursor seems to be using a different scale factor.
		ImVec2 offset, size, uv[4];
		if (!font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))
			continue;
		const ImVec2 pos = base_pos - offset;
		const float scale = base_scale;
		if (!viewport->GetMainRect().Overlaps(ImRect(pos, pos + ImVec2(size.x + 2, size.y + 2) * scale)))
			continue;
		ImDrawList *draw_list = GetForegroundDrawList(viewport);
		ImTextureID tex_id = font_atlas->TexID;
		draw_list->PushTextureID(tex_id);
		draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);
		draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);
		draw_list->AddImage(tex_id, pos, pos + size * scale, uv[2], uv[3], col_border);
		draw_list->AddImage(tex_id, pos, pos + size * scale, uv[0], uv[1], col_fill);
		draw_list->PopTextureID();
	}
}

//-----------------------------------------------------------------------------
// [SECTION] INITIALIZATION, SHUTDOWN
//-----------------------------------------------------------------------------

// Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
ImGuiContext *ImGui::GetCurrentContext() {
	return GImGui;
}

void ImGui::SetCurrentContext(ImGuiContext *ctx) {
#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
	IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
#else
	GImGui = ctx;
#endif
}

void ImGui::SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void *user_data) {
	GImAllocatorAllocFunc = alloc_func;
	GImAllocatorFreeFunc = free_func;
	GImAllocatorUserData = user_data;
}

// This is provided to facilitate copying allocators from one static/DLL boundary to another (e.g. retrieve default allocator of your executable address space)
void ImGui::GetAllocatorFunctions(ImGuiMemAllocFunc *p_alloc_func, ImGuiMemFreeFunc *p_free_func, void **p_user_data) {
	*p_alloc_func = GImAllocatorAllocFunc;
	*p_free_func = GImAllocatorFreeFunc;
	*p_user_data = GImAllocatorUserData;
}

ImGuiContext *ImGui::CreateContext(ImFontAtlas *shared_font_atlas) {
	ImGuiContext *prev_ctx = GetCurrentContext();
	ImGuiContext *ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
	SetCurrentContext(ctx);
	Initialize();
	if (prev_ctx != NULL)
		SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
	return ctx;
}

void ImGui::DestroyContext(ImGuiContext *ctx) {
	ImGuiContext *prev_ctx = GetCurrentContext();
	if (ctx == NULL) //-V1051
		ctx = prev_ctx;
	SetCurrentContext(ctx);
	Shutdown();
	SetCurrentContext((prev_ctx != ctx) ? prev_ctx : NULL);
	IM_DELETE(ctx);
}

// IMPORTANT: ###xxx suffixes must be same in ALL languages to allow for automation.
static const ImGuiLocEntry GLocalizationEntriesEnUS[] = {
	{ ImGuiLocKey_VersionStr, "Dear ImGui " IMGUI_VERSION " (" IM_STRINGIFY(IMGUI_VERSION_NUM) ")" },
	{ ImGuiLocKey_TableSizeOne, "Size column to fit###SizeOne" },
	{ ImGuiLocKey_TableSizeAllFit, "Size all columns to fit###SizeAll" },
	{ ImGuiLocKey_TableSizeAllDefault, "Size all columns to default###SizeAll" },
	{ ImGuiLocKey_TableResetOrder, "Reset order###ResetOrder" },
	{ ImGuiLocKey_WindowingMainMenuBar, "(Main menu bar)" },
	{ ImGuiLocKey_WindowingPopup, "(Popup)" },
	{ ImGuiLocKey_WindowingUntitled, "(Untitled)" },
	{ ImGuiLocKey_CopyLink, "Copy Link###CopyLink" },
};

void ImGui::Initialize() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(!g.Initialized && !g.SettingsLoaded);

	// Add .ini handle for ImGuiWindow and ImGuiTable types
	{
		ImGuiSettingsHandler ini_handler;
		ini_handler.TypeName = "Window";
		ini_handler.TypeHash = ImHashStr("Window");
		ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
		ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
		ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
		ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
		ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
		AddSettingsHandler(&ini_handler);
	}
	TableSettingsAddSettingsHandler();

	// Setup default localization table
	LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));

	// Setup default ImGuiPlatformIO clipboard/IME handlers.
	g.PlatformIO.Platform_GetClipboardTextFn = Platform_GetClipboardTextFn_DefaultImpl; // Platform dependent default implementations
	g.PlatformIO.Platform_SetClipboardTextFn = Platform_SetClipboardTextFn_DefaultImpl;
	g.PlatformIO.Platform_OpenInShellFn = Platform_OpenInShellFn_DefaultImpl;
	g.PlatformIO.Platform_SetImeDataFn = Platform_SetImeDataFn_DefaultImpl;

	// Create default viewport
	ImGuiViewportP *viewport = IM_NEW(ImGuiViewportP)();
	viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
	g.Viewports.push_back(viewport);
	g.TempBuffer.resize(1024 * 3 + 1, 0);

	// Build KeysMayBeCharInput[] lookup table (1 bool per named key)
	for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
		if ((key >= ImGuiKey_0 && key <= ImGuiKey_9) || (key >= ImGuiKey_A && key <= ImGuiKey_Z) || (key >= ImGuiKey_Keypad0 && key <= ImGuiKey_Keypad9) || key == ImGuiKey_Tab || key == ImGuiKey_Space || key == ImGuiKey_Apostrophe || key == ImGuiKey_Comma || key == ImGuiKey_Minus || key == ImGuiKey_Period || key == ImGuiKey_Slash || key == ImGuiKey_Semicolon || key == ImGuiKey_Equal || key == ImGuiKey_LeftBracket || key == ImGuiKey_RightBracket || key == ImGuiKey_GraveAccent || key == ImGuiKey_KeypadDecimal || key == ImGuiKey_KeypadDivide || key == ImGuiKey_KeypadMultiply || key == ImGuiKey_KeypadSubtract || key == ImGuiKey_KeypadAdd || key == ImGuiKey_KeypadEqual)
			g.KeysMayBeCharInput.SetBit(key);

#ifdef IMGUI_HAS_DOCK
#endif

	g.Initialized = true;
}

// This function is merely here to free heap allocations.
void ImGui::Shutdown() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT_USER_ERROR(g.IO.BackendPlatformUserData == NULL, "Forgot to shutdown Platform backend?");
	IM_ASSERT_USER_ERROR(g.IO.BackendRendererUserData == NULL, "Forgot to shutdown Renderer backend?");

	// The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
	if (g.IO.Fonts && g.FontAtlasOwnedByContext) {
		g.IO.Fonts->Locked = false;
		IM_DELETE(g.IO.Fonts);
	}
	g.IO.Fonts = NULL;
	g.DrawListSharedData.TempBuffer.clear();

	// Cleanup of other data are conditional on actually having initialized Dear ImGui.
	if (!g.Initialized)
		return;

	// Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
	if (g.SettingsLoaded && g.IO.IniFilename != NULL)
		SaveIniSettingsToDisk(g.IO.IniFilename);

	CallContextHooks(&g, ImGuiContextHookType_Shutdown);

	// Clear everything else
	g.Windows.clear_delete();
	g.WindowsFocusOrder.clear();
	g.WindowsTempSortBuffer.clear();
	g.CurrentWindow = NULL;
	g.CurrentWindowStack.clear();
	g.WindowsById.Clear();
	g.NavWindow = NULL;
	g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
	g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
	g.MovingWindow = NULL;

	g.KeysRoutingTable.Clear();

	g.ColorStack.clear();
	g.StyleVarStack.clear();
	g.FontStack.clear();
	g.OpenPopupStack.clear();
	g.BeginPopupStack.clear();
	g.TreeNodeStack.clear();

	g.Viewports.clear_delete();

	g.TabBars.Clear();
	g.CurrentTabBarStack.clear();
	g.ShrinkWidthBuffer.clear();

	g.ClipperTempData.clear_destruct();

	g.Tables.Clear();
	g.TablesTempData.clear_destruct();
	g.DrawChannelsTempMergeBuffer.clear();

	g.MultiSelectStorage.Clear();
	g.MultiSelectTempData.clear_destruct();

	g.ClipboardHandlerData.clear();
	g.MenusIdSubmittedThisFrame.clear();
	g.InputTextState.ClearFreeMemory();
	g.InputTextDeactivatedState.ClearFreeMemory();

	g.SettingsWindows.clear();
	g.SettingsHandlers.clear();

	if (g.LogFile) {
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
		if (g.LogFile != stdout)
#endif
			ImFileClose(g.LogFile);
		g.LogFile = NULL;
	}
	g.LogBuffer.clear();
	g.DebugLogBuf.clear();
	g.DebugLogIndex.clear();

	g.Initialized = false;
}

// No specific ordering/dependency support, will see as needed
ImGuiID ImGui::AddContextHook(ImGuiContext *ctx, const ImGuiContextHook *hook) {
	ImGuiContext &g = *ctx;
	IM_ASSERT(hook->Callback != NULL && hook->HookId == 0 && hook->Type != ImGuiContextHookType_PendingRemoval_);
	g.Hooks.push_back(*hook);
	g.Hooks.back().HookId = ++g.HookIdNext;
	return g.HookIdNext;
}

// Deferred removal, avoiding issue with changing vector while iterating it
void ImGui::RemoveContextHook(ImGuiContext *ctx, ImGuiID hook_id) {
	ImGuiContext &g = *ctx;
	IM_ASSERT(hook_id != 0);
	for (ImGuiContextHook &hook : g.Hooks)
		if (hook.HookId == hook_id)
			hook.Type = ImGuiContextHookType_PendingRemoval_;
}

// Call context hooks (used by e.g. test engine)
// We assume a small number of hooks so all stored in same array
void ImGui::CallContextHooks(ImGuiContext *ctx, ImGuiContextHookType hook_type) {
	ImGuiContext &g = *ctx;
	for (ImGuiContextHook &hook : g.Hooks)
		if (hook.Type == hook_type)
			hook.Callback(&g, &hook);
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
ImGuiWindow::ImGuiWindow(ImGuiContext *ctx, const char *name) : DrawListInst(NULL) {
	memset(this, 0, sizeof(*this));
	Ctx = ctx;
	Name = ImStrdup(name);
	NameBufLen = (int)strlen(name) + 1;
	ID = ImHashStr(name);
	IDStack.push_back(ID);
	MoveId = GetID("#MOVE");
	ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
	ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
	AutoFitFramesX = AutoFitFramesY = -1;
	AutoPosLastDirection = ImGuiDir_None;
	SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = 0;
	SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
	LastFrameActive = -1;
	LastTimeActive = -1.0f;
	FontWindowScale = 1.0f;
	SettingsOffset = -1;
	DrawList = &DrawListInst;
	DrawList->_Data = &Ctx->DrawListSharedData;
	DrawList->_OwnerName = Name;
	NavPreferredScoringPosRel[0] = NavPreferredScoringPosRel[1] = ImVec2(FLT_MAX, FLT_MAX);
}

ImGuiWindow::~ImGuiWindow() {
	IM_ASSERT(DrawList == &DrawListInst);
	IM_DELETE(Name);
	ColumnsStorage.clear_destruct();
}

static void SetCurrentWindow(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	g.CurrentWindow = window;
	g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
	g.CurrentDpiScale = 1.0f; // FIXME-DPI: WIP this is modified in docking
	if (window) {
		g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
		g.FontScale = g.FontSize / g.Font->FontSize;
		ImGui::NavUpdateCurrentWindowIsScrollPushableX();
	}
}

void ImGui::GcCompactTransientMiscBuffers() {
	ImGuiContext &g = *GImGui;
	g.ItemFlagsStack.clear();
	g.GroupStack.clear();
	g.MultiSelectTempDataStacked = 0;
	g.MultiSelectTempData.clear_destruct();
	TableGcCompactSettings();
}

// Free up/compact internal window buffers, we can use this when a window becomes unused.
// Not freed:
// - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)
// This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
void ImGui::GcCompactTransientWindowBuffers(ImGuiWindow *window) {
	window->MemoryCompacted = true;
	window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
	window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
	window->IDStack.clear();
	window->DrawList->_ClearFreeMemory();
	window->DC.ChildWindows.clear();
	window->DC.ItemWidthStack.clear();
	window->DC.TextWrapPosStack.clear();
}

void ImGui::GcAwakeTransientWindowBuffers(ImGuiWindow *window) {
	// We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
	// The other buffers tends to amortize much faster.
	window->MemoryCompacted = false;
	window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
	window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
	window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
}

void ImGui::SetActiveID(ImGuiID id, ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;

	// Clear previous active id
	if (g.ActiveId != 0) {
		// While most behaved code would make an effort to not steal active id during window move/drag operations,
		// we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
		// may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
		if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId) {
			IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
			g.MovingWindow = NULL;
		}

		// This could be written in a more general way (e.g associate a hook to ActiveId),
		// but since this is currently quite an exception we'll leave it as is.
		// One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveId()
		if (g.InputTextState.ID == g.ActiveId)
			InputTextDeactivateHook(g.ActiveId);
	}

	// Set active id
	g.ActiveIdIsJustActivated = (g.ActiveId != id);
	if (g.ActiveIdIsJustActivated) {
		IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : "");
		g.ActiveIdTimer = 0.0f;
		g.ActiveIdHasBeenPressedBefore = false;
		g.ActiveIdHasBeenEditedBefore = false;
		g.ActiveIdMouseButton = -1;
		if (id != 0) {
			g.LastActiveId = id;
			g.LastActiveIdTimer = 0.0f;
		}
	}
	g.ActiveId = id;
	g.ActiveIdAllowOverlap = false;
	g.ActiveIdNoClearOnFocusLoss = false;
	g.ActiveIdWindow = window;
	g.ActiveIdHasBeenEditedThisFrame = false;
	g.ActiveIdFromShortcut = false;
	if (id) {
		g.ActiveIdIsAlive = id;
		g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;
		IM_ASSERT(g.ActiveIdSource != ImGuiInputSource_None);
	}

	// Clear declaration of inputs claimed by the widget
	// (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
	g.ActiveIdUsingNavDirMask = 0x00;
	g.ActiveIdUsingAllKeyboardKeys = false;
}

void ImGui::ClearActiveID() {
	SetActiveID(0, NULL); // g.ActiveId = 0;
}

void ImGui::SetHoveredID(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	g.HoveredId = id;
	g.HoveredIdAllowOverlap = false;
	if (id != 0 && g.HoveredIdPreviousFrame != id)
		g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

ImGuiID ImGui::GetHoveredID() {
	ImGuiContext &g = *GImGui;
	return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void ImGui::MarkItemEdited(ImGuiID id) {
	// This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
	// ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need to fill the data.
	ImGuiContext &g = *GImGui;
	if (g.LockMarkEdited > 0)
		return;
	if (g.ActiveId == id || g.ActiveId == 0) {
		g.ActiveIdHasBeenEditedThisFrame = true;
		g.ActiveIdHasBeenEditedBefore = true;
	}

	// We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
	// We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
	IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id || (g.CurrentMultiSelect != NULL && g.BoxSelectState.IsActive));

	//IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
	g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;
}

bool ImGui::IsWindowContentHoverable(ImGuiWindow *window, ImGuiHoveredFlags flags) {
	// An active popup disable hovering on other windows (apart from its own children)
	// FIXME-OPT: This could be cached/stored within the window.
	ImGuiContext &g = *GImGui;
	if (g.NavWindow)
		if (ImGuiWindow *focused_root_window = g.NavWindow->RootWindow)
			if (focused_root_window->WasActive && focused_root_window != window->RootWindow) {
				// For the purpose of those flags we differentiate "standard popup" from "modal popup"
				// NB: The 'else' is important because Modal windows are also Popups.
				bool want_inhibit = false;
				if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
					want_inhibit = true;
				else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
					want_inhibit = true;

				// Inhibit hover unless the window is within the stack of our modal/popup
				if (want_inhibit)
					if (!IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))
						return false;
			}
	return true;
}

static inline float CalcDelayFromHoveredFlags(ImGuiHoveredFlags flags) {
	ImGuiContext &g = *GImGui;
	if (flags & ImGuiHoveredFlags_DelayNormal)
		return g.Style.HoverDelayNormal;
	if (flags & ImGuiHoveredFlags_DelayShort)
		return g.Style.HoverDelayShort;
	return 0.0f;
}

static ImGuiHoveredFlags ApplyHoverFlagsForTooltip(ImGuiHoveredFlags user_flags, ImGuiHoveredFlags shared_flags) {
	// Allow instance flags to override shared flags
	if (user_flags & (ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_DelayNormal))
		shared_flags &= ~(ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_DelayNormal);
	return user_flags | shared_flags;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool ImGui::IsItemHovered(ImGuiHoveredFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT((flags & ~ImGuiHoveredFlags_AllowedMaskForIsItemHovered) == 0 && "Invalid flags for IsItemHovered()!");

	if (g.NavDisableMouseHover && !g.NavDisableHighlight && !(flags & ImGuiHoveredFlags_NoNavOverride)) {
		if ((g.LastItemData.InFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
			return false;
		if (!IsItemFocused())
			return false;

		if (flags & ImGuiHoveredFlags_ForTooltip)
			flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipNav);
	} else {
		// Test for bounding box overlap, as updated as ItemAdd()
		ImGuiItemStatusFlags status_flags = g.LastItemData.StatusFlags;
		if (!(status_flags & ImGuiItemStatusFlags_HoveredRect))
			return false;

		if (flags & ImGuiHoveredFlags_ForTooltip)
			flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);

		IM_ASSERT((flags & (ImGuiHoveredFlags_AnyWindow | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_NoPopupHierarchy)) == 0); // Flags not supported by this function

		// Done with rectangle culling so we can perform heavier checks now
		// Test if we are hovering the right window (our window could be behind another window)
		// [2021/03/02] Reworked / reverted the revert, finally. Note we want e.g. BeginGroup/ItemAdd/EndGroup to work as well. (#3851)
		// [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable
		// to use IsItemHovered() after EndChild() itself. Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was
		// the test that has been running for a long while.
		if (g.HoveredWindow != window && (status_flags & ImGuiItemStatusFlags_HoveredWindow) == 0)
			if ((flags & ImGuiHoveredFlags_AllowWhenOverlappedByWindow) == 0)
				return false;

		// Test if another item is active (e.g. being dragged)
		const ImGuiID id = g.LastItemData.ID;
		if ((flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) == 0)
			if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
				if (g.ActiveId != window->MoveId)
					return false;

		// Test if interactions on this window are blocked by an active popup or modal.
		// The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.
		if (!IsWindowContentHoverable(window, flags) && !(g.LastItemData.InFlags & ImGuiItemFlags_NoWindowHoverableCheck))
			return false;

		// Test if the item is disabled
		if ((g.LastItemData.InFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
			return false;

		// Special handling for calling after Begin() which represent the title bar or tab.
		// When the window is skipped/collapsed (SkipItems==true) that last item (always ->MoveId submitted by Begin)
		// will never be overwritten so we need to detect the case.
		if (id == window->MoveId && window->WriteAccessed)
			return false;

		// Test if using AllowOverlap and overlapped
		if ((g.LastItemData.InFlags & ImGuiItemFlags_AllowOverlap) && id != 0)
			if ((flags & ImGuiHoveredFlags_AllowWhenOverlappedByItem) == 0)
				if (g.HoveredIdPreviousFrame != g.LastItemData.ID)
					return false;
	}

	// Handle hover delay
	// (some ideas: https://www.nngroup.com/articles/timing-exposing-content)
	const float delay = CalcDelayFromHoveredFlags(flags);
	if (delay > 0.0f || (flags & ImGuiHoveredFlags_Stationary)) {
		ImGuiID hover_delay_id = (g.LastItemData.ID != 0) ? g.LastItemData.ID : window->GetIDFromPos(g.LastItemData.Rect.Min);
		if ((flags & ImGuiHoveredFlags_NoSharedDelay) && (g.HoverItemDelayIdPreviousFrame != hover_delay_id))
			g.HoverItemDelayTimer = 0.0f;
		g.HoverItemDelayId = hover_delay_id;

		// When changing hovered item we requires a bit of stationary delay before activating hover timer,
		// but once unlocked on a given item we also moving.
		//if (g.HoverDelayTimer >= delay && (g.HoverDelayTimer - g.IO.DeltaTime < delay || g.MouseStationaryTimer - g.IO.DeltaTime < g.Style.HoverStationaryDelay)) { IMGUI_DEBUG_LOG("HoverDelayTimer = %f/%f, MouseStationaryTimer = %f\n", g.HoverDelayTimer, delay, g.MouseStationaryTimer); }
		if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverItemUnlockedStationaryId != hover_delay_id)
			return false;

		if (g.HoverItemDelayTimer < delay)
			return false;
	}

	return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
// (this does not rely on LastItemData it can be called from a ButtonBehavior() call not following an ItemAdd() call)
// FIXME-LEGACY: the 'ImGuiItemFlags item_flags' parameter was added on 2023-06-28.
// If you used this in your legacy/custom widgets code:
// - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass 'item_flags = g.LastItemData.InFlags'.
// - Rare: otherwise you may pass 'item_flags = 0' (ImGuiItemFlags_None) unless you want to benefit from special behavior handled by ItemHoverable.
bool ImGui::ItemHoverable(const ImRect &bb, ImGuiID id, ImGuiItemFlags item_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (g.HoveredWindow != window)
		return false;
	if (!IsMouseHoveringRect(bb.Min, bb.Max))
		return false;

	if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
		return false;
	if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
		if (!g.ActiveIdFromShortcut)
			return false;

	// Done with rectangle culling so we can perform heavier checks now.
	if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_None)) {
		g.HoveredIdIsDisabled = true;
		return false;
	}

	// We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
	// hover test in widgets code. We could also decide to split this function is two.
	if (id != 0) {
		// Drag source doesn't report as hovered
		if (g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
			return false;

		SetHoveredID(id);

		// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
		// This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
		if (item_flags & ImGuiItemFlags_AllowOverlap) {
			g.HoveredIdAllowOverlap = true;
			if (g.HoveredIdPreviousFrame != id)
				return false;
		}

		// Display shortcut (only works with mouse)
		// (ImGuiItemStatusFlags_HasShortcut in LastItemData denotes we want a tooltip)
		if (id == g.LastItemData.ID && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasShortcut))
			if (IsItemHovered(ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal))
				SetTooltip("%s", GetKeyChordName(g.LastItemData.Shortcut));
	}

	// When disabled we'll return false but still set HoveredId
	if (item_flags & ImGuiItemFlags_Disabled) {
		// Release active id if turning disabled
		if (g.ActiveId == id && id != 0)
			ClearActiveID();
		g.HoveredIdIsDisabled = true;
		return false;
	}

#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	if (id != 0) {
		// [DEBUG] Item Picker tool!
		// We perform the check here because reaching is path is rare (1~ time a frame),
		// making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
		// items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
		if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
			GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
		if (g.DebugItemPickerBreakId == id)
			IM_DEBUG_BREAK();
	}
#endif

	if (g.NavDisableMouseHover)
		return false;

	return true;
}

// FIXME: This is inlined/duplicated in ItemAdd()
// FIXME: The id != 0 path is not used by our codebase, may get rid of it?
bool ImGui::IsClippedEx(const ImRect &bb, ImGuiID id) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (!bb.Overlaps(window->ClipRect))
		if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId))
			if (!g.ItemUnclipByLog)
				return true;
	return false;
}

// This is also inlined in ItemAdd()
// Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set g.LastItemData.DisplayRect.
void ImGui::SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags item_flags, const ImRect &item_rect) {
	ImGuiContext &g = *GImGui;
	g.LastItemData.ID = item_id;
	g.LastItemData.InFlags = in_flags;
	g.LastItemData.StatusFlags = item_flags;
	g.LastItemData.Rect = g.LastItemData.NavRect = item_rect;
}

float ImGui::CalcWrapWidthForPos(const ImVec2 &pos, float wrap_pos_x) {
	if (wrap_pos_x < 0.0f)
		return 0.0f;

	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (wrap_pos_x == 0.0f) {
		// We could decide to setup a default wrapping max point for auto-resizing windows,
		// or have auto-wrap (with unspecified wrapping pos) behave as a ContentSize extending function?
		//if (window->Hidden && (window->Flags & ImGuiWindowFlags_AlwaysAutoResize))
		//    wrap_pos_x = ImMax(window->WorkRect.Min.x + g.FontSize * 10.0f, window->WorkRect.Max.x);
		//else
		wrap_pos_x = window->WorkRect.Max.x;
	} else if (wrap_pos_x > 0.0f) {
		wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space
	}

	return ImMax(wrap_pos_x - pos.x, 1.0f);
}

// IM_ALLOC() == ImGui::MemAlloc()
void *ImGui::MemAlloc(size_t size) {
	void *ptr = (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	if (ImGuiContext *ctx = GImGui)
		DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, size);
#endif
	return ptr;
}

// IM_FREE() == ImGui::MemFree()
void ImGui::MemFree(void *ptr) {
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	if (ptr != NULL)
		if (ImGuiContext *ctx = GImGui)
			DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, (size_t)-1);
#endif
	return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
}

// We record the number of allocation in recent frames, as a way to audit/sanitize our guiding principles of "no allocations on idle/repeating frames"
void ImGui::DebugAllocHook(ImGuiDebugAllocInfo *info, int frame_count, void *ptr, size_t size) {
	ImGuiDebugAllocEntry *entry = &info->LastEntriesBuf[info->LastEntriesIdx];
	IM_UNUSED(ptr);
	if (entry->FrameCount != frame_count) {
		info->LastEntriesIdx = (info->LastEntriesIdx + 1) % IM_ARRAYSIZE(info->LastEntriesBuf);
		entry = &info->LastEntriesBuf[info->LastEntriesIdx];
		entry->FrameCount = frame_count;
		entry->AllocCount = entry->FreeCount = 0;
	}
	if (size != (size_t)-1) {
		entry->AllocCount++;
		info->TotalAllocCount++;
		//printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, size, ptr);
	} else {
		entry->FreeCount++;
		info->TotalFreeCount++;
		//printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
	}
}

const char *ImGui::GetClipboardText() {
	ImGuiContext &g = *GImGui;
	return g.PlatformIO.Platform_GetClipboardTextFn ? g.PlatformIO.Platform_GetClipboardTextFn(&g) : "";
}

void ImGui::SetClipboardText(const char *text) {
	ImGuiContext &g = *GImGui;
	if (g.PlatformIO.Platform_SetClipboardTextFn != NULL)
		g.PlatformIO.Platform_SetClipboardTextFn(&g, text);
}

const char *ImGui::GetVersion() {
	return IMGUI_VERSION;
}

ImGuiIO &ImGui::GetIO() {
	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
	return GImGui->IO;
}

ImGuiPlatformIO &ImGui::GetPlatformIO() {
	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext()?");
	return GImGui->PlatformIO;
}

// Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()
ImDrawData *ImGui::GetDrawData() {
	ImGuiContext &g = *GImGui;
	ImGuiViewportP *viewport = g.Viewports[0];
	return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
}

double ImGui::GetTime() {
	return GImGui->Time;
}

int ImGui::GetFrameCount() {
	return GImGui->FrameCount;
}

static ImDrawList *GetViewportBgFgDrawList(ImGuiViewportP *viewport, size_t drawlist_no, const char *drawlist_name) {
	// Create the draw list on demand, because they are not frequently used for all viewports
	ImGuiContext &g = *GImGui;
	IM_ASSERT(drawlist_no < IM_ARRAYSIZE(viewport->BgFgDrawLists));
	ImDrawList *draw_list = viewport->BgFgDrawLists[drawlist_no];
	if (draw_list == NULL) {
		draw_list = IM_NEW(ImDrawList)(&g.DrawListSharedData);
		draw_list->_OwnerName = drawlist_name;
		viewport->BgFgDrawLists[drawlist_no] = draw_list;
	}

	// Our ImDrawList system requires that there is always a command
	if (viewport->BgFgDrawListsLastFrame[drawlist_no] != g.FrameCount) {
		draw_list->_ResetForNewFrame();
		draw_list->PushTextureID(g.IO.Fonts->TexID);
		draw_list->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size, false);
		viewport->BgFgDrawListsLastFrame[drawlist_no] = g.FrameCount;
	}
	return draw_list;
}

ImDrawList *ImGui::GetBackgroundDrawList(ImGuiViewport *viewport) {
	return GetViewportBgFgDrawList((ImGuiViewportP *)viewport, 0, "##Background");
}

ImDrawList *ImGui::GetBackgroundDrawList() {
	ImGuiContext &g = *GImGui;
	return GetBackgroundDrawList(g.Viewports[0]);
}

ImDrawList *ImGui::GetForegroundDrawList(ImGuiViewport *viewport) {
	return GetViewportBgFgDrawList((ImGuiViewportP *)viewport, 1, "##Foreground");
}

ImDrawList *ImGui::GetForegroundDrawList() {
	ImGuiContext &g = *GImGui;
	return GetForegroundDrawList(g.Viewports[0]);
}

ImDrawListSharedData *ImGui::GetDrawListSharedData() {
	return &GImGui->DrawListSharedData;
}

void ImGui::StartMouseMovingWindow(ImGuiWindow *window) {
	// Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
	// We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
	// This is because we want ActiveId to be set even when the window is not permitted to move.
	ImGuiContext &g = *GImGui;
	FocusWindow(window);
	SetActiveID(window->MoveId, window);
	g.NavDisableHighlight = true;
	g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindow->Pos;
	g.ActiveIdNoClearOnFocusLoss = true;
	SetActiveIdUsingAllKeyboardKeys();

	bool can_move_window = true;
	if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindow->Flags & ImGuiWindowFlags_NoMove))
		can_move_window = false;
	if (can_move_window)
		g.MovingWindow = window;
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.
// This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
// but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
void ImGui::UpdateMouseMovingWindowNewFrame() {
	ImGuiContext &g = *GImGui;
	if (g.MovingWindow != NULL) {
		// We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
		// We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
		KeepAliveID(g.ActiveId);
		IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
		ImGuiWindow *moving_window = g.MovingWindow->RootWindow;
		if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos)) {
			ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
			SetWindowPos(moving_window, pos, ImGuiCond_Always);
			FocusWindow(g.MovingWindow);
		} else {
			g.MovingWindow = NULL;
			ClearActiveID();
		}
	} else {
		// When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
		if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId) {
			KeepAliveID(g.ActiveId);
			if (!g.IO.MouseDown[0])
				ClearActiveID();
		}
	}
}

// Initiate moving window when clicking on empty space or title bar.
// Handle left-click and right-click focus.
void ImGui::UpdateMouseMovingWindowEndFrame() {
	ImGuiContext &g = *GImGui;
	if (g.ActiveId != 0 || g.HoveredId != 0)
		return;

	// Unless we just made a window/popup appear
	if (g.NavWindow && g.NavWindow->Appearing)
		return;

	// Click on empty space to focus window and start moving
	// (after we're done with all our widgets)
	if (g.IO.MouseClicked[0]) {
		// Handle the edge case of a popup being closed while clicking in its empty space.
		// If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
		ImGuiWindow *root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
		const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);

		if (root_window != NULL && !is_closed_popup) {
			StartMouseMovingWindow(g.HoveredWindow); //-V595

			// Cancel moving if clicked outside of title bar
			if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
				if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar))
					if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
						g.MovingWindow = NULL;

			// Cancel moving if clicked over an item which was disabled or inhibited by popups (note that we know HoveredId == 0 already)
			if (g.HoveredIdIsDisabled)
				g.MovingWindow = NULL;
		} else if (root_window == NULL && g.NavWindow != NULL) {
			// Clicking on void disable focus
			FocusWindow(NULL, ImGuiFocusRequestFlags_UnlessBelowModal);
		}
	}

	// With right mouse button we close popups without changing focus based on where the mouse is aimed
	// Instead, focus will be restored to the window under the bottom-most closed popup.
	// (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
	if (g.IO.MouseClicked[1]) {
		// Find the top-most window between HoveredWindow and the top-most Modal Window.
		// This is where we can trim the popup stack.
		ImGuiWindow *modal = GetTopMostPopupModal();
		bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
		ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
	}
}

static bool IsWindowActiveAndVisible(ImGuiWindow *window) {
	return (window->Active) && (!window->Hidden);
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
void ImGui::UpdateHoveredWindowAndCaptureFlags() {
	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;

	// FIXME-DPI: This storage was added on 2021/03/31 for test engine, but if we want to multiply WINDOWS_HOVER_PADDING
	// by DpiScale, we need to make this window-agnostic anyhow, maybe need storing inside ImGuiWindow.
	g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));

	// Find the window hovered by mouse:
	// - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
	// - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
	// - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
	bool clear_hovered_windows = false;
	FindHoveredWindowEx(g.IO.MousePos, false, &g.HoveredWindow, &g.HoveredWindowUnderMovingWindow);
	g.HoveredWindowBeforeClear = g.HoveredWindow;

	// Modal windows prevents mouse from hovering behind them.
	ImGuiWindow *modal_window = GetTopMostPopupModal();
	if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window))
		clear_hovered_windows = true;

	// Disabled mouse hovering (we don't currently clear MousePos, we could)
	if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
		clear_hovered_windows = true;

	// We track click ownership. When clicked outside of a window the click is owned by the application and
	// won't report hovering nor request capture even while dragging over our windows afterward.
	const bool has_open_popup = (g.OpenPopupStack.Size > 0);
	const bool has_open_modal = (modal_window != NULL);
	int mouse_earliest_down = -1;
	bool mouse_any_down = false;
	for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) {
		if (io.MouseClicked[i]) {
			io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
			io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;
		}
		mouse_any_down |= io.MouseDown[i];
		if (io.MouseDown[i] || io.MouseReleased[i]) // Increase release frame for our evaluation of earliest button (#1392)
			if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
				mouse_earliest_down = i;
	}
	const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
	const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];

	// If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
	// FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
	const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
	if (!mouse_avail && !mouse_dragging_extern_payload)
		clear_hovered_windows = true;

	if (clear_hovered_windows)
		g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;

	// Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
	// Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
	if (g.WantCaptureMouseNextFrame != -1) {
		io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
	} else {
		io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;
		io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;
	}

	// Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
	io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
	if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
		io.WantCaptureKeyboard = true;
	if (g.WantCaptureKeyboardNextFrame != -1) // Manual override
		io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);

	// Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
	io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

// Calling SetupDrawListSharedData() is followed by SetCurrentFont() which sets up the remaining data.
static void SetupDrawListSharedData() {
	ImGuiContext &g = *GImGui;
	ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
	for (ImGuiViewportP *viewport : g.Viewports)
		virtual_space.Add(viewport->GetMainRect());
	g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
	g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
	g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
	g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
	if (g.Style.AntiAliasedLines)
		g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
	if (g.Style.AntiAliasedLinesUseTex && !(g.IO.Fonts->Flags & ImFontAtlasFlags_NoBakedLines))
		g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
	if (g.Style.AntiAliasedFill)
		g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
	if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
		g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;
}

void ImGui::NewFrame() {
	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
	ImGuiContext &g = *GImGui;

	// Remove pending delete hooks before frame start.
	// This deferred removal avoid issues of removal while iterating the hook vector
	for (int n = g.Hooks.Size - 1; n >= 0; n--)
		if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
			g.Hooks.erase(&g.Hooks[n]);

	CallContextHooks(&g, ImGuiContextHookType_NewFramePre);

	// Check and assert for various common IO and Configuration mistakes
	ErrorCheckNewFrameSanityChecks();

	// Load settings on first frame, save settings when modified (after a delay)
	UpdateSettings();

	g.Time += g.IO.DeltaTime;
	g.WithinFrameScope = true;
	g.FrameCount += 1;
	g.TooltipOverrideCount = 0;
	g.WindowsActiveCount = 0;
	g.MenusIdSubmittedThisFrame.resize(0);

	// Calculate frame-rate for the user, as a purely luxurious feature
	g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
	g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
	g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
	g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));
	g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;

	// Process input queue (trickle as many events as possible), turn events into writes to IO structure
	g.InputEventsTrail.resize(0);
	UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);

	// Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
	UpdateViewportsNewFrame();

	// Setup current font and draw list shared data
	g.IO.Fonts->Locked = true;
	SetupDrawListSharedData();
	SetCurrentFont(GetDefaultFont());
	IM_ASSERT(g.Font->IsLoaded());

	// Mark rendering data as invalid to prevent user who may have a handle on it to use it.
	for (ImGuiViewportP *viewport : g.Viewports)
		viewport->DrawDataP.Valid = false;

	// Drag and drop keep the source ID alive so even if the source disappear our state is consistent
	if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
		KeepAliveID(g.DragDropPayload.SourceId);

	// Update HoveredId data
	if (!g.HoveredIdPreviousFrame)
		g.HoveredIdTimer = 0.0f;
	if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
		g.HoveredIdNotActiveTimer = 0.0f;
	if (g.HoveredId)
		g.HoveredIdTimer += g.IO.DeltaTime;
	if (g.HoveredId && g.ActiveId != g.HoveredId)
		g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
	g.HoveredIdPreviousFrame = g.HoveredId;
	g.HoveredId = 0;
	g.HoveredIdAllowOverlap = false;
	g.HoveredIdIsDisabled = false;

	// Clear ActiveID if the item is not alive anymore.
	// In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
	// As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
	if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId) {
		IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
		ClearActiveID();
	}

	// Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
	if (g.ActiveId)
		g.ActiveIdTimer += g.IO.DeltaTime;
	g.LastActiveIdTimer += g.IO.DeltaTime;
	g.ActiveIdPreviousFrame = g.ActiveId;
	g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
	g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
	g.ActiveIdIsAlive = 0;
	g.ActiveIdHasBeenEditedThisFrame = false;
	g.ActiveIdPreviousFrameIsAlive = false;
	g.ActiveIdIsJustActivated = false;
	if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
		g.TempInputId = 0;
	if (g.ActiveId == 0) {
		g.ActiveIdUsingNavDirMask = 0x00;
		g.ActiveIdUsingAllKeyboardKeys = false;
	}

	// Record when we have been stationary as this state is preserved while over same item.
	// FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
	// To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
	if (g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
		g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;
	else if (g.HoverItemDelayId == 0)
		g.HoverItemUnlockedStationaryId = 0;
	if (g.HoveredWindow != NULL && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
		g.HoverWindowUnlockedStationaryId = g.HoveredWindow->ID;
	else if (g.HoveredWindow == NULL)
		g.HoverWindowUnlockedStationaryId = 0;

	// Update hover delay for IsItemHovered() with delays and tooltips
	g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;
	if (g.HoverItemDelayId != 0) {
		g.HoverItemDelayTimer += g.IO.DeltaTime;
		g.HoverItemDelayClearTimer = 0.0f;
		g.HoverItemDelayId = 0;
	} else if (g.HoverItemDelayTimer > 0.0f) {
		// This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
		// We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
		g.HoverItemDelayClearTimer += g.IO.DeltaTime;
		if (g.HoverItemDelayClearTimer >= ImMax(0.25f, g.IO.DeltaTime * 2.0f)) // ~7 frames at 30 Hz + allow for low framerate
			g.HoverItemDelayTimer = g.HoverItemDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
	}

	// Drag and drop
	g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
	g.DragDropAcceptIdCurr = 0;
	g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
	g.DragDropWithinSource = false;
	g.DragDropWithinTarget = false;
	g.DragDropHoldJustPressedId = 0;

	// Close popups on focus lost (currently wip/opt-in)
	//if (g.IO.AppFocusLost)
	//    ClosePopupsExceptModals();

	// Update keyboard input state
	UpdateKeyboardInputs();

	//IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
	//IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
	//IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
	//IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));

	// Update gamepad/keyboard navigation
	NavUpdate();

	// Update mouse input state
	UpdateMouseInputs();

	// Find hovered window
	// (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
	UpdateHoveredWindowAndCaptureFlags();

	// Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
	UpdateMouseMovingWindowNewFrame();

	// Background darkening/whitening
	if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
		g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
	else
		g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

	g.MouseCursor = ImGuiMouseCursor_Arrow;
	g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;

	// Platform IME data: reset for the frame
	g.PlatformImeDataPrev = g.PlatformImeData;
	g.PlatformImeData.WantVisible = false;

	// Mouse wheel scrolling, scale
	UpdateMouseWheel();

	// Mark all windows as not visible and compact unused memory.
	IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
	const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
	for (ImGuiWindow *window : g.Windows) {
		window->WasActive = window->Active;
		window->Active = false;
		window->WriteAccessed = false;
		window->BeginCountPreviousFrame = window->BeginCount;
		window->BeginCount = 0;

		// Garbage collect transient buffers of recently unused windows
		if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
			GcCompactTransientWindowBuffers(window);
	}

	// Garbage collect transient buffers of recently unused tables
	for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
		if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
			TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
	for (ImGuiTableTempData &table_temp_data : g.TablesTempData)
		if (table_temp_data.LastTimeActive >= 0.0f && table_temp_data.LastTimeActive < memory_compact_start_time)
			TableGcCompactTransientBuffers(&table_temp_data);
	if (g.GcCompactAll)
		GcCompactTransientMiscBuffers();
	g.GcCompactAll = false;

	// Closing the focused window restore focus to the first active root window in descending z-order
	if (g.NavWindow && !g.NavWindow->WasActive)
		FocusTopMostWindowUnderOne(NULL, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild);

	// No window should be open at the beginning of the frame.
	// But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
	g.CurrentWindowStack.resize(0);
	g.BeginPopupStack.resize(0);
	g.ItemFlagsStack.resize(0);
	g.ItemFlagsStack.push_back(ImGuiItemFlags_AutoClosePopups); // Default flags
	g.CurrentItemFlags = g.ItemFlagsStack.back();
	g.GroupStack.resize(0);

	// [DEBUG] Update debug features
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	UpdateDebugToolItemPicker();
	UpdateDebugToolStackQueries();
	UpdateDebugToolFlashStyleColor();
	if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0) {
		g.DebugLocateId = 0;
		g.DebugBreakInLocateId = false;
	}
	if (g.DebugLogAutoDisableFrames > 0 && --g.DebugLogAutoDisableFrames == 0) {
		DebugLog("(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\n");
		g.DebugLogFlags &= ~g.DebugLogAutoDisableFlags;
		g.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;
	}
#endif

	// Create implicit/fallback window - which we will only render it if the user has added something to it.
	// We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
	// This fallback is particularly important as it prevents ImGui:: calls from crashing.
	g.WithinFrameScopeWithImplicitWindow = true;
	SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
	Begin("Debug##Default");
	IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);

	// [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
	// allowing to validate correct Begin/End behavior in user code.
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	if (g.IO.ConfigDebugBeginReturnValueLoop)
		g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10);
	else
		g.DebugBeginReturnValueCullDepth = -1;
#endif

	CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
}

// FIXME: Add a more explicit sort order in the window structure.
static int IMGUI_CDECL ChildWindowComparer(const void *lhs, const void *rhs) {
	const ImGuiWindow *const a = *(const ImGuiWindow *const *)lhs;
	const ImGuiWindow *const b = *(const ImGuiWindow *const *)rhs;
	if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
		return d;
	if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
		return d;
	return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortBuffer(ImVector<ImGuiWindow *> *out_sorted_windows, ImGuiWindow *window) {
	out_sorted_windows->push_back(window);
	if (window->Active) {
		int count = window->DC.ChildWindows.Size;
		ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow *), ChildWindowComparer);
		for (int i = 0; i < count; i++) {
			ImGuiWindow *child = window->DC.ChildWindows[i];
			if (child->Active)
				AddWindowToSortBuffer(out_sorted_windows, child);
		}
	}
}

static void AddWindowToDrawData(ImGuiWindow *window, int layer) {
	ImGuiContext &g = *GImGui;
	ImGuiViewportP *viewport = g.Viewports[0];
	g.IO.MetricsRenderWindows++;
	if (window->DrawList->_Splitter._Count > 1)
		window->DrawList->ChannelsMerge(); // Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
	ImGui::AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[layer], window->DrawList);
	for (ImGuiWindow *child : window->DC.ChildWindows)
		if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
			AddWindowToDrawData(child, layer);
}

static inline int GetWindowDisplayLayer(ImGuiWindow *window) {
	return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
}

// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
static inline void AddRootWindowToDrawData(ImGuiWindow *window) {
	AddWindowToDrawData(window, GetWindowDisplayLayer(window));
}

static void FlattenDrawDataIntoSingleLayer(ImDrawDataBuilder *builder) {
	int n = builder->Layers[0]->Size;
	int full_size = n;
	for (int i = 1; i < IM_ARRAYSIZE(builder->Layers); i++)
		full_size += builder->Layers[i]->Size;
	builder->Layers[0]->resize(full_size);
	for (int layer_n = 1; layer_n < IM_ARRAYSIZE(builder->Layers); layer_n++) {
		ImVector<ImDrawList *> *layer = builder->Layers[layer_n];
		if (layer->empty())
			continue;
		memcpy(builder->Layers[0]->Data + n, layer->Data, layer->Size * sizeof(ImDrawList *));
		n += layer->Size;
		layer->resize(0);
	}
}

static void InitViewportDrawData(ImGuiViewportP *viewport) {
	ImGuiIO &io = ImGui::GetIO();
	ImDrawData *draw_data = &viewport->DrawDataP;

	viewport->DrawDataBuilder.Layers[0] = &draw_data->CmdLists;
	viewport->DrawDataBuilder.Layers[1] = &viewport->DrawDataBuilder.LayerData1;
	viewport->DrawDataBuilder.Layers[0]->resize(0);
	viewport->DrawDataBuilder.Layers[1]->resize(0);

	draw_data->Valid = true;
	draw_data->CmdListsCount = 0;
	draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
	draw_data->DisplayPos = viewport->Pos;
	draw_data->DisplaySize = viewport->Size;
	draw_data->FramebufferScale = io.DisplayFramebufferScale;
	draw_data->OwnerViewport = viewport;
}

// Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.
// - When using this function it is sane to ensure that float are perfectly rounded to integer values,
//   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
// - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():
//   some frequently called functions which to modify both channels and clipping simultaneously tend to use the
//   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.
// - This is analoguous to PushFont()/PopFont() in the sense that are a mixing a global stack and a window stack,
//   which in the case of ClipRect is not so problematic but tends to be more restrictive for fonts.
void ImGui::PushClipRect(const ImVec2 &clip_rect_min, const ImVec2 &clip_rect_max, bool intersect_with_current_clip_rect) {
	ImGuiWindow *window = GetCurrentWindow();
	window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
	window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect() {
	ImGuiWindow *window = GetCurrentWindow();
	window->DrawList->PopClipRect();
	window->ClipRect = window->DrawList->_ClipRectStack.back();
}

static void ImGui::RenderDimmedBackgroundBehindWindow(ImGuiWindow *window, ImU32 col) {
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	ImGuiViewportP *viewport = (ImGuiViewportP *)GetMainViewport();
	ImRect viewport_rect = viewport->GetMainRect();

	// Draw behind window by moving the draw command at the FRONT of the draw list
	{
		// We've already called AddWindowToDrawData() which called DrawList->ChannelsMerge() on DockNodeHost windows,
		// and draw list have been trimmed already, hence the explicit recreation of a draw command if missing.
		// FIXME: This is creating complication, might be simpler if we could inject a drawlist in drawdata at a given position and not attempt to manipulate ImDrawCmd order.
		ImDrawList *draw_list = window->RootWindow->DrawList;
		if (draw_list->CmdBuffer.Size == 0)
			draw_list->AddDrawCmd();
		draw_list->PushClipRect(viewport_rect.Min - ImVec2(1, 1), viewport_rect.Max + ImVec2(1, 1), false); // FIXME: Need to stricty ensure ImDrawCmd are not merged (ElemCount==6 checks below will verify that)
		draw_list->AddRectFilled(viewport_rect.Min, viewport_rect.Max, col);
		ImDrawCmd cmd = draw_list->CmdBuffer.back();
		IM_ASSERT(cmd.ElemCount == 6);
		draw_list->CmdBuffer.pop_back();
		draw_list->CmdBuffer.push_front(cmd);
		draw_list->AddDrawCmd(); // We need to create a command as CmdBuffer.back().IdxOffset won't be correct if we append to same command.
		draw_list->PopClipRect();
	}
}

ImGuiWindow *ImGui::FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow *parent_window) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *bottom_most_visible_window = parent_window;
	for (int i = FindWindowDisplayIndex(parent_window); i >= 0; i--) {
		ImGuiWindow *window = g.Windows[i];
		if (window->Flags & ImGuiWindowFlags_ChildWindow)
			continue;
		if (!IsWindowWithinBeginStackOf(window, parent_window))
			break;
		if (IsWindowActiveAndVisible(window) && GetWindowDisplayLayer(window) <= GetWindowDisplayLayer(parent_window))
			bottom_most_visible_window = window;
	}
	return bottom_most_visible_window;
}

static void ImGui::RenderDimmedBackgrounds() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *modal_window = GetTopMostAndVisiblePopupModal();
	if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
		return;
	const bool dim_bg_for_modal = (modal_window != NULL);
	const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
	if (!dim_bg_for_modal && !dim_bg_for_window_list)
		return;

	if (dim_bg_for_modal) {
		// Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
		ImGuiWindow *dim_behind_window = FindBottomMostVisibleWindowWithinBeginStack(modal_window);
		RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(modal_window->DC.ModalDimBgColor, g.DimBgRatio));
	} else if (dim_bg_for_window_list) {
		// Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
		RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));

		// Draw border around CTRL+Tab target window
		ImGuiWindow *window = g.NavWindowingTargetAnim;
		ImGuiViewport *viewport = GetMainViewport();
		float distance = g.FontSize;
		ImRect bb = window->Rect();
		bb.Expand(distance);
		if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)
			bb.Expand(-distance - 1.0f); // If a window fits the entire viewport, adjust its highlight inward
		if (window->DrawList->CmdBuffer.Size == 0)
			window->DrawList->AddDrawCmd();
		window->DrawList->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size);
		window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window->WindowRounding, 0, 3.0f);
		window->DrawList->PopClipRect();
	}
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void ImGui::EndFrame() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.Initialized);

	// Don't process EndFrame() multiple times.
	if (g.FrameCountEnded == g.FrameCount)
		return;
	IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");

	CallContextHooks(&g, ImGuiContextHookType_EndFramePre);

	ErrorCheckEndFrameSanityChecks();

	// Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
	ImGuiPlatformImeData *ime_data = &g.PlatformImeData;
	if (g.PlatformIO.Platform_SetImeDataFn != NULL && memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0) {
		IMGUI_DEBUG_LOG_IO("[io] Calling Platform_SetImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data->WantVisible, ime_data->InputPos.x, ime_data->InputPos.y);
		ImGuiViewport *viewport = GetMainViewport();
		g.PlatformIO.Platform_SetImeDataFn(&g, viewport, ime_data);
	}

	// Hide implicit/fallback "Debug" window if it hasn't been used
	g.WithinFrameScopeWithImplicitWindow = false;
	if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
		g.CurrentWindow->Active = false;
	End();

	// Update navigation: CTRL+Tab, wrap-around requests
	NavEndFrame();

	// Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
	if (g.DragDropActive) {
		bool is_delivered = g.DragDropPayload.Delivery;
		bool is_elapsed = (g.DragDropSourceFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_PayloadAutoExpire) || g.DragDropMouseButton == -1 || !IsMouseDown(g.DragDropMouseButton));
		if (is_delivered || is_elapsed)
			ClearDragDrop();
	}

	// Drag and Drop: Fallback for missing source tooltip. This is not ideal but better than nothing.
	// If you want to handle source item disappearing: instead of submitting your description tooltip
	// in the BeginDragDropSource() block of the dragged item, you can submit them from a safe single spot
	// (e.g. end of your item loop, or before EndFrame) by reading payload data.
	// In the typical case, the contents of drag tooltip should be possible to infer solely from payload data.
	if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip)) {
		g.DragDropWithinSource = true;
		SetTooltip("...");
		g.DragDropWithinSource = false;
	}

	// End frame
	g.WithinFrameScope = false;
	g.FrameCountEnded = g.FrameCount;

	// Initiate moving window + handle left-click and right-click focus
	UpdateMouseMovingWindowEndFrame();

	// Sort the window list so that all child windows are after their parent
	// We cannot do that on FocusWindow() because children may not exist yet
	g.WindowsTempSortBuffer.resize(0);
	g.WindowsTempSortBuffer.reserve(g.Windows.Size);
	for (ImGuiWindow *window : g.Windows) {
		if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow)) // if a child is active its parent will add it
			continue;
		AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
	}

	// This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
	IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
	g.Windows.swap(g.WindowsTempSortBuffer);
	g.IO.MetricsActiveWindows = g.WindowsActiveCount;

	// Unlock font atlas
	g.IO.Fonts->Locked = false;

	// Clear Input data for next frame
	g.IO.MousePosPrev = g.IO.MousePos;
	g.IO.AppFocusLost = false;
	g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
	g.IO.InputQueueCharacters.resize(0);

	CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
}

// Prepare the data for rendering so you can call GetDrawData()
// (As with anything within the ImGui:: namspace this doesn't touch your GPU or graphics API at all:
// it is the role of the ImGui_ImplXXXX_RenderDrawData() function provided by the renderer backend)
void ImGui::Render() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.Initialized);

	if (g.FrameCountEnded != g.FrameCount)
		EndFrame();
	if (g.FrameCountRendered == g.FrameCount)
		return;
	g.FrameCountRendered = g.FrameCount;

	g.IO.MetricsRenderWindows = 0;
	CallContextHooks(&g, ImGuiContextHookType_RenderPre);

	// Add background ImDrawList (for each active viewport)
	for (ImGuiViewportP *viewport : g.Viewports) {
		InitViewportDrawData(viewport);
		if (viewport->BgFgDrawLists[0] != NULL)
			AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
	}

	// Draw modal/window whitening backgrounds
	RenderDimmedBackgrounds();

	// Add ImDrawList to render
	ImGuiWindow *windows_to_render_top_most[2];
	windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;
	windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
	for (ImGuiWindow *window : g.Windows) {
		IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
		if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
			AddRootWindowToDrawData(window);
	}
	for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
		if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
			AddRootWindowToDrawData(windows_to_render_top_most[n]);

	// Draw software mouse cursor if requested by io.MouseDrawCursor flag
	if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None)
		RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));

	// Setup ImDrawData structures for end-user
	g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
	for (ImGuiViewportP *viewport : g.Viewports) {
		FlattenDrawDataIntoSingleLayer(&viewport->DrawDataBuilder);

		// Add foreground ImDrawList (for each active viewport)
		if (viewport->BgFgDrawLists[1] != NULL)
			AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));

		// We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
		ImDrawData *draw_data = &viewport->DrawDataP;
		IM_ASSERT(draw_data->CmdLists.Size == draw_data->CmdListsCount);
		for (ImDrawList *draw_list : draw_data->CmdLists)
			draw_list->_PopUnusedDrawCmd();

		g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
		g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
	}

	CallContextHooks(&g, ImGuiContextHookType_RenderPost);
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, g.FontSize)
ImVec2 ImGui::CalcTextSize(const char *text, const char *text_end, bool hide_text_after_double_hash, float wrap_width) {
	ImGuiContext &g = *GImGui;

	const char *text_display_end;
	if (hide_text_after_double_hash)
		text_display_end = FindRenderedTextEnd(text, text_end); // Hide anything after a '##' string
	else
		text_display_end = text_end;

	ImFont *font = g.Font;
	const float font_size = g.FontSize;
	if (text == text_display_end)
		return ImVec2(0.0f, font_size);
	ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	// Round
	// FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
	// FIXME: Investigate using ceilf or e.g.
	// - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
	// - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
	text_size.x = IM_TRUNC(text_size.x + 0.99999f);

	return text_size;
}

// Find window given position, search front-to-back
// - Typically write output back to g.HoveredWindow and g.HoveredWindowUnderMovingWindow.
// - FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
//   with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
//   called, aka before the next Begin(). Moving window isn't affected.
// - The 'find_first_and_in_any_viewport = true' mode is only used by TestEngine. It is simpler to maintain here.
void ImGui::FindHoveredWindowEx(const ImVec2 &pos, bool find_first_and_in_any_viewport, ImGuiWindow **out_hovered_window, ImGuiWindow **out_hovered_window_under_moving_window) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *hovered_window = NULL;
	ImGuiWindow *hovered_window_under_moving_window = NULL;

	if (find_first_and_in_any_viewport == false && g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
		hovered_window = g.MovingWindow;

	ImVec2 padding_regular = g.Style.TouchExtraPadding;
	ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
	for (int i = g.Windows.Size - 1; i >= 0; i--) {
		ImGuiWindow *window = g.Windows[i];
		IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
		if (!window->Active || window->Hidden)
			continue;
		if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
			continue;

		// Using the clipped AABB, a child window will typically be clipped by its parent (not always)
		ImVec2 hit_padding = (window->Flags & (ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize;
		if (!window->OuterRectClipped.ContainsWithPad(pos, hit_padding))
			continue;

		// Support for one rectangular hole in any given window
		// FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
		if (window->HitTestHoleSize.x != 0) {
			ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
			ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
			if (ImRect(hole_pos, hole_pos + hole_size).Contains(pos))
				continue;
		}

		if (find_first_and_in_any_viewport) {
			hovered_window = window;
			break;
		} else {
			if (hovered_window == NULL)
				hovered_window = window;
			IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
			if (hovered_window_under_moving_window == NULL && (!g.MovingWindow || window->RootWindow != g.MovingWindow->RootWindow))
				hovered_window_under_moving_window = window;
			if (hovered_window && hovered_window_under_moving_window)
				break;
		}
	}

	*out_hovered_window = hovered_window;
	if (out_hovered_window_under_moving_window != NULL)
		*out_hovered_window_under_moving_window = hovered_window_under_moving_window;
}

bool ImGui::IsItemActive() {
	ImGuiContext &g = *GImGui;
	if (g.ActiveId)
		return g.ActiveId == g.LastItemData.ID;
	return false;
}

bool ImGui::IsItemActivated() {
	ImGuiContext &g = *GImGui;
	if (g.ActiveId)
		if (g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID)
			return true;
	return false;
}

bool ImGui::IsItemDeactivated() {
	ImGuiContext &g = *GImGui;
	if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasDeactivated)
		return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Deactivated) != 0;
	return (g.ActiveIdPreviousFrame == g.LastItemData.ID && g.ActiveIdPreviousFrame != 0 && g.ActiveId != g.LastItemData.ID);
}

bool ImGui::IsItemDeactivatedAfterEdit() {
	ImGuiContext &g = *GImGui;
	return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEditedBefore || (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore));
}

// == GetItemID() == GetFocusID()
bool ImGui::IsItemFocused() {
	ImGuiContext &g = *GImGui;
	if (g.NavId != g.LastItemData.ID || g.NavId == 0)
		return false;
	return true;
}

// Important: this can be useful but it is NOT equivalent to the behavior of e.g.Button()!
// Most widgets have specific reactions based on mouse-up/down state, mouse position etc.
bool ImGui::IsItemClicked(ImGuiMouseButton mouse_button) {
	return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
}

bool ImGui::IsItemToggledOpen() {
	ImGuiContext &g = *GImGui;
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_ToggledOpen) ? true : false;
}

// Call after a Selectable() or TreeNode() involved in multi-selection.
// Useful if you need the per-item information before reaching EndMultiSelect(), e.g. for rendering purpose.
// This is only meant to be called inside a BeginMultiSelect()/EndMultiSelect() block.
// (Outside of multi-select, it would be misleading/ambiguous to report this signal, as widgets
// return e.g. a pressed event and user code is in charge of altering selection in ways we cannot predict.)
bool ImGui::IsItemToggledSelection() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.CurrentMultiSelect != NULL); // Can only be used inside a BeginMultiSelect()/EndMultiSelect()
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_ToggledSelection) ? true : false;
}

// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
bool ImGui::IsAnyItemHovered() {
	ImGuiContext &g = *GImGui;
	return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive() {
	ImGuiContext &g = *GImGui;
	return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused() {
	ImGuiContext &g = *GImGui;
	return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible() {
	ImGuiContext &g = *GImGui;
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible) != 0;
}

bool ImGui::IsItemEdited() {
	ImGuiContext &g = *GImGui;
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Edited) != 0;
}

// Allow next item to be overlapped by subsequent items.
// This works by requiring HoveredId to match for two subsequent frames,
// so if a following items overwrite it our interactions will naturally be disabled.
void ImGui::SetNextItemAllowOverlap() {
	ImGuiContext &g = *GImGui;
	g.NextItemData.ItemFlags |= ImGuiItemFlags_AllowOverlap;
}

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
// FIXME-LEGACY: Use SetNextItemAllowOverlap() *before* your item instead.
void ImGui::SetItemAllowOverlap() {
	ImGuiContext &g = *GImGui;
	ImGuiID id = g.LastItemData.ID;
	if (g.HoveredId == id)
		g.HoveredIdAllowOverlap = true;
	if (g.ActiveId == id) // Before we made this obsolete, most calls to SetItemAllowOverlap() used to avoid this path by testing g.ActiveId != id.
		g.ActiveIdAllowOverlap = true;
}
#endif

// This is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations.
// FIXME: It might be undesirable that this will likely disable KeyOwner-aware shortcuts systems. Consider a more fine-tuned version if needed?
void ImGui::SetActiveIdUsingAllKeyboardKeys() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.ActiveId != 0);
	g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
	g.ActiveIdUsingAllKeyboardKeys = true;
	NavMoveRequestCancel();
}

ImGuiID ImGui::GetItemID() {
	ImGuiContext &g = *GImGui;
	return g.LastItemData.ID;
}

ImVec2 ImGui::GetItemRectMin() {
	ImGuiContext &g = *GImGui;
	return g.LastItemData.Rect.Min;
}

ImVec2 ImGui::GetItemRectMax() {
	ImGuiContext &g = *GImGui;
	return g.LastItemData.Rect.Max;
}

ImVec2 ImGui::GetItemRectSize() {
	ImGuiContext &g = *GImGui;
	return g.LastItemData.Rect.GetSize();
}

// Prior to v1.90 2023/10/16, the BeginChild() function took a 'bool border = false' parameter instead of 'ImGuiChildFlags child_flags = 0'.
// ImGuiChildFlags_Borders is defined as always == 1 in order to allow old code passing 'true'. Read comments in imgui.h for details!
bool ImGui::BeginChild(const char *str_id, const ImVec2 &size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags) {
	ImGuiID id = GetCurrentWindow()->GetID(str_id);
	return BeginChildEx(str_id, id, size_arg, child_flags, window_flags);
}

bool ImGui::BeginChild(ImGuiID id, const ImVec2 &size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags) {
	return BeginChildEx(NULL, id, size_arg, child_flags, window_flags);
}

bool ImGui::BeginChildEx(const char *name, ImGuiID id, const ImVec2 &size_arg, ImGuiChildFlags child_flags, ImGuiWindowFlags window_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *parent_window = g.CurrentWindow;
	IM_ASSERT(id != 0);

	// Sanity check as it is likely that some user will accidentally pass ImGuiWindowFlags into the ImGuiChildFlags argument.
	const ImGuiChildFlags ImGuiChildFlags_SupportedMask_ = ImGuiChildFlags_Borders | ImGuiChildFlags_AlwaysUseWindowPadding | ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY | ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_AlwaysAutoResize | ImGuiChildFlags_FrameStyle | ImGuiChildFlags_NavFlattened;
	IM_UNUSED(ImGuiChildFlags_SupportedMask_);
	IM_ASSERT((child_flags & ~ImGuiChildFlags_SupportedMask_) == 0 && "Illegal ImGuiChildFlags value. Did you pass ImGuiWindowFlags values instead of ImGuiChildFlags?");
	IM_ASSERT((window_flags & ImGuiWindowFlags_AlwaysAutoResize) == 0 && "Cannot specify ImGuiWindowFlags_AlwaysAutoResize for BeginChild(). Use ImGuiChildFlags_AlwaysAutoResize!");
	if (child_flags & ImGuiChildFlags_AlwaysAutoResize) {
		IM_ASSERT((child_flags & (ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY)) == 0 && "Cannot use ImGuiChildFlags_ResizeX or ImGuiChildFlags_ResizeY with ImGuiChildFlags_AlwaysAutoResize!");
		IM_ASSERT((child_flags & (ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY)) != 0 && "Must use ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY with ImGuiChildFlags_AlwaysAutoResize!");
	}
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	if (window_flags & ImGuiWindowFlags_AlwaysUseWindowPadding)
		child_flags |= ImGuiChildFlags_AlwaysUseWindowPadding;
	if (window_flags & ImGuiWindowFlags_NavFlattened)
		child_flags |= ImGuiChildFlags_NavFlattened;
#endif
	if (child_flags & ImGuiChildFlags_AutoResizeX)
		child_flags &= ~ImGuiChildFlags_ResizeX;
	if (child_flags & ImGuiChildFlags_AutoResizeY)
		child_flags &= ~ImGuiChildFlags_ResizeY;

	// Set window flags
	window_flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar;
	window_flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove); // Inherit the NoMove flag
	if (child_flags & (ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_AlwaysAutoResize))
		window_flags |= ImGuiWindowFlags_AlwaysAutoResize;
	if ((child_flags & (ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY)) == 0)
		window_flags |= ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;

	// Special framed style
	if (child_flags & ImGuiChildFlags_FrameStyle) {
		PushStyleColor(ImGuiCol_ChildBg, g.Style.Colors[ImGuiCol_FrameBg]);
		PushStyleVar(ImGuiStyleVar_ChildRounding, g.Style.FrameRounding);
		PushStyleVar(ImGuiStyleVar_ChildBorderSize, g.Style.FrameBorderSize);
		PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.FramePadding);
		child_flags |= ImGuiChildFlags_Borders | ImGuiChildFlags_AlwaysUseWindowPadding;
		window_flags |= ImGuiWindowFlags_NoMove;
	}

	// Forward child flags
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasChildFlags;
	g.NextWindowData.ChildFlags = child_flags;

	// Forward size
	// Important: Begin() has special processing to switch condition to ImGuiCond_FirstUseEver for a given axis when ImGuiChildFlags_ResizeXXX is set.
	// (the alternative would to store conditional flags per axis, which is possible but more code)
	const ImVec2 size_avail = GetContentRegionAvail();
	const ImVec2 size_default((child_flags & ImGuiChildFlags_AutoResizeX) ? 0.0f : size_avail.x, (child_flags & ImGuiChildFlags_AutoResizeY) ? 0.0f : size_avail.y);
	const ImVec2 size = CalcItemSize(size_arg, size_default.x, size_default.y);
	SetNextWindowSize(size);

	// Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
	// FIXME: 2023/11/14: commented out shorted version. We had an issue with multiple ### in child window path names, which the trailing hash helped workaround.
	// e.g. "ParentName###ParentIdentifier/ChildName###ChildIdentifier" would get hashed incorrectly by ImHashStr(), trailing _%08X somehow fixes it.
	const char *temp_window_name;
	/*if (name && parent_window->IDStack.back() == parent_window->ID)
		ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s", parent_window->Name, name); // May omit ID if in root of ID stack
	else*/
	if (name)
		ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s_%08X", parent_window->Name, name, id);
	else
		ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%08X", parent_window->Name, id);

	// Set style
	const float backup_border_size = g.Style.ChildBorderSize;
	if ((child_flags & ImGuiChildFlags_Borders) == 0)
		g.Style.ChildBorderSize = 0.0f;

	// Begin into window
	const bool ret = Begin(temp_window_name, NULL, window_flags);

	// Restore style
	g.Style.ChildBorderSize = backup_border_size;
	if (child_flags & ImGuiChildFlags_FrameStyle) {
		PopStyleVar(3);
		PopStyleColor();
	}

	ImGuiWindow *child_window = g.CurrentWindow;
	child_window->ChildId = id;

	// Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
	// While this is not really documented/defined, it seems that the expected thing to do.
	if (child_window->BeginCount == 1)
		parent_window->DC.CursorPos = child_window->Pos;

	// Process navigation-in immediately so NavInit can run on first frame
	// Can enter a child if (A) it has navigable items or (B) it can be scrolled.
	const ImGuiID temp_id_for_activation = ImHashStr("##Child", 0, id);
	if (g.ActiveId == temp_id_for_activation)
		ClearActiveID();
	if (g.NavActivateId == id && !(child_flags & ImGuiChildFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY)) {
		FocusWindow(child_window);
		NavInitWindow(child_window, false);
		SetActiveID(temp_id_for_activation, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
		g.ActiveIdSource = g.NavInputSource;
	}
	return ret;
}

void ImGui::EndChild() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *child_window = g.CurrentWindow;

	IM_ASSERT(g.WithinEndChild == false);
	IM_ASSERT(child_window->Flags & ImGuiWindowFlags_ChildWindow); // Mismatched BeginChild()/EndChild() calls

	g.WithinEndChild = true;
	ImVec2 child_size = child_window->Size;
	End();
	if (child_window->BeginCount == 1) {
		ImGuiWindow *parent_window = g.CurrentWindow;
		ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + child_size);
		ItemSize(child_size);
		const bool nav_flattened = (child_window->ChildFlags & ImGuiChildFlags_NavFlattened) != 0;
		if ((child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY) && !nav_flattened) {
			ItemAdd(bb, child_window->ChildId);
			RenderNavHighlight(bb, child_window->ChildId);

			// When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
			if (child_window->DC.NavLayersActiveMask == 0 && child_window == g.NavWindow)
				RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_Compact);
		} else {
			// Not navigable into
			// - This is a bit of a fringe use case, mostly useful for undecorated, non-scrolling contents childs, or empty childs.
			// - We could later decide to not apply this path if ImGuiChildFlags_FrameStyle or ImGuiChildFlags_Borders is set.
			ItemAdd(bb, child_window->ChildId, NULL, ImGuiItemFlags_NoNav);

			// But when flattened we directly reach items, adjust active layer mask accordingly
			if (nav_flattened)
				parent_window->DC.NavLayersActiveMaskNext |= child_window->DC.NavLayersActiveMaskNext;
		}
		if (g.HoveredWindow == child_window)
			g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
	}
	g.WithinEndChild = false;
	g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
}

static void SetWindowConditionAllowFlags(ImGuiWindow *window, ImGuiCond flags, bool enabled) {
	window->SetWindowPosAllowFlags = enabled ? (window->SetWindowPosAllowFlags | flags) : (window->SetWindowPosAllowFlags & ~flags);
	window->SetWindowSizeAllowFlags = enabled ? (window->SetWindowSizeAllowFlags | flags) : (window->SetWindowSizeAllowFlags & ~flags);
	window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
}

ImGuiWindow *ImGui::FindWindowByID(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	return (ImGuiWindow *)g.WindowsById.GetVoidPtr(id);
}

ImGuiWindow *ImGui::FindWindowByName(const char *name) {
	ImGuiID id = ImHashStr(name);
	return FindWindowByID(id);
}

static void ApplyWindowSettings(ImGuiWindow *window, ImGuiWindowSettings *settings) {
	window->Pos = ImTrunc(ImVec2(settings->Pos.x, settings->Pos.y));
	if (settings->Size.x > 0 && settings->Size.y > 0)
		window->Size = window->SizeFull = ImTrunc(ImVec2(settings->Size.x, settings->Size.y));
	window->Collapsed = settings->Collapsed;
}

static void UpdateWindowInFocusOrderList(ImGuiWindow *window, bool just_created, ImGuiWindowFlags new_flags) {
	ImGuiContext &g = *GImGui;

	const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
	const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
	if ((just_created || child_flag_changed) && !new_is_explicit_child) {
		IM_ASSERT(!g.WindowsFocusOrder.contains(window));
		g.WindowsFocusOrder.push_back(window);
		window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
	} else if (!just_created && child_flag_changed && new_is_explicit_child) {
		IM_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
		for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
			g.WindowsFocusOrder[n]->FocusOrder--;
		g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
		window->FocusOrder = -1;
	}
	window->IsExplicitChild = new_is_explicit_child;
}

static void InitOrLoadWindowSettings(ImGuiWindow *window, ImGuiWindowSettings *settings) {
	// Initial window state with e.g. default/arbitrary window position
	// Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
	const ImGuiViewport *main_viewport = ImGui::GetMainViewport();
	window->Pos = main_viewport->Pos + ImVec2(60, 60);
	window->Size = window->SizeFull = ImVec2(0, 0);
	window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags = window->SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;

	if (settings != NULL) {
		SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
		ApplyWindowSettings(window, settings);
	}
	window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values

	if ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0) {
		window->AutoFitFramesX = window->AutoFitFramesY = 2;
		window->AutoFitOnlyGrows = false;
	} else {
		if (window->Size.x <= 0.0f)
			window->AutoFitFramesX = 2;
		if (window->Size.y <= 0.0f)
			window->AutoFitFramesY = 2;
		window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
	}
}

static ImGuiWindow *CreateNewWindow(const char *name, ImGuiWindowFlags flags) {
	// Create window the first time
	//IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = IM_NEW(ImGuiWindow)(&g, name);
	window->Flags = flags;
	g.WindowsById.SetVoidPtr(window->ID, window);

	ImGuiWindowSettings *settings = NULL;
	if (!(flags & ImGuiWindowFlags_NoSavedSettings))
		if ((settings = ImGui::FindWindowSettingsByWindow(window)) != 0)
			window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);

	InitOrLoadWindowSettings(window, settings);

	if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
		g.Windows.push_front(window); // Quite slow but rare and only once
	else
		g.Windows.push_back(window);

	return window;
}

static inline ImVec2 CalcWindowMinSize(ImGuiWindow *window) {
	// We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
	// FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.
	// Perhaps should tend further a neater test for this.
	ImGuiContext &g = *GImGui;
	ImVec2 size_min;
	if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup)) {
		size_min.x = (window->ChildFlags & ImGuiChildFlags_ResizeX) ? g.Style.WindowMinSize.x : 4.0f;
		size_min.y = (window->ChildFlags & ImGuiChildFlags_ResizeY) ? g.Style.WindowMinSize.y : 4.0f;
	} else {
		size_min.x = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.x : 4.0f;
		size_min.y = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.y : 4.0f;
	}

	// Reduce artifacts with very small windows
	ImGuiWindow *window_for_height = window;
	size_min.y = ImMax(size_min.y, window_for_height->TitleBarHeight + window_for_height->MenuBarHeight + ImMax(0.0f, g.Style.WindowRounding - 1.0f));
	return size_min;
}

static ImVec2 CalcWindowSizeAfterConstraint(ImGuiWindow *window, const ImVec2 &size_desired) {
	ImGuiContext &g = *GImGui;
	ImVec2 new_size = size_desired;
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint) {
		// See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.
		ImRect cr = g.NextWindowData.SizeConstraintRect;
		new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
		new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
		if (g.NextWindowData.SizeCallback) {
			ImGuiSizeCallbackData data;
			data.UserData = g.NextWindowData.SizeCallbackUserData;
			data.Pos = window->Pos;
			data.CurrentSize = window->SizeFull;
			data.DesiredSize = new_size;
			g.NextWindowData.SizeCallback(&data);
			new_size = data.DesiredSize;
		}
		new_size.x = IM_TRUNC(new_size.x);
		new_size.y = IM_TRUNC(new_size.y);
	}

	// Minimum size
	ImVec2 size_min = CalcWindowMinSize(window);
	return ImMax(new_size, size_min);
}

static void CalcWindowContentSizes(ImGuiWindow *window, ImVec2 *content_size_current, ImVec2 *content_size_ideal) {
	bool preserve_old_content_sizes = false;
	if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		preserve_old_content_sizes = true;
	else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
		preserve_old_content_sizes = true;
	if (preserve_old_content_sizes) {
		*content_size_current = window->ContentSize;
		*content_size_ideal = window->ContentSizeIdeal;
		return;
	}

	content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
	content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
	content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
	content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
}

static ImVec2 CalcWindowAutoFitSize(ImGuiWindow *window, const ImVec2 &size_contents) {
	ImGuiContext &g = *GImGui;
	ImGuiStyle &style = g.Style;
	const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;
	const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;
	ImVec2 size_pad = window->WindowPadding * 2.0f;
	ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);
	if (window->Flags & ImGuiWindowFlags_Tooltip) {
		// Tooltip always resize
		return size_desired;
	} else {
		// Maximum window size is determined by the viewport size or monitor size
		ImVec2 size_min = CalcWindowMinSize(window);
		ImVec2 size_max = ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup)) ? ImVec2(FLT_MAX, FLT_MAX) : ImGui::GetMainViewport()->WorkSize - style.DisplaySafeAreaPadding * 2.0f;
		ImVec2 size_auto_fit = ImClamp(size_desired, size_min, size_max);

		// FIXME: CalcWindowAutoFitSize() doesn't take into account that only one axis may be auto-fit when calculating scrollbars,
		// we may need to compute/store three variants of size_auto_fit, for x/y/xy.
		// Here we implement a workaround for child windows only, but a full solution would apply to normal windows as well:
		if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && !(window->ChildFlags & ImGuiChildFlags_ResizeY))
			size_auto_fit.y = window->SizeFull.y;
		else if (!(window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->ChildFlags & ImGuiChildFlags_ResizeY))
			size_auto_fit.x = window->SizeFull.x;

		// When the window cannot fit all contents (either because of constraints, either because screen is too small),
		// we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
		ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
		bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
		bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
		if (will_have_scrollbar_x)
			size_auto_fit.y += style.ScrollbarSize;
		if (will_have_scrollbar_y)
			size_auto_fit.x += style.ScrollbarSize;
		return size_auto_fit;
	}
}

ImVec2 ImGui::CalcWindowNextAutoFitSize(ImGuiWindow *window) {
	ImVec2 size_contents_current;
	ImVec2 size_contents_ideal;
	CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);
	ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);
	ImVec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);
	return size_final;
}

static ImGuiCol GetWindowBgColorIdx(ImGuiWindow *window) {
	if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
		return ImGuiCol_PopupBg;
	if (window->Flags & ImGuiWindowFlags_ChildWindow)
		return ImGuiCol_ChildBg;
	return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(ImGuiWindow *window, const ImVec2 &corner_target, const ImVec2 &corner_norm, ImVec2 *out_pos, ImVec2 *out_size) {
	ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm); // Expected window upper-left
	ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
	ImVec2 size_expected = pos_max - pos_min;
	ImVec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);
	*out_pos = pos_min;
	if (corner_norm.x == 0.0f)
		out_pos->x -= (size_constrained.x - size_expected.x);
	if (corner_norm.y == 0.0f)
		out_pos->y -= (size_constrained.y - size_expected.y);
	*out_size = size_constrained;
}

// Data for resizing from resize grip / corner
struct ImGuiResizeGripDef {
	ImVec2 CornerPosN;
	ImVec2 InnerDir;
	int AngleMin12, AngleMax12;
};
static const ImGuiResizeGripDef resize_grip_def[4] = {
	{ ImVec2(1, 1), ImVec2(-1, -1), 0, 3 }, // Lower-right
	{ ImVec2(0, 1), ImVec2(+1, -1), 3, 6 }, // Lower-left
	{ ImVec2(0, 0), ImVec2(+1, +1), 6, 9 }, // Upper-left (Unused)
	{ ImVec2(1, 0), ImVec2(-1, +1), 9, 12 } // Upper-right (Unused)
};

// Data for resizing from borders
struct ImGuiResizeBorderDef {
	ImVec2 InnerDir; // Normal toward inside
	ImVec2 SegmentN1, SegmentN2; // End positions, normalized (0,0: upper left)
	float OuterAngle; // Angle toward outside
};
static const ImGuiResizeBorderDef resize_border_def[4] = {
	{ ImVec2(+1, 0), ImVec2(0, 1), ImVec2(0, 0), IM_PI * 1.00f }, // Left
	{ ImVec2(-1, 0), ImVec2(1, 0), ImVec2(1, 1), IM_PI * 0.00f }, // Right
	{ ImVec2(0, +1), ImVec2(0, 0), ImVec2(1, 0), IM_PI * 1.50f }, // Up
	{ ImVec2(0, -1), ImVec2(1, 1), ImVec2(0, 1), IM_PI * 0.50f } // Down
};

static ImRect GetResizeBorderRect(ImGuiWindow *window, int border_n, float perp_padding, float thickness) {
	ImRect rect = window->Rect();
	if (thickness == 0.0f)
		rect.Max -= ImVec2(1, 1);
	if (border_n == ImGuiDir_Left) {
		return ImRect(rect.Min.x - thickness, rect.Min.y + perp_padding, rect.Min.x + thickness, rect.Max.y - perp_padding);
	}
	if (border_n == ImGuiDir_Right) {
		return ImRect(rect.Max.x - thickness, rect.Min.y + perp_padding, rect.Max.x + thickness, rect.Max.y - perp_padding);
	}
	if (border_n == ImGuiDir_Up) {
		return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness, rect.Max.x - perp_padding, rect.Min.y + thickness);
	}
	if (border_n == ImGuiDir_Down) {
		return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness, rect.Max.x - perp_padding, rect.Max.y + thickness);
	}
	IM_ASSERT(0);
	return ImRect();
}

// 0..3: corners (Lower-right, Lower-left, Unused, Unused)
ImGuiID ImGui::GetWindowResizeCornerID(ImGuiWindow *window, int n) {
	IM_ASSERT(n >= 0 && n < 4);
	ImGuiID id = window->ID;
	id = ImHashStr("#RESIZE", 0, id);
	id = ImHashData(&n, sizeof(int), id);
	return id;
}

// Borders (Left, Right, Up, Down)
ImGuiID ImGui::GetWindowResizeBorderID(ImGuiWindow *window, ImGuiDir dir) {
	IM_ASSERT(dir >= 0 && dir < 4);
	int n = (int)dir + 4;
	ImGuiID id = window->ID;
	id = ImHashStr("#RESIZE", 0, id);
	id = ImHashData(&n, sizeof(int), id);
	return id;
}

// Handle resize for: Resize Grips, Borders, Gamepad
// Return true when using auto-fit (double-click on resize grip)
static int ImGui::UpdateWindowManualResize(ImGuiWindow *window, const ImVec2 &size_auto_fit, int *border_hovered, int *border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect &visibility_rect) {
	ImGuiContext &g = *GImGui;
	ImGuiWindowFlags flags = window->Flags;

	if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		return false;
	if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
		return false;

	int ret_auto_fit_mask = 0x00;
	const float grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
	const float grip_hover_inner_size = (resize_grip_count > 0) ? IM_TRUNC(grip_draw_size * 0.75f) : 0.0f;
	const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;

	ImRect clamp_rect = visibility_rect;
	const bool window_move_from_title_bar = g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar);
	if (window_move_from_title_bar)
		clamp_rect.Min.y -= window->TitleBarHeight;

	ImVec2 pos_target(FLT_MAX, FLT_MAX);
	ImVec2 size_target(FLT_MAX, FLT_MAX);

	// Resize grips and borders are on layer 1
	window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;

	// Manual resize grips
	PushID("#RESIZE");
	for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++) {
		const ImGuiResizeGripDef &def = resize_grip_def[resize_grip_n];
		const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);

		// Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
		bool hovered, held;
		ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);
		if (resize_rect.Min.x > resize_rect.Max.x)
			ImSwap(resize_rect.Min.x, resize_rect.Max.x);
		if (resize_rect.Min.y > resize_rect.Max.y)
			ImSwap(resize_rect.Min.y, resize_rect.Max.y);
		ImGuiID resize_grip_id = window->GetID(resize_grip_n); // == GetWindowResizeCornerID()
		ItemAdd(resize_rect, resize_grip_id, NULL, ImGuiItemFlags_NoNav);
		ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
		//GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
		if (hovered || held)
			g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

		if (held && g.IO.MouseDoubleClicked[0]) {
			// Auto-fit when double-clicking
			size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
			ret_auto_fit_mask = 0x03; // Both axises
			ClearActiveID();
		} else if (held) {
			// Resize from any of the four corners
			// We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
			ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? clamp_rect.Min.x : -FLT_MAX, (def.CornerPosN.y == 1.0f || (def.CornerPosN.y == 0.0f && window_move_from_title_bar)) ? clamp_rect.Min.y : -FLT_MAX);
			ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? clamp_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0f ? clamp_rect.Max.y : +FLT_MAX);
			ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
			corner_target = ImClamp(corner_target, clamp_min, clamp_max);
			CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
		}

		// Only lower-left grip is visible before hovering/activating
		if (resize_grip_n == 0 || held || hovered)
			resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered
																									: ImGuiCol_ResizeGrip);
	}

	int resize_border_mask = 0x00;
	if (window->Flags & ImGuiWindowFlags_ChildWindow)
		resize_border_mask |= ((window->ChildFlags & ImGuiChildFlags_ResizeX) ? 0x02 : 0) | ((window->ChildFlags & ImGuiChildFlags_ResizeY) ? 0x08 : 0);
	else
		resize_border_mask = g.IO.ConfigWindowsResizeFromEdges ? 0x0F : 0x00;
	for (int border_n = 0; border_n < 4; border_n++) {
		if ((resize_border_mask & (1 << border_n)) == 0)
			continue;
		const ImGuiResizeBorderDef &def = resize_border_def[border_n];
		const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;

		bool hovered, held;
		ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
		ImGuiID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()
		ItemAdd(border_rect, border_id, NULL, ImGuiItemFlags_NoNav);
		ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
		//GetForegroundDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
		if (hovered && g.HoveredIdTimer <= WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER)
			hovered = false;
		if (hovered || held)
			g.MouseCursor = (axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
		if (held && g.IO.MouseDoubleClicked[0]) {
			// Double-clicking bottom or right border auto-fit on this axis
			// FIXME: CalcWindowAutoFitSize() doesn't take into account that only one side may be auto-fit when calculating scrollbars.
			// FIXME: Support top and right borders: rework CalcResizePosSizeFromAnyCorner() to be reusable in both cases.
			if (border_n == 1 || border_n == 3) // Right and bottom border
			{
				size_target[axis] = CalcWindowSizeAfterConstraint(window, size_auto_fit)[axis];
				ret_auto_fit_mask |= (1 << axis);
				hovered = held = false; // So border doesn't show highlighted at new position
			}
			ClearActiveID();
		} else if (held) {
			// Switch to relative resizing mode when border geometry moved (e.g. resizing a child altering parent scroll), in order to avoid resizing feedback loop.
			// Currently only using relative mode on resizable child windows, as the problem to solve is more likely noticeable for them, but could apply for all windows eventually.
			// FIXME: May want to generalize this idiom at lower-level, so more widgets can use it!
			const bool just_scrolled_manually_while_resizing = (g.WheelingWindow != NULL && g.WheelingWindowScrolledFrame == g.FrameCount && IsWindowChildOf(window, g.WheelingWindow, false));
			if (g.ActiveIdIsJustActivated || just_scrolled_manually_while_resizing) {
				g.WindowResizeBorderExpectedRect = border_rect;
				g.WindowResizeRelativeMode = false;
			}
			if ((window->Flags & ImGuiWindowFlags_ChildWindow) && memcmp(&g.WindowResizeBorderExpectedRect, &border_rect, sizeof(ImRect)) != 0)
				g.WindowResizeRelativeMode = true;

			const ImVec2 border_curr = (window->Pos + ImMin(def.SegmentN1, def.SegmentN2) * window->Size);
			const float border_target_rel_mode_for_axis = border_curr[axis] + g.IO.MouseDelta[axis];
			const float border_target_abs_mode_for_axis = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING; // Match ButtonBehavior() padding above.

			// Use absolute mode position
			ImVec2 border_target = window->Pos;
			border_target[axis] = border_target_abs_mode_for_axis;

			// Use relative mode target for child window, ignore resize when moving back toward the ideal absolute position.
			bool ignore_resize = false;
			if (g.WindowResizeRelativeMode) {
				//GetForegroundDrawList()->AddText(GetMainViewport()->WorkPos, IM_COL32_WHITE, "Relative Mode");
				border_target[axis] = border_target_rel_mode_for_axis;
				if (g.IO.MouseDelta[axis] == 0.0f || (g.IO.MouseDelta[axis] > 0.0f) == (border_target_rel_mode_for_axis > border_target_abs_mode_for_axis))
					ignore_resize = true;
			}

			// Clamp, apply
			ImVec2 clamp_min(border_n == ImGuiDir_Right ? clamp_rect.Min.x : -FLT_MAX, border_n == ImGuiDir_Down || (border_n == ImGuiDir_Up && window_move_from_title_bar) ? clamp_rect.Min.y : -FLT_MAX);
			ImVec2 clamp_max(border_n == ImGuiDir_Left ? clamp_rect.Max.x : +FLT_MAX, border_n == ImGuiDir_Up ? clamp_rect.Max.y : +FLT_MAX);
			border_target = ImClamp(border_target, clamp_min, clamp_max);
			if (flags & ImGuiWindowFlags_ChildWindow) // Clamp resizing of childs within parent
			{
				ImGuiWindow *parent_window = window->ParentWindow;
				ImGuiWindowFlags parent_flags = parent_window->Flags;
				ImRect border_limit_rect = parent_window->InnerRect;
				border_limit_rect.Expand(ImVec2(-ImMax(parent_window->WindowPadding.x, parent_window->WindowBorderSize), -ImMax(parent_window->WindowPadding.y, parent_window->WindowBorderSize)));
				if ((axis == ImGuiAxis_X) && ((parent_flags & (ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar)) == 0 || (parent_flags & ImGuiWindowFlags_NoScrollbar)))
					border_target.x = ImClamp(border_target.x, border_limit_rect.Min.x, border_limit_rect.Max.x);
				if ((axis == ImGuiAxis_Y) && (parent_flags & ImGuiWindowFlags_NoScrollbar))
					border_target.y = ImClamp(border_target.y, border_limit_rect.Min.y, border_limit_rect.Max.y);
			}
			if (!ignore_resize)
				CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
		}
		if (hovered)
			*border_hovered = border_n;
		if (held)
			*border_held = border_n;
	}
	PopID();

	// Restore nav layer
	window->DC.NavLayerCurrent = ImGuiNavLayer_Main;

	// Navigation resize (keyboard/gamepad)
	// FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
	// Not even sure the callback works here.
	if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window) {
		ImVec2 nav_resize_dir;
		if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)
			nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
		if (g.NavInputSource == ImGuiInputSource_Gamepad)
			nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown);
		if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f) {
			const float NAV_RESIZE_SPEED = 600.0f;
			const float resize_step = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
			g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;
			g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, clamp_rect.Min - window->Pos - window->Size); // We need Pos+Size >= clmap_rect.Min, so Size >= clmap_rect.Min - Pos, so size_delta >= clmap_rect.Min - window->Pos - window->Size
			g.NavWindowingToggleLayer = false;
			g.NavDisableMouseHover = true;
			resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
			ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaSize);
			if (accum_floored.x != 0.0f || accum_floored.y != 0.0f) {
				// FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
				size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + accum_floored);
				g.NavWindowingAccumDeltaSize -= accum_floored;
			}
		}
	}

	// Apply back modified position/size to window
	const ImVec2 curr_pos = window->Pos;
	const ImVec2 curr_size = window->SizeFull;
	if (size_target.x != FLT_MAX && (window->Size.x != size_target.x || window->SizeFull.x != size_target.x))
		window->Size.x = window->SizeFull.x = size_target.x;
	if (size_target.y != FLT_MAX && (window->Size.y != size_target.y || window->SizeFull.y != size_target.y))
		window->Size.y = window->SizeFull.y = size_target.y;
	if (pos_target.x != FLT_MAX && window->Pos.x != ImTrunc(pos_target.x))
		window->Pos.x = ImTrunc(pos_target.x);
	if (pos_target.y != FLT_MAX && window->Pos.y != ImTrunc(pos_target.y))
		window->Pos.y = ImTrunc(pos_target.y);
	if (curr_pos.x != window->Pos.x || curr_pos.y != window->Pos.y || curr_size.x != window->SizeFull.x || curr_size.y != window->SizeFull.y)
		MarkIniSettingsDirty(window);

	// Recalculate next expected border expected coordinates
	if (*border_held != -1)
		g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, *border_held, grip_hover_inner_size, WINDOWS_HOVER_PADDING);

	return ret_auto_fit_mask;
}

static inline void ClampWindowPos(ImGuiWindow *window, const ImRect &visibility_rect) {
	ImGuiContext &g = *GImGui;
	ImVec2 size_for_clamping = window->Size;
	if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar))
		size_for_clamping.y = window->TitleBarHeight;
	window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
}

static void RenderWindowOuterSingleBorder(ImGuiWindow *window, int border_n, ImU32 border_col, float border_size) {
	const ImGuiResizeBorderDef &def = resize_border_def[border_n];
	const float rounding = window->WindowRounding;
	const ImRect border_r = GetResizeBorderRect(window, border_n, rounding, 0.0f);
	window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
	window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
	window->DrawList->PathStroke(border_col, ImDrawFlags_None, border_size);
}

static void ImGui::RenderWindowOuterBorders(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	const float border_size = window->WindowBorderSize;
	const ImU32 border_col = GetColorU32(ImGuiCol_Border);
	if (border_size > 0.0f && (window->Flags & ImGuiWindowFlags_NoBackground) == 0)
		window->DrawList->AddRect(window->Pos, window->Pos + window->Size, border_col, window->WindowRounding, 0, window->WindowBorderSize);
	else if (border_size > 0.0f) {
		if (window->ChildFlags & ImGuiChildFlags_ResizeX) // Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.
			RenderWindowOuterSingleBorder(window, 1, border_col, border_size);
		if (window->ChildFlags & ImGuiChildFlags_ResizeY)
			RenderWindowOuterSingleBorder(window, 3, border_col, border_size);
	}
	if (window->ResizeBorderHovered != -1 || window->ResizeBorderHeld != -1) {
		const int border_n = (window->ResizeBorderHeld != -1) ? window->ResizeBorderHeld : window->ResizeBorderHovered;
		const ImU32 border_col_resizing = GetColorU32((window->ResizeBorderHeld != -1) ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);
		RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(2.0f, window->WindowBorderSize)); // Thicker than usual
	}
	if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar)) {
		float y = window->Pos.y + window->TitleBarHeight - 1;
		window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), border_col, g.Style.FrameBorderSize);
	}
}

// Draw background and borders
// Draw and handle scrollbars
void ImGui::RenderWindowDecorations(ImGuiWindow *window, const ImRect &title_bar_rect, bool title_bar_is_highlight, bool handle_borders_and_resize_grips, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size) {
	ImGuiContext &g = *GImGui;
	ImGuiStyle &style = g.Style;
	ImGuiWindowFlags flags = window->Flags;

	// Ensure that ScrollBar doesn't read last frame's SkipItems
	IM_ASSERT(window->BeginCount == 0);
	window->SkipItems = false;

	// Draw window + handle manual resize
	// As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
	const float window_rounding = window->WindowRounding;
	const float window_border_size = window->WindowBorderSize;
	if (window->Collapsed) {
		// Title bar only
		const float backup_border_size = style.FrameBorderSize;
		g.Style.FrameBorderSize = window->WindowBorderSize;
		ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
		RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
		g.Style.FrameBorderSize = backup_border_size;
	} else {
		// Window background
		if (!(flags & ImGuiWindowFlags_NoBackground)) {
			ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
			bool override_alpha = false;
			float alpha = 1.0f;
			if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha) {
				alpha = g.NextWindowData.BgAlphaVal;
				override_alpha = true;
			}
			if (override_alpha)
				bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
			window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
		}

		// Title bar
		if (!(flags & ImGuiWindowFlags_NoTitleBar)) {
			ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
			window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
		}

		// Menu bar
		if (flags & ImGuiWindowFlags_MenuBar) {
			ImRect menu_bar_rect = window->MenuBarRect();
			menu_bar_rect.ClipWith(window->Rect()); // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
			window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
			if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
				window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
		}

		// Scrollbars
		if (window->ScrollbarX)
			Scrollbar(ImGuiAxis_X);
		if (window->ScrollbarY)
			Scrollbar(ImGuiAxis_Y);

		// Render resize grips (after their input handling so we don't have a frame of latency)
		if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize)) {
			for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++) {
				const ImU32 col = resize_grip_col[resize_grip_n];
				if ((col & IM_COL32_A_MASK) == 0)
					continue;
				const ImGuiResizeGripDef &grip = resize_grip_def[resize_grip_n];
				const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
				window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
				window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
				window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
				window->DrawList->PathFillConvex(col);
			}
		}

		// Borders
		if (handle_borders_and_resize_grips)
			RenderWindowOuterBorders(window);
	}
}

// Render title text, collapse button, close button
void ImGui::RenderWindowTitleBarContents(ImGuiWindow *window, const ImRect &title_bar_rect, const char *name, bool *p_open) {
	ImGuiContext &g = *GImGui;
	ImGuiStyle &style = g.Style;
	ImGuiWindowFlags flags = window->Flags;

	const bool has_close_button = (p_open != NULL);
	const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);

	// Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
	// FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
	const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
	g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
	window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;

	// Layout buttons
	// FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
	float pad_l = style.FramePadding.x;
	float pad_r = style.FramePadding.x;
	float button_sz = g.FontSize;
	ImVec2 close_button_pos;
	ImVec2 collapse_button_pos;
	if (has_close_button) {
		close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
		pad_r += button_sz + style.ItemInnerSpacing.x;
	}
	if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right) {
		collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
		pad_r += button_sz + style.ItemInnerSpacing.x;
	}
	if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left) {
		collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y);
		pad_l += button_sz + style.ItemInnerSpacing.x;
	}

	// Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
	if (has_collapse_button)
		if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos))
			window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function

	// Close button
	if (has_close_button)
		if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
			*p_open = false;

	window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
	g.CurrentItemFlags = item_flags_backup;

	// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
	// FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
	const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
	const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);

	// As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
	// while uncentered title text will still reach edges correctly.
	if (pad_l > style.FramePadding.x)
		pad_l += g.Style.ItemInnerSpacing.x;
	if (pad_r > style.FramePadding.x)
		pad_r += g.Style.ItemInnerSpacing.x;
	if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f) {
		float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
		float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
		pad_l = ImMax(pad_l, pad_extend * centerness);
		pad_r = ImMax(pad_r, pad_extend * centerness);
	}

	ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
	ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
	if (flags & ImGuiWindowFlags_UnsavedDocument) {
		ImVec2 marker_pos;
		marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
		marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
		if (marker_pos.x > layout_r.Min.x) {
			RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
			clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
		}
	}
	//if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
	//if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
	RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
}

void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow *window, ImGuiWindowFlags flags, ImGuiWindow *parent_window) {
	window->ParentWindow = parent_window;
	window->RootWindow = window->RootWindowPopupTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
	if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
		window->RootWindow = parent_window->RootWindow;
	if (parent_window && (flags & ImGuiWindowFlags_Popup))
		window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
	if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))
		window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
	while (window->RootWindowForNav->ChildFlags & ImGuiChildFlags_NavFlattened) {
		IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
		window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
	}
}

// [EXPERIMENTAL] Called by Begin(). NextWindowData is valid at this point.
// This is designed as a toy/test-bed for
void ImGui::UpdateWindowSkipRefresh(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	window->SkipRefresh = false;
	if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasRefreshPolicy) == 0)
		return;
	if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_TryToAvoidRefresh) {
		// FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.
		if (window->Appearing) // If currently appearing
			return;
		if (window->Hidden) // If was hidden (previous frame)
			return;
		if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnHover) && g.HoveredWindow)
			if (window->RootWindow == g.HoveredWindow->RootWindow || IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, window))
				return;
		if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnFocus) && g.NavWindow)
			if (window->RootWindow == g.NavWindow->RootWindow || IsWindowWithinBeginStackOf(g.NavWindow->RootWindow, window))
				return;
		window->DrawList = NULL;
		window->SkipRefresh = true;
	}
}

static void SetWindowActiveForSkipRefresh(ImGuiWindow *window) {
	window->Active = true;
	for (ImGuiWindow *child : window->DC.ChildWindows)
		if (!child->Hidden) {
			child->Active = child->SkipRefresh = true;
			SetWindowActiveForSkipRefresh(child);
		}
}

// When a modal popup is open, newly created windows that want focus (i.e. are not popups and do not specify ImGuiWindowFlags_NoFocusOnAppearing)
// should be positioned behind that modal window, unless the window was created inside the modal begin-stack.
// In case of multiple stacked modals newly created window honors begin stack order and does not go below its own modal parent.
// - WindowA            // FindBlockingModal() returns Modal1
//   - WindowB          //                  .. returns Modal1
//   - Modal1           //                  .. returns Modal2
//      - WindowC       //                  .. returns Modal2
//          - WindowD   //                  .. returns Modal2
//          - Modal2    //                  .. returns Modal2
//            - WindowE //                  .. returns NULL
// Notes:
// - FindBlockingModal(NULL) == NULL is generally equivalent to GetTopMostPopupModal() == NULL.
//   Only difference is here we check for ->Active/WasActive but it may be unnecessary.
ImGuiWindow *ImGui::FindBlockingModal(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	if (g.OpenPopupStack.Size <= 0)
		return NULL;

	// Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
	for (ImGuiPopupData &popup_data : g.OpenPopupStack) {
		ImGuiWindow *popup_window = popup_data.Window;
		if (popup_window == NULL || !(popup_window->Flags & ImGuiWindowFlags_Modal))
			continue;
		if (!popup_window->Active && !popup_window->WasActive) // Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.
			continue;
		if (window == NULL) // FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.
			return popup_window;
		if (IsWindowWithinBeginStackOf(window, popup_window)) // Window may be over modal
			continue;
		return popup_window; // Place window right below first block modal
	}
	return NULL;
}

// Push a new Dear ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
bool ImGui::Begin(const char *name, bool *p_open, ImGuiWindowFlags flags) {
	ImGuiContext &g = *GImGui;
	const ImGuiStyle &style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0'); // Window name required
	IM_ASSERT(g.WithinFrameScope); // Forgot to call ImGui::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount); // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

	// Find or create
	ImGuiWindow *window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
		window = CreateNewWindow(name, flags);

	// [DEBUG] Debug break requested by user
	if (g.DebugBreakInWindow == window->ID)
		IM_DEBUG_BREAK();

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
		flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
	window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	if (flags & ImGuiWindowFlags_Popup) {
		ImGuiPopupData &popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = window_just_activated_by_user;
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame) {
		UpdateWindowInFocusOrderList(window, window_just_created, flags);
		window->Flags = (ImGuiWindowFlags)flags;
		window->ChildFlags = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasChildFlags) ? g.NextWindowData.ChildFlags : 0;
		window->LastFrameActive = current_frame;
		window->LastTimeActive = (float)g.Time;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	} else {
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	ImGuiWindow *parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
	ImGuiWindow *parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));

	// We allow window memory to be compacted so recreate the base stack when needed.
	if (window->IDStack.Size == 0)
		window->IDStack.push_back(window->ID);

	// Add to stack
	g.CurrentWindow = window;
	ImGuiWindowStackData window_stack_data;
	window_stack_data.Window = window;
	window_stack_data.ParentLastItemDataBackup = g.LastItemData;
	window_stack_data.StackSizesOnBegin.SetToContextState(&g);
	window_stack_data.DisabledOverrideReenable = (flags & ImGuiWindowFlags_Tooltip) && (g.CurrentItemFlags & ImGuiItemFlags_Disabled);
	g.CurrentWindowStack.push_back(window_stack_data);
	if (flags & ImGuiWindowFlags_ChildMenu)
		g.BeginMenuDepth++;

	// Update ->RootWindow and others pointers (before any possible call to FocusWindow)
	if (first_begin_of_the_frame) {
		UpdateWindowParentAndRootLinks(window, flags, parent_window);
		window->ParentWindowInBeginStack = parent_window_in_stack;

		// There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,
		// e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)
		window->ParentWindowForFocusRoute = (flags & ImGuiWindowFlags_ChildWindow) ? parent_window_in_stack : NULL;
	}

	// Add to focus scope stack
	PushFocusScope((window->ChildFlags & ImGuiChildFlags_NavFlattened) ? g.CurrentFocusScopeId : window->ID);
	window->NavRootFocusScopeId = g.CurrentFocusScopeId;

	// Add to popup stacks: update OpenPopupStack[] data, push to BeginPopupStack[]
	if (flags & ImGuiWindowFlags_Popup) {
		ImGuiPopupData &popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	// Process SetNextWindow***() calls
	// (FIXME: Consider splitting the HasXXX flags into X/Y components
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) {
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f) {
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
		} else {
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) {
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0) // Axis-specific conditions for BeginChild()
			g.NextWindowData.SizeVal.x = window->SizeFull.x;
		if ((window->ChildFlags & ImGuiChildFlags_ResizeY) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0)
			g.NextWindowData.SizeVal.y = window->SizeFull.y;
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll) {
		if (g.NextWindowData.ScrollVal.x >= 0.0f) {
			window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
			window->ScrollTargetCenterRatio.x = 0.0f;
		}
		if (g.NextWindowData.ScrollVal.y >= 0.0f) {
			window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
			window->ScrollTargetCenterRatio.y = 0.0f;
		}
	}
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
		window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
	else if (first_begin_of_the_frame)
		window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);

	// [EXPERIMENTAL] Skip Refresh mode
	UpdateWindowSkipRefresh(window);

	// Nested root windows (typically tooltips) override disabled state
	if (window_stack_data.DisabledOverrideReenable && window->RootWindow == window)
		BeginDisabledOverrideReenable();

	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindow = NULL;

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame && !window->SkipRefresh) {
		// Initialize
		const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);
		window->DrawList->_ResetForNewFrame();
		window->DC.CurrentTableIdx = -1;

		// Restore buffer capacity when woken from a compacted state, to avoid
		if (window->MemoryCompacted)
			GcAwakeTransientWindowBuffers(window);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0) // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0) {
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;
		if (window->HiddenFramesForRenderOnly > 0)
			window->HiddenFramesForRenderOnly--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0) {
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & ImGuiWindowFlags_AlwaysAutoResize) {
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
			}
		}

		// SELECT VIEWPORT
		// FIXME-VIEWPORT: In the docking/viewport branch, this is the point where we select the current viewport (which may affect the style)

		ImGuiViewportP *viewport = (ImGuiViewportP *)(void *)GetMainViewport();
		SetWindowViewport(window, viewport);
		SetCurrentWindow(window);

		// LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)

		if (flags & ImGuiWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !(window->ChildFlags & ImGuiChildFlags_AlwaysUseWindowPadding) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);

		// Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
		window->TitleBarHeight = (flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : g.FontSize + g.Style.FramePadding.y * 2.0f;
		window->MenuBarHeight = (flags & ImGuiWindowFlags_MenuBar) ? window->DC.MenuBarOffset.y + g.FontSize + g.Style.FramePadding.y * 2.0f : 0.0f;

		// Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.
		// Those flags will be altered further down in the function depending on more conditions.
		bool use_current_size_for_scrollbar_x = window_just_created;
		bool use_current_size_for_scrollbar_y = window_just_created;
		if (window_size_x_set_by_api && window->ContentSizeExplicit.x != 0.0f)
			use_current_size_for_scrollbar_x = true;
		if (window_size_y_set_by_api && window->ContentSizeExplicit.y != 0.0f) // #7252
			use_current_size_for_scrollbar_y = true;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse)) {
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			ImRect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max))
				if (g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey_MouseLeft) == ImGuiKeyOwner_NoOwner)
					window->WantCollapseToggle = true;
			if (window->WantCollapseToggle) {
				window->Collapsed = !window->Collapsed;
				if (!window->Collapsed)
					use_current_size_for_scrollbar_y = true;
				MarkIniSettingsDirty(window);
			}
		} else {
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Outer Decoration Sizes
		// (we need to clear ScrollbarSize immediately as CalcWindowAutoFitSize() needs it and can be called from other locations).
		const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
		window->DecoOuterSizeX1 = 0.0f;
		window->DecoOuterSizeX2 = 0.0f;
		window->DecoOuterSizeY1 = window->TitleBarHeight + window->MenuBarHeight;
		window->DecoOuterSizeY2 = 0.0f;
		window->ScrollbarSizes = ImVec2(0.0f, 0.0f);

		// Calculate auto-fit size, handle automatic resize
		const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
		if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed) {
			// Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api) {
				window->SizeFull.x = size_auto_fit.x;
				use_current_size_for_scrollbar_x = true;
			}
			if (!window_size_y_set_by_api) {
				window->SizeFull.y = size_auto_fit.y;
				use_current_size_for_scrollbar_y = true;
			}
		} else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0) {
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0) {
				window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
				use_current_size_for_scrollbar_x = true;
			}
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0) {
				window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
				use_current_size_for_scrollbar_y = true;
			}
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user) {
			window->AutoPosLastDirection = ImGuiDir_None;
			if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & ImGuiWindowFlags_ChildWindow) {
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
		else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
		// When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
		ImRect viewport_rect(viewport->GetMainRect());
		ImRect viewport_work_rect(viewport->GetWorkRect());
		ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
		ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);

		// Clamp position/size so window stays visible within its viewport or monitor
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
			if (viewport_rect.GetWidth() > 0.0f && viewport_rect.GetHeight() > 0.0f)
				ClampWindowPos(window, visibility_rect);
		window->Pos = ImTrunc(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		// Large values tend to lead to variety of artifacts and are not recommended.
		window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding
																																										: style.WindowRounding;

		// For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
		//if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
		//    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing)) {
			if (flags & ImGuiWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// [Test Engine] Register whole window in the item system (before submitting further decorations)
#ifdef IMGUI_ENABLE_TEST_ENGINE
		if (g.TestEngineHookItems) {
			IM_ASSERT(window->IDStack.Size == 1);
			window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
			IMGUI_TEST_ENGINE_ITEM_ADD(window->ID, window->Rect(), NULL);
			IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
			window->IDStack.Size = 1;
		}
#endif

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_hovered = -1, border_held = -1;
		ImU32 resize_grip_col[4] = {};
		const int resize_grip_count = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup)) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2
																																							: 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
		const float resize_grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
		if (!window->Collapsed)
			if (int auto_fit_mask = UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect)) {
				if (auto_fit_mask & (1 << ImGuiAxis_X))
					use_current_size_for_scrollbar_x = true;
				if (auto_fit_mask & (1 << ImGuiAxis_Y))
					use_current_size_for_scrollbar_y = true;
			}
		window->ResizeBorderHovered = (signed char)border_hovered;
		window->ResizeBorderHeld = (signed char)border_held;

		// SCROLLBAR VISIBILITY

		// Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed) {
			// When reading the current size we need to read it after size constraints have been applied.
			// Intentionally use previous frame values for InnerRect and ScrollbarSizes.
			// And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
			ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
			ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;
			ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
			float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
			float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
			//bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
			window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);
			window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);

			// Amend the partially filled window->DecorationXXX values.
			window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
			window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
		}

		// UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
		// Update various regions. Variables they depend on should be set above in this function.
		// We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.

		// Outer rectangle
		// Not affected by window border size. Used by:
		// - FindHoveredWindow() (w/ extra padding when border resize is enabled)
		// - Begin() initial clipping rect for drawing window background and borders.
		// - Begin() clipping whole child
		const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
		const ImRect outer_rect = window->Rect();
		const ImRect title_bar_rect = window->TitleBarRect();
		window->OuterRectClipped = outer_rect;
		window->OuterRectClipped.ClipWith(host_rect);

		// Inner rectangle
		// Not affected by window border size. Used by:
		// - InnerClipRect
		// - ScrollToRectEx()
		// - NavUpdatePageUpPageDown()
		// - Scrollbar()
		window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
		window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
		window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
		window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;

		// Inner clipping rectangle.
		// - Extend a outside of normal work region up to borders.
		// - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
		// - It also makes clipped items be more noticeable.
		// - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312
		// - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		// Affected by window/frame border size. Used by:
		// - Begin() initial clip rect
		float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);

		// Try to match the fact that our border is drawn centered over the window rectangle, rather than inner.
		// This is why we do a *0.5f here. We don't currently even technically support large values for WindowBorderSize,
		// see e.g #7887 #7888, but may do after we move the window border to become an inner border (and then we can remove the 0.5f here).
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + window->WindowBorderSize * 0.5f);
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size * 0.5f);
		window->InnerClipRect.Max.x = ImFloor(window->InnerRect.Max.x - window->WindowBorderSize * 0.5f);
		window->InnerClipRect.Max.y = ImFloor(window->InnerRect.Max.y - window->WindowBorderSize * 0.5f);
		window->InnerClipRect.ClipWithFull(host_rect);

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = ImTrunc(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = ImTrunc(g.FontSize * 16.0f);

		// SCROLLING

		// Lock down maximum scrolling
		// The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
		// for right/bottom aligned items without creating a scrollbar.
		window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
		window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
		window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
		window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;

		// DRAWING

		// Setup draw list and outer clipping rectangle
		IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		PushClipRect(host_rect.Min, host_rect.Max, false);

		// Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
		// When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
		// FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
		{
			bool render_decorations_in_parent = false;
			if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) {
				// - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
				// - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
				ImGuiWindow *previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;
				bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
				bool parent_is_empty = (parent_window->DrawList->VtxBuffer.Size == 0);
				if (window->DrawList->CmdBuffer.back().ElemCount == 0 && !parent_is_empty && !previous_child_overlapping)
					render_decorations_in_parent = true;
			}
			if (render_decorations_in_parent)
				window->DrawList = parent_window->DrawList;

			// Handle title bar, scrollbar, resize grips and resize borders
			const ImGuiWindow *window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
			const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
			const bool handle_borders_and_resize_grips = true; // This exists to facilitate merge with 'docking' branch.
			RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);

			if (render_decorations_in_parent)
				window->DrawList = &window->DrawListInst;
		}

		// UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)

		// Work rectangle.
		// Affected by window padding and border size. Used by:
		// - Columns() for right-most edge
		// - TreeNode(), CollapsingHeader() for right-most edge
		// - BeginTabBar() for right-most edge
		const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
		const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
		const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
		const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
		window->WorkRect.Min.x = ImTrunc(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
		window->WorkRect.Min.y = ImTrunc(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
		window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
		window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
		window->ParentWorkRect = window->WorkRect;

		// [LEGACY] Content Region
		// FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		// Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
		// Used by:
		// - Mouse wheel scrolling + many other things
		window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;
		window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;
		window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
		window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;

		// Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
		// This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
		double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;
		double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;
		window->DC.CursorStartPos = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
		window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.IdealMaxPos = window->DC.CursorStartPos;
		window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
		window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.IsSameLine = window->DC.IsSetPos = false;

		window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
		window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
		window->DC.NavLayersActiveMaskNext = 0x00;
		window->DC.NavIsScrollPushableX = true;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavWindowHasScrollY = (window->ScrollMax.y > 0.0f);

		window->DC.MenuBarAppending = false;
		window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
		window->DC.TreeDepth = 0;
		window->DC.TreeHasStackDataDepthMask = 0x00;
		window->DC.ChildWindows.resize(0);
		window->DC.StateStorage = &window->StateStorage;
		window->DC.CurrentColumns = NULL;
		window->DC.LayoutType = ImGuiLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;

		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		if (flags & ImGuiWindowFlags_Modal)
			window->DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol_ModalWindowDimBg));

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		// We ImGuiFocusRequestFlags_UnlessBelowModal to:
		// - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
		// - Position window behind the modal that is not a begin-parent of this window.
		if (want_focus)
			FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);
		if (want_focus && window == g.NavWindow)
			NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls

		// Title bar
		if (!(flags & ImGuiWindowFlags_NoTitleBar))
			RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);

		// Clear hit test shape every frame
		window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		//if (g.NavWindow == window && g.ActiveId == 0)
		if (g.ActiveId == window->MoveId)
			if (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_C))
				LogToClipboard();
		*/

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		SetLastItemDataForWindow(window, title_bar_rect);

		// [DEBUG]
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
		if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
			DebugLocateItemResolveWithLastItem();
#endif

		// [Test Engine] Register title bar / tab with MoveId.
#ifdef IMGUI_ENABLE_TEST_ENGINE
		if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
			IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData);
#endif
	} else {
		// Skip refresh always mark active
		if (window->SkipRefresh)
			SetWindowActiveForSkipRefresh(window);

		// Append
		SetCurrentWindow(window);
		SetLastItemDataForWindow(window, window->TitleBarRect());
	}

	if (!window->SkipRefresh)
		PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	window->WriteAccessed = false;
	window->BeginCount++;
	g.NextWindowData.ClearFlags();

	// Update visibility
	if (first_begin_of_the_frame && !window->SkipRefresh) {
		if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_ChildMenu)) {
			// Child window can be out of sight and have "negative" clip windows.
			// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
			IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);
			const bool nav_request = (window->ChildFlags & ImGuiChildFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
			if (!g.LogEnabled && !nav_request)
				if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y) {
					if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
						window->HiddenFramesCannotSkipItems = 1;
					else
						window->HiddenFramesCanSkipItems = 1;
				}

			// Hide along with parent or if parent is collapsed
			if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
				window->HiddenFramesCanSkipItems = 1;
			if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
				window->HiddenFramesCannotSkipItems = 1;
		}

		// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
		if (style.Alpha <= 0.0f)
			window->HiddenFramesCanSkipItems = 1;

		// Update the Hidden flag
		bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
		window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);

		// Disable inputs for requested number of frames
		if (window->DisableInputsFrames > 0) {
			window->DisableInputsFrames--;
			window->Flags |= ImGuiWindowFlags_NoInputs;
		}

		// Update the SkipItems flag, used to early out of all items functions (no layout required)
		bool skip_items = false;
		if (window->Collapsed || !window->Active || hidden_regular)
			if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
				skip_items = true;
		window->SkipItems = skip_items;
	} else if (first_begin_of_the_frame) {
		// Skip refresh mode
		window->SkipItems = true;
	}

	// [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
	// (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	if (!window->IsFallbackWindow)
		if ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size)) {
			if (window->AutoFitFramesX > 0) {
				window->AutoFitFramesX++;
			}
			if (window->AutoFitFramesY > 0) {
				window->AutoFitFramesY++;
			}
			return false;
		}
#endif

	return !window->SkipItems;
}

static void ImGui::SetLastItemDataForWindow(ImGuiWindow *window, const ImRect &rect) {
	ImGuiContext &g = *GImGui;
	SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, rect);
}

void ImGui::End() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	// Error checking: verify that user hasn't called End() too many times!
	if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow) {
		IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
		return;
	}
	ImGuiWindowStackData &window_stack_data = g.CurrentWindowStack.back();

	// Error checking: verify that user doesn't directly call End() on a child window.
	if (window->Flags & ImGuiWindowFlags_ChildWindow)
		IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");

	// Close anything that is open
	if (window->DC.CurrentColumns)
		EndColumns();
	if (!window->SkipRefresh)
		PopClipRect(); // Inner window clip rectangle
	PopFocusScope();
	if (window_stack_data.DisabledOverrideReenable && window->RootWindow == window)
		EndDisabledOverrideReenable();

	if (window->SkipRefresh) {
		IM_ASSERT(window->DrawList == NULL);
		window->DrawList = &window->DrawListInst;
	}

	// Stop logging
	if (!(window->Flags & ImGuiWindowFlags_ChildWindow)) // FIXME: add more options for scope of logging
		LogFinish();

	if (window->DC.IsSetPos)
		ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

	// Pop from window stack
	g.LastItemData = window_stack_data.ParentLastItemDataBackup;
	if (window->Flags & ImGuiWindowFlags_ChildMenu)
		g.BeginMenuDepth--;
	if (window->Flags & ImGuiWindowFlags_Popup)
		g.BeginPopupStack.pop_back();
	window_stack_data.StackSizesOnBegin.CompareWithContextState(&g);
	g.CurrentWindowStack.pop_back();
	SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);
}

void ImGui::BringWindowToFocusFront(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(window == window->RootWindow);

	const int cur_order = window->FocusOrder;
	IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
	if (g.WindowsFocusOrder.back() == window)
		return;

	const int new_order = g.WindowsFocusOrder.Size - 1;
	for (int n = cur_order; n < new_order; n++) {
		g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
		g.WindowsFocusOrder[n]->FocusOrder--;
		IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
	}
	g.WindowsFocusOrder[new_order] = window;
	window->FocusOrder = (short)new_order;
}

void ImGui::BringWindowToDisplayFront(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *current_front_window = g.Windows.back();
	if (current_front_window == window || current_front_window->RootWindow == window) // Cheap early out (could be better)
		return;
	for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
		if (g.Windows[i] == window) {
			memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow *));
			g.Windows[g.Windows.Size - 1] = window;
			break;
		}
}

void ImGui::BringWindowToDisplayBack(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	if (g.Windows[0] == window)
		return;
	for (int i = 0; i < g.Windows.Size; i++)
		if (g.Windows[i] == window) {
			memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow *));
			g.Windows[0] = window;
			break;
		}
}

void ImGui::BringWindowToDisplayBehind(ImGuiWindow *window, ImGuiWindow *behind_window) {
	IM_ASSERT(window != NULL && behind_window != NULL);
	ImGuiContext &g = *GImGui;
	window = window->RootWindow;
	behind_window = behind_window->RootWindow;
	int pos_wnd = FindWindowDisplayIndex(window);
	int pos_beh = FindWindowDisplayIndex(behind_window);
	if (pos_wnd < pos_beh) {
		size_t copy_bytes = (pos_beh - pos_wnd - 1) * sizeof(ImGuiWindow *);
		memmove(&g.Windows.Data[pos_wnd], &g.Windows.Data[pos_wnd + 1], copy_bytes);
		g.Windows[pos_beh - 1] = window;
	} else {
		size_t copy_bytes = (pos_wnd - pos_beh) * sizeof(ImGuiWindow *);
		memmove(&g.Windows.Data[pos_beh + 1], &g.Windows.Data[pos_beh], copy_bytes);
		g.Windows[pos_beh] = window;
	}
}

int ImGui::FindWindowDisplayIndex(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	return g.Windows.index_from_ptr(g.Windows.find(window));
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void ImGui::FocusWindow(ImGuiWindow *window, ImGuiFocusRequestFlags flags) {
	ImGuiContext &g = *GImGui;

	// Modal check?
	if ((flags & ImGuiFocusRequestFlags_UnlessBelowModal) && (g.NavWindow != window)) // Early out in common case.
		if (ImGuiWindow *blocking_modal = FindBlockingModal(window)) {
			// This block would typically be reached in two situations:
			// - API call to FocusWindow() with a window under a modal and ImGuiFocusRequestFlags_UnlessBelowModal flag.
			// - User clicking on void or anything behind a modal while a modal is open (window == NULL)
			IMGUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window ? window->Name : "<NULL>", blocking_modal->Name);
			if (window && window == window->RootWindow && (window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
				BringWindowToDisplayBehind(window, blocking_modal); // Still bring right under modal. (FIXME: Could move in focus list too?)
			ClosePopupsOverWindow(GetTopMostPopupModal(), false); // Note how we need to use GetTopMostPopupModal() aad NOT blocking_modal, to handle nested modals
			return;
		}

	// Find last focused child (if any) and focus it instead.
	if ((flags & ImGuiFocusRequestFlags_RestoreFocusedChild) && window != NULL)
		window = NavRestoreLastChildNavWindow(window);

	// Apply focus
	if (g.NavWindow != window) {
		SetNavWindow(window);
		if (window && g.NavDisableMouseHover)
			g.NavMousePosDirty = true;
		g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
		g.NavLayer = ImGuiNavLayer_Main;
		SetNavFocusScope(window ? window->NavRootFocusScopeId : 0);
		g.NavIdIsAlive = false;
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;

		// Close popups if any
		ClosePopupsOverWindow(window, false);
	}

	// Move the root window to the top of the pile
	IM_ASSERT(window == NULL || window->RootWindow != NULL);
	ImGuiWindow *focus_front_window = window ? window->RootWindow : NULL; // NB: In docking branch this is window->RootWindowDockStop
	ImGuiWindow *display_front_window = window ? window->RootWindow : NULL;

	// Steal active widgets. Some of the cases it triggers includes:
	// - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
	// - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
	if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
		if (!g.ActiveIdNoClearOnFocusLoss)
			ClearActiveID();

	// Passing NULL allow to disable keyboard focus
	if (!window)
		return;

	// Bring to front
	BringWindowToFocusFront(focus_front_window);
	if (((window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
		BringWindowToDisplayFront(display_front_window);
}

void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow *under_this_window, ImGuiWindow *ignore_window, ImGuiViewport *filter_viewport, ImGuiFocusRequestFlags flags) {
	ImGuiContext &g = *GImGui;
	IM_UNUSED(filter_viewport); // Unused in master branch.
	int start_idx = g.WindowsFocusOrder.Size - 1;
	if (under_this_window != NULL) {
		// Aim at root window behind us, if we are in a child window that's our own root (see #4640)
		int offset = -1;
		while (under_this_window->Flags & ImGuiWindowFlags_ChildWindow) {
			under_this_window = under_this_window->ParentWindow;
			offset = 0;
		}
		start_idx = FindWindowFocusIndex(under_this_window) + offset;
	}
	for (int i = start_idx; i >= 0; i--) {
		// We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
		ImGuiWindow *window = g.WindowsFocusOrder[i];
		if (window == ignore_window || !window->WasActive)
			continue;
		if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) {
			FocusWindow(window, flags);
			return;
		}
	}
	FocusWindow(NULL, flags);
}

// Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.
void ImGui::SetCurrentFont(ImFont *font) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(font && font->IsLoaded()); // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
	IM_ASSERT(font->Scale > 0.0f);
	g.Font = font;
	g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
	g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;
	g.FontScale = g.FontSize / g.Font->FontSize;

	ImFontAtlas *atlas = g.Font->ContainerAtlas;
	g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
	g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
	g.DrawListSharedData.Font = g.Font;
	g.DrawListSharedData.FontSize = g.FontSize;
	g.DrawListSharedData.FontScale = g.FontScale;
}

// Use ImDrawList::_SetTextureID(), making our shared g.FontStack[] authorative against window-local ImDrawList.
// - Whereas ImDrawList::PushTextureID()/PopTextureID() is not to be used across Begin() calls.
// - Note that we don't propagate current texture id when e.g. Begin()-ing into a new window, we never really did...
//   - Some code paths never really fully worked with multiple atlas textures.
//   - The right-ish solution may be to remove _SetTextureID() and make AddText/RenderText lazily call PushTextureID()/PopTextureID()
//     the same way AddImage() does, but then all other primitives would also need to? I don't think we should tackle this problem
//     because we have a concrete need and a test bed for multiple atlas textures.
void ImGui::PushFont(ImFont *font) {
	ImGuiContext &g = *GImGui;
	if (font == NULL)
		font = GetDefaultFont();
	g.FontStack.push_back(font);
	SetCurrentFont(font);
	g.CurrentWindow->DrawList->_SetTextureID(font->ContainerAtlas->TexID);
}

void ImGui::PopFont() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.FontStack.Size > 0);
	g.FontStack.pop_back();
	ImFont *font = g.FontStack.Size == 0 ? GetDefaultFont() : g.FontStack.back();
	SetCurrentFont(font);
	g.CurrentWindow->DrawList->_SetTextureID(font->ContainerAtlas->TexID);
}

void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled) {
	ImGuiContext &g = *GImGui;
	ImGuiItemFlags item_flags = g.CurrentItemFlags;
	IM_ASSERT(item_flags == g.ItemFlagsStack.back());
	if (enabled)
		item_flags |= option;
	else
		item_flags &= ~option;
	g.CurrentItemFlags = item_flags;
	g.ItemFlagsStack.push_back(item_flags);
}

void ImGui::PopItemFlag() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.ItemFlagsStack.Size > 1); // Too many calls to PopItemFlag() - we always leave a 0 at the bottom of the stack.
	g.ItemFlagsStack.pop_back();
	g.CurrentItemFlags = g.ItemFlagsStack.back();
}

// BeginDisabled()/EndDisabled()
// - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)
// - Visually this is currently altering alpha, but it is expected that in a future styling system this would work differently.
// - Feedback welcome at https://github.com/ocornut/imgui/issues/211
// - BeginDisabled(false) essentially does nothing useful but is provided to facilitate use of boolean expressions. If you can avoid calling BeginDisabled(False)/EndDisabled() best to avoid it.
// - Optimized shortcuts instead of PushStyleVar() + PushItemFlag()
void ImGui::BeginDisabled(bool disabled) {
	ImGuiContext &g = *GImGui;
	bool was_disabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
	if (!was_disabled && disabled) {
		g.DisabledAlphaBackup = g.Style.Alpha;
		g.Style.Alpha *= g.Style.DisabledAlpha; // PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * g.Style.DisabledAlpha);
	}
	if (was_disabled || disabled)
		g.CurrentItemFlags |= ImGuiItemFlags_Disabled;
	g.ItemFlagsStack.push_back(g.CurrentItemFlags); // FIXME-OPT: can we simply skip this and use DisabledStackSize?
	g.DisabledStackSize++;
}

void ImGui::EndDisabled() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.DisabledStackSize > 0);
	g.DisabledStackSize--;
	bool was_disabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
	//PopItemFlag();
	g.ItemFlagsStack.pop_back();
	g.CurrentItemFlags = g.ItemFlagsStack.back();
	if (was_disabled && (g.CurrentItemFlags & ImGuiItemFlags_Disabled) == 0)
		g.Style.Alpha = g.DisabledAlphaBackup; //PopStyleVar();
}

// Could have been called BeginDisabledDisable() but it didn't want to be award nominated for most awkward function name.
// Ideally we would use a shared e.g. BeginDisabled()->BeginDisabledEx() but earlier needs to be optimal.
// The whole code for this is awkward, will reevaluate if we find a way to implement SetNextItemDisabled().
void ImGui::BeginDisabledOverrideReenable() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.CurrentItemFlags & ImGuiItemFlags_Disabled);
	g.Style.Alpha = g.DisabledAlphaBackup;
	g.CurrentItemFlags &= ~ImGuiItemFlags_Disabled;
	g.ItemFlagsStack.push_back(g.CurrentItemFlags);
	g.DisabledStackSize++;
}

void ImGui::EndDisabledOverrideReenable() {
	ImGuiContext &g = *GImGui;
	g.DisabledStackSize--;
	IM_ASSERT(g.DisabledStackSize > 0);
	g.ItemFlagsStack.pop_back();
	g.CurrentItemFlags = g.ItemFlagsStack.back();
	g.Style.Alpha = g.DisabledAlphaBackup * g.Style.DisabledAlpha;
}

void ImGui::PushTextWrapPos(float wrap_pos_x) {
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.TextWrapPosStack.push_back(window->DC.TextWrapPos);
	window->DC.TextWrapPos = wrap_pos_x;
}

void ImGui::PopTextWrapPos() {
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();
	window->DC.TextWrapPosStack.pop_back();
}

static ImGuiWindow *GetCombinedRootWindow(ImGuiWindow *window, bool popup_hierarchy) {
	ImGuiWindow *last_window = NULL;
	while (last_window != window) {
		last_window = window;
		window = window->RootWindow;
		if (popup_hierarchy)
			window = window->RootWindowPopupTree;
	}
	return window;
}

bool ImGui::IsWindowChildOf(ImGuiWindow *window, ImGuiWindow *potential_parent, bool popup_hierarchy) {
	ImGuiWindow *window_root = GetCombinedRootWindow(window, popup_hierarchy);
	if (window_root == potential_parent)
		return true;
	while (window != NULL) {
		if (window == potential_parent)
			return true;
		if (window == window_root) // end of chain
			return false;
		window = window->ParentWindow;
	}
	return false;
}

bool ImGui::IsWindowWithinBeginStackOf(ImGuiWindow *window, ImGuiWindow *potential_parent) {
	if (window->RootWindow == potential_parent)
		return true;
	while (window != NULL) {
		if (window == potential_parent)
			return true;
		window = window->ParentWindowInBeginStack;
	}
	return false;
}

bool ImGui::IsWindowAbove(ImGuiWindow *potential_above, ImGuiWindow *potential_below) {
	ImGuiContext &g = *GImGui;

	// It would be saner to ensure that display layer is always reflected in the g.Windows[] order, which would likely requires altering all manipulations of that array
	const int display_layer_delta = GetWindowDisplayLayer(potential_above) - GetWindowDisplayLayer(potential_below);
	if (display_layer_delta != 0)
		return display_layer_delta > 0;

	for (int i = g.Windows.Size - 1; i >= 0; i--) {
		ImGuiWindow *candidate_window = g.Windows[i];
		if (candidate_window == potential_above)
			return true;
		if (candidate_window == potential_below)
			return false;
	}
	return false;
}

// Is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options.
// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags) {
	IM_ASSERT((flags & ~ImGuiHoveredFlags_AllowedMaskForIsWindowHovered) == 0 && "Invalid flags for IsWindowHovered()!");

	ImGuiContext &g = *GImGui;
	ImGuiWindow *ref_window = g.HoveredWindow;
	ImGuiWindow *cur_window = g.CurrentWindow;
	if (ref_window == NULL)
		return false;

	if ((flags & ImGuiHoveredFlags_AnyWindow) == 0) {
		IM_ASSERT(cur_window); // Not inside a Begin()/End()
		const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
		if (flags & ImGuiHoveredFlags_RootWindow)
			cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy);

		bool result;
		if (flags & ImGuiHoveredFlags_ChildWindows)
			result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy);
		else
			result = (ref_window == cur_window);
		if (!result)
			return false;
	}

	if (!IsWindowContentHoverable(ref_window, flags))
		return false;
	if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
		if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)
			return false;

	// When changing hovered window we requires a bit of stationary delay before activating hover timer.
	// FIXME: We don't support delay other than stationary one for now, other delay would need a way
	// to fulfill the possibility that multiple IsWindowHovered() with varying flag could return true
	// for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.
	// We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.
	if (flags & ImGuiHoveredFlags_ForTooltip)
		flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);
	if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverWindowUnlockedStationaryId != ref_window->ID)
		return false;

	return true;
}

bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *ref_window = g.NavWindow;
	ImGuiWindow *cur_window = g.CurrentWindow;

	if (ref_window == NULL)
		return false;
	if (flags & ImGuiFocusedFlags_AnyWindow)
		return true;

	IM_ASSERT(cur_window); // Not inside a Begin()/End()
	const bool popup_hierarchy = (flags & ImGuiFocusedFlags_NoPopupHierarchy) == 0;
	if (flags & ImGuiHoveredFlags_RootWindow)
		cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy);

	if (flags & ImGuiHoveredFlags_ChildWindows)
		return IsWindowChildOf(ref_window, cur_window, popup_hierarchy);
	else
		return (ref_window == cur_window);
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmatically.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
bool ImGui::IsWindowNavFocusable(ImGuiWindow *window) {
	return window->WasActive && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
}

float ImGui::GetWindowWidth() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->Size.x;
}

float ImGui::GetWindowHeight() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->Size.y;
}

ImVec2 ImGui::GetWindowPos() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	return window->Pos;
}

void ImGui::SetWindowPos(ImGuiWindow *window, const ImVec2 &pos, ImGuiCond cond) {
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
		return;

	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
	window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);

	// Set
	const ImVec2 old_pos = window->Pos;
	window->Pos = ImTrunc(pos);
	ImVec2 offset = window->Pos - old_pos;
	if (offset.x == 0.0f && offset.y == 0.0f)
		return;
	MarkIniSettingsDirty(window);
	window->DC.CursorPos += offset; // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
	window->DC.CursorMaxPos += offset; // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
	window->DC.IdealMaxPos += offset;
	window->DC.CursorStartPos += offset;
}

void ImGui::SetWindowPos(const ImVec2 &pos, ImGuiCond cond) {
	ImGuiWindow *window = GetCurrentWindowRead();
	SetWindowPos(window, pos, cond);
}

void ImGui::SetWindowPos(const char *name, const ImVec2 &pos, ImGuiCond cond) {
	if (ImGuiWindow *window = FindWindowByName(name))
		SetWindowPos(window, pos, cond);
}

ImVec2 ImGui::GetWindowSize() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->Size;
}

void ImGui::SetWindowSize(ImGuiWindow *window, const ImVec2 &size, ImGuiCond cond) {
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
		return;

	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

	// Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)
	if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
		window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
	if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
		window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;

	// Set
	ImVec2 old_size = window->SizeFull;
	if (size.x <= 0.0f)
		window->AutoFitOnlyGrows = false;
	else
		window->SizeFull.x = IM_TRUNC(size.x);
	if (size.y <= 0.0f)
		window->AutoFitOnlyGrows = false;
	else
		window->SizeFull.y = IM_TRUNC(size.y);
	if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
		MarkIniSettingsDirty(window);
}

void ImGui::SetWindowSize(const ImVec2 &size, ImGuiCond cond) {
	SetWindowSize(GImGui->CurrentWindow, size, cond);
}

void ImGui::SetWindowSize(const char *name, const ImVec2 &size, ImGuiCond cond) {
	if (ImGuiWindow *window = FindWindowByName(name))
		SetWindowSize(window, size, cond);
}

void ImGui::SetWindowCollapsed(ImGuiWindow *window, bool collapsed, ImGuiCond cond) {
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
		return;
	window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

	// Set
	window->Collapsed = collapsed;
}

void ImGui::SetWindowHitTestHole(ImGuiWindow *window, const ImVec2 &pos, const ImVec2 &size) {
	IM_ASSERT(window->HitTestHoleSize.x == 0); // We don't support multiple holes/hit test filters
	window->HitTestHoleSize = ImVec2ih(size);
	window->HitTestHoleOffset = ImVec2ih(pos - window->Pos);
}

void ImGui::SetWindowHiddenAndSkipItemsForCurrentFrame(ImGuiWindow *window) {
	window->Hidden = window->SkipItems = true;
	window->HiddenFramesCanSkipItems = 1;
}

void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond) {
	SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
}

bool ImGui::IsWindowCollapsed() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->Collapsed;
}

bool ImGui::IsWindowAppearing() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->Appearing;
}

void ImGui::SetWindowCollapsed(const char *name, bool collapsed, ImGuiCond cond) {
	if (ImGuiWindow *window = FindWindowByName(name))
		SetWindowCollapsed(window, collapsed, cond);
}

void ImGui::SetWindowFocus() {
	FocusWindow(GImGui->CurrentWindow);
}

void ImGui::SetWindowFocus(const char *name) {
	if (name) {
		if (ImGuiWindow *window = FindWindowByName(name))
			FocusWindow(window);
	} else {
		FocusWindow(NULL);
	}
}

void ImGui::SetNextWindowPos(const ImVec2 &pos, ImGuiCond cond, const ImVec2 &pivot) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
	g.NextWindowData.PosVal = pos;
	g.NextWindowData.PosPivotVal = pivot;
	g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSize(const ImVec2 &size, ImGuiCond cond) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
	g.NextWindowData.SizeVal = size;
	g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

// For each axis:
// - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min = (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.
// - Use -1 for both min and max of same axis to preserve current size which itself is a constraint.
// - See "Demo->Examples->Constrained-resizing window" for examples.
void ImGui::SetNextWindowSizeConstraints(const ImVec2 &size_min, const ImVec2 &size_max, ImGuiSizeCallback custom_callback, void *custom_callback_user_data) {
	ImGuiContext &g = *GImGui;
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
	g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
	g.NextWindowData.SizeCallback = custom_callback;
	g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

// Content size = inner scrollable rectangle, padded with WindowPadding.
// SetNextWindowContentSize(ImVec2(100,100) + ImGuiWindowFlags_AlwaysAutoResize will always allow submitting a 100x100 item.
void ImGui::SetNextWindowContentSize(const ImVec2 &size) {
	ImGuiContext &g = *GImGui;
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasContentSize;
	g.NextWindowData.ContentSizeVal = ImTrunc(size);
}

void ImGui::SetNextWindowScroll(const ImVec2 &scroll) {
	ImGuiContext &g = *GImGui;
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasScroll;
	g.NextWindowData.ScrollVal = scroll;
}

void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasCollapsed;
	g.NextWindowData.CollapsedVal = collapsed;
	g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus() {
	ImGuiContext &g = *GImGui;
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasFocus;
}

void ImGui::SetNextWindowBgAlpha(float alpha) {
	ImGuiContext &g = *GImGui;
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;
	g.NextWindowData.BgAlphaVal = alpha;
}

// This is experimental and meant to be a toy for exploring a future/wider range of features.
void ImGui::SetNextWindowRefreshPolicy(ImGuiWindowRefreshFlags flags) {
	ImGuiContext &g = *GImGui;
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasRefreshPolicy;
	g.NextWindowData.RefreshFlagsVal = flags;
}

ImDrawList *ImGui::GetWindowDrawList() {
	ImGuiWindow *window = GetCurrentWindow();
	return window->DrawList;
}

ImFont *ImGui::GetFont() {
	return GImGui->Font;
}

float ImGui::GetFontSize() {
	return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel() {
	return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale(float scale) {
	IM_ASSERT(scale > 0.0f);
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	window->FontWindowScale = scale;
	g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
	g.FontScale = g.DrawListSharedData.FontScale = g.FontSize / g.Font->FontSize;
}

void ImGui::PushFocusScope(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	ImGuiFocusScopeData data;
	data.ID = id;
	data.WindowID = g.CurrentWindow->ID;
	g.FocusScopeStack.push_back(data);
	g.CurrentFocusScopeId = id;
}

void ImGui::PopFocusScope() {
	ImGuiContext &g = *GImGui;
	if (g.FocusScopeStack.Size == 0) {
		IM_ASSERT_USER_ERROR(g.FocusScopeStack.Size > 0, "Calling PopFocusScope() too many times!");
		return;
	}
	g.FocusScopeStack.pop_back();
	g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back().ID : 0;
}

void ImGui::SetNavFocusScope(ImGuiID focus_scope_id) {
	ImGuiContext &g = *GImGui;
	g.NavFocusScopeId = focus_scope_id;
	g.NavFocusRoute.resize(0); // Invalidate
	if (focus_scope_id == 0)
		return;
	IM_ASSERT(g.NavWindow != NULL);

	// Store current path (in reverse order)
	if (focus_scope_id == g.CurrentFocusScopeId) {
		// Top of focus stack contains local focus scopes inside current window
		for (int n = g.FocusScopeStack.Size - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow->ID; n--)
			g.NavFocusRoute.push_back(g.FocusScopeStack.Data[n]);
	} else if (focus_scope_id == g.NavWindow->NavRootFocusScopeId)
		g.NavFocusRoute.push_back({ focus_scope_id, g.NavWindow->ID });
	else
		return;

	// Then follow on manually set ParentWindowForFocusRoute field (#6798)
	for (ImGuiWindow *window = g.NavWindow->ParentWindowForFocusRoute; window != NULL; window = window->ParentWindowForFocusRoute)
		g.NavFocusRoute.push_back({ window->NavRootFocusScopeId, window->ID });
	IM_ASSERT(g.NavFocusRoute.Size < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3
}

// Focus = move navigation cursor, set scrolling, set focus window.
void ImGui::FocusItem() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IMGUI_DEBUG_LOG_FOCUS("FocusItem(0x%08x) in window \"%s\"\n", g.LastItemData.ID, window->Name);
	if (g.DragDropActive || g.MovingWindow != NULL) // FIXME: Opt-in flags for this?
	{
		IMGUI_DEBUG_LOG_FOCUS("FocusItem() ignored while DragDropActive!\n");
		return;
	}

	ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_NoSetNavHighlight | ImGuiNavMoveFlags_NoSelect;
	ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
	SetNavWindow(window);
	NavMoveRequestSubmit(ImGuiDir_None, ImGuiDir_Up, move_flags, scroll_flags);
	NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
}

void ImGui::ActivateItemByID(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	g.NavNextActivateId = id;
	g.NavNextActivateFlags = ImGuiActivateFlags_None;
}

// Note: this will likely be called ActivateItem() once we rework our Focus/Activation system!
// But ActivateItem() should function without altering scroll/focus?
void ImGui::SetKeyboardFocusHere(int offset) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(offset >= -1); // -1 is allowed but not below
	IMGUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere(%d) in window \"%s\"\n", offset, window->Name);

	// It makes sense in the vast majority of cases to never interrupt a drag and drop.
	// When we refactor this function into ActivateItem() we may want to make this an option.
	// MovingWindow is protected from most user inputs using SetActiveIdUsingNavAndKeys(), but
	// is also automatically dropped in the event g.ActiveId is stolen.
	if (g.DragDropActive || g.MovingWindow != NULL) {
		IMGUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere() ignored while DragDropActive!\n");
		return;
	}

	SetNavWindow(window);

	ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate | ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_NoSetNavHighlight;
	ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
	NavMoveRequestSubmit(ImGuiDir_None, offset < 0 ? ImGuiDir_Up : ImGuiDir_Down, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
	if (offset == -1) {
		NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
	} else {
		g.NavTabbingDir = 1;
		g.NavTabbingCounter = offset + 1;
	}
}

void ImGui::SetItemDefaultFocus() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (!window->Appearing)
		return;
	if (g.NavWindow != window->RootWindowForNav || (!g.NavInitRequest && g.NavInitResult.ID == 0) || g.NavLayer != window->DC.NavLayerCurrent)
		return;

	g.NavInitRequest = false;
	NavApplyItemToResult(&g.NavInitResult);
	NavUpdateAnyRequestFlag();

	// Scroll could be done in NavInitRequestApplyResult() via an opt-in flag (we however don't want regular init requests to scroll)
	if (!window->ClipRect.Contains(g.LastItemData.Rect))
		ScrollToRectEx(window, g.LastItemData.Rect, ImGuiScrollFlags_None);
}

void ImGui::SetStateStorage(ImGuiStorage *tree) {
	ImGuiWindow *window = GImGui->CurrentWindow;
	window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage *ImGui::GetStateStorage() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->DC.StateStorage;
}

bool ImGui::IsRectVisible(const ImVec2 &size) {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool ImGui::IsRectVisible(const ImVec2 &rect_min, const ImVec2 &rect_max) {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
}

//-----------------------------------------------------------------------------
// [SECTION] ID STACK
//-----------------------------------------------------------------------------

// This is one of the very rare legacy case where we use ImGuiWindow methods,
// it should ideally be flattened at some point but it's been used a lots by widgets.
IM_MSVC_RUNTIME_CHECKS_OFF
ImGuiID ImGuiWindow::GetID(const char *str, const char *str_end) {
	ImGuiID seed = IDStack.back();
	ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	ImGuiContext &g = *Ctx;
	if (g.DebugHookIdInfo == id)
		ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
#endif
	return id;
}

ImGuiID ImGuiWindow::GetID(const void *ptr) {
	ImGuiID seed = IDStack.back();
	ImGuiID id = ImHashData(&ptr, sizeof(void *), seed);
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	ImGuiContext &g = *Ctx;
	if (g.DebugHookIdInfo == id)
		ImGui::DebugHookIdInfo(id, ImGuiDataType_Pointer, ptr, NULL);
#endif
	return id;
}

ImGuiID ImGuiWindow::GetID(int n) {
	ImGuiID seed = IDStack.back();
	ImGuiID id = ImHashData(&n, sizeof(n), seed);
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	ImGuiContext &g = *Ctx;
	if (g.DebugHookIdInfo == id)
		ImGui::DebugHookIdInfo(id, ImGuiDataType_S32, (void *)(intptr_t)n, NULL);
#endif
	return id;
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
// FIXME: Consider instead storing last non-zero ID + count of successive zero-ID, and combine those?
ImGuiID ImGuiWindow::GetIDFromPos(const ImVec2 &p_abs) {
	ImGuiID seed = IDStack.back();
	ImVec2 p_rel = ImGui::WindowPosAbsToRel(this, p_abs);
	ImGuiID id = ImHashData(&p_rel, sizeof(p_rel), seed);
	return id;
}

// "
ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect &r_abs) {
	ImGuiID seed = IDStack.back();
	ImRect r_rel = ImGui::WindowRectAbsToRel(this, r_abs);
	ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);
	return id;
}

void ImGui::PushID(const char *str_id) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiID id = window->GetID(str_id);
	window->IDStack.push_back(id);
}

void ImGui::PushID(const char *str_id_begin, const char *str_id_end) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiID id = window->GetID(str_id_begin, str_id_end);
	window->IDStack.push_back(id);
}

void ImGui::PushID(const void *ptr_id) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiID id = window->GetID(ptr_id);
	window->IDStack.push_back(id);
}

void ImGui::PushID(int int_id) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiID id = window->GetID(int_id);
	window->IDStack.push_back(id);
}

// Push a given id value ignoring the ID stack as a seed.
void ImGui::PushOverrideID(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	if (g.DebugHookIdInfo == id)
		DebugHookIdInfo(id, ImGuiDataType_ID, NULL, NULL);
#endif
	window->IDStack.push_back(id);
}

// Helper to avoid a common series of PushOverrideID -> GetID() -> PopID() call
// (note that when using this pattern, ID Stack Tool will tend to not display the intermediate stack level.
//  for that to work we would need to do PushOverrideID() -> ItemAdd() -> PopID() which would alter widget code a little more)
ImGuiID ImGui::GetIDWithSeed(const char *str, const char *str_end, ImGuiID seed) {
	ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	ImGuiContext &g = *GImGui;
	if (g.DebugHookIdInfo == id)
		DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
#endif
	return id;
}

ImGuiID ImGui::GetIDWithSeed(int n, ImGuiID seed) {
	ImGuiID id = ImHashData(&n, sizeof(n), seed);
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	ImGuiContext &g = *GImGui;
	if (g.DebugHookIdInfo == id)
		DebugHookIdInfo(id, ImGuiDataType_S32, (void *)(intptr_t)n, NULL);
#endif
	return id;
}

void ImGui::PopID() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	IM_ASSERT(window->IDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?
	window->IDStack.pop_back();
}

ImGuiID ImGui::GetID(const char *str_id) {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->GetID(str_id);
}

ImGuiID ImGui::GetID(const char *str_id_begin, const char *str_id_end) {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->GetID(str_id_begin, str_id_end);
}

ImGuiID ImGui::GetID(const void *ptr_id) {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->GetID(ptr_id);
}

ImGuiID ImGui::GetID(int int_id) {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->GetID(int_id);
}
IM_MSVC_RUNTIME_CHECKS_RESTORE

//-----------------------------------------------------------------------------
// [SECTION] INPUTS
//-----------------------------------------------------------------------------
// - GetModForLRModKey() [Internal]
// - FixupKeyChord() [Internal]
// - GetKeyData() [Internal]
// - GetKeyIndex() [Internal]
// - GetKeyName()
// - GetKeyChordName() [Internal]
// - CalcTypematicRepeatAmount() [Internal]
// - GetTypematicRepeatRate() [Internal]
// - GetKeyPressedAmount() [Internal]
// - GetKeyMagnitude2d() [Internal]
//-----------------------------------------------------------------------------
// - UpdateKeyRoutingTable() [Internal]
// - GetRoutingIdFromOwnerId() [Internal]
// - GetShortcutRoutingData() [Internal]
// - CalcRoutingScore() [Internal]
// - SetShortcutRouting() [Internal]
// - TestShortcutRouting() [Internal]
//-----------------------------------------------------------------------------
// - IsKeyDown()
// - IsKeyPressed()
// - IsKeyReleased()
//-----------------------------------------------------------------------------
// - IsMouseDown()
// - IsMouseClicked()
// - IsMouseReleased()
// - IsMouseDoubleClicked()
// - GetMouseClickedCount()
// - IsMouseHoveringRect() [Internal]
// - IsMouseDragPastThreshold() [Internal]
// - IsMouseDragging()
// - GetMousePos()
// - SetMousePos() [Internal]
// - GetMousePosOnOpeningCurrentPopup()
// - IsMousePosValid()
// - IsAnyMouseDown()
// - GetMouseDragDelta()
// - ResetMouseDragDelta()
// - GetMouseCursor()
// - SetMouseCursor()
//-----------------------------------------------------------------------------
// - UpdateAliasKey()
// - GetMergedModsFromKeys()
// - UpdateKeyboardInputs()
// - UpdateMouseInputs()
//-----------------------------------------------------------------------------
// - LockWheelingWindow [Internal]
// - FindBestWheelingWindow [Internal]
// - UpdateMouseWheel() [Internal]
//-----------------------------------------------------------------------------
// - SetNextFrameWantCaptureKeyboard()
// - SetNextFrameWantCaptureMouse()
//-----------------------------------------------------------------------------
// - GetInputSourceName() [Internal]
// - DebugPrintInputEvent() [Internal]
// - UpdateInputEvents() [Internal]
//-----------------------------------------------------------------------------
// - GetKeyOwner() [Internal]
// - TestKeyOwner() [Internal]
// - SetKeyOwner() [Internal]
// - SetItemKeyOwner() [Internal]
// - Shortcut() [Internal]
//-----------------------------------------------------------------------------

static ImGuiKeyChord GetModForLRModKey(ImGuiKey key) {
	if (key == ImGuiKey_LeftCtrl || key == ImGuiKey_RightCtrl)
		return ImGuiMod_Ctrl;
	if (key == ImGuiKey_LeftShift || key == ImGuiKey_RightShift)
		return ImGuiMod_Shift;
	if (key == ImGuiKey_LeftAlt || key == ImGuiKey_RightAlt)
		return ImGuiMod_Alt;
	if (key == ImGuiKey_LeftSuper || key == ImGuiKey_RightSuper)
		return ImGuiMod_Super;
	return ImGuiMod_None;
}

ImGuiKeyChord ImGui::FixupKeyChord(ImGuiKeyChord key_chord) {
	// Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
	ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
	if (IsLRModKey(key))
		key_chord |= GetModForLRModKey(key);
	return key_chord;
}

ImGuiKeyData *ImGui::GetKeyData(ImGuiContext *ctx, ImGuiKey key) {
	ImGuiContext &g = *ctx;

	// Special storage location for mods
	if (key & ImGuiMod_Mask_)
		key = ConvertSingleModFlagToKey(key);

#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
	IM_ASSERT(key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_NamedKey_END);
	if (IsLegacyKey(key) && g.IO.KeyMap[key] != -1)
		key = (ImGuiKey)g.IO.KeyMap[key]; // Remap native->imgui or imgui->native
#else
	IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
#endif
	return &g.IO.KeysData[key - ImGuiKey_KeysData_OFFSET];
}

#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
// Formally moved to obsolete section in 1.90.5 in spite of documented as obsolete since 1.87
ImGuiKey ImGui::GetKeyIndex(ImGuiKey key) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(IsNamedKey(key));
	const ImGuiKeyData *key_data = GetKeyData(key);
	return (ImGuiKey)(key_data - g.IO.KeysData);
}
#endif

// Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
static const char *const GKeyNames[] = {
	"Tab",
	"LeftArrow",
	"RightArrow",
	"UpArrow",
	"DownArrow",
	"PageUp",
	"PageDown",
	"Home",
	"End",
	"Insert",
	"Delete",
	"Backspace",
	"Space",
	"Enter",
	"Escape",
	"LeftCtrl",
	"LeftShift",
	"LeftAlt",
	"LeftSuper",
	"RightCtrl",
	"RightShift",
	"RightAlt",
	"RightSuper",
	"Menu",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"F1",
	"F2",
	"F3",
	"F4",
	"F5",
	"F6",
	"F7",
	"F8",
	"F9",
	"F10",
	"F11",
	"F12",
	"F13",
	"F14",
	"F15",
	"F16",
	"F17",
	"F18",
	"F19",
	"F20",
	"F21",
	"F22",
	"F23",
	"F24",
	"Apostrophe",
	"Comma",
	"Minus",
	"Period",
	"Slash",
	"Semicolon",
	"Equal",
	"LeftBracket",
	"Backslash",
	"RightBracket",
	"GraveAccent",
	"CapsLock",
	"ScrollLock",
	"NumLock",
	"PrintScreen",
	"Pause",
	"Keypad0",
	"Keypad1",
	"Keypad2",
	"Keypad3",
	"Keypad4",
	"Keypad5",
	"Keypad6",
	"Keypad7",
	"Keypad8",
	"Keypad9",
	"KeypadDecimal",
	"KeypadDivide",
	"KeypadMultiply",
	"KeypadSubtract",
	"KeypadAdd",
	"KeypadEnter",
	"KeypadEqual",
	"AppBack",
	"AppForward",
	"GamepadStart",
	"GamepadBack",
	"GamepadFaceLeft",
	"GamepadFaceRight",
	"GamepadFaceUp",
	"GamepadFaceDown",
	"GamepadDpadLeft",
	"GamepadDpadRight",
	"GamepadDpadUp",
	"GamepadDpadDown",
	"GamepadL1",
	"GamepadR1",
	"GamepadL2",
	"GamepadR2",
	"GamepadL3",
	"GamepadR3",
	"GamepadLStickLeft",
	"GamepadLStickRight",
	"GamepadLStickUp",
	"GamepadLStickDown",
	"GamepadRStickLeft",
	"GamepadRStickRight",
	"GamepadRStickUp",
	"GamepadRStickDown",
	"MouseLeft",
	"MouseRight",
	"MouseMiddle",
	"MouseX1",
	"MouseX2",
	"MouseWheelX",
	"MouseWheelY",
	"ModCtrl",
	"ModShift",
	"ModAlt",
	"ModSuper", // ReservedForModXXX are showing the ModXXX names.
};
IM_STATIC_ASSERT(ImGuiKey_NamedKey_COUNT == IM_ARRAYSIZE(GKeyNames));

const char *ImGui::GetKeyName(ImGuiKey key) {
	if (key == ImGuiKey_None)
		return "None";
#ifdef IMGUI_DISABLE_OBSOLETE_KEYIO
	IM_ASSERT(IsNamedKeyOrMod(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend and user code.");
#else
	ImGuiContext &g = *GImGui;
	if (IsLegacyKey(key)) {
		if (g.IO.KeyMap[key] == -1)
			return "N/A";
		IM_ASSERT(IsNamedKey((ImGuiKey)g.IO.KeyMap[key]));
		key = (ImGuiKey)g.IO.KeyMap[key];
	}
#endif
	if (key & ImGuiMod_Mask_)
		key = ConvertSingleModFlagToKey(key);
	if (!IsNamedKey(key))
		return "Unknown";

	return GKeyNames[key - ImGuiKey_NamedKey_BEGIN];
}

// Return untranslated names: on macOS, Cmd key will show as Ctrl, Ctrl key will show as super.
// Lifetime of return value: valid until next call to same function.
const char *ImGui::GetKeyChordName(ImGuiKeyChord key_chord) {
	ImGuiContext &g = *GImGui;

	const ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
	if (IsLRModKey(key))
		key_chord &= ~GetModForLRModKey(key); // Return "Ctrl+LeftShift" instead of "Ctrl+Shift+LeftShift"
	ImFormatString(g.TempKeychordName, IM_ARRAYSIZE(g.TempKeychordName), "%s%s%s%s%s",
			(key_chord & ImGuiMod_Ctrl) ? "Ctrl+" : "",
			(key_chord & ImGuiMod_Shift) ? "Shift+" : "",
			(key_chord & ImGuiMod_Alt) ? "Alt+" : "",
			(key_chord & ImGuiMod_Super) ? "Super+" : "",
			(key != ImGuiKey_None || key_chord == ImGuiKey_None) ? GetKeyName(key) : "");
	size_t len;
	if (key == ImGuiKey_None && key_chord != 0)
		if ((len = strlen(g.TempKeychordName)) != 0) // Remove trailing '+'
			g.TempKeychordName[len - 1] = 0;
	return g.TempKeychordName;
}

// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)
// t1 = current time (e.g.: g.Time)
// An event is triggered at:
//  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N
int ImGui::CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate) {
	if (t1 == 0.0f)
		return 1;
	if (t0 >= t1)
		return 0;
	if (repeat_rate <= 0.0f)
		return (t0 < repeat_delay) && (t1 >= repeat_delay);
	const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
	const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
	const int count = count_t1 - count_t0;
	return count;
}

void ImGui::GetTypematicRepeatRate(ImGuiInputFlags flags, float *repeat_delay, float *repeat_rate) {
	ImGuiContext &g = *GImGui;
	switch (flags & ImGuiInputFlags_RepeatRateMask_) {
		case ImGuiInputFlags_RepeatRateNavMove:
			*repeat_delay = g.IO.KeyRepeatDelay * 0.72f;
			*repeat_rate = g.IO.KeyRepeatRate * 0.80f;
			return;
		case ImGuiInputFlags_RepeatRateNavTweak:
			*repeat_delay = g.IO.KeyRepeatDelay * 0.72f;
			*repeat_rate = g.IO.KeyRepeatRate * 0.30f;
			return;
		case ImGuiInputFlags_RepeatRateDefault:
		default:
			*repeat_delay = g.IO.KeyRepeatDelay * 1.00f;
			*repeat_rate = g.IO.KeyRepeatRate * 1.00f;
			return;
	}
}

// Return value representing the number of presses in the last time period, for the given repeat rate
// (most often returns 0 or 1. The result is generally only >1 when RepeatRate is smaller than DeltaTime, aka large DeltaTime or fast RepeatRate)
int ImGui::GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float repeat_rate) {
	ImGuiContext &g = *GImGui;
	const ImGuiKeyData *key_data = GetKeyData(key);
	if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
		return 0;
	const float t = key_data->DownDuration;
	return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
}

// Return 2D vector representing the combination of four cardinal direction, with analog value support (for e.g. ImGuiKey_GamepadLStick* values).
ImVec2 ImGui::GetKeyMagnitude2d(ImGuiKey key_left, ImGuiKey key_right, ImGuiKey key_up, ImGuiKey key_down) {
	return ImVec2(
			GetKeyData(key_right)->AnalogValue - GetKeyData(key_left)->AnalogValue,
			GetKeyData(key_down)->AnalogValue - GetKeyData(key_up)->AnalogValue);
}

// Rewrite routing data buffers to strip old entries + sort by key to make queries not touch scattered data.
//   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D
//   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6
// See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that operation.
static void ImGui::UpdateKeyRoutingTable(ImGuiKeyRoutingTable *rt) {
	ImGuiContext &g = *GImGui;
	rt->EntriesNext.resize(0);
	for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1)) {
		const int new_routing_start_idx = rt->EntriesNext.Size;
		ImGuiKeyRoutingData *routing_entry;
		for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex) {
			routing_entry = &rt->Entries[old_routing_idx];
			routing_entry->RoutingCurrScore = routing_entry->RoutingNextScore;
			routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
			routing_entry->RoutingNext = ImGuiKeyOwner_NoOwner;
			routing_entry->RoutingNextScore = 255;
			if (routing_entry->RoutingCurr == ImGuiKeyOwner_NoOwner)
				continue;
			rt->EntriesNext.push_back(*routing_entry); // Write alive ones into new buffer

			// Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
			// This is the result of previous frame's SetShortcutRouting() call.
			if (routing_entry->Mods == g.IO.KeyMods) {
				ImGuiKeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
				if (owner_data->OwnerCurr == ImGuiKeyOwner_NoOwner) {
					owner_data->OwnerCurr = routing_entry->RoutingCurr;
					//IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X) via Routing\n", GetKeyName(key), routing_entry->RoutingCurr);
				}
			}
		}

		// Rewrite linked-list
		rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
		for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
			rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
	}
	rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
}

// owner_id may be None/Any, but routing_id needs to be always be set, so we default to GetCurrentFocusScope().
static inline ImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id) {
	ImGuiContext &g = *GImGui;
	return (owner_id != ImGuiKeyOwner_NoOwner && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId;
}

ImGuiKeyRoutingData *ImGui::GetShortcutRoutingData(ImGuiKeyChord key_chord) {
	// Majority of shortcuts will be Key + any number of Mods
	// We accept _Single_ mod with ImGuiKey_None.
	//  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl);                    // Legal
	//  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl | ImGuiMod_Shift);   // Legal
	//  - Shortcut(ImGuiMod_Ctrl);                                 // Legal
	//  - Shortcut(ImGuiMod_Ctrl | ImGuiMod_Shift);                // Not legal
	ImGuiContext &g = *GImGui;
	ImGuiKeyRoutingTable *rt = &g.KeysRoutingTable;
	ImGuiKeyRoutingData *routing_data;
	ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
	ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
	if (key == ImGuiKey_None)
		key = ConvertSingleModFlagToKey(mods);
	IM_ASSERT(IsNamedKey(key));

	// Get (in the majority of case, the linked list will have one element so this should be 2 reads.
	// Subsequent elements will be contiguous in memory as list is sorted/rebuilt in NewFrame).
	for (ImGuiKeyRoutingIndex idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; idx != -1; idx = routing_data->NextEntryIndex) {
		routing_data = &rt->Entries[idx];
		if (routing_data->Mods == mods)
			return routing_data;
	}

	// Add to linked-list
	ImGuiKeyRoutingIndex routing_data_idx = (ImGuiKeyRoutingIndex)rt->Entries.Size;
	rt->Entries.push_back(ImGuiKeyRoutingData());
	routing_data = &rt->Entries[routing_data_idx];
	routing_data->Mods = (ImU16)mods;
	routing_data->NextEntryIndex = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; // Setup linked list
	rt->Index[key - ImGuiKey_NamedKey_BEGIN] = routing_data_idx;
	return routing_data;
}

// Current score encoding (lower is highest priority):
//  -   0: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverActive
//  -   1: ImGuiInputFlags_ActiveItem or ImGuiInputFlags_RouteFocused (if item active)
//  -   2: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused
//  -  3+: ImGuiInputFlags_RouteFocused (if window in focus-stack)
//  - 254: ImGuiInputFlags_RouteGlobal
//  - 255: never route
// 'flags' should include an explicit routing policy
static int CalcRoutingScore(ImGuiID focus_scope_id, ImGuiID owner_id, ImGuiInputFlags flags) {
	ImGuiContext &g = *GImGui;
	if (flags & ImGuiInputFlags_RouteFocused) {
		// ActiveID gets top priority
		// (we don't check g.ActiveIdUsingAllKeys here. Routing is applied but if input ownership is tested later it may discard it)
		if (owner_id != 0 && g.ActiveId == owner_id)
			return 1;

		// Score based on distance to focused window (lower is better)
		// Assuming both windows are submitting a routing request,
		// - When Window....... is focused -> Window scores 3 (best), Window/ChildB scores 255 (no match)
		// - When Window/ChildB is focused -> Window scores 4,        Window/ChildB scores 3 (best)
		// Assuming only WindowA is submitting a routing request,
		// - When Window/ChildB is focused -> Window scores 4 (best), Window/ChildB doesn't have a score.
		// This essentially follow the window->ParentWindowForFocusRoute chain.
		if (focus_scope_id == 0)
			return 255;
		for (int index_in_focus_path = 0; index_in_focus_path < g.NavFocusRoute.Size; index_in_focus_path++)
			if (g.NavFocusRoute.Data[index_in_focus_path].ID == focus_scope_id)
				return 3 + index_in_focus_path;
		return 255;
	} else if (flags & ImGuiInputFlags_RouteActive) {
		if (owner_id != 0 && g.ActiveId == owner_id)
			return 1;
		return 255;
	} else if (flags & ImGuiInputFlags_RouteGlobal) {
		if (flags & ImGuiInputFlags_RouteOverActive)
			return 0;
		if (flags & ImGuiInputFlags_RouteOverFocused)
			return 2;
		return 254;
	}
	IM_ASSERT(0);
	return 0;
}

// - We need this to filter some Shortcut() routes when an item e.g. an InputText() is active
//   e.g. ImGuiKey_G won't be considered a shortcut when item is active, but ImGuiMod|ImGuiKey_G can be.
// - This is also used by UpdateInputEvents() to avoid trickling in the most common case of e.g. pressing ImGuiKey_G also emitting a G character.
static bool IsKeyChordPotentiallyCharInput(ImGuiKeyChord key_chord) {
	// Mimic 'ignore_char_inputs' logic in InputText()
	ImGuiContext &g = *GImGui;

	// When the right mods are pressed it cannot be a char input so we won't filter the shortcut out.
	ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
	const bool ignore_char_inputs = ((mods & ImGuiMod_Ctrl) && !(mods & ImGuiMod_Alt)) || (g.IO.ConfigMacOSXBehaviors && (mods & ImGuiMod_Ctrl));
	if (ignore_char_inputs)
		return false;

	// Return true for A-Z, 0-9 and other keys associated to char inputs. Other keys such as F1-F12 won't be filtered.
	ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
	if (key == ImGuiKey_None)
		return false;
	return g.KeysMayBeCharInput.TestBit(key);
}

// Request a desired route for an input chord (key + mods).
// Return true if the route is available this frame.
// - Routes and key ownership are attributed at the beginning of next frame based on best score and mod state.
//   (Conceptually this does a "Submit for next frame" + "Test for current frame".
//   As such, it could be called TrySetXXX or SubmitXXX, or the Submit and Test operations should be separate.)
bool ImGui::SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id) {
	ImGuiContext &g = *GImGui;
	if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0)
		flags |= ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
	else
		IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteTypeMask_)); // Check that only 1 routing flag is used
	IM_ASSERT(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_NoOwner);
	if (flags & (ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused))
		IM_ASSERT(flags & ImGuiInputFlags_RouteGlobal);

	// Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
	key_chord = FixupKeyChord(key_chord);

	// [DEBUG] Debug break requested by user
	if (g.DebugBreakInShortcutRouting == key_chord)
		IM_DEBUG_BREAK();

	if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
		if (g.NavWindow == NULL)
			return false;

	// Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?
	if (flags & ImGuiInputFlags_RouteAlways) {
		IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> always, no register\n", GetKeyChordName(key_chord), flags, owner_id);
		return true;
	}

	// Specific culling when there's an active item.
	if (g.ActiveId != 0 && g.ActiveId != owner_id) {
		if (flags & ImGuiInputFlags_RouteActive)
			return false;

		// Cull shortcuts with no modifiers when it could generate a character.
		// e.g. Shortcut(ImGuiKey_G) also generates 'g' character, should not trigger when InputText() is active.
		// but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.
		// TL;DR: lettered shortcut with no mods or with only Alt mod will not trigger while an item reading text input is active.
		// (We cannot filter based on io.InputQueueCharacters[] contents because of trickling and key<>chars submission order are undefined)
		if (g.IO.WantTextInput && IsKeyChordPotentiallyCharInput(key_chord)) {
			IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> filtered as potential char input\n", GetKeyChordName(key_chord), flags, owner_id);
			return false;
		}

		// ActiveIdUsingAllKeyboardKeys trumps all for ActiveId
		if ((flags & ImGuiInputFlags_RouteOverActive) == 0 && g.ActiveIdUsingAllKeyboardKeys) {
			ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
			if (key == ImGuiKey_None)
				key = ConvertSingleModFlagToKey((ImGuiKey)(key_chord & ImGuiMod_Mask_));
			if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
				return false;
		}
	}

	// Where do we evaluate route for?
	ImGuiID focus_scope_id = g.CurrentFocusScopeId;
	if (flags & ImGuiInputFlags_RouteFromRootWindow)
		focus_scope_id = g.CurrentWindow->RootWindow->ID; // See PushFocusScope() call in Begin()

	const int score = CalcRoutingScore(focus_scope_id, owner_id, flags);
	IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> score %d\n", GetKeyChordName(key_chord), flags, owner_id, score);
	if (score == 255)
		return false;

	// Submit routing for NEXT frame (assuming score is sufficient)
	// FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
	ImGuiKeyRoutingData *routing_data = GetShortcutRoutingData(key_chord);
	//const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
	if (score < routing_data->RoutingNextScore) {
		routing_data->RoutingNext = owner_id;
		routing_data->RoutingNextScore = (ImU8)score;
	}

	// Return routing state for CURRENT frame
	if (routing_data->RoutingCurr == owner_id)
		IMGUI_DEBUG_LOG_INPUTROUTING("--> granting current route\n");
	return routing_data->RoutingCurr == owner_id;
}

// Currently unused by core (but used by tests)
// Note: this cannot be turned into GetShortcutRouting() because we do the owner_id->routing_id translation, name would be more misleading.
bool ImGui::TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id) {
	const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);
	key_chord = FixupKeyChord(key_chord);
	ImGuiKeyRoutingData *routing_data = GetShortcutRoutingData(key_chord); // FIXME: Could avoid creating entry.
	return routing_data->RoutingCurr == routing_id;
}

// Note that Dear ImGui doesn't know the meaning/semantic of ImGuiKey from 0..511: they are legacy native keycodes.
// Consider transitioning from 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(ImGuiKey_A) (>= 1.87)
bool ImGui::IsKeyDown(ImGuiKey key) {
	return IsKeyDown(key, ImGuiKeyOwner_Any);
}

bool ImGui::IsKeyDown(ImGuiKey key, ImGuiID owner_id) {
	const ImGuiKeyData *key_data = GetKeyData(key);
	if (!key_data->Down)
		return false;
	if (!TestKeyOwner(key, owner_id))
		return false;
	return true;
}

bool ImGui::IsKeyPressed(ImGuiKey key, bool repeat) {
	return IsKeyPressed(key, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);
}

// Important: unless legacy IsKeyPressed(ImGuiKey, bool repeat=true) which DEFAULT to repeat, this requires EXPLICIT repeat.
bool ImGui::IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id) {
	const ImGuiKeyData *key_data = GetKeyData(key);
	if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
		return false;
	const float t = key_data->DownDuration;
	if (t < 0.0f)
		return false;
	IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
	if (flags & (ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_)) // Setting any _RepeatXXX option enables _Repeat
		flags |= ImGuiInputFlags_Repeat;

	bool pressed = (t == 0.0f);
	if (!pressed && (flags & ImGuiInputFlags_Repeat) != 0) {
		float repeat_delay, repeat_rate;
		GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
		pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
		if (pressed && (flags & ImGuiInputFlags_RepeatUntilMask_)) {
			// Slightly bias 'key_pressed_time' as DownDuration is an accumulation of DeltaTime which we compare to an absolute time value.
			// Ideally we'd replace DownDuration with KeyPressedTime but it would break user's code.
			ImGuiContext &g = *GImGui;
			double key_pressed_time = g.Time - t + 0.00001f;
			if ((flags & ImGuiInputFlags_RepeatUntilKeyModsChange) && (g.LastKeyModsChangeTime > key_pressed_time))
				pressed = false;
			if ((flags & ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone) && (g.LastKeyModsChangeFromNoneTime > key_pressed_time))
				pressed = false;
			if ((flags & ImGuiInputFlags_RepeatUntilOtherKeyPress) && (g.LastKeyboardKeyPressTime > key_pressed_time))
				pressed = false;
		}
	}
	if (!pressed)
		return false;
	if (!TestKeyOwner(key, owner_id))
		return false;
	return true;
}

bool ImGui::IsKeyReleased(ImGuiKey key) {
	return IsKeyReleased(key, ImGuiKeyOwner_Any);
}

bool ImGui::IsKeyReleased(ImGuiKey key, ImGuiID owner_id) {
	const ImGuiKeyData *key_data = GetKeyData(key);
	if (key_data->DownDurationPrev < 0.0f || key_data->Down)
		return false;
	if (!TestKeyOwner(key, owner_id))
		return false;
	return true;
}

bool ImGui::IsMouseDown(ImGuiMouseButton button) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // should be same as IsKeyDown(MouseButtonToKey(button), ImGuiKeyOwner_Any), but this allows legacy code hijacking the io.Mousedown[] array.
}

bool ImGui::IsMouseDown(ImGuiMouseButton button, ImGuiID owner_id) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.
}

bool ImGui::IsMouseClicked(ImGuiMouseButton button, bool repeat) {
	return IsMouseClicked(button, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);
}

bool ImGui::IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
		return false;
	const float t = g.IO.MouseDownDuration[button];
	if (t < 0.0f)
		return false;
	IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsMouseClicked) == 0); // Passing flags not supported by this function! // FIXME: Could support RepeatRate and RepeatUntil flags here.

	const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
	const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);
	if (!pressed)
		return false;

	if (!TestKeyOwner(MouseButtonToKey(button), owner_id))
		return false;

	return true;
}

bool ImGui::IsMouseReleased(ImGuiMouseButton button) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // Should be same as IsKeyReleased(MouseButtonToKey(button), ImGuiKeyOwner_Any)
}

bool ImGui::IsMouseReleased(ImGuiMouseButton button, ImGuiID owner_id) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)
}

bool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any);
}

bool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button, ImGuiID owner_id) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), owner_id);
}

int ImGui::GetMouseClickedCount(ImGuiMouseButton button) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseClickedCount[button];
}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool ImGui::IsMouseHoveringRect(const ImVec2 &r_min, const ImVec2 &r_max, bool clip) {
	ImGuiContext &g = *GImGui;

	// Clip
	ImRect rect_clipped(r_min, r_max);
	if (clip)
		rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

	// Hit testing, expanded for touch input
	if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))
		return false;
	return true;
}

// Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.
// [Internal] This doesn't test if the button is pressed
bool ImGui::IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	if (lock_threshold < 0.0f)
		lock_threshold = g.IO.MouseDragThreshold;
	return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

bool ImGui::IsMouseDragging(ImGuiMouseButton button, float lock_threshold) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	if (!g.IO.MouseDown[button])
		return false;
	return IsMouseDragPastThreshold(button, lock_threshold);
}

ImVec2 ImGui::GetMousePos() {
	ImGuiContext &g = *GImGui;
	return g.IO.MousePos;
}

// This is called TeleportMousePos() and not SetMousePos() to emphasis that setting MousePosPrev will effectively clear mouse delta as well.
// It is expected you only call this if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos) is set and supported by backend.
void ImGui::TeleportMousePos(const ImVec2 &pos) {
	ImGuiContext &g = *GImGui;
	g.IO.MousePos = g.IO.MousePosPrev = pos;
	g.IO.MouseDelta = ImVec2(0.0f, 0.0f);
	g.IO.WantSetMousePos = true;
	//IMGUI_DEBUG_LOG_IO("TeleportMousePos: (%.1f,%.1f)\n", io.MousePos.x, io.MousePos.y);
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup() {
	ImGuiContext &g = *GImGui;
	if (g.BeginPopupStack.Size > 0)
		return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;
	return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
bool ImGui::IsMousePosValid(const ImVec2 *mouse_pos) {
	// The assert is only to silence a false-positive in XCode Static Analysis.
	// Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
	IM_ASSERT(GImGui != NULL);
	const float MOUSE_INVALID = -256000.0f;
	ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
	return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}

// [WILL OBSOLETE] This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
bool ImGui::IsAnyMouseDown() {
	ImGuiContext &g = *GImGui;
	for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
		if (g.IO.MouseDown[n])
			return true;
	return false;
}

// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.
ImVec2 ImGui::GetMouseDragDelta(ImGuiMouseButton button, float lock_threshold) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	if (lock_threshold < 0.0f)
		lock_threshold = g.IO.MouseDragThreshold;
	if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])
		if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
			if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]))
				return g.IO.MousePos - g.IO.MouseClickedPos[button];
	return ImVec2(0.0f, 0.0f);
}

void ImGui::ResetMouseDragDelta(ImGuiMouseButton button) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	// NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
	g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

// Get desired mouse cursor shape.
// Important: this is meant to be used by a platform backend, it is reset in ImGui::NewFrame(),
// updated during the frame, and locked in EndFrame()/Render().
// If you use software rendering by setting io.MouseDrawCursor then Dear ImGui will render those for you
ImGuiMouseCursor ImGui::GetMouseCursor() {
	ImGuiContext &g = *GImGui;
	return g.MouseCursor;
}

void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type) {
	ImGuiContext &g = *GImGui;
	g.MouseCursor = cursor_type;
}

static void UpdateAliasKey(ImGuiKey key, bool v, float analog_value) {
	IM_ASSERT(ImGui::IsAliasKey(key));
	ImGuiKeyData *key_data = ImGui::GetKeyData(key);
	key_data->Down = v;
	key_data->AnalogValue = analog_value;
}

// [Internal] Do not use directly
static ImGuiKeyChord GetMergedModsFromKeys() {
	ImGuiKeyChord mods = 0;
	if (ImGui::IsKeyDown(ImGuiMod_Ctrl)) {
		mods |= ImGuiMod_Ctrl;
	}
	if (ImGui::IsKeyDown(ImGuiMod_Shift)) {
		mods |= ImGuiMod_Shift;
	}
	if (ImGui::IsKeyDown(ImGuiMod_Alt)) {
		mods |= ImGuiMod_Alt;
	}
	if (ImGui::IsKeyDown(ImGuiMod_Super)) {
		mods |= ImGuiMod_Super;
	}
	return mods;
}

static void ImGui::UpdateKeyboardInputs() {
	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;

	if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
		io.ClearInputKeys();

	// Import legacy keys or verify they are not used
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
	if (io.BackendUsingLegacyKeyArrays == 0) {
		// Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are never written to externally.
		for (int n = 0; n < ImGuiKey_LegacyNativeKey_END; n++)
			IM_ASSERT((io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
	} else {
		if (g.FrameCount == 0)
			for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
				IM_ASSERT(g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!");

		// Build reverse KeyMap (Named -> Legacy)
		for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
			if (io.KeyMap[n] != -1) {
				IM_ASSERT(IsLegacyKey((ImGuiKey)io.KeyMap[n]));
				io.KeyMap[io.KeyMap[n]] = n;
			}

		// Import legacy keys into new ones
		for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
			if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1) {
				const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
				IM_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
				io.KeysData[key].Down = io.KeysDown[n];
				if (key != n)
					io.KeysDown[key] = io.KeysDown[n]; // Allow legacy code using io.KeysDown[GetKeyIndex()] with old backends
				io.BackendUsingLegacyKeyArrays = 1;
			}
		if (io.BackendUsingLegacyKeyArrays == 1) {
			GetKeyData(ImGuiMod_Ctrl)->Down = io.KeyCtrl;
			GetKeyData(ImGuiMod_Shift)->Down = io.KeyShift;
			GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
			GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
		}
	}
#endif

	// Import legacy ImGuiNavInput_ io inputs and convert to gamepad keys
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
	const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
	if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active) {
#define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)              \
	do {                                                       \
		io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f); \
		io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1];   \
	} while (0)
#define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)                                       \
	do {                                                                                       \
		io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f); \
		io.KeysData[_KEY].AnalogValue = ImMax(io.NavInputs[_NAV1], io.NavInputs[_NAV2]);       \
	} while (0)
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceDown, ImGuiNavInput_Activate);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceRight, ImGuiNavInput_Cancel);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceLeft, ImGuiNavInput_Menu);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceUp, ImGuiNavInput_Input);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadLeft, ImGuiNavInput_DpadLeft);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadRight, ImGuiNavInput_DpadRight);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadUp, ImGuiNavInput_DpadUp);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadDown, ImGuiNavInput_DpadDown);
		MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadL1, ImGuiNavInput_FocusPrev, ImGuiNavInput_TweakSlow);
		MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadR1, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakFast);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickLeft, ImGuiNavInput_LStickLeft);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickRight, ImGuiNavInput_LStickRight);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickUp, ImGuiNavInput_LStickUp);
		MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickDown, ImGuiNavInput_LStickDown);
#undef NAV_MAP_KEY
	}
#endif

	// Update aliases
	for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
		UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
	UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
	UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);

	// Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.
	// - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
	// - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
	// So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
	const ImGuiKeyChord prev_key_mods = io.KeyMods;
	io.KeyMods = GetMergedModsFromKeys();
	io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;
	io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;
	io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;
	io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;
	if (prev_key_mods != io.KeyMods)
		g.LastKeyModsChangeTime = g.Time;
	if (prev_key_mods != io.KeyMods && prev_key_mods == 0)
		g.LastKeyModsChangeFromNoneTime = g.Time;

	// Clear gamepad data if disabled
	if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
		for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++) {
			io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
			io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
		}

	// Update keys
	for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++) {
		ImGuiKeyData *key_data = &io.KeysData[i];
		key_data->DownDurationPrev = key_data->DownDuration;
		key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
		if (key_data->DownDuration == 0.0f) {
			ImGuiKey key = (ImGuiKey)(ImGuiKey_KeysData_OFFSET + i);
			if (IsKeyboardKey(key))
				g.LastKeyboardKeyPressTime = g.Time;
			else if (key == ImGuiKey_ReservedForModCtrl || key == ImGuiKey_ReservedForModShift || key == ImGuiKey_ReservedForModAlt || key == ImGuiKey_ReservedForModSuper)
				g.LastKeyboardKeyPressTime = g.Time;
		}
	}

	// Update keys/input owner (named keys only): one entry per key
	for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1)) {
		ImGuiKeyData *key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
		ImGuiKeyOwnerData *owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
		owner_data->OwnerCurr = owner_data->OwnerNext;
		if (!key_data->Down) // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
			owner_data->OwnerNext = ImGuiKeyOwner_NoOwner;
		owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down; // Clear LockUntilRelease when key is not Down anymore
	}

	// Update key routing (for e.g. shortcuts)
	UpdateKeyRoutingTable(&g.KeysRoutingTable);
}

static void ImGui::UpdateMouseInputs() {
	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;

	// Mouse Wheel swapping flag
	// As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
	// - We avoid doing it on OSX as it the OS input layer handles this already.
	// - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
	// - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
	io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors;

	// Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
	if (IsMousePosValid(&io.MousePos))
		io.MousePos = g.MouseLastValidPos = ImFloor(io.MousePos);

	// If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
	if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
		io.MouseDelta = io.MousePos - io.MousePosPrev;
	else
		io.MouseDelta = ImVec2(0.0f, 0.0f);

	// Update stationary timer.
	// FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
	const float mouse_stationary_threshold = (io.MouseSource == ImGuiMouseSource_Mouse) ? 2.0f : 3.0f; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
	const bool mouse_stationary = (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold);
	g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0f;
	//IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);

	// If mouse moved we re-enable mouse hovering in case it was disabled by gamepad/keyboard. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
	if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
		g.NavDisableMouseHover = false;

	for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) {
		io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
		io.MouseClickedCount[i] = 0; // Will be filled below
		io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
		io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
		io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
		if (io.MouseClicked[i]) {
			bool is_repeated_click = false;
			if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime) {
				ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
				if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
					is_repeated_click = true;
			}
			if (is_repeated_click)
				io.MouseClickedLastCount[i]++;
			else
				io.MouseClickedLastCount[i] = 1;
			io.MouseClickedTime[i] = g.Time;
			io.MouseClickedPos[i] = io.MousePos;
			io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
			io.MouseDragMaxDistanceSqr[i] = 0.0f;
		} else if (io.MouseDown[i]) {
			// Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
			float delta_sqr_click_pos = IsMousePosValid(&io.MousePos) ? ImLengthSqr(io.MousePos - io.MouseClickedPos[i]) : 0.0f;
			io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], delta_sqr_click_pos);
		}

		// We provide io.MouseDoubleClicked[] as a legacy service
		io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);

		// Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
		if (io.MouseClicked[i])
			g.NavDisableMouseHover = false;
	}
}

static void LockWheelingWindow(ImGuiWindow *window, float wheel_amount) {
	ImGuiContext &g = *GImGui;
	if (window)
		g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
	else
		g.WheelingWindowReleaseTimer = 0.0f;
	if (g.WheelingWindow == window)
		return;
	IMGUI_DEBUG_LOG_IO("[io] LockWheelingWindow() \"%s\"\n", window ? window->Name : "NULL");
	g.WheelingWindow = window;
	g.WheelingWindowRefMousePos = g.IO.MousePos;
	if (window == NULL) {
		g.WheelingWindowStartFrame = -1;
		g.WheelingAxisAvg = ImVec2(0.0f, 0.0f);
	}
}

static ImGuiWindow *FindBestWheelingWindow(const ImVec2 &wheel) {
	// For each axis, find window in the hierarchy that may want to use scrolling
	ImGuiContext &g = *GImGui;
	ImGuiWindow *windows[2] = { NULL, NULL };
	for (int axis = 0; axis < 2; axis++)
		if (wheel[axis] != 0.0f)
			for (ImGuiWindow *window = windows[axis] = g.HoveredWindow; window->Flags & ImGuiWindowFlags_ChildWindow; window = windows[axis] = window->ParentWindow) {
				// Bubble up into parent window if:
				// - a child window doesn't allow any scrolling.
				// - a child window has the ImGuiWindowFlags_NoScrollWithMouse flag.
				//// - a child window doesn't need scrolling because it is already at the edge for the direction we are going in (FIXME-WIP)
				const bool has_scrolling = (window->ScrollMax[axis] != 0.0f);
				const bool inputs_disabled = (window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs);
				//const bool scrolling_past_limits = (wheel_v < 0.0f) ? (window->Scroll[axis] <= 0.0f) : (window->Scroll[axis] >= window->ScrollMax[axis]);
				if (has_scrolling && !inputs_disabled) // && !scrolling_past_limits)
					break; // select this window
			}
	if (windows[0] == NULL && windows[1] == NULL)
		return NULL;

	// If there's only one window or only one axis then there's no ambiguity
	if (windows[0] == windows[1] || windows[0] == NULL || windows[1] == NULL)
		return windows[1] ? windows[1] : windows[0];

	// If candidate are different windows we need to decide which one to prioritize
	// - First frame: only find a winner if one axis is zero.
	// - Subsequent frames: only find a winner when one is more than the other.
	if (g.WheelingWindowStartFrame == -1)
		g.WheelingWindowStartFrame = g.FrameCount;
	if ((g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0f && wheel.y != 0.0f) || (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y)) {
		g.WheelingWindowWheelRemainder = wheel;
		return NULL;
	}
	return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
}

// Called by NewFrame()
void ImGui::UpdateMouseWheel() {
	// Reset the locked window if we move the mouse or after the timer elapses.
	// FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
	ImGuiContext &g = *GImGui;
	if (g.WheelingWindow != NULL) {
		g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
		if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
			g.WheelingWindowReleaseTimer = 0.0f;
		if (g.WheelingWindowReleaseTimer <= 0.0f)
			LockWheelingWindow(NULL, 0.0f);
	}

	ImVec2 wheel;
	wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheelH : 0.0f;
	wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheel : 0.0f;

	//IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
	ImGuiWindow *mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
	if (!mouse_window || mouse_window->Collapsed)
		return;

	// Zoom / Scale window
	// FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
	if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling) {
		LockWheelingWindow(mouse_window, wheel.y);
		ImGuiWindow *window = mouse_window;
		const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
		const float scale = new_font_scale / window->FontWindowScale;
		window->FontWindowScale = new_font_scale;
		if (window == window->RootWindow) {
			const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
			SetWindowPos(window, window->Pos + offset, 0);
			window->Size = ImTrunc(window->Size * scale);
			window->SizeFull = ImTrunc(window->SizeFull * scale);
		}
		return;
	}
	if (g.IO.KeyCtrl)
		return;

	// Mouse wheel scrolling
	// Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
	if (g.IO.MouseWheelRequestAxisSwap)
		wheel = ImVec2(wheel.y, 0.0f);

	// Maintain a rough average of moving magnitude on both axises
	// FIXME: should by based on wall clock time rather than frame-counter
	g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
	g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);

	// In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
	wheel += g.WheelingWindowWheelRemainder;
	g.WheelingWindowWheelRemainder = ImVec2(0.0f, 0.0f);
	if (wheel.x == 0.0f && wheel.y == 0.0f)
		return;

	// Mouse wheel scrolling: find target and apply
	// - don't renew lock if axis doesn't apply on the window.
	// - select a main axis when both axises are being moved.
	if (ImGuiWindow *window = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
		if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs)) {
			bool do_scroll[2] = { wheel.x != 0.0f && window->ScrollMax.x != 0.0f, wheel.y != 0.0f && window->ScrollMax.y != 0.0f };
			if (do_scroll[ImGuiAxis_X] && do_scroll[ImGuiAxis_Y])
				do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis_Y : ImGuiAxis_X] = false;
			if (do_scroll[ImGuiAxis_X]) {
				LockWheelingWindow(window, wheel.x);
				float max_step = window->InnerRect.GetWidth() * 0.67f;
				float scroll_step = ImTrunc(ImMin(2 * window->CalcFontSize(), max_step));
				SetScrollX(window, window->Scroll.x - wheel.x * scroll_step);
				g.WheelingWindowScrolledFrame = g.FrameCount;
			}
			if (do_scroll[ImGuiAxis_Y]) {
				LockWheelingWindow(window, wheel.y);
				float max_step = window->InnerRect.GetHeight() * 0.67f;
				float scroll_step = ImTrunc(ImMin(5 * window->CalcFontSize(), max_step));
				SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
				g.WheelingWindowScrolledFrame = g.FrameCount;
			}
		}
}

void ImGui::SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard) {
	ImGuiContext &g = *GImGui;
	g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0;
}

void ImGui::SetNextFrameWantCaptureMouse(bool want_capture_mouse) {
	ImGuiContext &g = *GImGui;
	g.WantCaptureMouseNextFrame = want_capture_mouse ? 1 : 0;
}

#ifndef IMGUI_DISABLE_DEBUG_TOOLS
static const char *GetInputSourceName(ImGuiInputSource source) {
	const char *input_source_names[] = { "None", "Mouse", "Keyboard", "Gamepad" };
	IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT && source >= 0 && source < ImGuiInputSource_COUNT);
	return input_source_names[source];
}
static const char *GetMouseSourceName(ImGuiMouseSource source) {
	const char *mouse_source_names[] = { "Mouse", "TouchScreen", "Pen" };
	IM_ASSERT(IM_ARRAYSIZE(mouse_source_names) == ImGuiMouseSource_COUNT && source >= 0 && source < ImGuiMouseSource_COUNT);
	return mouse_source_names[source];
}
static void DebugPrintInputEvent(const char *prefix, const ImGuiInputEvent *e) {
	ImGuiContext &g = *GImGui;
	if (e->Type == ImGuiInputEventType_MousePos) {
		if (e->MousePos.PosX == -FLT_MAX && e->MousePos.PosY == -FLT_MAX)
			IMGUI_DEBUG_LOG_IO("[io] %s: MousePos (-FLT_MAX, -FLT_MAX)\n", prefix);
		else
			IMGUI_DEBUG_LOG_IO("[io] %s: MousePos (%.1f, %.1f) (%s)\n", prefix, e->MousePos.PosX, e->MousePos.PosY, GetMouseSourceName(e->MousePos.MouseSource));
		return;
	}
	if (e->Type == ImGuiInputEventType_MouseButton) {
		IMGUI_DEBUG_LOG_IO("[io] %s: MouseButton %d %s (%s)\n", prefix, e->MouseButton.Button, e->MouseButton.Down ? "Down" : "Up", GetMouseSourceName(e->MouseButton.MouseSource));
		return;
	}
	if (e->Type == ImGuiInputEventType_MouseWheel) {
		IMGUI_DEBUG_LOG_IO("[io] %s: MouseWheel (%.3f, %.3f) (%s)\n", prefix, e->MouseWheel.WheelX, e->MouseWheel.WheelY, GetMouseSourceName(e->MouseWheel.MouseSource));
		return;
	}
	if (e->Type == ImGuiInputEventType_Key) {
		IMGUI_DEBUG_LOG_IO("[io] %s: Key \"%s\" %s\n", prefix, ImGui::GetKeyName(e->Key.Key), e->Key.Down ? "Down" : "Up");
		return;
	}
	if (e->Type == ImGuiInputEventType_Text) {
		IMGUI_DEBUG_LOG_IO("[io] %s: Text: %c (U+%08X)\n", prefix, e->Text.Char, e->Text.Char);
		return;
	}
	if (e->Type == ImGuiInputEventType_Focus) {
		IMGUI_DEBUG_LOG_IO("[io] %s: AppFocused %d\n", prefix, e->AppFocused.Focused);
		return;
	}
}
#endif

// Process input queue
// We always call this with the value of 'bool g.IO.ConfigInputTrickleEventQueue'.
// - trickle_fast_inputs = false : process all events, turn into flattened input state (e.g. successive down/up/down/up will be lost)
// - trickle_fast_inputs = true  : process as many events as possible (successive down/up/down/up will be trickled over several frames so nothing is lost) (new feature in 1.87)
void ImGui::UpdateInputEvents(bool trickle_fast_inputs) {
	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;

	// Only trickle chars<>key when working with InputText()
	// FIXME: InputText() could parse event trail?
	// FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
	const bool trickle_interleaved_nonchar_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);

	bool mouse_moved = false, mouse_wheeled = false, key_changed = false, key_changed_nonchar = false, text_inputted = false;
	int mouse_button_changed = 0x00;
	ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;

	int event_n = 0;
	for (; event_n < g.InputEventsQueue.Size; event_n++) {
		ImGuiInputEvent *e = &g.InputEventsQueue[event_n];
		if (e->Type == ImGuiInputEventType_MousePos) {
			if (g.IO.WantSetMousePos)
				continue;
			// Trickling Rule: Stop processing queued events if we already handled a mouse button change
			ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
			if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
				break;
			io.MousePos = event_pos;
			io.MouseSource = e->MousePos.MouseSource;
			mouse_moved = true;
		} else if (e->Type == ImGuiInputEventType_MouseButton) {
			// Trickling Rule: Stop processing queued events if we got multiple action on the same button
			const ImGuiMouseButton button = e->MouseButton.Button;
			IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
			if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
				break;
			if (trickle_fast_inputs && e->MouseButton.MouseSource == ImGuiMouseSource_TouchScreen && mouse_moved) // #2702: TouchScreen have no initial hover.
				break;
			io.MouseDown[button] = e->MouseButton.Down;
			io.MouseSource = e->MouseButton.MouseSource;
			mouse_button_changed |= (1 << button);
		} else if (e->Type == ImGuiInputEventType_MouseWheel) {
			// Trickling Rule: Stop processing queued events if we got multiple action on the event
			if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
				break;
			io.MouseWheelH += e->MouseWheel.WheelX;
			io.MouseWheel += e->MouseWheel.WheelY;
			io.MouseSource = e->MouseWheel.MouseSource;
			mouse_wheeled = true;
		} else if (e->Type == ImGuiInputEventType_Key) {
			// Trickling Rule: Stop processing queued events if we got multiple action on the same button
			if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
				continue;
			ImGuiKey key = e->Key.Key;
			IM_ASSERT(key != ImGuiKey_None);
			ImGuiKeyData *key_data = GetKeyData(key);
			const int key_data_index = (int)(key_data - g.IO.KeysData);
			if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || mouse_button_changed != 0))
				break;

			const bool key_is_potentially_for_char_input = IsKeyChordPotentiallyCharInput(GetMergedModsFromKeys() | key);
			if (trickle_interleaved_nonchar_keys_and_text && (text_inputted && !key_is_potentially_for_char_input))
				break;

			key_data->Down = e->Key.Down;
			key_data->AnalogValue = e->Key.AnalogValue;
			key_changed = true;
			key_changed_mask.SetBit(key_data_index);
			if (trickle_interleaved_nonchar_keys_and_text && !key_is_potentially_for_char_input)
				key_changed_nonchar = true;

			// Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
			io.KeysDown[key_data_index] = key_data->Down;
			if (io.KeyMap[key_data_index] != -1)
				io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
#endif
		} else if (e->Type == ImGuiInputEventType_Text) {
			if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
				continue;
			// Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
			if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
				break;
			if (trickle_interleaved_nonchar_keys_and_text && key_changed_nonchar)
				break;
			unsigned int c = e->Text.Char;
			io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
			if (trickle_interleaved_nonchar_keys_and_text)
				text_inputted = true;
		} else if (e->Type == ImGuiInputEventType_Focus) {
			// We intentionally overwrite this and process in NewFrame(), in order to give a chance
			// to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
			const bool focus_lost = !e->AppFocused.Focused;
			io.AppFocusLost = focus_lost;
		} else {
			IM_ASSERT(0 && "Unknown event!");
		}
	}

	// Record trail (for domain-specific applications wanting to access a precise trail)
	//if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
	for (int n = 0; n < event_n; n++)
		g.InputEventsTrail.push_back(g.InputEventsQueue[n]);

	// [DEBUG]
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
		for (int n = 0; n < g.InputEventsQueue.Size; n++)
			DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
#endif

	// Remaining events will be processed on the next frame
	if (event_n == g.InputEventsQueue.Size)
		g.InputEventsQueue.resize(0);
	else
		g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);

	// Clear buttons state when focus is lost
	// - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
	// - we clear in EndFrame() and not now in order allow application/user code polling this flag
	//   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
	if (g.IO.AppFocusLost) {
		g.IO.ClearInputKeys();
		g.IO.ClearInputMouse();
	}
}

ImGuiID ImGui::GetKeyOwner(ImGuiKey key) {
	if (!IsNamedKeyOrMod(key))
		return ImGuiKeyOwner_NoOwner;

	ImGuiContext &g = *GImGui;
	ImGuiKeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
	ImGuiID owner_id = owner_data->OwnerCurr;

	if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
		if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
			return ImGuiKeyOwner_NoOwner;

	return owner_id;
}

// TestKeyOwner(..., ID)   : (owner == None || owner == ID)
// TestKeyOwner(..., None) : (owner == None)
// TestKeyOwner(..., Any)  : no owner test
// All paths are also testing for key not being locked, for the rare cases that key have been locked with using ImGuiInputFlags_LockXXX flags.
bool ImGui::TestKeyOwner(ImGuiKey key, ImGuiID owner_id) {
	if (!IsNamedKeyOrMod(key))
		return true;

	ImGuiContext &g = *GImGui;
	if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
		if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
			return false;

	ImGuiKeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
	if (owner_id == ImGuiKeyOwner_Any)
		return (owner_data->LockThisFrame == false);

	// Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
	// are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
	// Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
	if (owner_data->OwnerCurr != owner_id) {
		if (owner_data->LockThisFrame)
			return false;
		if (owner_data->OwnerCurr != ImGuiKeyOwner_NoOwner)
			return false;
	}

	return true;
}

// _LockXXX flags are useful to lock keys away from code which is not input-owner aware.
// When using _LockXXX flags, you can use ImGuiKeyOwner_Any to lock keys from everyone.
// - SetKeyOwner(..., None)              : clears owner
// - SetKeyOwner(..., Any, !Lock)        : illegal (assert)
// - SetKeyOwner(..., Any or None, Lock) : set lock
void ImGui::SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(IsNamedKeyOrMod(key) && (owner_id != ImGuiKeyOwner_Any || (flags & (ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease)))); // Can only use _Any with _LockXXX flags (to eat a key away without an ID to retrieve it)
	IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetKeyOwner) == 0); // Passing flags not supported by this function!
	//IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X, flags=%08X)\n", GetKeyName(key), owner_id, flags);

	ImGuiKeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
	owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	// We cannot lock by default as it would likely break lots of legacy code.
	// In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
	owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
	owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);
}

// Rarely used helper
void ImGui::SetKeyOwnersForKeyChord(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags) {
	if (key_chord & ImGuiMod_Ctrl) {
		SetKeyOwner(ImGuiMod_Ctrl, owner_id, flags);
	}
	if (key_chord & ImGuiMod_Shift) {
		SetKeyOwner(ImGuiMod_Shift, owner_id, flags);
	}
	if (key_chord & ImGuiMod_Alt) {
		SetKeyOwner(ImGuiMod_Alt, owner_id, flags);
	}
	if (key_chord & ImGuiMod_Super) {
		SetKeyOwner(ImGuiMod_Super, owner_id, flags);
	}
	if (key_chord & ~ImGuiMod_Mask_) {
		SetKeyOwner((ImGuiKey)(key_chord & ~ImGuiMod_Mask_), owner_id, flags);
	}
}

// This is more or less equivalent to:
//   if (IsItemHovered() || IsItemActive())
//       SetKeyOwner(key, GetItemID());
// Extensive uses of that (e.g. many calls for a single item) may want to manually perform the tests once and then call SetKeyOwner() multiple times.
// More advanced usage scenarios may want to call SetKeyOwner() manually based on different condition.
// Worth noting is that only one item can be hovered and only one item can be active, therefore this usage pattern doesn't need to bother with routing and priority.
void ImGui::SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiID id = g.LastItemData.ID;
	if (id == 0 || (g.HoveredId != id && g.ActiveId != id))
		return;
	if ((flags & ImGuiInputFlags_CondMask_) == 0)
		flags |= ImGuiInputFlags_CondDefault_;
	if ((g.HoveredId == id && (flags & ImGuiInputFlags_CondHovered)) || (g.ActiveId == id && (flags & ImGuiInputFlags_CondActive))) {
		IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetItemKeyOwner) == 0); // Passing flags not supported by this function!
		SetKeyOwner(key, id, flags & ~ImGuiInputFlags_CondMask_);
	}
}

void ImGui::SetItemKeyOwner(ImGuiKey key) {
	SetItemKeyOwner(key, ImGuiInputFlags_None);
}

// This is the only public API until we expose owner_id versions of the API as replacements.
bool ImGui::IsKeyChordPressed(ImGuiKeyChord key_chord) {
	return IsKeyChordPressed(key_chord, ImGuiInputFlags_None, ImGuiKeyOwner_Any);
}

// This is equivalent to comparing KeyMods + doing a IsKeyPressed()
bool ImGui::IsKeyChordPressed(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id) {
	ImGuiContext &g = *GImGui;
	key_chord = FixupKeyChord(key_chord);
	ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
	if (g.IO.KeyMods != mods)
		return false;

	// Special storage location for mods
	ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
	if (key == ImGuiKey_None)
		key = ConvertSingleModFlagToKey(mods);
	if (!IsKeyPressed(key, (flags & ImGuiInputFlags_RepeatMask_), owner_id))
		return false;
	return true;
}

void ImGui::SetNextItemShortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags) {
	ImGuiContext &g = *GImGui;
	g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasShortcut;
	g.NextItemData.Shortcut = key_chord;
	g.NextItemData.ShortcutFlags = flags;
}

// Called from within ItemAdd: at this point we can read from NextItemData and write to LastItemData
void ImGui::ItemHandleShortcut(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	ImGuiInputFlags flags = g.NextItemData.ShortcutFlags;
	IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetNextItemShortcut) == 0); // Passing flags not supported by SetNextItemShortcut()!

	if (g.LastItemData.InFlags & ImGuiItemFlags_Disabled)
		return;
	if (flags & ImGuiInputFlags_Tooltip) {
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasShortcut;
		g.LastItemData.Shortcut = g.NextItemData.Shortcut;
	}
	if (!Shortcut(g.NextItemData.Shortcut, flags & ImGuiInputFlags_SupportedByShortcut, id) || g.NavActivateId != 0)
		return;

	// FIXME: Generalize Activation queue?
	g.NavActivateId = id; // Will effectively disable clipping.
	g.NavActivateFlags = ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_FromShortcut;
	//if (g.ActiveId == 0 || g.ActiveId == id)
	g.NavActivateDownId = g.NavActivatePressedId = id;
	NavHighlightActivated(id);
}

bool ImGui::Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags) {
	return Shortcut(key_chord, flags, ImGuiKeyOwner_Any);
}

bool ImGui::Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags, ImGuiID owner_id) {
	ImGuiContext &g = *GImGui;
	//IMGUI_DEBUG_LOG("Shortcut(%s, flags=%X, owner_id=0x%08X)\n", GetKeyChordName(key_chord, g.TempBuffer.Data, g.TempBuffer.Size), flags, owner_id);

	// When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
	if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0)
		flags |= ImGuiInputFlags_RouteFocused;

	// Using 'owner_id == ImGuiKeyOwner_Any/0': auto-assign an owner based on current focus scope (each window has its focus scope by default)
	// Effectively makes Shortcut() always input-owner aware.
	if (owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_NoOwner)
		owner_id = GetRoutingIdFromOwnerId(owner_id);

	if (g.CurrentItemFlags & ImGuiItemFlags_Disabled)
		return false;

	// Submit route
	if (!SetShortcutRouting(key_chord, flags, owner_id))
		return false;

	// Default repeat behavior for Shortcut()
	// So e.g. pressing Ctrl+W and releasing Ctrl while holding W will not trigger the W shortcut.
	if ((flags & ImGuiInputFlags_Repeat) != 0 && (flags & ImGuiInputFlags_RepeatUntilMask_) == 0)
		flags |= ImGuiInputFlags_RepeatUntilKeyModsChange;

	if (!IsKeyChordPressed(key_chord, flags, owner_id))
		return false;

	// Claim mods during the press
	SetKeyOwnersForKeyChord(key_chord & ImGuiMod_Mask_, owner_id);

	IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
	return true;
}

//-----------------------------------------------------------------------------
// [SECTION] ERROR CHECKING
//-----------------------------------------------------------------------------

// Verify ABI compatibility between caller code and compiled version of Dear ImGui. This helps detects some build issues.
// Called by IMGUI_CHECKVERSION().
// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If this triggers you have mismatched headers and compiled code versions.
// - It could be because of a build issue (using new headers with old compiled code)
// - It could be because of mismatched configuration #define, compilation settings, packing pragma etc.
//   THE CONFIGURATION SETTINGS MENTIONED IN imconfig.h MUST BE SET FOR ALL COMPILATION UNITS INVOLVED WITH DEAR IMGUI.
//   Which is why it is required you put them in your imconfig file (and NOT only before including imgui.h).
//   Otherwise it is possible that different compilation units would see different structure layout.
//   If you don't want to modify imconfig.h you can use the IMGUI_USER_CONFIG define to change filename.
bool ImGui::DebugCheckVersionAndDataLayout(const char *version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx) {
	bool error = false;
	if (strcmp(version, IMGUI_VERSION) != 0) {
		error = true;
		IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!");
	}
	if (sz_io != sizeof(ImGuiIO)) {
		error = true;
		IM_ASSERT(sz_io == sizeof(ImGuiIO) && "Mismatched struct layout!");
	}
	if (sz_style != sizeof(ImGuiStyle)) {
		error = true;
		IM_ASSERT(sz_style == sizeof(ImGuiStyle) && "Mismatched struct layout!");
	}
	if (sz_vec2 != sizeof(ImVec2)) {
		error = true;
		IM_ASSERT(sz_vec2 == sizeof(ImVec2) && "Mismatched struct layout!");
	}
	if (sz_vec4 != sizeof(ImVec4)) {
		error = true;
		IM_ASSERT(sz_vec4 == sizeof(ImVec4) && "Mismatched struct layout!");
	}
	if (sz_vert != sizeof(ImDrawVert)) {
		error = true;
		IM_ASSERT(sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!");
	}
	if (sz_idx != sizeof(ImDrawIdx)) {
		error = true;
		IM_ASSERT(sz_idx == sizeof(ImDrawIdx) && "Mismatched struct layout!");
	}
	return !error;
}

// Until 1.89 (IMGUI_VERSION_NUM < 18814) it was legal to use SetCursorPos() to extend the boundary of a parent (e.g. window or table cell)
// This is causing issues and ambiguity and we need to retire that.
// See https://github.com/ocornut/imgui/issues/5548 for more details.
// [Scenario 1]
//  Previously this would make the window content size ~200x200:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + End();  // NOT OK
//  Instead, please submit an item:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + Dummy(ImVec2(0,0)) + End(); // OK
//  Alternative:
//    Begin(...) + Dummy(ImVec2(200,200)) + End(); // OK
// [Scenario 2]
//  For reference this is one of the issue what we aim to fix with this change:
//    BeginGroup() + SomeItem("foobar") + SetCursorScreenPos(GetCursorScreenPos()) + EndGroup()
//  The previous logic made SetCursorScreenPos(GetCursorScreenPos()) have a side-effect! It would erroneously incorporate ItemSpacing.y after the item into content size, making the group taller!
//  While this code is a little twisted, no-one would expect SetXXX(GetXXX()) to have a side-effect. Using vertical alignment patterns could trigger this issue.
void ImGui::ErrorCheckUsingSetCursorPosToExtendParentBoundaries() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(window->DC.IsSetPos);
	window->DC.IsSetPos = false;
#ifdef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	if (window->DC.CursorPos.x <= window->DC.CursorMaxPos.x && window->DC.CursorPos.y <= window->DC.CursorMaxPos.y)
		return;
	if (window->SkipItems)
		return;
	IM_ASSERT(0 && "Code uses SetCursorPos()/SetCursorScreenPos() to extend window/parent boundaries. Please submit an item e.g. Dummy() to validate extent.");
#else
	window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
#endif
}

static void ImGui::ErrorCheckNewFrameSanityChecks() {
	ImGuiContext &g = *GImGui;

	// Check user IM_ASSERT macro
	// (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
	//  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
	//  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
	// #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
	// #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
	if (true)
		IM_ASSERT(1);
	else
		IM_ASSERT(0);

	// Emscripten backends are often imprecise in their submission of DeltaTime. (#6114, #3644)
	// Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
#ifdef __EMSCRIPTEN__
	if (g.IO.DeltaTime <= 0.0f && g.FrameCount > 0)
		g.IO.DeltaTime = 0.00001f;
#endif

	// Check user data
	// (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
	IM_ASSERT(g.Initialized);
	IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0) && "Need a positive DeltaTime!");
	IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
	IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f && "Invalid DisplaySize value!");
	IM_ASSERT(g.IO.Fonts->IsBuilt() && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
	IM_ASSERT(g.Style.CurveTessellationTol > 0.0f && "Invalid style setting!");
	IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0f && "Invalid style setting!");
	IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
	IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
	IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
	IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right);
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
	for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
		IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ImGuiKey_LegacyNativeKey_END && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)");

	// Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
	if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
		IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
#endif

	// Remap legacy clipboard handlers (OBSOLETED in 1.91.1, August 2024)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	if (g.IO.GetClipboardTextFn != NULL && (g.PlatformIO.Platform_GetClipboardTextFn == NULL || g.PlatformIO.Platform_GetClipboardTextFn == Platform_GetClipboardTextFn_DefaultImpl))
		g.PlatformIO.Platform_GetClipboardTextFn = [](ImGuiContext *ctx) { return ctx->IO.GetClipboardTextFn(ctx->IO.ClipboardUserData); };
	if (g.IO.SetClipboardTextFn != NULL && (g.PlatformIO.Platform_SetClipboardTextFn == NULL || g.PlatformIO.Platform_SetClipboardTextFn == Platform_SetClipboardTextFn_DefaultImpl))
		g.PlatformIO.Platform_SetClipboardTextFn = [](ImGuiContext *ctx, const char *text) { return ctx->IO.SetClipboardTextFn(ctx->IO.ClipboardUserData, text); };
#endif
}

static void ImGui::ErrorCheckEndFrameSanityChecks() {
	ImGuiContext &g = *GImGui;

	// Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
	// One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
	// It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
	// send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
	// We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
	// while still correctly asserting on mid-frame key press events.
	const ImGuiKeyChord key_mods = GetMergedModsFromKeys();
	IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
	IM_UNUSED(key_mods);

	// [EXPERIMENTAL] Recover from errors: You may call this yourself before EndFrame().
	//ErrorCheckEndFrameRecover();

	// Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
	// to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
	if (g.CurrentWindowStack.Size != 1) {
		if (g.CurrentWindowStack.Size > 1) {
			ImGuiWindow *window = g.CurrentWindowStack.back().Window; // <-- This window was not Ended!
			IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
			IM_UNUSED(window);
			while (g.CurrentWindowStack.Size > 1)
				End();
		} else {
			IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
		}
	}

	IM_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
}

// Experimental recovery from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX calls.
// Must be called during or before EndFrame().
// This is generally flawed as we are not necessarily End/Popping things in the right order.
// FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
// FIXME: Can't recover from interleaved BeginTabBar/Begin
void ImGui::ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void *user_data) {
	// PVS-Studio V1044 is "Loop break conditions do not depend on the number of iterations"
	ImGuiContext &g = *GImGui;
	while (g.CurrentWindowStack.Size > 0) //-V1044
	{
		ErrorCheckEndWindowRecover(log_callback, user_data);
		ImGuiWindow *window = g.CurrentWindow;
		if (g.CurrentWindowStack.Size == 1) {
			IM_ASSERT(window->IsFallbackWindow);
			break;
		}
		if (window->Flags & ImGuiWindowFlags_ChildWindow) {
			if (log_callback)
				log_callback(user_data, "Recovered from missing EndChild() for '%s'", window->Name);
			EndChild();
		} else {
			if (log_callback)
				log_callback(user_data, "Recovered from missing End() for '%s'", window->Name);
			End();
		}
	}
}

// Must be called before End()/EndChild()
void ImGui::ErrorCheckEndWindowRecover(ImGuiErrorLogCallback log_callback, void *user_data) {
	ImGuiContext &g = *GImGui;
	while (g.CurrentTable && (g.CurrentTable->OuterWindow == g.CurrentWindow || g.CurrentTable->InnerWindow == g.CurrentWindow)) {
		if (log_callback)
			log_callback(user_data, "Recovered from missing EndTable() in '%s'", g.CurrentTable->OuterWindow->Name);
		EndTable();
	}

	ImGuiWindow *window = g.CurrentWindow;
	ImGuiStackSizes *stack_sizes = &g.CurrentWindowStack.back().StackSizesOnBegin;
	IM_ASSERT(window != NULL);
	while (g.CurrentTabBar != NULL) //-V1044
	{
		if (log_callback)
			log_callback(user_data, "Recovered from missing EndTabBar() in '%s'", window->Name);
		EndTabBar();
	}
	while (g.CurrentMultiSelect != NULL && g.CurrentMultiSelect->Storage->Window == window) {
		if (log_callback)
			log_callback(user_data, "Recovered from missing EndMultiSelect() in '%s'", window->Name);
		EndMultiSelect();
	}
	while (window->DC.TreeDepth > 0) {
		if (log_callback)
			log_callback(user_data, "Recovered from missing TreePop() in '%s'", window->Name);
		TreePop();
	}
	while (g.GroupStack.Size > stack_sizes->SizeOfGroupStack) //-V1044
	{
		if (log_callback)
			log_callback(user_data, "Recovered from missing EndGroup() in '%s'", window->Name);
		EndGroup();
	}
	while (window->IDStack.Size > 1) {
		if (log_callback)
			log_callback(user_data, "Recovered from missing PopID() in '%s'", window->Name);
		PopID();
	}
	while (g.DisabledStackSize > stack_sizes->SizeOfDisabledStack) //-V1044
	{
		if (log_callback)
			log_callback(user_data, "Recovered from missing EndDisabled() in '%s'", window->Name);
		if (g.CurrentItemFlags & ImGuiItemFlags_Disabled)
			EndDisabled();
		else {
			EndDisabledOverrideReenable();
			g.CurrentWindowStack.back().DisabledOverrideReenable = false;
		}
	}
	while (g.ColorStack.Size > stack_sizes->SizeOfColorStack) {
		if (log_callback)
			log_callback(user_data, "Recovered from missing PopStyleColor() in '%s' for ImGuiCol_%s", window->Name, GetStyleColorName(g.ColorStack.back().Col));
		PopStyleColor();
	}
	while (g.ItemFlagsStack.Size > stack_sizes->SizeOfItemFlagsStack) //-V1044
	{
		if (log_callback)
			log_callback(user_data, "Recovered from missing PopItemFlag() in '%s'", window->Name);
		PopItemFlag();
	}
	while (g.StyleVarStack.Size > stack_sizes->SizeOfStyleVarStack) //-V1044
	{
		if (log_callback)
			log_callback(user_data, "Recovered from missing PopStyleVar() in '%s'", window->Name);
		PopStyleVar();
	}
	while (g.FontStack.Size > stack_sizes->SizeOfFontStack) //-V1044
	{
		if (log_callback)
			log_callback(user_data, "Recovered from missing PopFont() in '%s'", window->Name);
		PopFont();
	}
	while (g.FocusScopeStack.Size > stack_sizes->SizeOfFocusScopeStack + 1) //-V1044
	{
		if (log_callback)
			log_callback(user_data, "Recovered from missing PopFocusScope() in '%s'", window->Name);
		PopFocusScope();
	}
}

// Save current stack sizes for later compare
void ImGuiStackSizes::SetToContextState(ImGuiContext *ctx) {
	ImGuiContext &g = *ctx;
	ImGuiWindow *window = g.CurrentWindow;
	SizeOfIDStack = (short)window->IDStack.Size;
	SizeOfColorStack = (short)g.ColorStack.Size;
	SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
	SizeOfFontStack = (short)g.FontStack.Size;
	SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
	SizeOfGroupStack = (short)g.GroupStack.Size;
	SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
	SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
	SizeOfDisabledStack = (short)g.DisabledStackSize;
}

// Compare to detect usage errors
void ImGuiStackSizes::CompareWithContextState(ImGuiContext *ctx) {
	ImGuiContext &g = *ctx;
	ImGuiWindow *window = g.CurrentWindow;
	IM_UNUSED(window);

	// Window stacks
	// NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
	IM_ASSERT(SizeOfIDStack == window->IDStack.Size && "PushID/PopID or TreeNode/TreePop Mismatch!");

	// Global stacks
	// For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
	IM_ASSERT(SizeOfGroupStack == g.GroupStack.Size && "BeginGroup/EndGroup Mismatch!");
	IM_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
	IM_ASSERT(SizeOfDisabledStack == g.DisabledStackSize && "BeginDisabled/EndDisabled Mismatch!");
	IM_ASSERT(SizeOfItemFlagsStack >= g.ItemFlagsStack.Size && "PushItemFlag/PopItemFlag Mismatch!");
	IM_ASSERT(SizeOfColorStack >= g.ColorStack.Size && "PushStyleColor/PopStyleColor Mismatch!");
	IM_ASSERT(SizeOfStyleVarStack >= g.StyleVarStack.Size && "PushStyleVar/PopStyleVar Mismatch!");
	IM_ASSERT(SizeOfFontStack >= g.FontStack.Size && "PushFont/PopFont Mismatch!");
	IM_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size && "PushFocusScope/PopFocusScope Mismatch!");
}

//-----------------------------------------------------------------------------
// [SECTION] ITEM SUBMISSION
//-----------------------------------------------------------------------------
// - KeepAliveID()
// - ItemAdd()
//-----------------------------------------------------------------------------

// Code not using ItemAdd() may need to call this manually otherwise ActiveId will be cleared. In IMGUI_VERSION_NUM < 18717 this was called by GetID().
void ImGui::KeepAliveID(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	if (g.ActiveId == id)
		g.ActiveIdIsAlive = id;
	if (g.ActiveIdPreviousFrame == id)
		g.ActiveIdPreviousFrameIsAlive = true;
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
// THIS IS IN THE PERFORMANCE CRITICAL PATH (UNTIL THE CLIPPING TEST AND EARLY-RETURN)
IM_MSVC_RUNTIME_CHECKS_OFF
bool ImGui::ItemAdd(const ImRect &bb, ImGuiID id, const ImRect *nav_bb_arg, ImGuiItemFlags extra_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	// Set item data
	// (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
	g.LastItemData.ID = id;
	g.LastItemData.Rect = bb;
	g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
	g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;
	g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
	// Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.

	if (id != 0) {
		KeepAliveID(id);

		// Directional navigation processing
		// Runs prior to clipping early-out
		//  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
		//  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
		//      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
		//      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
		//      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
		//      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
		// We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
		// If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
		if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav)) {
			// FIMXE-NAV: investigate changing the window tests into a simple 'if (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
			window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
			if (g.NavId == id || g.NavAnyRequest)
				if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
					if (window == g.NavWindow || ((window->ChildFlags | g.NavWindow->ChildFlags) & ImGuiChildFlags_NavFlattened))
						NavProcessItem();
		}

		if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasShortcut)
			ItemHandleShortcut(id);
	}

	// Lightweight clear of SetNextItemXXX data.
	g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
	g.NextItemData.ItemFlags = ImGuiItemFlags_None;

#ifdef IMGUI_ENABLE_TEST_ENGINE
	if (id != 0)
		IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
#endif

	// Clipping test
	// (this is an inline copy of IsClippedEx() so we can reuse the is_rect_visible value, otherwise we'd do 'if (IsClippedEx(bb, id)) return false')
	// g.NavActivateId is not necessarily == g.NavId, in the case of remote activation (e.g. shortcuts)
	const bool is_rect_visible = bb.Overlaps(window->ClipRect);
	if (!is_rect_visible)
		if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId))
			if (!g.ItemUnclipByLog)
				return false;

	// [DEBUG]
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
	if (id != 0) {
		if (id == g.DebugLocateId)
			DebugLocateItemResolveWithLastItem();

		// [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
		// Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
		// READ THE FAQ: https://dearimgui.com/faq
		IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
	}
	//if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
	//if ((g.LastItemData.InFlags & ImGuiItemFlags_NoNav) == 0)
	//    window->DrawList->AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
#endif

	// We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
	if (is_rect_visible)
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
	if (IsMouseHoveringRect(bb.Min, bb.Max))
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
	return true;
}
IM_MSVC_RUNTIME_CHECKS_RESTORE

//-----------------------------------------------------------------------------
// [SECTION] LAYOUT
//-----------------------------------------------------------------------------
// - ItemSize()
// - SameLine()
// - GetCursorScreenPos()
// - SetCursorScreenPos()
// - GetCursorPos(), GetCursorPosX(), GetCursorPosY()
// - SetCursorPos(), SetCursorPosX(), SetCursorPosY()
// - GetCursorStartPos()
// - Indent()
// - Unindent()
// - SetNextItemWidth()
// - PushItemWidth()
// - PushMultiItemsWidths()
// - PopItemWidth()
// - CalcItemWidth()
// - CalcItemSize()
// - GetTextLineHeight()
// - GetTextLineHeightWithSpacing()
// - GetFrameHeight()
// - GetFrameHeightWithSpacing()
// - GetContentRegionMax()
// - GetContentRegionAvail(),
// - BeginGroup()
// - EndGroup()
// Also see in imgui_widgets: tab bars, and in imgui_tables: tables, columns.
//-----------------------------------------------------------------------------

// Advance cursor given item size for layout.
// Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
// See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
// THIS IS IN THE PERFORMANCE CRITICAL PATH.
IM_MSVC_RUNTIME_CHECKS_OFF
void ImGui::ItemSize(const ImVec2 &size, float text_baseline_y) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return;

	// We increase the height in this function to accommodate for baseline offset.
	// In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
	// but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
	const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;

	const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
	const float line_height = ImMax(window->DC.CurrLineSize.y, /*ImMax(*/ window->DC.CursorPos.y - line_y1 /*, 0.0f)*/ + size.y + offset_to_match_baseline_y);

	// Always align ourselves on pixel boundaries
	//if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
	window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
	window->DC.CursorPosPrevLine.y = line_y1;
	window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x); // Next line
	window->DC.CursorPos.y = IM_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y); // Next line
	window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
	window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
	//if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

	window->DC.PrevLineSize.y = line_height;
	window->DC.CurrLineSize.y = 0.0f;
	window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
	window->DC.CurrLineTextBaseOffset = 0.0f;
	window->DC.IsSameLine = window->DC.IsSetPos = false;

	// Horizontal layout mode
	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
		SameLine();
}
IM_MSVC_RUNTIME_CHECKS_RESTORE

// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
//      spacing_w < 0            : use default spacing if offset_from_start_x == 0, no spacing if offset_from_start_x != 0
//      spacing_w >= 0           : enforce spacing amount
void ImGui::SameLine(float offset_from_start_x, float spacing_w) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return;

	if (offset_from_start_x != 0.0f) {
		if (spacing_w < 0.0f)
			spacing_w = 0.0f;
		window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
		window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
	} else {
		if (spacing_w < 0.0f)
			spacing_w = g.Style.ItemSpacing.x;
		window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
		window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
	}
	window->DC.CurrLineSize = window->DC.PrevLineSize;
	window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
	window->DC.IsSameLine = true;
}

ImVec2 ImGui::GetCursorScreenPos() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->DC.CursorPos;
}

void ImGui::SetCursorScreenPos(const ImVec2 &pos) {
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.CursorPos = pos;
	//window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
	window->DC.IsSetPos = true;
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
ImVec2 ImGui::GetCursorPos() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos(const ImVec2 &local_pos) {
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
	//window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
	window->DC.IsSetPos = true;
}

void ImGui::SetCursorPosX(float x) {
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
	//window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
	window->DC.IsSetPos = true;
}

void ImGui::SetCursorPosY(float y) {
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
	//window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
	window->DC.IsSetPos = true;
}

ImVec2 ImGui::GetCursorStartPos() {
	ImGuiWindow *window = GetCurrentWindowRead();
	return window->DC.CursorStartPos - window->Pos;
}

void ImGui::Indent(float indent_w) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
	window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::Unindent(float indent_w) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
	window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

// Affect large frame+labels widgets only.
void ImGui::SetNextItemWidth(float item_width) {
	ImGuiContext &g = *GImGui;
	g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;
	g.NextItemData.Width = item_width;
}

// FIXME: Remove the == 0.0f behavior?
void ImGui::PushItemWidth(float item_width) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	window->DC.ItemWidthStack.push_back(window->DC.ItemWidth); // Backup current width
	window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
	g.NextItemData.Flags &= ~ImGuiNextItemDataFlags_HasWidth;
}

void ImGui::PushMultiItemsWidths(int components, float w_full) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(components > 0);
	const ImGuiStyle &style = g.Style;
	window->DC.ItemWidthStack.push_back(window->DC.ItemWidth); // Backup current width
	float w_items = w_full - style.ItemInnerSpacing.x * (components - 1);
	float prev_split = w_items;
	for (int i = components - 1; i > 0; i--) {
		float next_split = IM_TRUNC(w_items * i / components);
		window->DC.ItemWidthStack.push_back(ImMax(prev_split - next_split, 1.0f));
		prev_split = next_split;
	}
	window->DC.ItemWidth = ImMax(prev_split, 1.0f);
	g.NextItemData.Flags &= ~ImGuiNextItemDataFlags_HasWidth;
}

void ImGui::PopItemWidth() {
	ImGuiWindow *window = GetCurrentWindow();
	window->DC.ItemWidth = window->DC.ItemWidthStack.back();
	window->DC.ItemWidthStack.pop_back();
}

// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth().
// The SetNextItemWidth() data is generally cleared/consumed by ItemAdd() or NextItemData.ClearFlags()
float ImGui::CalcItemWidth() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	float w;
	if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasWidth)
		w = g.NextItemData.Width;
	else
		w = window->DC.ItemWidth;
	if (w < 0.0f) {
		float region_avail_x = GetContentRegionAvail().x;
		w = ImMax(1.0f, region_avail_x + w);
	}
	w = IM_TRUNC(w);
	return w;
}

// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == CalcItemWidth().
// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
// Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_w, float default_h) {
	ImVec2 avail;
	if (size.x < 0.0f || size.y < 0.0f)
		avail = GetContentRegionAvail();

	if (size.x == 0.0f)
		size.x = default_w;
	else if (size.x < 0.0f)
		size.x = ImMax(4.0f, avail.x + size.x); // <-- size.x is negative here so we are subtracting

	if (size.y == 0.0f)
		size.y = default_h;
	else if (size.y < 0.0f)
		size.y = ImMax(4.0f, avail.y + size.y); // <-- size.y is negative here so we are subtracting

	return size;
}

float ImGui::GetTextLineHeight() {
	ImGuiContext &g = *GImGui;
	return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing() {
	ImGuiContext &g = *GImGui;
	return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight() {
	ImGuiContext &g = *GImGui;
	return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing() {
	ImGuiContext &g = *GImGui;
	return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

ImVec2 ImGui::GetContentRegionAvail() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;
	return mx - window->DC.CursorPos;
}

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS

// You should never need those functions. Always use GetCursorScreenPos() and GetContentRegionAvail()!
// They are bizarre local-coordinates which don't play well with scrolling.
ImVec2 ImGui::GetContentRegionMax() {
	return GetContentRegionAvail() + GetCursorScreenPos() - GetWindowPos();
}

ImVec2 ImGui::GetWindowContentRegionMin() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->ContentRegionRect.Min - window->Pos;
}

ImVec2 ImGui::GetWindowContentRegionMax() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->ContentRegionRect.Max - window->Pos;
}
#endif

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
// Groups are currently a mishmash of functionalities which should perhaps be clarified and separated.
// FIXME-OPT: Could we safely early out on ->SkipItems?
void ImGui::BeginGroup() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	g.GroupStack.resize(g.GroupStack.Size + 1);
	ImGuiGroupData &group_data = g.GroupStack.back();
	group_data.WindowID = window->ID;
	group_data.BackupCursorPos = window->DC.CursorPos;
	group_data.BackupCursorPosPrevLine = window->DC.CursorPosPrevLine;
	group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
	group_data.BackupIndent = window->DC.Indent;
	group_data.BackupGroupOffset = window->DC.GroupOffset;
	group_data.BackupCurrLineSize = window->DC.CurrLineSize;
	group_data.BackupCurrLineTextBaseOffset = window->DC.CurrLineTextBaseOffset;
	group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
	group_data.BackupHoveredIdIsAlive = g.HoveredId != 0;
	group_data.BackupIsSameLine = window->DC.IsSameLine;
	group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
	group_data.EmitItem = true;

	window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
	window->DC.Indent = window->DC.GroupOffset;
	window->DC.CursorMaxPos = window->DC.CursorPos;
	window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
	if (g.LogEnabled)
		g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
}

void ImGui::EndGroup() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(g.GroupStack.Size > 0); // Mismatched BeginGroup()/EndGroup() calls

	ImGuiGroupData &group_data = g.GroupStack.back();
	IM_ASSERT(group_data.WindowID == window->ID); // EndGroup() in wrong window?

	if (window->DC.IsSetPos)
		ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

	// Include LastItemData.Rect.Max as a workaround for e.g. EndTable() undershooting with CursorMaxPos report. (#7543)
	ImRect group_bb(group_data.BackupCursorPos, ImMax(ImMax(window->DC.CursorMaxPos, g.LastItemData.Rect.Max), group_data.BackupCursorPos));
	window->DC.CursorPos = group_data.BackupCursorPos;
	window->DC.CursorPosPrevLine = group_data.BackupCursorPosPrevLine;
	window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, group_bb.Max);
	window->DC.Indent = group_data.BackupIndent;
	window->DC.GroupOffset = group_data.BackupGroupOffset;
	window->DC.CurrLineSize = group_data.BackupCurrLineSize;
	window->DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
	window->DC.IsSameLine = group_data.BackupIsSameLine;
	if (g.LogEnabled)
		g.LogLinePosY = -FLT_MAX; // To enforce a carriage return

	if (!group_data.EmitItem) {
		g.GroupStack.pop_back();
		return;
	}

	window->DC.CurrLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset); // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
	ItemSize(group_bb.GetSize());
	ItemAdd(group_bb, 0, NULL, ImGuiItemFlags_NoTabStop);

	// If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
	// It would be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
	// Also if you grep for LastItemId you'll notice it is only used in that context.
	// (The two tests not the same because ActiveIdIsAlive is an ID itself, in order to be able to handle ActiveId being overwritten during the frame.)
	const bool group_contains_curr_active_id = (group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId;
	const bool group_contains_prev_active_id = (group_data.BackupActiveIdPreviousFrameIsAlive == false) && (g.ActiveIdPreviousFrameIsAlive == true);
	if (group_contains_curr_active_id)
		g.LastItemData.ID = g.ActiveId;
	else if (group_contains_prev_active_id)
		g.LastItemData.ID = g.ActiveIdPreviousFrame;
	g.LastItemData.Rect = group_bb;

	// Forward Hovered flag
	const bool group_contains_curr_hovered_id = (group_data.BackupHoveredIdIsAlive == false) && g.HoveredId != 0;
	if (group_contains_curr_hovered_id)
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;

	// Forward Edited flag
	if (group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame)
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	// Forward Deactivated flag
	g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDeactivated;
	if (group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame)
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Deactivated;

	g.GroupStack.pop_back();
	if (g.DebugShowGroupRects)
		window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255, 0, 255, 255)); // [Debug]
}

//-----------------------------------------------------------------------------
// [SECTION] SCROLLING
//-----------------------------------------------------------------------------

// Helper to snap on edges when aiming at an item very close to the edge,
// So the difference between WindowPadding and ItemSpacing will be in the visible area after scrolling.
// When we refactor the scrolling API this may be configurable with a flag?
// Note that the effect for this won't be visible on X axis with default Style settings as WindowPadding.x == ItemSpacing.x by default.
static float CalcScrollEdgeSnap(float target, float snap_min, float snap_max, float snap_threshold, float center_ratio) {
	if (target <= snap_min + snap_threshold)
		return ImLerp(snap_min, target, center_ratio);
	if (target >= snap_max - snap_threshold)
		return ImLerp(target, snap_max, center_ratio);
	return target;
}

static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow *window) {
	ImVec2 scroll = window->Scroll;
	ImVec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 + window->DecoOuterSizeX2, window->DecoOuterSizeY1 + window->DecoInnerSizeY1 + window->DecoOuterSizeY2);
	for (int axis = 0; axis < 2; axis++) {
		if (window->ScrollTarget[axis] < FLT_MAX) {
			float center_ratio = window->ScrollTargetCenterRatio[axis];
			float scroll_target = window->ScrollTarget[axis];
			if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f) {
				float snap_min = 0.0f;
				float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] - decoration_size[axis];
				scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window->ScrollTargetEdgeSnapDist[axis], center_ratio);
			}
			scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] - decoration_size[axis]);
		}
		scroll[axis] = IM_ROUND(ImMax(scroll[axis], 0.0f));
		if (!window->Collapsed && !window->SkipItems)
			scroll[axis] = ImMin(scroll[axis], window->ScrollMax[axis]);
	}
	return scroll;
}

void ImGui::ScrollToItem(ImGuiScrollFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ScrollToRectEx(window, g.LastItemData.NavRect, flags);
}

void ImGui::ScrollToRect(ImGuiWindow *window, const ImRect &item_rect, ImGuiScrollFlags flags) {
	ScrollToRectEx(window, item_rect, flags);
}

// Scroll to keep newly navigated item fully into view
ImVec2 ImGui::ScrollToRectEx(ImGuiWindow *window, const ImRect &item_rect, ImGuiScrollFlags flags) {
	ImGuiContext &g = *GImGui;
	ImRect scroll_rect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1));
	scroll_rect.Min.x = ImMin(scroll_rect.Min.x + window->DecoInnerSizeX1, scroll_rect.Max.x);
	scroll_rect.Min.y = ImMin(scroll_rect.Min.y + window->DecoInnerSizeY1, scroll_rect.Max.y);
	//GetForegroundDrawList(window)->AddRect(item_rect.Min, item_rect.Max, IM_COL32(255,0,0,255), 0.0f, 0, 5.0f); // [DEBUG]
	//GetForegroundDrawList(window)->AddRect(scroll_rect.Min, scroll_rect.Max, IM_COL32_WHITE); // [DEBUG]

	// Check that only one behavior is selected per axis
	IM_ASSERT((flags & ImGuiScrollFlags_MaskX_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskX_));
	IM_ASSERT((flags & ImGuiScrollFlags_MaskY_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskY_));

	// Defaults
	ImGuiScrollFlags in_flags = flags;
	if ((flags & ImGuiScrollFlags_MaskX_) == 0 && window->ScrollbarX)
		flags |= ImGuiScrollFlags_KeepVisibleEdgeX;
	if ((flags & ImGuiScrollFlags_MaskY_) == 0)
		flags |= window->Appearing ? ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeY;

	const bool fully_visible_x = item_rect.Min.x >= scroll_rect.Min.x && item_rect.Max.x <= scroll_rect.Max.x;
	const bool fully_visible_y = item_rect.Min.y >= scroll_rect.Min.y && item_rect.Max.y <= scroll_rect.Max.y;
	const bool can_be_fully_visible_x = (item_rect.GetWidth() + g.Style.ItemSpacing.x * 2.0f) <= scroll_rect.GetWidth() || (window->AutoFitFramesX > 0) || (window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0;
	const bool can_be_fully_visible_y = (item_rect.GetHeight() + g.Style.ItemSpacing.y * 2.0f) <= scroll_rect.GetHeight() || (window->AutoFitFramesY > 0) || (window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0;

	if ((flags & ImGuiScrollFlags_KeepVisibleEdgeX) && !fully_visible_x) {
		if (item_rect.Min.x < scroll_rect.Min.x || !can_be_fully_visible_x)
			SetScrollFromPosX(window, item_rect.Min.x - g.Style.ItemSpacing.x - window->Pos.x, 0.0f);
		else if (item_rect.Max.x >= scroll_rect.Max.x)
			SetScrollFromPosX(window, item_rect.Max.x + g.Style.ItemSpacing.x - window->Pos.x, 1.0f);
	} else if (((flags & ImGuiScrollFlags_KeepVisibleCenterX) && !fully_visible_x) || (flags & ImGuiScrollFlags_AlwaysCenterX)) {
		if (can_be_fully_visible_x)
			SetScrollFromPosX(window, ImTrunc((item_rect.Min.x + item_rect.Max.x) * 0.5f) - window->Pos.x, 0.5f);
		else
			SetScrollFromPosX(window, item_rect.Min.x - window->Pos.x, 0.0f);
	}

	if ((flags & ImGuiScrollFlags_KeepVisibleEdgeY) && !fully_visible_y) {
		if (item_rect.Min.y < scroll_rect.Min.y || !can_be_fully_visible_y)
			SetScrollFromPosY(window, item_rect.Min.y - g.Style.ItemSpacing.y - window->Pos.y, 0.0f);
		else if (item_rect.Max.y >= scroll_rect.Max.y)
			SetScrollFromPosY(window, item_rect.Max.y + g.Style.ItemSpacing.y - window->Pos.y, 1.0f);
	} else if (((flags & ImGuiScrollFlags_KeepVisibleCenterY) && !fully_visible_y) || (flags & ImGuiScrollFlags_AlwaysCenterY)) {
		if (can_be_fully_visible_y)
			SetScrollFromPosY(window, ImTrunc((item_rect.Min.y + item_rect.Max.y) * 0.5f) - window->Pos.y, 0.5f);
		else
			SetScrollFromPosY(window, item_rect.Min.y - window->Pos.y, 0.0f);
	}

	ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
	ImVec2 delta_scroll = next_scroll - window->Scroll;

	// Also scroll parent window to keep us into view if necessary
	if (!(flags & ImGuiScrollFlags_NoScrollParent) && (window->Flags & ImGuiWindowFlags_ChildWindow)) {
		// FIXME-SCROLL: May be an option?
		if ((in_flags & (ImGuiScrollFlags_AlwaysCenterX | ImGuiScrollFlags_KeepVisibleCenterX)) != 0)
			in_flags = (in_flags & ~ImGuiScrollFlags_MaskX_) | ImGuiScrollFlags_KeepVisibleEdgeX;
		if ((in_flags & (ImGuiScrollFlags_AlwaysCenterY | ImGuiScrollFlags_KeepVisibleCenterY)) != 0)
			in_flags = (in_flags & ~ImGuiScrollFlags_MaskY_) | ImGuiScrollFlags_KeepVisibleEdgeY;
		delta_scroll += ScrollToRectEx(window->ParentWindow, ImRect(item_rect.Min - delta_scroll, item_rect.Max - delta_scroll), in_flags);
	}

	return delta_scroll;
}

float ImGui::GetScrollX() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->Scroll.x;
}

float ImGui::GetScrollY() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->Scroll.y;
}

float ImGui::GetScrollMaxX() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->ScrollMax.x;
}

float ImGui::GetScrollMaxY() {
	ImGuiWindow *window = GImGui->CurrentWindow;
	return window->ScrollMax.y;
}

void ImGui::SetScrollX(ImGuiWindow *window, float scroll_x) {
	window->ScrollTarget.x = scroll_x;
	window->ScrollTargetCenterRatio.x = 0.0f;
	window->ScrollTargetEdgeSnapDist.x = 0.0f;
}

void ImGui::SetScrollY(ImGuiWindow *window, float scroll_y) {
	window->ScrollTarget.y = scroll_y;
	window->ScrollTargetCenterRatio.y = 0.0f;
	window->ScrollTargetEdgeSnapDist.y = 0.0f;
}

void ImGui::SetScrollX(float scroll_x) {
	ImGuiContext &g = *GImGui;
	SetScrollX(g.CurrentWindow, scroll_x);
}

void ImGui::SetScrollY(float scroll_y) {
	ImGuiContext &g = *GImGui;
	SetScrollY(g.CurrentWindow, scroll_y);
}

// Note that a local position will vary depending on initial scroll value,
// This is a little bit confusing so bear with us:
//  - local_pos = (absolution_pos - window->Pos)
//  - So local_x/local_y are 0.0f for a position at the upper-left corner of a window,
//    and generally local_x/local_y are >(padding+decoration) && <(size-padding-decoration) when in the visible area.
//  - They mostly exist because of legacy API.
// Following the rules above, when trying to work with scrolling code, consider that:
//  - SetScrollFromPosY(0.0f) == SetScrollY(0.0f + scroll.y) == has no effect!
//  - SetScrollFromPosY(-scroll.y) == SetScrollY(-scroll.y + scroll.y) == SetScrollY(0.0f) == reset scroll. Of course writing SetScrollY(0.0f) directly then makes more sense
// We store a target position so centering and clamping can occur on the next frame when we are guaranteed to have a known window size
void ImGui::SetScrollFromPosX(ImGuiWindow *window, float local_x, float center_x_ratio) {
	IM_ASSERT(center_x_ratio >= 0.0f && center_x_ratio <= 1.0f);
	window->ScrollTarget.x = IM_TRUNC(local_x - window->DecoOuterSizeX1 - window->DecoInnerSizeX1 + window->Scroll.x); // Convert local position to scroll offset
	window->ScrollTargetCenterRatio.x = center_x_ratio;
	window->ScrollTargetEdgeSnapDist.x = 0.0f;
}

void ImGui::SetScrollFromPosY(ImGuiWindow *window, float local_y, float center_y_ratio) {
	IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
	window->ScrollTarget.y = IM_TRUNC(local_y - window->DecoOuterSizeY1 - window->DecoInnerSizeY1 + window->Scroll.y); // Convert local position to scroll offset
	window->ScrollTargetCenterRatio.y = center_y_ratio;
	window->ScrollTargetEdgeSnapDist.y = 0.0f;
}

void ImGui::SetScrollFromPosX(float local_x, float center_x_ratio) {
	ImGuiContext &g = *GImGui;
	SetScrollFromPosX(g.CurrentWindow, local_x, center_x_ratio);
}

void ImGui::SetScrollFromPosY(float local_y, float center_y_ratio) {
	ImGuiContext &g = *GImGui;
	SetScrollFromPosY(g.CurrentWindow, local_y, center_y_ratio);
}

// center_x_ratio: 0.0f left of last item, 0.5f horizontal center of last item, 1.0f right of last item.
void ImGui::SetScrollHereX(float center_x_ratio) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	float spacing_x = ImMax(window->WindowPadding.x, g.Style.ItemSpacing.x);
	float target_pos_x = ImLerp(g.LastItemData.Rect.Min.x - spacing_x, g.LastItemData.Rect.Max.x + spacing_x, center_x_ratio);
	SetScrollFromPosX(window, target_pos_x - window->Pos.x, center_x_ratio); // Convert from absolute to local pos

	// Tweak: snap on edges when aiming at an item very close to the edge
	window->ScrollTargetEdgeSnapDist.x = ImMax(0.0f, window->WindowPadding.x - spacing_x);
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void ImGui::SetScrollHereY(float center_y_ratio) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	float spacing_y = ImMax(window->WindowPadding.y, g.Style.ItemSpacing.y);
	float target_pos_y = ImLerp(window->DC.CursorPosPrevLine.y - spacing_y, window->DC.CursorPosPrevLine.y + window->DC.PrevLineSize.y + spacing_y, center_y_ratio);
	SetScrollFromPosY(window, target_pos_y - window->Pos.y, center_y_ratio); // Convert from absolute to local pos

	// Tweak: snap on edges when aiming at an item very close to the edge
	window->ScrollTargetEdgeSnapDist.y = ImMax(0.0f, window->WindowPadding.y - spacing_y);
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

bool ImGui::BeginTooltip() {
	return BeginTooltipEx(ImGuiTooltipFlags_None, ImGuiWindowFlags_None);
}

bool ImGui::BeginItemTooltip() {
	if (!IsItemHovered(ImGuiHoveredFlags_ForTooltip))
		return false;
	return BeginTooltipEx(ImGuiTooltipFlags_None, ImGuiWindowFlags_None);
}

bool ImGui::BeginTooltipEx(ImGuiTooltipFlags tooltip_flags, ImGuiWindowFlags extra_window_flags) {
	ImGuiContext &g = *GImGui;

	if (g.DragDropWithinSource || g.DragDropWithinTarget) {
		// Drag and Drop tooltips are positioning differently than other tooltips:
		// - offset visibility to increase visibility around mouse.
		// - never clamp within outer viewport boundary.
		// We call SetNextWindowPos() to enforce position and disable clamping.
		// See FindBestWindowPosForPopup() for positionning logic of other tooltips (not drag and drop ones).
		//ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
		ImVec2 tooltip_pos = g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET * g.Style.MouseCursorScale;
		if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) == 0)
			SetNextWindowPos(tooltip_pos);
		SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);
		//PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
		tooltip_flags |= ImGuiTooltipFlags_OverridePrevious;
	}

	char window_name[16];
	ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);
	if (tooltip_flags & ImGuiTooltipFlags_OverridePrevious)
		if (ImGuiWindow *window = FindWindowByName(window_name))
			if (window->Active) {
				// Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
				SetWindowHiddenAndSkipItemsForCurrentFrame(window);
				ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);
			}
	ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize;
	Begin(window_name, NULL, flags | extra_window_flags);
	// 2023-03-09: Added bool return value to the API, but currently always returning true.
	// If this ever returns false we need to update BeginDragDropSource() accordingly.
	//if (!ret)
	//    End();
	//return ret;
	return true;
}

void ImGui::EndTooltip() {
	IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip); // Mismatched BeginTooltip()/EndTooltip() calls
	End();
}

void ImGui::SetTooltip(const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	SetTooltipV(fmt, args);
	va_end(args);
}

void ImGui::SetTooltipV(const char *fmt, va_list args) {
	if (!BeginTooltipEx(ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_None))
		return;
	TextV(fmt, args);
	EndTooltip();
}

// Shortcut to use 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav'.
// Defaults to == ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort when using the mouse.
void ImGui::SetItemTooltip(const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	if (IsItemHovered(ImGuiHoveredFlags_ForTooltip))
		SetTooltipV(fmt, args);
	va_end(args);
}

void ImGui::SetItemTooltipV(const char *fmt, va_list args) {
	if (IsItemHovered(ImGuiHoveredFlags_ForTooltip))
		SetTooltipV(fmt, args);
}

//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

// Supported flags: ImGuiPopupFlags_AnyPopupId, ImGuiPopupFlags_AnyPopupLevel
bool ImGui::IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags) {
	ImGuiContext &g = *GImGui;
	if (popup_flags & ImGuiPopupFlags_AnyPopupId) {
		// Return true if any popup is open at the current BeginPopup() level of the popup stack
		// This may be used to e.g. test for another popups already opened to handle popups priorities at the same level.
		IM_ASSERT(id == 0);
		if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
			return g.OpenPopupStack.Size > 0;
		else
			return g.OpenPopupStack.Size > g.BeginPopupStack.Size;
	} else {
		if (popup_flags & ImGuiPopupFlags_AnyPopupLevel) {
			// Return true if the popup is open anywhere in the popup stack
			for (int n = 0; n < g.OpenPopupStack.Size; n++)
				if (g.OpenPopupStack[n].PopupId == id)
					return true;
			return false;
		} else {
			// Return true if the popup is open at the current BeginPopup() level of the popup stack (this is the most-common query)
			return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
		}
	}
}

bool ImGui::IsPopupOpen(const char *str_id, ImGuiPopupFlags popup_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiID id = (popup_flags & ImGuiPopupFlags_AnyPopupId) ? 0 : g.CurrentWindow->GetID(str_id);
	if ((popup_flags & ImGuiPopupFlags_AnyPopupLevel) && id != 0)
		IM_ASSERT(0 && "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel."); // But non-string version is legal and used internally
	return IsPopupOpen(id, popup_flags);
}

// Also see FindBlockingModal(NULL)
ImGuiWindow *ImGui::GetTopMostPopupModal() {
	ImGuiContext &g = *GImGui;
	for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
		if (ImGuiWindow *popup = g.OpenPopupStack.Data[n].Window)
			if (popup->Flags & ImGuiWindowFlags_Modal)
				return popup;
	return NULL;
}

// See Demo->Stacked Modal to confirm what this is for.
ImGuiWindow *ImGui::GetTopMostAndVisiblePopupModal() {
	ImGuiContext &g = *GImGui;
	for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
		if (ImGuiWindow *popup = g.OpenPopupStack.Data[n].Window)
			if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
				return popup;
	return NULL;
}

void ImGui::OpenPopup(const char *str_id, ImGuiPopupFlags popup_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiID id = g.CurrentWindow->GetID(str_id);
	IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopup(\"%s\" -> 0x%08X)\n", str_id, id);
	OpenPopupEx(id, popup_flags);
}

void ImGui::OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags) {
	OpenPopupEx(id, popup_flags);
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
void ImGui::OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *parent_window = g.CurrentWindow;
	const int current_stack_size = g.BeginPopupStack.Size;

	if (popup_flags & ImGuiPopupFlags_NoOpenOverExistingPopup)
		if (IsPopupOpen((ImGuiID)0, ImGuiPopupFlags_AnyPopupId))
			return;

	ImGuiPopupData popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
	popup_ref.PopupId = id;
	popup_ref.Window = NULL;
	popup_ref.RestoreNavWindow = g.NavWindow; // When popup closes focus may be restored to NavWindow (depend on window type).
	popup_ref.OpenFrameCount = g.FrameCount;
	popup_ref.OpenParentId = parent_window->IDStack.back();
	popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
	popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

	IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopupEx(0x%08X)\n", id);
	if (g.OpenPopupStack.Size < current_stack_size + 1) {
		g.OpenPopupStack.push_back(popup_ref);
	} else {
		// Gently handle the user mistakenly calling OpenPopup() every frames: it is likely a programming mistake!
		// However, if we were to run the regular code path, the ui would become completely unusable because the popup will always be
		// in hidden-while-calculating-size state _while_ claiming focus. Which is extremely confusing situation for the programmer.
		// Instead, for successive frames calls to OpenPopup(), we silently avoid reopening even if ImGuiPopupFlags_NoReopen is not specified.
		bool keep_existing = false;
		if (g.OpenPopupStack[current_stack_size].PopupId == id)
			if ((g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1) || (popup_flags & ImGuiPopupFlags_NoReopen))
				keep_existing = true;
		if (keep_existing) {
			// No reopen
			g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
		} else {
			// Reopen: close child popups if any, then flag popup for open/reopen (set position, focus, init navigation)
			ClosePopupToLevel(current_stack_size, true);
			g.OpenPopupStack.push_back(popup_ref);
		}

		// When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
		// This is equivalent to what ClosePopupToLevel() does.
		//if (g.OpenPopupStack[current_stack_size].PopupId == id)
		//    FocusWindow(parent_window);
	}
}

// When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
// This function closes any popups that are over 'ref_window'.
void ImGui::ClosePopupsOverWindow(ImGuiWindow *ref_window, bool restore_focus_to_window_under_popup) {
	ImGuiContext &g = *GImGui;
	if (g.OpenPopupStack.Size == 0)
		return;

	// Don't close our own child popup windows.
	//IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\") restore_under=%d\n", ref_window ? ref_window->Name : "<NULL>", restore_focus_to_window_under_popup);
	int popup_count_to_keep = 0;
	if (ref_window) {
		// Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
		for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++) {
			ImGuiPopupData &popup = g.OpenPopupStack[popup_count_to_keep];
			if (!popup.Window)
				continue;
			IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);

			// Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
			// - Clicking/Focusing Window2 won't close Popup1:
			//     Window -> Popup1 -> Window2(Ref)
			// - Clicking/focusing Popup1 will close Popup2 and Popup3:
			//     Window -> Popup1(Ref) -> Popup2 -> Popup3
			// - Each popups may contain child windows, which is why we compare ->RootWindow!
			//     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
			// We step through every popup from bottom to top to validate their position relative to reference window.
			bool ref_window_is_descendent_of_popup = false;
			for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
				if (ImGuiWindow *popup_window = g.OpenPopupStack[n].Window)
					if (IsWindowWithinBeginStackOf(ref_window, popup_window)) {
						ref_window_is_descendent_of_popup = true;
						break;
					}
			if (!ref_window_is_descendent_of_popup)
				break;
		}
	}
	if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
	{
		IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>");
		ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
	}
}

void ImGui::ClosePopupsExceptModals() {
	ImGuiContext &g = *GImGui;

	int popup_count_to_keep;
	for (popup_count_to_keep = g.OpenPopupStack.Size; popup_count_to_keep > 0; popup_count_to_keep--) {
		ImGuiWindow *window = g.OpenPopupStack[popup_count_to_keep - 1].Window;
		if (!window || (window->Flags & ImGuiWindowFlags_Modal))
			break;
	}
	if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
		ClosePopupToLevel(popup_count_to_keep, true);
}

void ImGui::ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup) {
	ImGuiContext &g = *GImGui;
	IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupToLevel(%d), restore_under=%d\n", remaining, restore_focus_to_window_under_popup);
	IM_ASSERT(remaining >= 0 && remaining < g.OpenPopupStack.Size);
	if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup)
		for (int n = remaining; n < g.OpenPopupStack.Size; n++)
			IMGUI_DEBUG_LOG_POPUP("[popup] - Closing PopupID 0x%08X Window \"%s\"\n", g.OpenPopupStack[n].PopupId, g.OpenPopupStack[n].Window ? g.OpenPopupStack[n].Window->Name : NULL);

	// Trim open popup stack
	ImGuiPopupData prev_popup = g.OpenPopupStack[remaining];
	g.OpenPopupStack.resize(remaining);

	// Restore focus (unless popup window was not yet submitted, and didn't have a chance to take focus anyhow. See #7325 for an edge case)
	if (restore_focus_to_window_under_popup && prev_popup.Window) {
		ImGuiWindow *popup_window = prev_popup.Window;
		ImGuiWindow *focus_window = (popup_window->Flags & ImGuiWindowFlags_ChildMenu) ? popup_window->ParentWindow : prev_popup.RestoreNavWindow;
		if (focus_window && !focus_window->WasActive)
			FocusTopMostWindowUnderOne(popup_window, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild); // Fallback
		else
			FocusWindow(focus_window, (g.NavLayer == ImGuiNavLayer_Main) ? ImGuiFocusRequestFlags_RestoreFocusedChild : ImGuiFocusRequestFlags_None);
	}
}

// Close the popup we have begin-ed into.
void ImGui::CloseCurrentPopup() {
	ImGuiContext &g = *GImGui;
	int popup_idx = g.BeginPopupStack.Size - 1;
	if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
		return;

	// Closing a menu closes its top-most parent popup (unless a modal)
	while (popup_idx > 0) {
		ImGuiWindow *popup_window = g.OpenPopupStack[popup_idx].Window;
		ImGuiWindow *parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
		bool close_parent = false;
		if (popup_window && (popup_window->Flags & ImGuiWindowFlags_ChildMenu))
			if (parent_popup_window && !(parent_popup_window->Flags & ImGuiWindowFlags_MenuBar))
				close_parent = true;
		if (!close_parent)
			break;
		popup_idx--;
	}
	IMGUI_DEBUG_LOG_POPUP("[popup] CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);
	ClosePopupToLevel(popup_idx, true);

	// A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
	// To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
	// Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
	if (ImGuiWindow *window = g.NavWindow)
		window->DC.NavHideHighlightOneFrame = true;
}

// Attention! BeginPopup() adds default flags when calling BeginPopupEx()!
bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_window_flags) {
	ImGuiContext &g = *GImGui;
	if (!IsPopupOpen(id, ImGuiPopupFlags_None)) {
		g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
		return false;
	}

	char name[20];
	if (extra_window_flags & ImGuiWindowFlags_ChildMenu)
		ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginMenuDepth); // Recycle windows based on depth
	else
		ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame

	bool is_open = Begin(name, NULL, extra_window_flags | ImGuiWindowFlags_Popup);
	if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
		EndPopup();

	//g.CurrentWindow->FocusRouteParentWindow = g.CurrentWindow->ParentWindowInBeginStack;

	return is_open;
}

bool ImGui::BeginPopup(const char *str_id, ImGuiWindowFlags flags) {
	ImGuiContext &g = *GImGui;
	if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance
	{
		g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
		return false;
	}
	flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
	ImGuiID id = g.CurrentWindow->GetID(str_id);
	return BeginPopupEx(id, flags);
}

// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by Dear ImGui (and manipulated with e.g. OpenPopup).
// - *p_open set back to false in BeginPopupModal() when popup is not open.
// - if you set *p_open to false before calling BeginPopupModal(), it will close the popup.
bool ImGui::BeginPopupModal(const char *name, bool *p_open, ImGuiWindowFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	const ImGuiID id = window->GetID(name);
	if (!IsPopupOpen(id, ImGuiPopupFlags_None)) {
		g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
		if (p_open && *p_open)
			*p_open = false;
		return false;
	}

	// Center modal windows by default for increased visibility
	// (this won't really last as settings will kick in, and is mostly for backward compatibility. user may do the same themselves)
	// FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
	if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) == 0) {
		const ImGuiViewport *viewport = GetMainViewport();
		SetNextWindowPos(viewport->GetCenter(), ImGuiCond_FirstUseEver, ImVec2(0.5f, 0.5f));
	}

	flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse;
	const bool is_open = Begin(name, p_open, flags);
	if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
	{
		EndPopup();
		if (is_open)
			ClosePopupToLevel(g.BeginPopupStack.Size, true);
		return false;
	}
	return is_open;
}

void ImGui::EndPopup() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(window->Flags & ImGuiWindowFlags_Popup); // Mismatched BeginPopup()/EndPopup() calls
	IM_ASSERT(g.BeginPopupStack.Size > 0);

	// Make all menus and popups wrap around for now, may need to expose that policy (e.g. focus scope could include wrap/loop policy flags used by new move requests)
	if (g.NavWindow == window)
		NavMoveRequestTryWrapping(window, ImGuiNavMoveFlags_LoopY);

	// Child-popups don't need to be laid out
	IM_ASSERT(g.WithinEndChild == false);
	if (window->Flags & ImGuiWindowFlags_ChildWindow)
		g.WithinEndChild = true;
	End();
	g.WithinEndChild = false;
}

// Helper to open a popup if mouse button is released over the item
// - This is essentially the same as BeginPopupContextItem() but without the trailing BeginPopup()
void ImGui::OpenPopupOnItemClick(const char *str_id, ImGuiPopupFlags popup_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
	if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup)) {
		ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
		IM_ASSERT(id != 0); // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
		OpenPopupEx(id, popup_flags);
	}
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// - To create a popup associated to the last item, you generally want to pass a NULL value to str_id.
// - To create a popup with a specific identifier, pass it in str_id.
//    - This is useful when using using BeginPopupContextItem() on an item which doesn't have an identifier, e.g. a Text() call.
//    - This is useful when multiple code locations may want to manipulate/open the same popup, given an explicit id.
// - You may want to handle the whole on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
//   This is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       OpenPopupOnItemClick(str_id, ImGuiPopupFlags_MouseButtonRight);
//       return BeginPopup(id);
//   Which is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
//           OpenPopup(id);
//       return BeginPopup(id);
//   The main difference being that this is tweaked to avoid computing the ID twice.
bool ImGui::BeginPopupContextItem(const char *str_id, ImGuiPopupFlags popup_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (window->SkipItems)
		return false;
	ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
	IM_ASSERT(id != 0); // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
	int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
	if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
		OpenPopupEx(id, popup_flags);
	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextWindow(const char *str_id, ImGuiPopupFlags popup_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (!str_id)
		str_id = "window_context";
	ImGuiID id = window->GetID(str_id);
	int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
	if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
		if (!(popup_flags & ImGuiPopupFlags_NoOpenOverItems) || !IsAnyItemHovered())
			OpenPopupEx(id, popup_flags);
	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextVoid(const char *str_id, ImGuiPopupFlags popup_flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (!str_id)
		str_id = "void_context";
	ImGuiID id = window->GetID(str_id);
	int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
	if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
		if (GetTopMostPopupModal() == NULL)
			OpenPopupEx(id, popup_flags);
	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
// (r_outer is usually equivalent to the viewport rectangle minus padding, but when multi-viewports are enabled and monitor
//  information are available, it may represent the entire platform monitor from the frame of reference of the current viewport.
//  this allows us to have tooltips/popups displayed out of the parent viewport.)
ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2 &ref_pos, const ImVec2 &size, ImGuiDir *last_dir, const ImRect &r_outer, const ImRect &r_avoid, ImGuiPopupPositionPolicy policy) {
	ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
	//GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
	//GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

	// Combo Box policy (we want a connecting edge)
	if (policy == ImGuiPopupPositionPolicy_ComboBox) {
		const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
		for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++) {
			const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
			if (n != -1 && dir == *last_dir) // Already tried this direction?
				continue;
			ImVec2 pos;
			if (dir == ImGuiDir_Down)
				pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y); // Below, Toward Right (default)
			if (dir == ImGuiDir_Right)
				pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
			if (dir == ImGuiDir_Left)
				pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
			if (dir == ImGuiDir_Up)
				pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
			if (!r_outer.Contains(ImRect(pos, pos + size)))
				continue;
			*last_dir = dir;
			return pos;
		}
	}

	// Tooltip and Default popup policy
	// (Always first try the direction we used on the last frame, if any)
	if (policy == ImGuiPopupPositionPolicy_Tooltip || policy == ImGuiPopupPositionPolicy_Default) {
		const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
		for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++) {
			const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
			if (n != -1 && dir == *last_dir) // Already tried this direction?
				continue;

			const float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
			const float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);

			// If there's not enough room on one axis, there's no point in positioning on a side on this axis (e.g. when not enough width, use a top/bottom position to maximize available width)
			if (avail_w < size.x && (dir == ImGuiDir_Left || dir == ImGuiDir_Right))
				continue;
			if (avail_h < size.y && (dir == ImGuiDir_Up || dir == ImGuiDir_Down))
				continue;

			ImVec2 pos;
			pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x
																							  : base_pos_clamped.x;
			pos.y = (dir == ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down) ? r_avoid.Max.y
																						   : base_pos_clamped.y;

			// Clamp top-left corner of popup
			pos.x = ImMax(pos.x, r_outer.Min.x);
			pos.y = ImMax(pos.y, r_outer.Min.y);

			*last_dir = dir;
			return pos;
		}
	}

	// Fallback when not enough room:
	*last_dir = ImGuiDir_None;

	// For tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
	if (policy == ImGuiPopupPositionPolicy_Tooltip)
		return ref_pos + ImVec2(2, 2);

	// Otherwise try to keep within display
	ImVec2 pos = ref_pos;
	pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
	pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
	return pos;
}

// Note that this is used for popups, which can overlap the non work-area of individual viewports.
ImRect ImGui::GetPopupAllowedExtentRect(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	IM_UNUSED(window);
	ImRect r_screen = ((ImGuiViewportP *)(void *)GetMainViewport())->GetMainRect();
	ImVec2 padding = g.Style.DisplaySafeAreaPadding;
	r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
	return r_screen;
}

ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;

	ImRect r_outer = GetPopupAllowedExtentRect(window);
	if (window->Flags & ImGuiWindowFlags_ChildMenu) {
		// Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
		// This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
		IM_ASSERT(g.CurrentWindow == window);
		ImGuiWindow *parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2].Window;
		float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
		ImRect r_avoid;
		if (parent_window->DC.MenuBarAppending)
			r_avoid = ImRect(-FLT_MAX, parent_window->ClipRect.Min.y, FLT_MAX, parent_window->ClipRect.Max.y); // Avoid parent menu-bar. If we wanted multi-line menu-bar, we may instead want to have the calling window setup e.g. a NextWindowData.PosConstraintAvoidRect field
		else
			r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
		return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Default);
	}
	if (window->Flags & ImGuiWindowFlags_Popup) {
		return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, ImRect(window->Pos, window->Pos), ImGuiPopupPositionPolicy_Default); // Ideally we'd disable r_avoid here
	}
	if (window->Flags & ImGuiWindowFlags_Tooltip) {
		// Position tooltip (always follows mouse + clamp within outer boundaries)
		// Note that drag and drop tooltips are NOT using this path: BeginTooltipEx() manually sets their position.
		// In theory we could handle both cases in same location, but requires a bit of shuffling as drag and drop tooltips are calling SetWindowPos() leading to 'window_pos_set_by_api' being set in Begin()
		IM_ASSERT(g.CurrentWindow == window);
		const float scale = g.Style.MouseCursorScale;
		const ImVec2 ref_pos = NavCalcPreferredRefPos();
		const ImVec2 tooltip_pos = ref_pos + TOOLTIP_DEFAULT_OFFSET * scale;
		ImRect r_avoid;
		if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
			r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
		else
			r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * scale, ref_pos.y + 24 * scale); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
		//GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255, 0, 255, 255));
		return FindBestWindowPosForPopupEx(tooltip_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Tooltip);
	}
	IM_ASSERT(0);
	return window->Pos;
}

//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

// FIXME-NAV: The existence of SetNavID vs SetFocusID vs FocusWindow() needs to be clarified/reworked.
// In our terminology those should be interchangeable, yet right now this is super confusing.
// Those two functions are merely a legacy artifact, so at minimum naming should be clarified.

void ImGui::SetNavWindow(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	if (g.NavWindow != window) {
		IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>");
		g.NavWindow = window;
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
	}
	g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
	NavUpdateAnyRequestFlag();
}

void ImGui::NavHighlightActivated(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	g.NavHighlightActivatedId = id;
	g.NavHighlightActivatedTimer = NAV_ACTIVATE_HIGHLIGHT_TIMER;
}

void ImGui::NavClearPreferredPosForAxis(ImGuiAxis axis) {
	ImGuiContext &g = *GImGui;
	g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;
}

void ImGui::SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect &rect_rel) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.NavWindow != NULL);
	IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
	g.NavId = id;
	g.NavLayer = nav_layer;
	SetNavFocusScope(focus_scope_id);
	g.NavWindow->NavLastIds[nav_layer] = id;
	g.NavWindow->NavRectRel[nav_layer] = rect_rel;

	// Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
	NavClearPreferredPosForAxis(ImGuiAxis_X);
	NavClearPreferredPosForAxis(ImGuiAxis_Y);
}

void ImGui::SetFocusID(ImGuiID id, ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(id != 0);

	if (g.NavWindow != window)
		SetNavWindow(window);

	// Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and g.CurrentFocusScopeId are valid.
	// Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
	const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
	g.NavId = id;
	g.NavLayer = nav_layer;
	SetNavFocusScope(g.CurrentFocusScopeId);
	window->NavLastIds[nav_layer] = id;
	if (g.LastItemData.ID == id)
		window->NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect);

	if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
		g.NavDisableMouseHover = true;
	else
		g.NavDisableHighlight = true;

	// Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
	NavClearPreferredPosForAxis(ImGuiAxis_X);
	NavClearPreferredPosForAxis(ImGuiAxis_Y);
}

static ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy) {
	if (ImFabs(dx) > ImFabs(dy))
		return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
	return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float inline NavScoreItemDistInterval(float cand_min, float cand_max, float curr_min, float curr_max) {
	if (cand_max < curr_min)
		return cand_max - curr_min;
	if (curr_max < cand_min)
		return cand_min - curr_max;
	return 0.0f;
}

// Scoring function for gamepad/keyboard directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool ImGui::NavScoreItem(ImGuiNavItemData *result) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	if (g.NavLayer != window->DC.NavLayerCurrent)
		return false;

	// FIXME: Those are not good variables names
	ImRect cand = g.LastItemData.NavRect; // Current item nav rectangle
	const ImRect curr = g.NavScoringRect; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
	g.NavScoringDebugCount++;

	// When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
	if (window->ParentWindow == g.NavWindow) {
		IM_ASSERT((window->ChildFlags | g.NavWindow->ChildFlags) & ImGuiChildFlags_NavFlattened);
		if (!window->ClipRect.Overlaps(cand))
			return false;
		cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
	}

	// Compute distance between boxes
	// FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
	float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
	float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
	if (dby != 0.0f && dbx != 0.0f)
		dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
	float dist_box = ImFabs(dbx) + ImFabs(dby);

	// Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
	float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
	float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
	float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

	// Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
	ImGuiDir quadrant;
	float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
	if (dbx != 0.0f || dby != 0.0f) {
		// For non-overlapping boxes, use distance between boxes
		// FIXME-NAV: Quadrant may be incorrect because of (1) dbx bias and (2) curr.Max.y bias applied by NavBiasScoringRect() where typically curr.Max.y==curr.Min.y
		// One typical case where this happens, with style.WindowMenuButtonPosition == ImGuiDir_Right, pressing Left to navigate from Close to Collapse tends to fail.
		// Also see #6344. Calling ImGetDirQuadrantFromDelta() with unbiased values may be good but side-effects are plenty.
		dax = dbx;
		day = dby;
		dist_axial = dist_box;
		quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
	} else if (dcx != 0.0f || dcy != 0.0f) {
		// For overlapping boxes with different centers, use distance between centers
		dax = dcx;
		day = dcy;
		dist_axial = dist_center;
		quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
	} else {
		// Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
		quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
	}

	const ImGuiDir move_dir = g.NavMoveDir;
#if IMGUI_DEBUG_NAV_SCORING
	char buf[200];
	if (g.IO.KeyCtrl) // Hold CTRL to preview score in matching quadrant. CTRL+Arrow to rotate.
	{
		if (quadrant == move_dir) {
			ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
			ImDrawList *draw_list = GetForegroundDrawList(window);
			draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 80));
			draw_list->AddRectFilled(cand.Min, cand.Min + CalcTextSize(buf), IM_COL32(255, 0, 0, 200));
			draw_list->AddText(cand.Min, IM_COL32(255, 255, 255, 255), buf);
		}
	}
	const bool debug_hovering = IsMouseHoveringRect(cand.Min, cand.Max);
	const bool debug_tty = (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_Space));
	if (debug_hovering || debug_tty) {
		ImFormatString(buf, IM_ARRAYSIZE(buf),
				"d-box    (%7.3f,%7.3f) -> %7.3f\nd-center (%7.3f,%7.3f) -> %7.3f\nd-axial  (%7.3f,%7.3f) -> %7.3f\nnav %c, quadrant %c",
				dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "-WENS"[move_dir + 1], "-WENS"[quadrant + 1]);
		if (debug_hovering) {
			ImDrawList *draw_list = GetForegroundDrawList(window);
			draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255, 200, 0, 100));
			draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255, 255, 0, 200));
			draw_list->AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40, 0, 0, 200));
			draw_list->AddText(cand.Max, ~0U, buf);
		}
		if (debug_tty) {
			IMGUI_DEBUG_LOG_NAV("id 0x%08X\n%s\n", g.LastItemData.ID, buf);
		}
	}
#endif

	// Is it in the quadrant we're interested in moving to?
	bool new_best = false;
	if (quadrant == move_dir) {
		// Does it beat the current best candidate?
		if (dist_box < result->DistBox) {
			result->DistBox = dist_box;
			result->DistCenter = dist_center;
			return true;
		}
		if (dist_box == result->DistBox) {
			// Try using distance between center points to break ties
			if (dist_center < result->DistCenter) {
				result->DistCenter = dist_center;
				new_best = true;
			} else if (dist_center == result->DistCenter) {
				// Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
				// (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
				// this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
				if (((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
					new_best = true;
			}
		}
	}

	// Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
	// are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
	// This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
	// 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
	// Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
	if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial) // Check axial match
		if (g.NavLayer == ImGuiNavLayer_Menu && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
			if ((move_dir == ImGuiDir_Left && dax < 0.0f) || (move_dir == ImGuiDir_Right && dax > 0.0f) || (move_dir == ImGuiDir_Up && day < 0.0f) || (move_dir == ImGuiDir_Down && day > 0.0f)) {
				result->DistAxial = dist_axial;
				new_best = true;
			}

	return new_best;
}

static void ImGui::NavApplyItemToResult(ImGuiNavItemData *result) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	result->Window = window;
	result->ID = g.LastItemData.ID;
	result->FocusScopeId = g.CurrentFocusScopeId;
	result->InFlags = g.LastItemData.InFlags;
	result->RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect);
	if (result->InFlags & ImGuiItemFlags_HasSelectionUserData) {
		IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
		result->SelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
	}
}

// True when current work location may be scrolled horizontally when moving left / right.
// This is generally always true UNLESS within a column. We don't have a vertical equivalent.
void ImGui::NavUpdateCurrentWindowIsScrollPushableX() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	window->DC.NavIsScrollPushableX = (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
// This is called after LastItemData is set, but NextItemData is also still valid.
static void ImGui::NavProcessItem() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	const ImGuiID id = g.LastItemData.ID;
	const ImGuiItemFlags item_flags = g.LastItemData.InFlags;

	// When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
	if (window->DC.NavIsScrollPushableX == false) {
		g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
		g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
	}
	const ImRect nav_bb = g.LastItemData.NavRect;

	// Process Init Request
	if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0) {
		// Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
		const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
		if (candidate_for_nav_default_focus || g.NavInitResult.ID == 0) {
			NavApplyItemToResult(&g.NavInitResult);
		}
		if (candidate_for_nav_default_focus) {
			g.NavInitRequest = false; // Found a match, clear request
			NavUpdateAnyRequestFlag();
		}
	}

	// Process Move Request (scoring for navigation)
	// FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
	if (g.NavMoveScoringItems && (item_flags & ImGuiItemFlags_Disabled) == 0) {
		if ((g.NavMoveFlags & ImGuiNavMoveFlags_FocusApi) || (window->Flags & ImGuiWindowFlags_NoNavInputs) == 0) {
			const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
			if (is_tabbing) {
				NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags);
			} else if (g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) {
				ImGuiNavItemData *result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
				if (NavScoreItem(result))
					NavApplyItemToResult(result);

				// Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
				const float VISIBLE_RATIO = 0.70f;
				if ((g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
					if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
						if (NavScoreItem(&g.NavMoveResultLocalVisible))
							NavApplyItemToResult(&g.NavMoveResultLocalVisible);
			}
		}
	}

	// Update information for currently focused/navigated item
	if (g.NavId == id) {
		if (g.NavWindow != window)
			SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
		g.NavLayer = window->DC.NavLayerCurrent;
		SetNavFocusScope(g.CurrentFocusScopeId); // Will set g.NavFocusScopeId AND store g.NavFocusScopePath
		g.NavFocusScopeId = g.CurrentFocusScopeId;
		g.NavIdIsAlive = true;
		if (g.LastItemData.InFlags & ImGuiItemFlags_HasSelectionUserData) {
			IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
			g.NavLastValidSelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
		}
		window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb); // Store item bounding box (relative to window position)
	}
}

// Handle "scoring" of an item for a tabbing/focusing request initiated by NavUpdateCreateTabbingRequest().
// Note that SetKeyboardFocusHere() API calls are considered tabbing requests!
// - Case 1: no nav/active id:    set result to first eligible item, stop storing.
// - Case 2: tab forward:         on ref id set counter, on counter elapse store result
// - Case 3: tab forward wrap:    set result to first eligible item (preemptively), on ref id set counter, on next frame if counter hasn't elapsed store result. // FIXME-TABBING: Could be done as a next-frame forwarded request
// - Case 4: tab backward:        store all results, on ref id pick prev, stop storing
// - Case 5: tab backward wrap:   store all results, on ref id if no result keep storing until last // FIXME-TABBING: Could be done as next-frame forwarded requested
void ImGui::NavProcessItemForTabbingRequest(ImGuiID id, ImGuiItemFlags item_flags, ImGuiNavMoveFlags move_flags) {
	ImGuiContext &g = *GImGui;

	if ((move_flags & ImGuiNavMoveFlags_FocusApi) == 0) {
		if (g.NavLayer != g.CurrentWindow->DC.NavLayerCurrent)
			return;
		if (g.NavFocusScopeId != g.CurrentFocusScopeId)
			return;
	}

	// - Can always land on an item when using API call.
	// - Tabbing with _NavEnableKeyboard (space/enter/arrows): goes through every item.
	// - Tabbing without _NavEnableKeyboard: goes through inputable items only.
	bool can_stop;
	if (move_flags & ImGuiNavMoveFlags_FocusApi)
		can_stop = true;
	else
		can_stop = (item_flags & ImGuiItemFlags_NoTabStop) == 0 && ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) || (item_flags & ImGuiItemFlags_Inputable));

	// Always store in NavMoveResultLocal (unlike directional request which uses NavMoveResultOther on sibling/flattened windows)
	ImGuiNavItemData *result = &g.NavMoveResultLocal;
	if (g.NavTabbingDir == +1) {
		// Tab Forward or SetKeyboardFocusHere() with >= 0
		if (can_stop && g.NavTabbingResultFirst.ID == 0)
			NavApplyItemToResult(&g.NavTabbingResultFirst);
		if (can_stop && g.NavTabbingCounter > 0 && --g.NavTabbingCounter == 0)
			NavMoveRequestResolveWithLastItem(result);
		else if (g.NavId == id)
			g.NavTabbingCounter = 1;
	} else if (g.NavTabbingDir == -1) {
		// Tab Backward
		if (g.NavId == id) {
			if (result->ID) {
				g.NavMoveScoringItems = false;
				NavUpdateAnyRequestFlag();
			}
		} else if (can_stop) {
			// Keep applying until reaching NavId
			NavApplyItemToResult(result);
		}
	} else if (g.NavTabbingDir == 0) {
		if (can_stop && g.NavId == id)
			NavMoveRequestResolveWithLastItem(result);
		if (can_stop && g.NavTabbingResultFirst.ID == 0) // Tab init
			NavApplyItemToResult(&g.NavTabbingResultFirst);
	}
}

bool ImGui::NavMoveRequestButNoResultYet() {
	ImGuiContext &g = *GImGui;
	return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

// FIXME: ScoringRect is not set
void ImGui::NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.NavWindow != NULL);
	//IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestSubmit: dir %c, window \"%s\"\n", "-WENS"[move_dir + 1], g.NavWindow->Name);

	if (move_flags & ImGuiNavMoveFlags_IsTabbing)
		move_flags |= ImGuiNavMoveFlags_AllowCurrentNavId;

	g.NavMoveSubmitted = g.NavMoveScoringItems = true;
	g.NavMoveDir = move_dir;
	g.NavMoveDirForDebug = move_dir;
	g.NavMoveClipDir = clip_dir;
	g.NavMoveFlags = move_flags;
	g.NavMoveScrollFlags = scroll_flags;
	g.NavMoveForwardToNextFrame = false;
	g.NavMoveKeyMods = (move_flags & ImGuiNavMoveFlags_FocusApi) ? 0 : g.IO.KeyMods;
	g.NavMoveResultLocal.Clear();
	g.NavMoveResultLocalVisible.Clear();
	g.NavMoveResultOther.Clear();
	g.NavTabbingCounter = 0;
	g.NavTabbingResultFirst.Clear();
	NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestResolveWithLastItem(ImGuiNavItemData *result) {
	ImGuiContext &g = *GImGui;
	g.NavMoveScoringItems = false; // Ensure request doesn't need more processing
	NavApplyItemToResult(result);
	NavUpdateAnyRequestFlag();
}

// Called by TreePop() to implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere
void ImGui::NavMoveRequestResolveWithPastTreeNode(ImGuiNavItemData *result, ImGuiTreeNodeStackData *tree_node_data) {
	ImGuiContext &g = *GImGui;
	g.NavMoveScoringItems = false;
	g.LastItemData.ID = tree_node_data->ID;
	g.LastItemData.InFlags = tree_node_data->InFlags & ~ImGuiItemFlags_HasSelectionUserData; // Losing SelectionUserData, recovered next-frame (cheaper).
	g.LastItemData.NavRect = tree_node_data->NavRect;
	NavApplyItemToResult(result); // Result this instead of implementing a NavApplyPastTreeNodeToResult()
	NavClearPreferredPosForAxis(ImGuiAxis_Y);
	NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestCancel() {
	ImGuiContext &g = *GImGui;
	g.NavMoveSubmitted = g.NavMoveScoringItems = false;
	NavUpdateAnyRequestFlag();
}

// Forward will reuse the move request again on the next frame (generally with modifications done to it)
void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.NavMoveForwardToNextFrame == false);
	NavMoveRequestCancel();
	g.NavMoveForwardToNextFrame = true;
	g.NavMoveDir = move_dir;
	g.NavMoveClipDir = clip_dir;
	g.NavMoveFlags = move_flags | ImGuiNavMoveFlags_Forwarded;
	g.NavMoveScrollFlags = scroll_flags;
}

// Navigation wrap-around logic is delayed to the end of the frame because this operation is only valid after entire
// popup is assembled and in case of appended popups it is not clear which EndPopup() call is final.
void ImGui::NavMoveRequestTryWrapping(ImGuiWindow *window, ImGuiNavMoveFlags wrap_flags) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT((wrap_flags & ImGuiNavMoveFlags_WrapMask_) != 0 && (wrap_flags & ~ImGuiNavMoveFlags_WrapMask_) == 0); // Call with _WrapX, _WrapY, _LoopX, _LoopY

	// In theory we should test for NavMoveRequestButNoResultYet() but there's no point doing it:
	// as NavEndFrame() will do the same test. It will end up calling NavUpdateCreateWrappingRequest().
	if (g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer_Main)
		g.NavMoveFlags = (g.NavMoveFlags & ~ImGuiNavMoveFlags_WrapMask_) | wrap_flags;
}

// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
// This way we could find the last focused window among our children. It would be much less confusing this way?
static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow *nav_window) {
	ImGuiWindow *parent = nav_window;
	while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
		parent = parent->ParentWindow;
	if (parent && parent != nav_window)
		parent->NavLastChildNavWindow = nav_window;
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
static ImGuiWindow *ImGui::NavRestoreLastChildNavWindow(ImGuiWindow *window) {
	if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
		return window->NavLastChildNavWindow;
	return window;
}

void ImGui::NavRestoreLayer(ImGuiNavLayer layer) {
	ImGuiContext &g = *GImGui;
	if (layer == ImGuiNavLayer_Main) {
		ImGuiWindow *prev_nav_window = g.NavWindow;
		g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow); // FIXME-NAV: Should clear ongoing nav requests?
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
		if (prev_nav_window)
			IMGUI_DEBUG_LOG_FOCUS("[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n", prev_nav_window->Name, g.NavWindow->Name);
	}
	ImGuiWindow *window = g.NavWindow;
	if (window->NavLastIds[layer] != 0) {
		SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
	} else {
		g.NavLayer = layer;
		NavInitWindow(window, true);
	}
}

void ImGui::NavRestoreHighlightAfterMove() {
	ImGuiContext &g = *GImGui;
	g.NavDisableHighlight = false;
	g.NavDisableMouseHover = g.NavMousePosDirty = true;
}

static inline void ImGui::NavUpdateAnyRequestFlag() {
	ImGuiContext &g = *GImGui;
	g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
	if (g.NavAnyRequest)
		IM_ASSERT(g.NavWindow != NULL);
}

// This needs to be called before we submit any widget (aka in or before Begin)
void ImGui::NavInitWindow(ImGuiWindow *window, bool force_reinit) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(window == g.NavWindow);

	if (window->Flags & ImGuiWindowFlags_NoNavInputs) {
		g.NavId = 0;
		SetNavFocusScope(window->NavRootFocusScopeId);
		return;
	}

	bool init_for_nav = false;
	if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
		init_for_nav = true;
	IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
	if (init_for_nav) {
		SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
		g.NavInitRequest = true;
		g.NavInitRequestFromMove = false;
		g.NavInitResult.ID = 0;
		NavUpdateAnyRequestFlag();
	} else {
		g.NavId = window->NavLastIds[0];
		SetNavFocusScope(window->NavRootFocusScopeId);
	}
}

static ImVec2 ImGui::NavCalcPreferredRefPos() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.NavWindow;
	const bool activated_shortcut = g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID;

	// Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
	if ((g.NavDisableHighlight || !g.NavDisableMouseHover || !window) && !activated_shortcut) {
		// Mouse (we need a fallback in case the mouse becomes invalid after being used)
		// The +1.0f offset when stored by OpenPopupEx() allows reopening this or another popup (same or another mouse button) while not moving the mouse, it is pretty standard.
		// In theory we could move that +1.0f offset in OpenPopupEx()
		ImVec2 p = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : g.MouseLastValidPos;
		return ImVec2(p.x + 1.0f, p.y);
	} else {
		// When navigation is active and mouse is disabled, pick a position around the bottom left of the currently navigated item
		ImRect ref_rect;
		if (activated_shortcut)
			ref_rect = g.LastItemData.NavRect;
		else
			ref_rect = WindowRectRelToAbs(window, window->NavRectRel[g.NavLayer]);

		// Take account of upcoming scrolling (maybe set mouse pos should be done in EndFrame?)
		if (window->LastFrameActive != g.FrameCount && (window->ScrollTarget.x != FLT_MAX || window->ScrollTarget.y != FLT_MAX)) {
			ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
			ref_rect.Translate(window->Scroll - next_scroll);
		}
		ImVec2 pos = ImVec2(ref_rect.Min.x + ImMin(g.Style.FramePadding.x * 4, ref_rect.GetWidth()), ref_rect.Max.y - ImMin(g.Style.FramePadding.y, ref_rect.GetHeight()));
		ImGuiViewport *viewport = GetMainViewport();
		return ImTrunc(ImClamp(pos, viewport->Pos, viewport->Pos + viewport->Size)); // ImTrunc() is important because non-integer mouse position application in backend might be lossy and result in undesirable non-zero delta.
	}
}

float ImGui::GetNavTweakPressedAmount(ImGuiAxis axis) {
	ImGuiContext &g = *GImGui;
	float repeat_delay, repeat_rate;
	GetTypematicRepeatRate(ImGuiInputFlags_RepeatRateNavTweak, &repeat_delay, &repeat_rate);

	ImGuiKey key_less, key_more;
	if (g.NavInputSource == ImGuiInputSource_Gamepad) {
		key_less = (axis == ImGuiAxis_X) ? ImGuiKey_GamepadDpadLeft : ImGuiKey_GamepadDpadUp;
		key_more = (axis == ImGuiAxis_X) ? ImGuiKey_GamepadDpadRight : ImGuiKey_GamepadDpadDown;
	} else {
		key_less = (axis == ImGuiAxis_X) ? ImGuiKey_LeftArrow : ImGuiKey_UpArrow;
		key_more = (axis == ImGuiAxis_X) ? ImGuiKey_RightArrow : ImGuiKey_DownArrow;
	}
	float amount = (float)GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) - (float)GetKeyPressedAmount(key_less, repeat_delay, repeat_rate);
	if (amount != 0.0f && IsKeyDown(key_less) && IsKeyDown(key_more)) // Cancel when opposite directions are held, regardless of repeat phase
		amount = 0.0f;
	return amount;
}

static void ImGui::NavUpdate() {
	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;

	io.WantSetMousePos = false;
	//if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);

	// Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
	// FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
	const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
	const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
	if (nav_gamepad_active)
		for (ImGuiKey key : nav_gamepad_keys_to_change_source)
			if (IsKeyDown(key))
				g.NavInputSource = ImGuiInputSource_Gamepad;
	const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
	const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
	if (nav_keyboard_active)
		for (ImGuiKey key : nav_keyboard_keys_to_change_source)
			if (IsKeyDown(key))
				g.NavInputSource = ImGuiInputSource_Keyboard;

	// Process navigation init request (select first/default focus)
	g.NavJustMovedToId = 0;
	g.NavJustMovedToFocusScopeId = g.NavJustMovedFromFocusScopeId = 0;
	if (g.NavInitResult.ID != 0)
		NavInitRequestApplyResult();
	g.NavInitRequest = false;
	g.NavInitRequestFromMove = false;
	g.NavInitResult.ID = 0;

	// Process navigation move request
	if (g.NavMoveSubmitted)
		NavMoveRequestApplyResult();
	g.NavTabbingCounter = 0;
	g.NavMoveSubmitted = g.NavMoveScoringItems = false;

	// Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
	bool set_mouse_pos = false;
	if (g.NavMousePosDirty && g.NavIdIsAlive)
		if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
			set_mouse_pos = true;
	g.NavMousePosDirty = false;
	IM_ASSERT(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);

	// Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
	if (g.NavWindow)
		NavSaveLastChildNavWindowIntoParent(g.NavWindow);
	if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
		g.NavWindow->NavLastChildNavWindow = NULL;

	// Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
	NavUpdateWindowing();

	// Set output flags for user application
	io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
	io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);

	// Process NavCancel input (to close a popup, get back to parent, clear focus)
	NavUpdateCancelRequest();

	// Process manual activation request
	g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = 0;
	g.NavActivateFlags = ImGuiActivateFlags_None;
	if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs)) {
		const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_NoOwner));
		const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, 0, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, 0, ImGuiKeyOwner_NoOwner)));
		const bool input_down = (nav_keyboard_active && (IsKeyDown(ImGuiKey_Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey_KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner));
		const bool input_pressed = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey_Enter, 0, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey_KeypadEnter, 0, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, 0, ImGuiKeyOwner_NoOwner)));
		if (g.ActiveId == 0 && activate_pressed) {
			g.NavActivateId = g.NavId;
			g.NavActivateFlags = ImGuiActivateFlags_PreferTweak;
		}
		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed) {
			g.NavActivateId = g.NavId;
			g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
		}
		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down))
			g.NavActivateDownId = g.NavId;
		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed)) {
			g.NavActivatePressedId = g.NavId;
			NavHighlightActivated(g.NavId);
		}
	}
	if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
		g.NavDisableHighlight = true;
	if (g.NavActivateId != 0)
		IM_ASSERT(g.NavActivateDownId == g.NavActivateId);

	// Highlight
	if (g.NavHighlightActivatedTimer > 0.0f)
		g.NavHighlightActivatedTimer = ImMax(0.0f, g.NavHighlightActivatedTimer - io.DeltaTime);
	if (g.NavHighlightActivatedTimer == 0.0f)
		g.NavHighlightActivatedId = 0;

	// Process programmatic activation request
	// FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
	if (g.NavNextActivateId != 0) {
		g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
		g.NavActivateFlags = g.NavNextActivateFlags;
	}
	g.NavNextActivateId = 0;

	// Process move requests
	NavUpdateCreateMoveRequest();
	if (g.NavMoveDir == ImGuiDir_None)
		NavUpdateCreateTabbingRequest();
	NavUpdateAnyRequestFlag();
	g.NavIdIsAlive = false;

	// Scrolling
	if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget) {
		// *Fallback* manual-scroll with Nav directional keys when window has no navigable item
		ImGuiWindow *window = g.NavWindow;
		const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
		const ImGuiDir move_dir = g.NavMoveDir;
		if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY && move_dir != ImGuiDir_None) {
			if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
				SetScrollX(window, ImTrunc(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
			if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
				SetScrollY(window, ImTrunc(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
		}

		// *Normal* Manual scroll with LStick
		// Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
		if (nav_gamepad_active) {
			const ImVec2 scroll_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
			const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f
																																		: 1.0f;
			if (scroll_dir.x != 0.0f && window->ScrollbarX)
				SetScrollX(window, ImTrunc(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
			if (scroll_dir.y != 0.0f)
				SetScrollY(window, ImTrunc(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
		}
	}

	// Always prioritize mouse highlight if navigation is disabled
	if (!nav_keyboard_active && !nav_gamepad_active) {
		g.NavDisableHighlight = true;
		g.NavDisableMouseHover = set_mouse_pos = false;
	}

	// Update mouse position if requested
	// (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
	if (set_mouse_pos && (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
		TeleportMousePos(NavCalcPreferredRefPos());

	// [DEBUG]
	g.NavScoringDebugCount = 0;
#if IMGUI_DEBUG_NAV_RECTS
	if (ImGuiWindow *debug_window = g.NavWindow) {
		ImDrawList *draw_list = GetForegroundDrawList(debug_window);
		int layer = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/
		{
			ImRect r = WindowRectRelToAbs(debug_window, debug_window->NavRectRel[layer]);
			draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 200, 0, 255));
		}
		//if (1) { ImU32 col = (!debug_window->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
	}
#endif
}

void ImGui::NavInitRequestApplyResult() {
	// In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
	ImGuiContext &g = *GImGui;
	if (!g.NavWindow)
		return;

	ImGuiNavItemData *result = &g.NavInitResult;
	if (g.NavId != result->ID) {
		g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId;
		g.NavJustMovedToId = result->ID;
		g.NavJustMovedToFocusScopeId = result->FocusScopeId;
		g.NavJustMovedToKeyMods = 0;
		g.NavJustMovedToIsTabbing = false;
		g.NavJustMovedToHasSelectionData = (result->InFlags & ImGuiItemFlags_HasSelectionUserData) != 0;
	}

	// Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
	// FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
	IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
	SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
	g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
	if (result->SelectionUserData != ImGuiSelectionUserData_Invalid)
		g.NavLastValidSelectionUserData = result->SelectionUserData;
	if (g.NavInitRequestFromMove)
		NavRestoreHighlightAfterMove();
}

// Bias scoring rect ahead of scoring + update preferred pos (if missing) using source position
static void NavBiasScoringRect(ImRect &r, ImVec2 &preferred_pos_rel, ImGuiDir move_dir, ImGuiNavMoveFlags move_flags) {
	// Bias initial rect
	ImGuiContext &g = *GImGui;
	const ImVec2 rel_to_abs_offset = g.NavWindow->DC.CursorStartPos;

	// Initialize bias on departure if we don't have any. So mouse-click + arrow will record bias.
	// - We default to L/U bias, so moving down from a large source item into several columns will land on left-most column.
	// - But each successful move sets new bias on one axis, only cleared when using mouse.
	if ((move_flags & ImGuiNavMoveFlags_Forwarded) == 0) {
		if (preferred_pos_rel.x == FLT_MAX)
			preferred_pos_rel.x = ImMin(r.Min.x + 1.0f, r.Max.x) - rel_to_abs_offset.x;
		if (preferred_pos_rel.y == FLT_MAX)
			preferred_pos_rel.y = r.GetCenter().y - rel_to_abs_offset.y;
	}

	// Apply general bias on the other axis
	if ((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) && preferred_pos_rel.x != FLT_MAX)
		r.Min.x = r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x;
	else if ((move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right) && preferred_pos_rel.y != FLT_MAX)
		r.Min.y = r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y;
}

void ImGui::NavUpdateCreateMoveRequest() {
	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;
	ImGuiWindow *window = g.NavWindow;
	const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
	const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;

	if (g.NavMoveForwardToNextFrame && window != NULL) {
		// Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
		// (preserve most state, which were already set by the NavMoveRequestForward() function)
		IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
		IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded);
		IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
	} else {
		// Initiate directional inputs request
		g.NavMoveDir = ImGuiDir_None;
		g.NavMoveFlags = ImGuiNavMoveFlags_None;
		g.NavMoveScrollFlags = ImGuiScrollFlags_None;
		if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs)) {
			const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateNavMove;
			if (!IsActiveIdUsingNavDir(ImGuiDir_Left) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow, repeat_mode, ImGuiKeyOwner_NoOwner)))) {
				g.NavMoveDir = ImGuiDir_Left;
			}
			if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, repeat_mode, ImGuiKeyOwner_NoOwner)))) {
				g.NavMoveDir = ImGuiDir_Right;
			}
			if (!IsActiveIdUsingNavDir(ImGuiDir_Up) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow, repeat_mode, ImGuiKeyOwner_NoOwner)))) {
				g.NavMoveDir = ImGuiDir_Up;
			}
			if (!IsActiveIdUsingNavDir(ImGuiDir_Down) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow, repeat_mode, ImGuiKeyOwner_NoOwner)))) {
				g.NavMoveDir = ImGuiDir_Down;
			}
		}
		g.NavMoveClipDir = g.NavMoveDir;
		g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
	}

	// Update PageUp/PageDown/Home/End scroll
	// FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
	float scoring_rect_offset_y = 0.0f;
	if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
		scoring_rect_offset_y = NavUpdatePageUpPageDown();
	if (scoring_rect_offset_y != 0.0f) {
		g.NavScoringNoClipRect = window->InnerRect;
		g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
	}

	// [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
#if IMGUI_DEBUG_NAV_SCORING
	//if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
	//    g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
	if (io.KeyCtrl) {
		if (g.NavMoveDir == ImGuiDir_None)
			g.NavMoveDir = g.NavMoveDirForDebug;
		g.NavMoveClipDir = g.NavMoveDir;
		g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
	}
#endif

	// Submit
	g.NavMoveForwardToNextFrame = false;
	if (g.NavMoveDir != ImGuiDir_None)
		NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);

	// Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
	if (g.NavMoveSubmitted && g.NavId == 0) {
		IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer);
		g.NavInitRequest = g.NavInitRequestFromMove = true;
		g.NavInitResult.ID = 0;
		g.NavDisableHighlight = false;
	}

	// When using gamepad, we project the reference nav bounding box into window visible area.
	// This is to allow resuming navigation inside the visible area after doing a large amount of scrolling,
	// since with gamepad all movements are relative (can't focus a visible object like we can with the mouse).
	if (g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != NULL) // && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
	{
		bool clamp_x = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
		bool clamp_y = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
		ImRect inner_rect_rel = WindowRectAbsToRel(window, ImRect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1)));

		// Take account of changing scroll to handle triggering a new move request on a scrolling frame. (#6171)
		// Otherwise 'inner_rect_rel' would be off on the move result frame.
		inner_rect_rel.Translate(CalcNextScrollFromScrollTargetAndClamp(window) - window->Scroll);

		if ((clamp_x || clamp_y) && !inner_rect_rel.Contains(window->NavRectRel[g.NavLayer])) {
			IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n");
			float pad_x = ImMin(inner_rect_rel.GetWidth(), window->CalcFontSize() * 0.5f);
			float pad_y = ImMin(inner_rect_rel.GetHeight(), window->CalcFontSize() * 0.5f); // Terrible approximation for the intent of starting navigation from first fully visible item
			inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX;
			inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX;
			inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
			inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
			window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
			g.NavId = 0;
		}
	}

	// For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
	ImRect scoring_rect;
	if (window != NULL) {
		ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
		scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
		scoring_rect.TranslateY(scoring_rect_offset_y);
		if (g.NavMoveSubmitted)
			NavBiasScoringRect(scoring_rect, window->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags);
		IM_ASSERT(!scoring_rect.IsInverted()); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
		//GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
		//if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
	}
	g.NavScoringRect = scoring_rect;
	g.NavScoringNoClipRect.Add(scoring_rect);
}

void ImGui::NavUpdateCreateTabbingRequest() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.NavWindow;
	IM_ASSERT(g.NavMoveDir == ImGuiDir_None);
	if (window == NULL || g.NavWindowingTarget != NULL || (window->Flags & ImGuiWindowFlags_NoNavInputs))
		return;

	const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
	if (!tab_pressed)
		return;

	// Initiate tabbing request
	// (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
	// See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
	const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
	if (nav_keyboard_active)
		g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.NavDisableHighlight == true && g.ActiveId == 0) ? 0
																								  : +1;
	else
		g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0
																 : +1;
	ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate;
	ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
	ImGuiDir clip_dir = (g.NavTabbingDir < 0) ? ImGuiDir_Up : ImGuiDir_Down;
	NavMoveRequestSubmit(ImGuiDir_None, clip_dir, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
	g.NavTabbingCounter = -1;
}

// Apply result from previous frame navigation directional move request. Always called from NavUpdate()
void ImGui::NavMoveRequestApplyResult() {
	ImGuiContext &g = *GImGui;
#if IMGUI_DEBUG_NAV_SCORING
	if (g.NavMoveFlags & ImGuiNavMoveFlags_DebugNoResult) // [DEBUG] Scoring all items in NavWindow at all times
		return;
#endif

	// Select which result to use
	ImGuiNavItemData *result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther
																													   : NULL;

	// Tabbing forward wrap
	if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && result == NULL)
		if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID)
			result = &g.NavTabbingResultFirst;

	// In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
	const ImGuiAxis axis = (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
	if (result == NULL) {
		if (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing)
			g.NavMoveFlags |= ImGuiNavMoveFlags_NoSetNavHighlight;
		if (g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_NoSetNavHighlight) == 0)
			NavRestoreHighlightAfterMove();
		NavClearPreferredPosForAxis(axis); // On a failed move, clear preferred pos for this axis.
		IMGUI_DEBUG_LOG_NAV("[nav] NavMoveSubmitted but not led to a result!\n");
		return;
	}

	// PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
	if (g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
		if (g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId)
			result = &g.NavMoveResultLocalVisible;

	// Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
	if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
		if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
			result = &g.NavMoveResultOther;
	IM_ASSERT(g.NavWindow && result->Window);

	// Scroll to keep newly navigated item fully into view.
	if (g.NavLayer == ImGuiNavLayer_Main) {
		ImRect rect_abs = WindowRectRelToAbs(result->Window, result->RectRel);
		ScrollToRectEx(result->Window, rect_abs, g.NavMoveScrollFlags);

		if (g.NavMoveFlags & ImGuiNavMoveFlags_ScrollToEdgeY) {
			// FIXME: Should remove this? Or make more precise: use ScrollToRectEx() with edge?
			float scroll_target = (g.NavMoveDir == ImGuiDir_Up) ? result->Window->ScrollMax.y : 0.0f;
			SetScrollY(result->Window, scroll_target);
		}
	}

	if (g.NavWindow != result->Window) {
		IMGUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result->Window->Name);
		g.NavWindow = result->Window;
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
	}

	// Clear active id unless requested not to
	// FIXME: ImGuiNavMoveFlags_NoClearActiveId is currently unused as we don't have a clear strategy to preserve active id after interaction,
	// so this is mostly provided as a gateway for further experiments (see #1418, #2890)
	if (g.ActiveId != result->ID && (g.NavMoveFlags & ImGuiNavMoveFlags_NoClearActiveId) == 0)
		ClearActiveID();

	// Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
	// PageUp/PageDown however sets always set NavJustMovedTo (vs Home/End which doesn't) mimicking Windows behavior.
	if ((g.NavId != result->ID || (g.NavMoveFlags & ImGuiNavMoveFlags_IsPageMove)) && (g.NavMoveFlags & ImGuiNavMoveFlags_NoSelect) == 0) {
		g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId;
		g.NavJustMovedToId = result->ID;
		g.NavJustMovedToFocusScopeId = result->FocusScopeId;
		g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
		g.NavJustMovedToIsTabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
		g.NavJustMovedToHasSelectionData = (result->InFlags & ImGuiItemFlags_HasSelectionUserData) != 0;
		//IMGUI_DEBUG_LOG_NAV("[nav] NavJustMovedFromFocusScopeId = 0x%08X, NavJustMovedToFocusScopeId = 0x%08X\n", g.NavJustMovedFromFocusScopeId, g.NavJustMovedToFocusScopeId);
	}

	// Apply new NavID/Focus
	IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
	ImVec2 preferred_scoring_pos_rel = g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer];
	SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
	if (result->SelectionUserData != ImGuiSelectionUserData_Invalid)
		g.NavLastValidSelectionUserData = result->SelectionUserData;

	// Restore last preferred position for current axis
	// (storing in RootWindowForNav-> as the info is desirable at the beginning of a Move Request. In theory all storage should use RootWindowForNav..)
	if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) == 0) {
		preferred_scoring_pos_rel[axis] = result->RectRel.GetCenter()[axis];
		g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer] = preferred_scoring_pos_rel;
	}

	// Tabbing: Activates Inputable, otherwise only Focus
	if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && (result->InFlags & ImGuiItemFlags_Inputable) == 0)
		g.NavMoveFlags &= ~ImGuiNavMoveFlags_Activate;

	// Activate
	if (g.NavMoveFlags & ImGuiNavMoveFlags_Activate) {
		g.NavNextActivateId = result->ID;
		g.NavNextActivateFlags = ImGuiActivateFlags_None;
		if (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing)
			g.NavNextActivateFlags |= ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_TryToPreserveState | ImGuiActivateFlags_FromTabbing;
	}

	// Enable nav highlight
	if ((g.NavMoveFlags & ImGuiNavMoveFlags_NoSetNavHighlight) == 0)
		NavRestoreHighlightAfterMove();
}

// Process NavCancel input (to close a popup, get back to parent, clear focus)
// FIXME: In order to support e.g. Escape to clear a selection we'll need:
// - either to store the equivalent of ActiveIdUsingKeyInputMask for a FocusScope and test for it.
// - either to move most/all of those tests to the epilogue/end functions of the scope they are dealing with (e.g. exit child window in EndChild()) or in EndFrame(), to allow an earlier intercept
static void ImGui::NavUpdateCancelRequest() {
	ImGuiContext &g = *GImGui;
	const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
	const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
	if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, 0, ImGuiKeyOwner_NoOwner)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, 0, ImGuiKeyOwner_NoOwner)))
		return;

	IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
	if (g.ActiveId != 0) {
		ClearActiveID();
	} else if (g.NavLayer != ImGuiNavLayer_Main) {
		// Leave the "menu" layer
		NavRestoreLayer(ImGuiNavLayer_Main);
		NavRestoreHighlightAfterMove();
	} else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow && !(g.NavWindow->RootWindowForNav->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->RootWindowForNav->ParentWindow) {
		// Exit child window
		ImGuiWindow *child_window = g.NavWindow->RootWindowForNav;
		ImGuiWindow *parent_window = child_window->ParentWindow;
		IM_ASSERT(child_window->ChildId != 0);
		FocusWindow(parent_window);
		SetNavID(child_window->ChildId, ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, child_window->Rect()));
		NavRestoreHighlightAfterMove();
	} else if (g.OpenPopupStack.Size > 0 && g.OpenPopupStack.back().Window != NULL && !(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal)) {
		// Close open popup/menu
		ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
	} else {
		// Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
		if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
			g.NavWindow->NavLastIds[0] = 0;
		g.NavId = 0;
	}
}

// Handle PageUp/PageDown/Home/End keys
// Called from NavUpdateCreateMoveRequest() which will use our output to create a move request
// FIXME-NAV: This doesn't work properly with NavFlattened siblings as we use NavWindow rectangle for reference
// FIXME-NAV: how to get Home/End to aim at the beginning/end of a 2D grid?
static float ImGui::NavUpdatePageUpPageDown() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.NavWindow;
	if ((window->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL)
		return 0.0f;

	const bool page_up_held = IsKeyDown(ImGuiKey_PageUp, ImGuiKeyOwner_NoOwner);
	const bool page_down_held = IsKeyDown(ImGuiKey_PageDown, ImGuiKeyOwner_NoOwner);
	const bool home_pressed = IsKeyPressed(ImGuiKey_Home, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner);
	const bool end_pressed = IsKeyPressed(ImGuiKey_End, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner);
	if (page_up_held == page_down_held && home_pressed == end_pressed) // Proceed if either (not both) are pressed, otherwise early out
		return 0.0f;

	if (g.NavLayer != ImGuiNavLayer_Main)
		NavRestoreLayer(ImGuiNavLayer_Main);

	if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY) {
		// Fallback manual-scroll when window has no navigable item
		if (IsKeyPressed(ImGuiKey_PageUp, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner))
			SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
		else if (IsKeyPressed(ImGuiKey_PageDown, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner))
			SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
		else if (home_pressed)
			SetScrollY(window, 0.0f);
		else if (end_pressed)
			SetScrollY(window, window->ScrollMax.y);
	} else {
		ImRect &nav_rect_rel = window->NavRectRel[g.NavLayer];
		const float page_offset_y = ImMax(0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
		float nav_scoring_rect_offset_y = 0.0f;
		if (IsKeyPressed(ImGuiKey_PageUp, true)) {
			nav_scoring_rect_offset_y = -page_offset_y;
			g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
			g.NavMoveClipDir = ImGuiDir_Up;
			g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
		} else if (IsKeyPressed(ImGuiKey_PageDown, true)) {
			nav_scoring_rect_offset_y = +page_offset_y;
			g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
			g.NavMoveClipDir = ImGuiDir_Down;
			g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
		} else if (home_pressed) {
			// FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
			// Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
			// Preserve current horizontal position if we have any.
			nav_rect_rel.Min.y = nav_rect_rel.Max.y = 0.0f;
			if (nav_rect_rel.IsInverted())
				nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
			g.NavMoveDir = ImGuiDir_Down;
			g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
			// FIXME-NAV: MoveClipDir left to _None, intentional?
		} else if (end_pressed) {
			nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ContentSize.y;
			if (nav_rect_rel.IsInverted())
				nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
			g.NavMoveDir = ImGuiDir_Up;
			g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
			// FIXME-NAV: MoveClipDir left to _None, intentional?
		}
		return nav_scoring_rect_offset_y;
	}
	return 0.0f;
}

static void ImGui::NavEndFrame() {
	ImGuiContext &g = *GImGui;

	// Show CTRL+TAB list window
	if (g.NavWindowingTarget != NULL)
		NavUpdateWindowingOverlay();

	// Perform wrap-around in menus
	// FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
	// FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
	if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_WrapMask_) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
		NavUpdateCreateWrappingRequest();
}

static void ImGui::NavUpdateCreateWrappingRequest() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.NavWindow;

	bool do_forward = false;
	ImRect bb_rel = window->NavRectRel[g.NavLayer];
	ImGuiDir clip_dir = g.NavMoveDir;

	const ImGuiNavMoveFlags move_flags = g.NavMoveFlags;
	//const ImGuiAxis move_axis = (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
	if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX))) {
		bb_rel.Min.x = bb_rel.Max.x = window->ContentSize.x + window->WindowPadding.x;
		if (move_flags & ImGuiNavMoveFlags_WrapX) {
			bb_rel.TranslateY(-bb_rel.GetHeight()); // Previous row
			clip_dir = ImGuiDir_Up;
		}
		do_forward = true;
	}
	if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX))) {
		bb_rel.Min.x = bb_rel.Max.x = -window->WindowPadding.x;
		if (move_flags & ImGuiNavMoveFlags_WrapX) {
			bb_rel.TranslateY(+bb_rel.GetHeight()); // Next row
			clip_dir = ImGuiDir_Down;
		}
		do_forward = true;
	}
	if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY))) {
		bb_rel.Min.y = bb_rel.Max.y = window->ContentSize.y + window->WindowPadding.y;
		if (move_flags & ImGuiNavMoveFlags_WrapY) {
			bb_rel.TranslateX(-bb_rel.GetWidth()); // Previous column
			clip_dir = ImGuiDir_Left;
		}
		do_forward = true;
	}
	if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY))) {
		bb_rel.Min.y = bb_rel.Max.y = -window->WindowPadding.y;
		if (move_flags & ImGuiNavMoveFlags_WrapY) {
			bb_rel.TranslateX(+bb_rel.GetWidth()); // Next column
			clip_dir = ImGuiDir_Right;
		}
		do_forward = true;
	}
	if (!do_forward)
		return;
	window->NavRectRel[g.NavLayer] = bb_rel;
	NavClearPreferredPosForAxis(ImGuiAxis_X);
	NavClearPreferredPosForAxis(ImGuiAxis_Y);
	NavMoveRequestForward(g.NavMoveDir, clip_dir, move_flags, g.NavMoveScrollFlags);
}

static int ImGui::FindWindowFocusIndex(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	IM_UNUSED(g);
	int order = window->FocusOrder;
	IM_ASSERT(window->RootWindow == window); // No child window (not testing _ChildWindow because of docking)
	IM_ASSERT(g.WindowsFocusOrder[order] == window);
	return order;
}

static ImGuiWindow *FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
{
	ImGuiContext &g = *GImGui;
	for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
		if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
			return g.WindowsFocusOrder[i];
	return NULL;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.NavWindowingTarget);
	if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
		return;

	const int i_current = ImGui::FindWindowFocusIndex(g.NavWindowingTarget);
	ImGuiWindow *window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
	if (!window_target)
		window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
	if (window_target) // Don't reset windowing target if there's a single window in the list
	{
		g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
		g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
	}
	g.NavWindowingToggleLayer = false;
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
static void ImGui::NavUpdateWindowing() {
	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;

	ImGuiWindow *apply_focus_window = NULL;
	bool apply_toggle_layer = false;

	ImGuiWindow *modal_window = GetTopMostPopupModal();
	bool allow_windowing = (modal_window == NULL); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
	if (!allow_windowing)
		g.NavWindowingTarget = NULL;

	// Fade out
	if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL) {
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
		if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
			g.NavWindowingTargetAnim = NULL;
	}

	// Start CTRL+Tab or Square+L/R window selection
	// (g.ConfigNavWindowingKeyNext/g.ConfigNavWindowingKeyPrev defaults are ImGuiMod_Ctrl|ImGuiKey_Tab and ImGuiMod_Ctrl|ImGuiMod_Shift|ImGuiKey_Tab)
	const ImGuiID owner_id = ImHashStr("###NavUpdateWindowing");
	const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
	const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
	const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways, owner_id);
	const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways, owner_id);
	const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, ImGuiInputFlags_None);
	const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
	if (start_windowing_with_gamepad || start_windowing_with_keyboard)
		if (ImGuiWindow *window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1)) {
			g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
			g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
			g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
			g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
			g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;

			// Manually register ownership of our mods. Using a global route in the Shortcut() calls instead would probably be correct but may have more side-effects.
			if (keyboard_next_window || keyboard_prev_window)
				SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiMod_Mask_, owner_id);
		}

	// Gamepad update
	g.NavWindowingTimer += io.DeltaTime;
	if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad) {
		// Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));

		// Select window to focus
		const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
		if (focus_change_dir != 0) {
			NavUpdateWindowingHighlightWindow(focus_change_dir);
			g.NavWindowingHighlightAlpha = 1.0f;
		}

		// Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
		if (!IsKeyDown(ImGuiKey_NavGamepadMenu)) {
			g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
			if (g.NavWindowingToggleLayer && g.NavWindow)
				apply_toggle_layer = true;
			else if (!g.NavWindowingToggleLayer)
				apply_focus_window = g.NavWindowingTarget;
			g.NavWindowingTarget = NULL;
		}
	}

	// Keyboard: Focus
	if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard) {
		// Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
		ImGuiKeyChord shared_mods = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiMod_Mask_)) & ImGuiMod_Mask_;
		IM_ASSERT(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
		if (keyboard_next_window || keyboard_prev_window)
			NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
		else if ((io.KeyMods & shared_mods) != shared_mods)
			apply_focus_window = g.NavWindowingTarget;
	}

	// Keyboard: Press and Release ALT to toggle menu layer
	const ImGuiKey windowing_toggle_keys[] = { ImGuiKey_LeftAlt, ImGuiKey_RightAlt };
	for (ImGuiKey windowing_toggle_key : windowing_toggle_keys)
		if (nav_keyboard_active && IsKeyPressed(windowing_toggle_key, 0, ImGuiKeyOwner_NoOwner)) {
			g.NavWindowingToggleLayer = true;
			g.NavWindowingToggleKey = windowing_toggle_key;
			g.NavInputSource = ImGuiInputSource_Keyboard;
			break;
		}
	if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard) {
		// We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
		// We cancel toggling nav layer when other modifiers are pressed. (See #4439)
		// - AltGR is Alt+Ctrl on some layout but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl).
		// We cancel toggling nav layer if an owner has claimed the key.
		if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper)
			g.NavWindowingToggleLayer = false;
		if (TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_NoOwner) == false || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_NoOwner) == false)
			g.NavWindowingToggleLayer = false;

		// Apply layer toggle on Alt release
		// Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
		if (IsKeyReleased(g.NavWindowingToggleKey) && g.NavWindowingToggleLayer)
			if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
				if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
					apply_toggle_layer = true;
		if (!IsKeyDown(g.NavWindowingToggleKey))
			g.NavWindowingToggleLayer = false;
	}

	// Move window
	if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove)) {
		ImVec2 nav_move_dir;
		if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
			nav_move_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
		if (g.NavInputSource == ImGuiInputSource_Gamepad)
			nav_move_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
		if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f) {
			const float NAV_MOVE_SPEED = 800.0f;
			const float move_step = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
			g.NavWindowingAccumDeltaPos += nav_move_dir * move_step;
			g.NavDisableMouseHover = true;
			ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaPos);
			if (accum_floored.x != 0.0f || accum_floored.y != 0.0f) {
				ImGuiWindow *moving_window = g.NavWindowingTarget->RootWindow;
				SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
				g.NavWindowingAccumDeltaPos -= accum_floored;
			}
		}
	}

	// Apply final focus
	if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow)) {
		ClearActiveID();
		NavRestoreHighlightAfterMove();
		ClosePopupsOverWindow(apply_focus_window, false);
		FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_RestoreFocusedChild);
		apply_focus_window = g.NavWindow;
		if (apply_focus_window->NavLastIds[0] == 0)
			NavInitWindow(apply_focus_window, false);

		// If the window has ONLY a menu layer (no main layer), select it directly
		// Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
		// so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
		// the target window as already been previewed once.
		// FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
		// we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
		// won't be valid.
		if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu))
			g.NavLayer = ImGuiNavLayer_Menu;
	}
	if (apply_focus_window)
		g.NavWindowingTarget = NULL;

	// Apply menu/layer toggle
	if (apply_toggle_layer && g.NavWindow) {
		ClearActiveID();

		// Move to parent menu if necessary
		ImGuiWindow *new_nav_window = g.NavWindow;
		while (new_nav_window->ParentWindow && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0 && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
			new_nav_window = new_nav_window->ParentWindow;
		if (new_nav_window != g.NavWindow) {
			ImGuiWindow *old_nav_window = g.NavWindow;
			FocusWindow(new_nav_window);
			new_nav_window->NavLastChildNavWindow = old_nav_window;
		}

		// Toggle layer
		const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
		if (new_nav_layer != g.NavLayer) {
			// Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
			if (new_nav_layer == ImGuiNavLayer_Menu)
				g.NavWindow->NavLastIds[new_nav_layer] = 0;
			NavRestoreLayer(new_nav_layer);
			NavRestoreHighlightAfterMove();
		}
	}
}

// Window has already passed the IsWindowNavFocusable()
static const char *GetFallbackWindowNameForWindowingList(ImGuiWindow *window) {
	if (window->Flags & ImGuiWindowFlags_Popup)
		return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingPopup);
	if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
		return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingMainMenuBar);
	return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingUntitled);
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void ImGui::NavUpdateWindowingOverlay() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.NavWindowingTarget != NULL);

	if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
		return;

	if (g.NavWindowingListWindow == NULL)
		g.NavWindowingListWindow = FindWindowByName("###NavWindowingList");
	const ImGuiViewport *viewport = GetMainViewport();
	SetNextWindowSizeConstraints(ImVec2(viewport->Size.x * 0.20f, viewport->Size.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));
	SetNextWindowPos(viewport->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
	PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
	Begin("###NavWindowingList", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
	if (g.ContextName[0] != 0)
		SeparatorText(g.ContextName);
	for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--) {
		ImGuiWindow *window = g.WindowsFocusOrder[n];
		IM_ASSERT(window != NULL); // Fix static analyzers
		if (!IsWindowNavFocusable(window))
			continue;
		const char *label = window->Name;
		if (label == FindRenderedTextEnd(label))
			label = GetFallbackWindowNameForWindowingList(window);
		Selectable(label, g.NavWindowingTarget == window);
	}
	End();
	PopStyleVar();
}

//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

bool ImGui::IsDragDropActive() {
	ImGuiContext &g = *GImGui;
	return g.DragDropActive;
}

void ImGui::ClearDragDrop() {
	ImGuiContext &g = *GImGui;
	if (g.DragDropActive)
		IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] ClearDragDrop()\n");
	g.DragDropActive = false;
	g.DragDropPayload.Clear();
	g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
	g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
	g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
	g.DragDropAcceptFrameCount = -1;

	g.DragDropPayloadBufHeap.clear();
	memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}

bool ImGui::BeginTooltipHidden() {
	ImGuiContext &g = *GImGui;
	bool ret = Begin("##Tooltip_Hidden", NULL, ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize);
	SetWindowHiddenAndSkipItemsForCurrentFrame(g.CurrentWindow);
	return ret;
}

// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
// If the item has an identifier:
// - This assume/require the item to be activated (typically via ButtonBehavior).
// - Therefore if you want to use this with a mouse button other than left mouse button, it is up to the item itself to activate with another button.
// - We then pull and use the mouse button that was used to activate the item and use it to carry on the drag.
// If the item has no identifier:
// - Currently always assume left mouse button.
bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	// FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
	// in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
	ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;

	bool source_drag_active = false;
	ImGuiID source_id = 0;
	ImGuiID source_parent_id = 0;
	if ((flags & ImGuiDragDropFlags_SourceExtern) == 0) {
		source_id = g.LastItemData.ID;
		if (source_id != 0) {
			// Common path: items with ID
			if (g.ActiveId != source_id)
				return false;
			if (g.ActiveIdMouseButton != -1)
				mouse_button = g.ActiveIdMouseButton;
			if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
				return false;
			g.ActiveIdAllowOverlap = false;
		} else {
			// Uncommon path: items without ID
			if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
				return false;
			if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
				return false;

			// If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
			// A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
			if (!(flags & ImGuiDragDropFlags_SourceAllowNullID)) {
				IM_ASSERT(0);
				return false;
			}

			// Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
			// We build a throwaway ID based on current ID stack + relative AABB of items in window.
			// THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
			// We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
			// Rely on keeping other window->LastItemXXX fields intact.
			source_id = g.LastItemData.ID = window->GetIDFromRectangle(g.LastItemData.Rect);
			KeepAliveID(source_id);
			bool is_hovered = ItemHoverable(g.LastItemData.Rect, source_id, g.LastItemData.InFlags);
			if (is_hovered && g.IO.MouseClicked[mouse_button]) {
				SetActiveID(source_id, window);
				FocusWindow(window);
			}
			if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
				g.ActiveIdAllowOverlap = is_hovered;
		}
		if (g.ActiveId != source_id)
			return false;
		source_parent_id = window->IDStack.back();
		source_drag_active = IsMouseDragging(mouse_button);

		// Disable navigation and key inputs while dragging + cancel existing request if any
		SetActiveIdUsingAllKeyboardKeys();
	} else {
		// When ImGuiDragDropFlags_SourceExtern is set:
		window = NULL;
		source_id = ImHashStr("#SourceExtern");
		source_drag_active = true;
		mouse_button = g.IO.MouseDown[0] ? 0 : -1;
		KeepAliveID(source_id);
		SetActiveID(source_id, NULL);
	}

	IM_ASSERT(g.DragDropWithinTarget == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	if (!source_drag_active)
		return false;

	// Activate drag and drop
	if (!g.DragDropActive) {
		IM_ASSERT(source_id != 0);
		ClearDragDrop();
		IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] BeginDragDropSource() DragDropActive = true, source_id = 0x%08X%s\n",
				source_id, (flags & ImGuiDragDropFlags_SourceExtern) ? " (EXTERN)" : "");
		ImGuiPayload &payload = g.DragDropPayload;
		payload.SourceId = source_id;
		payload.SourceParentId = source_parent_id;
		g.DragDropActive = true;
		g.DragDropSourceFlags = flags;
		g.DragDropMouseButton = mouse_button;
		if (payload.SourceId == g.ActiveId)
			g.ActiveIdNoClearOnFocusLoss = true;
	}
	g.DragDropSourceFrameCount = g.FrameCount;
	g.DragDropWithinSource = true;

	if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip)) {
		// Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
		// We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
		bool ret;
		if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
			ret = BeginTooltipHidden();
		else
			ret = BeginTooltip();
		IM_ASSERT(ret); // FIXME-NEWBEGIN: If this ever becomes false, we need to Begin("##Hidden", NULL, ImGuiWindowFlags_NoSavedSettings) + SetWindowHiddendAndSkipItemsForCurrentFrame().
		IM_UNUSED(ret);
	}

	if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
		g.LastItemData.StatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

	return true;
}

void ImGui::EndDragDropSource() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.DragDropActive);
	IM_ASSERT(g.DragDropWithinSource && "Not after a BeginDragDropSource()?");

	if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
		EndTooltip();

	// Discard the drag if have not called SetDragDropPayload()
	if (g.DragDropPayload.DataFrameCount == -1)
		ClearDragDrop();
	g.DragDropWithinSource = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool ImGui::SetDragDropPayload(const char *type, const void *data, size_t data_size, ImGuiCond cond) {
	ImGuiContext &g = *GImGui;
	ImGuiPayload &payload = g.DragDropPayload;
	if (cond == 0)
		cond = ImGuiCond_Always;

	IM_ASSERT(type != NULL);
	IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
	IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
	IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
	IM_ASSERT(payload.SourceId != 0); // Not called between BeginDragDropSource() and EndDragDropSource()

	if (cond == ImGuiCond_Always || payload.DataFrameCount == -1) {
		// Copy payload
		ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
		g.DragDropPayloadBufHeap.resize(0);
		if (data_size > sizeof(g.DragDropPayloadBufLocal)) {
			// Store in heap
			g.DragDropPayloadBufHeap.resize((int)data_size);
			payload.Data = g.DragDropPayloadBufHeap.Data;
			memcpy(payload.Data, data, data_size);
		} else if (data_size > 0) {
			// Store locally
			memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
			payload.Data = g.DragDropPayloadBufLocal;
			memcpy(payload.Data, data, data_size);
		} else {
			payload.Data = NULL;
		}
		payload.DataSize = (int)data_size;
	}
	payload.DataFrameCount = g.FrameCount;

	// Return whether the payload has been accepted
	return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool ImGui::BeginDragDropTargetCustom(const ImRect &bb, ImGuiID id) {
	ImGuiContext &g = *GImGui;
	if (!g.DragDropActive)
		return false;

	ImGuiWindow *window = g.CurrentWindow;
	ImGuiWindow *hovered_window = g.HoveredWindowUnderMovingWindow;
	if (hovered_window == NULL || window->RootWindow != hovered_window->RootWindow)
		return false;
	IM_ASSERT(id != 0);
	if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
		return false;
	if (window->SkipItems)
		return false;

	IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	g.DragDropTargetRect = bb;
	g.DragDropTargetClipRect = window->ClipRect; // May want to be overridden by user depending on use case?
	g.DragDropTargetId = id;
	g.DragDropWithinTarget = true;
	return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemData's ImGuiItemStatusFlags_HoveredRect which handles items that push a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool ImGui::BeginDragDropTarget() {
	ImGuiContext &g = *GImGui;
	if (!g.DragDropActive)
		return false;

	ImGuiWindow *window = g.CurrentWindow;
	if (!(g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect))
		return false;
	ImGuiWindow *hovered_window = g.HoveredWindowUnderMovingWindow;
	if (hovered_window == NULL || window->RootWindow != hovered_window->RootWindow || window->SkipItems)
		return false;

	const ImRect &display_rect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? g.LastItemData.DisplayRect : g.LastItemData.Rect;
	ImGuiID id = g.LastItemData.ID;
	if (id == 0) {
		id = window->GetIDFromRectangle(display_rect);
		KeepAliveID(id);
	}
	if (g.DragDropPayload.SourceId == id)
		return false;

	IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	g.DragDropTargetRect = display_rect;
	g.DragDropTargetClipRect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasClipRect) ? g.LastItemData.ClipRect : window->ClipRect;
	g.DragDropTargetId = id;
	g.DragDropWithinTarget = true;
	return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted() {
	ImGuiContext &g = *GImGui;
	return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload *ImGui::AcceptDragDropPayload(const char *type, ImGuiDragDropFlags flags) {
	ImGuiContext &g = *GImGui;
	ImGuiPayload &payload = g.DragDropPayload;
	IM_ASSERT(g.DragDropActive); // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
	IM_ASSERT(payload.DataFrameCount != -1); // Forgot to call EndDragDropTarget() ?
	if (type != NULL && !payload.IsDataType(type))
		return NULL;

	// Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
	// NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
	const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
	ImRect r = g.DragDropTargetRect;
	float r_surface = r.GetWidth() * r.GetHeight();
	if (r_surface > g.DragDropAcceptIdCurrRectSurface)
		return NULL;

	g.DragDropAcceptFlags = flags;
	g.DragDropAcceptIdCurr = g.DragDropTargetId;
	g.DragDropAcceptIdCurrRectSurface = r_surface;
	//IMGUI_DEBUG_LOG("AcceptDragDropPayload(): %08X: accept\n", g.DragDropTargetId);

	// Render default drop visuals
	payload.Preview = was_accepted_previously;
	flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that live for 1 frame)
	if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
		RenderDragDropTargetRect(r, g.DragDropTargetClipRect);

	g.DragDropAcceptFrameCount = g.FrameCount;
	if ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) && g.DragDropMouseButton == -1)
		payload.Delivery = was_accepted_previously && (g.DragDropSourceFrameCount < g.FrameCount);
	else
		payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting OS window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
	if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
		return NULL;

	if (payload.Delivery)
		IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] AcceptDragDropPayload(): 0x%08X: payload delivery\n", g.DragDropTargetId);
	return &payload;
}

// FIXME-STYLE FIXME-DRAGDROP: Settle on a proper default visuals for drop target.
void ImGui::RenderDragDropTargetRect(const ImRect &bb, const ImRect &item_clip_rect) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImRect bb_display = bb;
	bb_display.ClipWith(item_clip_rect); // Clip THEN expand so we have a way to visualize that target is not entirely visible.
	bb_display.Expand(3.5f);
	bool push_clip_rect = !window->ClipRect.Contains(bb_display);
	if (push_clip_rect)
		window->DrawList->PushClipRectFullScreen();
	window->DrawList->AddRect(bb_display.Min, bb_display.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, 0, 2.0f);
	if (push_clip_rect)
		window->DrawList->PopClipRect();
}

const ImGuiPayload *ImGui::GetDragDropPayload() {
	ImGuiContext &g = *GImGui;
	return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1) ? &g.DragDropPayload : NULL;
}

void ImGui::EndDragDropTarget() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.DragDropActive);
	IM_ASSERT(g.DragDropWithinTarget);
	g.DragDropWithinTarget = false;

	// Clear drag and drop state payload right after delivery
	if (g.DragDropPayload.Delivery)
		ClearDragDrop();
}

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
static inline void LogTextV(ImGuiContext &g, const char *fmt, va_list args) {
	if (g.LogFile) {
		g.LogBuffer.Buf.resize(0);
		g.LogBuffer.appendfv(fmt, args);
		ImFileWrite(g.LogBuffer.c_str(), sizeof(char), (ImU64)g.LogBuffer.size(), g.LogFile);
	} else {
		g.LogBuffer.appendfv(fmt, args);
	}
}

void ImGui::LogText(const char *fmt, ...) {
	ImGuiContext &g = *GImGui;
	if (!g.LogEnabled)
		return;

	va_list args;
	va_start(args, fmt);
	LogTextV(g, fmt, args);
	va_end(args);
}

void ImGui::LogTextV(const char *fmt, va_list args) {
	ImGuiContext &g = *GImGui;
	if (!g.LogEnabled)
		return;

	LogTextV(g, fmt, args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
// FIXME: This code is a little complicated perhaps, considering simplifying the whole system.
void ImGui::LogRenderedText(const ImVec2 *ref_pos, const char *text, const char *text_end) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	const char *prefix = g.LogNextPrefix;
	const char *suffix = g.LogNextSuffix;
	g.LogNextPrefix = g.LogNextSuffix = NULL;

	if (!text_end)
		text_end = FindRenderedTextEnd(text, text_end);

	const bool log_new_line = ref_pos && (ref_pos->y > g.LogLinePosY + g.Style.FramePadding.y + 1);
	if (ref_pos)
		g.LogLinePosY = ref_pos->y;
	if (log_new_line) {
		LogText(IM_NEWLINE);
		g.LogLineFirstItem = true;
	}

	if (prefix)
		LogRenderedText(ref_pos, prefix, prefix + strlen(prefix)); // Calculate end ourself to ensure "##" are included here.

	// Re-adjust padding if we have popped out of our starting depth
	if (g.LogDepthRef > window->DC.TreeDepth)
		g.LogDepthRef = window->DC.TreeDepth;
	const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);

	const char *text_remaining = text;
	for (;;) {
		// Split the string. Each new line (after a '\n') is followed by indentation corresponding to the current depth of our log entry.
		// We don't add a trailing \n yet to allow a subsequent item on the same line to be captured.
		const char *line_start = text_remaining;
		const char *line_end = ImStreolRange(line_start, text_end);
		const bool is_last_line = (line_end == text_end);
		if (line_start != line_end || !is_last_line) {
			const int line_length = (int)(line_end - line_start);
			const int indentation = g.LogLineFirstItem ? tree_depth * 4 : 1;
			LogText("%*s%.*s", indentation, "", line_length, line_start);
			g.LogLineFirstItem = false;
			if (*line_end == '\n') {
				LogText(IM_NEWLINE);
				g.LogLineFirstItem = true;
			}
		}
		if (is_last_line)
			break;
		text_remaining = line_end + 1;
	}

	if (suffix)
		LogRenderedText(ref_pos, suffix, suffix + strlen(suffix));
}

// Start logging/capturing text output
void ImGui::LogBegin(ImGuiLogType type, int auto_open_depth) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	IM_ASSERT(g.LogEnabled == false);
	IM_ASSERT(g.LogFile == NULL);
	IM_ASSERT(g.LogBuffer.empty());
	g.LogEnabled = g.ItemUnclipByLog = true;
	g.LogType = type;
	g.LogNextPrefix = g.LogNextSuffix = NULL;
	g.LogDepthRef = window->DC.TreeDepth;
	g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);
	g.LogLinePosY = FLT_MAX;
	g.LogLineFirstItem = true;
}

// Important: doesn't copy underlying data, use carefully (prefix/suffix must be in scope at the time of the next LogRenderedText)
void ImGui::LogSetNextTextDecoration(const char *prefix, const char *suffix) {
	ImGuiContext &g = *GImGui;
	g.LogNextPrefix = prefix;
	g.LogNextSuffix = suffix;
}

void ImGui::LogToTTY(int auto_open_depth) {
	ImGuiContext &g = *GImGui;
	if (g.LogEnabled)
		return;
	IM_UNUSED(auto_open_depth);
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
	LogBegin(ImGuiLogType_TTY, auto_open_depth);
	g.LogFile = stdout;
#endif
}

// Start logging/capturing text output to given file
void ImGui::LogToFile(int auto_open_depth, const char *filename) {
	ImGuiContext &g = *GImGui;
	if (g.LogEnabled)
		return;

	// FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
	// be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
	// By opening the file in binary mode "ab" we have consistent output everywhere.
	if (!filename)
		filename = g.IO.LogFilename;
	if (!filename || !filename[0])
		return;
	ImFileHandle f = ImFileOpen(filename, "ab");
	if (!f) {
		IM_ASSERT(0);
		return;
	}

	LogBegin(ImGuiLogType_File, auto_open_depth);
	g.LogFile = f;
}

// Start logging/capturing text output to clipboard
void ImGui::LogToClipboard(int auto_open_depth) {
	ImGuiContext &g = *GImGui;
	if (g.LogEnabled)
		return;
	LogBegin(ImGuiLogType_Clipboard, auto_open_depth);
}

void ImGui::LogToBuffer(int auto_open_depth) {
	ImGuiContext &g = *GImGui;
	if (g.LogEnabled)
		return;
	LogBegin(ImGuiLogType_Buffer, auto_open_depth);
}

void ImGui::LogFinish() {
	ImGuiContext &g = *GImGui;
	if (!g.LogEnabled)
		return;

	LogText(IM_NEWLINE);
	switch (g.LogType) {
		case ImGuiLogType_TTY:
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
			fflush(g.LogFile);
#endif
			break;
		case ImGuiLogType_File:
			ImFileClose(g.LogFile);
			break;
		case ImGuiLogType_Buffer:
			break;
		case ImGuiLogType_Clipboard:
			if (!g.LogBuffer.empty())
				SetClipboardText(g.LogBuffer.begin());
			break;
		case ImGuiLogType_None:
			IM_ASSERT(0);
			break;
	}

	g.LogEnabled = g.ItemUnclipByLog = false;
	g.LogType = ImGuiLogType_None;
	g.LogFile = NULL;
	g.LogBuffer.clear();
}

// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
void ImGui::LogButtons() {
	ImGuiContext &g = *GImGui;

	PushID("LogButtons");
#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
	const bool log_to_tty = Button("Log To TTY");
	SameLine();
#else
	const bool log_to_tty = false;
#endif
	const bool log_to_file = Button("Log To File");
	SameLine();
	const bool log_to_clipboard = Button("Log To Clipboard");
	SameLine();
	PushItemFlag(ImGuiItemFlags_NoTabStop, true);
	SetNextItemWidth(80.0f);
	SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, NULL);
	PopItemFlag();
	PopID();

	// Start logging at the end of the function so that the buttons don't appear in the log
	if (log_to_tty)
		LogToTTY();
	if (log_to_file)
		LogToFile();
	if (log_to_clipboard)
		LogToClipboard();
}

//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------
// - UpdateSettings() [Internal]
// - MarkIniSettingsDirty() [Internal]
// - FindSettingsHandler() [Internal]
// - ClearIniSettings() [Internal]
// - LoadIniSettingsFromDisk()
// - LoadIniSettingsFromMemory()
// - SaveIniSettingsToDisk()
// - SaveIniSettingsToMemory()
//-----------------------------------------------------------------------------
// - CreateNewWindowSettings() [Internal]
// - FindWindowSettingsByID() [Internal]
// - FindWindowSettingsByWindow() [Internal]
// - ClearWindowSettings() [Internal]
// - WindowSettingsHandler_***() [Internal]
//-----------------------------------------------------------------------------

// Called by NewFrame()
void ImGui::UpdateSettings() {
	// Load settings on first frame (if not explicitly loaded manually before)
	ImGuiContext &g = *GImGui;
	if (!g.SettingsLoaded) {
		IM_ASSERT(g.SettingsWindows.empty());
		if (g.IO.IniFilename)
			LoadIniSettingsFromDisk(g.IO.IniFilename);
		g.SettingsLoaded = true;
	}

	// Save settings (with a delay after the last modification, so we don't spam disk too much)
	if (g.SettingsDirtyTimer > 0.0f) {
		g.SettingsDirtyTimer -= g.IO.DeltaTime;
		if (g.SettingsDirtyTimer <= 0.0f) {
			if (g.IO.IniFilename != NULL)
				SaveIniSettingsToDisk(g.IO.IniFilename);
			else
				g.IO.WantSaveIniSettings = true; // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
			g.SettingsDirtyTimer = 0.0f;
		}
	}
}

void ImGui::MarkIniSettingsDirty() {
	ImGuiContext &g = *GImGui;
	if (g.SettingsDirtyTimer <= 0.0f)
		g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::MarkIniSettingsDirty(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
		if (g.SettingsDirtyTimer <= 0.0f)
			g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::AddSettingsHandler(const ImGuiSettingsHandler *handler) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
	g.SettingsHandlers.push_back(*handler);
}

void ImGui::RemoveSettingsHandler(const char *type_name) {
	ImGuiContext &g = *GImGui;
	if (ImGuiSettingsHandler *handler = FindSettingsHandler(type_name))
		g.SettingsHandlers.erase(handler);
}

ImGuiSettingsHandler *ImGui::FindSettingsHandler(const char *type_name) {
	ImGuiContext &g = *GImGui;
	const ImGuiID type_hash = ImHashStr(type_name);
	for (ImGuiSettingsHandler &handler : g.SettingsHandlers)
		if (handler.TypeHash == type_hash)
			return &handler;
	return NULL;
}

// Clear all settings (windows, tables, docking etc.)
void ImGui::ClearIniSettings() {
	ImGuiContext &g = *GImGui;
	g.SettingsIniData.clear();
	for (ImGuiSettingsHandler &handler : g.SettingsHandlers)
		if (handler.ClearAllFn != NULL)
			handler.ClearAllFn(&g, &handler);
}

void ImGui::LoadIniSettingsFromDisk(const char *ini_filename) {
	size_t file_data_size = 0;
	char *file_data = (char *)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
	if (!file_data)
		return;
	if (file_data_size > 0)
		LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
	IM_FREE(file_data);
}

// Zero-tolerance, no error reporting, cheap .ini parsing
// Set ini_size==0 to let us use strlen(ini_data). Do not call this function with a 0 if your buffer is actually empty!
void ImGui::LoadIniSettingsFromMemory(const char *ini_data, size_t ini_size) {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.Initialized);
	//IM_ASSERT(!g.WithinFrameScope && "Cannot be called between NewFrame() and EndFrame()");
	//IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

	// For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
	// For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
	if (ini_size == 0)
		ini_size = strlen(ini_data);
	g.SettingsIniData.Buf.resize((int)ini_size + 1);
	char *const buf = g.SettingsIniData.Buf.Data;
	char *const buf_end = buf + ini_size;
	memcpy(buf, ini_data, ini_size);
	buf_end[0] = 0;

	// Call pre-read handlers
	// Some types will clear their data (e.g. dock information) some types will allow merge/override (window)
	for (ImGuiSettingsHandler &handler : g.SettingsHandlers)
		if (handler.ReadInitFn != NULL)
			handler.ReadInitFn(&g, &handler);

	void *entry_data = NULL;
	ImGuiSettingsHandler *entry_handler = NULL;

	char *line_end = NULL;
	for (char *line = buf; line < buf_end; line = line_end + 1) {
		// Skip new lines markers, then find end of the line
		while (*line == '\n' || *line == '\r')
			line++;
		line_end = line;
		while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
			line_end++;
		line_end[0] = 0;
		if (line[0] == ';')
			continue;
		if (line[0] == '[' && line_end > line && line_end[-1] == ']') {
			// Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
			line_end[-1] = 0;
			const char *name_end = line_end - 1;
			const char *type_start = line + 1;
			char *type_end = (char *)(void *)ImStrchrRange(type_start, name_end, ']');
			const char *name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
			if (!type_end || !name_start)
				continue;
			*type_end = 0; // Overwrite first ']'
			name_start++; // Skip second '['
			entry_handler = FindSettingsHandler(type_start);
			entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
		} else if (entry_handler != NULL && entry_data != NULL) {
			// Let type handler parse the line
			entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
		}
	}
	g.SettingsLoaded = true;

	// [DEBUG] Restore untouched copy so it can be browsed in Metrics (not strictly necessary)
	memcpy(buf, ini_data, ini_size);

	// Call post-read handlers
	for (ImGuiSettingsHandler &handler : g.SettingsHandlers)
		if (handler.ApplyAllFn != NULL)
			handler.ApplyAllFn(&g, &handler);
}

void ImGui::SaveIniSettingsToDisk(const char *ini_filename) {
	ImGuiContext &g = *GImGui;
	g.SettingsDirtyTimer = 0.0f;
	if (!ini_filename)
		return;

	size_t ini_data_size = 0;
	const char *ini_data = SaveIniSettingsToMemory(&ini_data_size);
	ImFileHandle f = ImFileOpen(ini_filename, "wt");
	if (!f)
		return;
	ImFileWrite(ini_data, sizeof(char), ini_data_size, f);
	ImFileClose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
const char *ImGui::SaveIniSettingsToMemory(size_t *out_size) {
	ImGuiContext &g = *GImGui;
	g.SettingsDirtyTimer = 0.0f;
	g.SettingsIniData.Buf.resize(0);
	g.SettingsIniData.Buf.push_back(0);
	for (ImGuiSettingsHandler &handler : g.SettingsHandlers)
		handler.WriteAllFn(&g, &handler, &g.SettingsIniData);
	if (out_size)
		*out_size = (size_t)g.SettingsIniData.size();
	return g.SettingsIniData.c_str();
}

ImGuiWindowSettings *ImGui::CreateNewWindowSettings(const char *name) {
	ImGuiContext &g = *GImGui;

	if (g.IO.ConfigDebugIniSettings == false) {
		// Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
		// Preserve the full string when ConfigDebugVerboseIniSettings is set to make .ini inspection easier.
		if (const char *p = strstr(name, "###"))
			name = p;
	}
	const size_t name_len = strlen(name);

	// Allocate chunk
	const size_t chunk_size = sizeof(ImGuiWindowSettings) + name_len + 1;
	ImGuiWindowSettings *settings = g.SettingsWindows.alloc_chunk(chunk_size);
	IM_PLACEMENT_NEW(settings)
	ImGuiWindowSettings();
	settings->ID = ImHashStr(name, name_len);
	memcpy(settings->GetName(), name, name_len + 1); // Store with zero terminator

	return settings;
}

// We don't provide a FindWindowSettingsByName() because Docking system doesn't always hold on names.
// This is called once per window .ini entry + once per newly instantiated window.
ImGuiWindowSettings *ImGui::FindWindowSettingsByID(ImGuiID id) {
	ImGuiContext &g = *GImGui;
	for (ImGuiWindowSettings *settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
		if (settings->ID == id && !settings->WantDelete)
			return settings;
	return NULL;
}

// This is faster if you are holding on a Window already as we don't need to perform a search.
ImGuiWindowSettings *ImGui::FindWindowSettingsByWindow(ImGuiWindow *window) {
	ImGuiContext &g = *GImGui;
	if (window->SettingsOffset != -1)
		return g.SettingsWindows.ptr_from_offset(window->SettingsOffset);
	return FindWindowSettingsByID(window->ID);
}

// This will revert window to its initial state, including enabling the ImGuiCond_FirstUseEver/ImGuiCond_Once conditions once more.
void ImGui::ClearWindowSettings(const char *name) {
	//IMGUI_DEBUG_LOG("ClearWindowSettings('%s')\n", name);
	ImGuiWindow *window = FindWindowByName(name);
	if (window != NULL) {
		window->Flags |= ImGuiWindowFlags_NoSavedSettings;
		InitOrLoadWindowSettings(window, NULL);
	}
	if (ImGuiWindowSettings *settings = window ? FindWindowSettingsByWindow(window) : FindWindowSettingsByID(ImHashStr(name)))
		settings->WantDelete = true;
}

static void WindowSettingsHandler_ClearAll(ImGuiContext *ctx, ImGuiSettingsHandler *) {
	ImGuiContext &g = *ctx;
	for (ImGuiWindow *window : g.Windows)
		window->SettingsOffset = -1;
	g.SettingsWindows.clear();
}

static void *WindowSettingsHandler_ReadOpen(ImGuiContext *, ImGuiSettingsHandler *, const char *name) {
	ImGuiID id = ImHashStr(name);
	ImGuiWindowSettings *settings = ImGui::FindWindowSettingsByID(id);
	if (settings)
		*settings = ImGuiWindowSettings(); // Clear existing if recycling previous entry
	else
		settings = ImGui::CreateNewWindowSettings(name);
	settings->ID = id;
	settings->WantApply = true;
	return (void *)settings;
}

static void WindowSettingsHandler_ReadLine(ImGuiContext *, ImGuiSettingsHandler *, void *entry, const char *line) {
	ImGuiWindowSettings *settings = (ImGuiWindowSettings *)entry;
	int x, y;
	int i;
	if (sscanf(line, "Pos=%i,%i", &x, &y) == 2) {
		settings->Pos = ImVec2ih((short)x, (short)y);
	} else if (sscanf(line, "Size=%i,%i", &x, &y) == 2) {
		settings->Size = ImVec2ih((short)x, (short)y);
	} else if (sscanf(line, "Collapsed=%d", &i) == 1) {
		settings->Collapsed = (i != 0);
	} else if (sscanf(line, "IsChild=%d", &i) == 1) {
		settings->IsChild = (i != 0);
	}
}

// Apply to existing windows (if any)
static void WindowSettingsHandler_ApplyAll(ImGuiContext *ctx, ImGuiSettingsHandler *) {
	ImGuiContext &g = *ctx;
	for (ImGuiWindowSettings *settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
		if (settings->WantApply) {
			if (ImGuiWindow *window = ImGui::FindWindowByID(settings->ID))
				ApplyWindowSettings(window, settings);
			settings->WantApply = false;
		}
}

static void WindowSettingsHandler_WriteAll(ImGuiContext *ctx, ImGuiSettingsHandler *handler, ImGuiTextBuffer *buf) {
	// Gather data from windows that were active during this session
	// (if a window wasn't opened in this session we preserve its settings)
	ImGuiContext &g = *ctx;
	for (ImGuiWindow *window : g.Windows) {
		if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
			continue;

		ImGuiWindowSettings *settings = ImGui::FindWindowSettingsByWindow(window);
		if (!settings) {
			settings = ImGui::CreateNewWindowSettings(window->Name);
			window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
		}
		IM_ASSERT(settings->ID == window->ID);
		settings->Pos = ImVec2ih(window->Pos);
		settings->Size = ImVec2ih(window->SizeFull);
		settings->IsChild = (window->Flags & ImGuiWindowFlags_ChildWindow) != 0;
		settings->Collapsed = window->Collapsed;
		settings->WantDelete = false;
	}

	// Write to text buffer
	buf->reserve(buf->size() + g.SettingsWindows.size() * 6); // ballpark reserve
	for (ImGuiWindowSettings *settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings)) {
		if (settings->WantDelete)
			continue;
		const char *settings_name = settings->GetName();
		buf->appendf("[%s][%s]\n", handler->TypeName, settings_name);
		if (settings->IsChild) {
			buf->appendf("IsChild=1\n");
			buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
		} else {
			buf->appendf("Pos=%d,%d\n", settings->Pos.x, settings->Pos.y);
			buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
			if (settings->Collapsed)
				buf->appendf("Collapsed=1\n");
		}
		buf->append("\n");
	}
}

//-----------------------------------------------------------------------------
// [SECTION] LOCALIZATION
//-----------------------------------------------------------------------------

void ImGui::LocalizeRegisterEntries(const ImGuiLocEntry *entries, int count) {
	ImGuiContext &g = *GImGui;
	for (int n = 0; n < count; n++)
		g.LocalizationTable[entries[n].Key] = entries[n].Text;
}

//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------
// - GetMainViewport()
// - SetWindowViewport() [Internal]
// - UpdateViewportsNewFrame() [Internal]
// (this section is more complete in the 'docking' branch)
//-----------------------------------------------------------------------------

ImGuiViewport *ImGui::GetMainViewport() {
	ImGuiContext &g = *GImGui;
	return g.Viewports[0];
}

void ImGui::SetWindowViewport(ImGuiWindow *window, ImGuiViewportP *viewport) {
	window->Viewport = viewport;
}

// Update viewports and monitor infos
static void ImGui::UpdateViewportsNewFrame() {
	ImGuiContext &g = *GImGui;
	IM_ASSERT(g.Viewports.Size == 1);

	// Update main viewport with current platform position.
	// FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
	ImGuiViewportP *main_viewport = g.Viewports[0];
	main_viewport->Flags = ImGuiViewportFlags_IsPlatformWindow | ImGuiViewportFlags_OwnedByApp;
	main_viewport->Pos = ImVec2(0.0f, 0.0f);
	main_viewport->Size = g.IO.DisplaySize;

	for (ImGuiViewportP *viewport : g.Viewports) {
		// Lock down space taken by menu bars and status bars
		// Setup initial value for functions like BeginMainMenuBar(), DockSpaceOverViewport() etc.
		viewport->WorkInsetMin = viewport->BuildWorkInsetMin;
		viewport->WorkInsetMax = viewport->BuildWorkInsetMax;
		viewport->BuildWorkInsetMin = viewport->BuildWorkInsetMax = ImVec2(0.0f, 0.0f);
		viewport->UpdateWorkRect();
	}
}

//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)

//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------
// - Default clipboard handlers
// - Default shell function handlers
// - Default IME handlers
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#pragma comment(lib, "kernel32")
#endif

// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
static const char *Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext *ctx) {
	ImGuiContext &g = *ctx;
	g.ClipboardHandlerData.clear();
	if (!::OpenClipboard(NULL))
		return NULL;
	HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
	if (wbuf_handle == NULL) {
		::CloseClipboard();
		return NULL;
	}
	if (const WCHAR *wbuf_global = (const WCHAR *)::GlobalLock(wbuf_handle)) {
		int buf_len = ::WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, NULL, 0, NULL, NULL);
		g.ClipboardHandlerData.resize(buf_len);
		::WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, g.ClipboardHandlerData.Data, buf_len, NULL, NULL);
	}
	::GlobalUnlock(wbuf_handle);
	::CloseClipboard();
	return g.ClipboardHandlerData.Data;
}

static void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext *, const char *text) {
	if (!::OpenClipboard(NULL))
		return;
	const int wbuf_length = ::MultiByteToWideChar(CP_UTF8, 0, text, -1, NULL, 0);
	HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(WCHAR));
	if (wbuf_handle == NULL) {
		::CloseClipboard();
		return;
	}
	WCHAR *wbuf_global = (WCHAR *)::GlobalLock(wbuf_handle);
	::MultiByteToWideChar(CP_UTF8, 0, text, -1, wbuf_global, wbuf_length);
	::GlobalUnlock(wbuf_handle);
	::EmptyClipboard();
	if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
		::GlobalFree(wbuf_handle);
	::CloseClipboard();
}

#elif defined(__APPLE__) && TARGET_OS_OSX && defined(IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS)

#include <Carbon/Carbon.h> // Use old API to avoid need for separate .mm file
static PasteboardRef main_clipboard = 0;

// OSX clipboard implementation
// If you enable this you will need to add '-framework ApplicationServices' to your linker command-line!
static void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext *, const char *text) {
	if (!main_clipboard)
		PasteboardCreate(kPasteboardClipboard, &main_clipboard);
	PasteboardClear(main_clipboard);
	CFDataRef cf_data = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)text, strlen(text));
	if (cf_data) {
		PasteboardPutItemFlavor(main_clipboard, (PasteboardItemID)1, CFSTR("public.utf8-plain-text"), cf_data, 0);
		CFRelease(cf_data);
	}
}

static const char *Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext *ctx) {
	ImGuiContext &g = *ctx;
	if (!main_clipboard)
		PasteboardCreate(kPasteboardClipboard, &main_clipboard);
	PasteboardSynchronize(main_clipboard);

	ItemCount item_count = 0;
	PasteboardGetItemCount(main_clipboard, &item_count);
	for (ItemCount i = 0; i < item_count; i++) {
		PasteboardItemID item_id = 0;
		PasteboardGetItemIdentifier(main_clipboard, i + 1, &item_id);
		CFArrayRef flavor_type_array = 0;
		PasteboardCopyItemFlavors(main_clipboard, item_id, &flavor_type_array);
		for (CFIndex j = 0, nj = CFArrayGetCount(flavor_type_array); j < nj; j++) {
			CFDataRef cf_data;
			if (PasteboardCopyItemFlavorData(main_clipboard, item_id, CFSTR("public.utf8-plain-text"), &cf_data) == noErr) {
				g.ClipboardHandlerData.clear();
				int length = (int)CFDataGetLength(cf_data);
				g.ClipboardHandlerData.resize(length + 1);
				CFDataGetBytes(cf_data, CFRangeMake(0, length), (UInt8 *)g.ClipboardHandlerData.Data);
				g.ClipboardHandlerData[length] = 0;
				CFRelease(cf_data);
				return g.ClipboardHandlerData.Data;
			}
		}
	}
	return NULL;
}

#else

// Local Dear ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers.
static const char *Platform_GetClipboardTextFn_DefaultImpl(ImGuiContext *ctx) {
	ImGuiContext &g = *ctx;
	return g.ClipboardHandlerData.empty() ? NULL : g.ClipboardHandlerData.begin();
}

static void Platform_SetClipboardTextFn_DefaultImpl(ImGuiContext *ctx, const char *text) {
	ImGuiContext &g = *ctx;
	g.ClipboardHandlerData.clear();
	const char *text_end = text + strlen(text);
	g.ClipboardHandlerData.resize((int)(text_end - text) + 1);
	memcpy(&g.ClipboardHandlerData[0], text, (size_t)(text_end - text));
	g.ClipboardHandlerData[(int)(text_end - text)] = 0;
}

#endif // Default clipboard handlers

//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
#if defined(__APPLE__) && TARGET_OS_IPHONE
#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
#endif

#if defined(_WIN32) && defined(IMGUI_DISABLE_WIN32_FUNCTIONS)
#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
#endif
#endif

#ifndef IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
#ifdef _WIN32
#include <shellapi.h> // ShellExecuteA()
#ifdef _MSC_VER
#pragma comment(lib, "shell32")
#endif
static bool Platform_OpenInShellFn_DefaultImpl(ImGuiContext *, const char *path) {
	return (INT_PTR)::ShellExecuteA(NULL, "open", path, NULL, NULL, SW_SHOWDEFAULT) > 32;
}
#else
#include <sys/wait.h>
#include <unistd.h>
static bool Platform_OpenInShellFn_DefaultImpl(ImGuiContext *, const char *path) {
#if defined(__APPLE__)
	const char *args[]{ "open", "--", path, NULL };
#else
	const char *args[]{ "xdg-open", path, NULL };
#endif
	pid_t pid = fork();
	if (pid < 0)
		return false;
	if (!pid) {
		execvp(args[0], const_cast<char **>(args));
		exit(-1);
	} else {
		int status;
		waitpid(pid, &status, 0);
		return WEXITSTATUS(status) == 0;
	}
}
#endif
#else
static bool Platform_OpenInShellFn_DefaultImpl(ImGuiContext *, const char *) {
	return false;
}
#endif // Default shell handlers

//-----------------------------------------------------------------------------

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void Platform_SetImeDataFn_DefaultImpl(ImGuiContext *, ImGuiViewport *viewport, ImGuiPlatformImeData *data) {
	// Notify OS Input Method Editor of text input position
	HWND hwnd = (HWND)viewport->PlatformHandleRaw;
	if (hwnd == 0)
		return;

	//::ImmAssociateContextEx(hwnd, NULL, data->WantVisible ? IACE_DEFAULT : 0);
	if (HIMC himc = ::ImmGetContext(hwnd)) {
		COMPOSITIONFORM composition_form = {};
		composition_form.ptCurrentPos.x = (LONG)data->InputPos.x;
		composition_form.ptCurrentPos.y = (LONG)data->InputPos.y;
		composition_form.dwStyle = CFS_FORCE_POSITION;
		::ImmSetCompositionWindow(himc, &composition_form);
		CANDIDATEFORM candidate_form = {};
		candidate_form.dwStyle = CFS_CANDIDATEPOS;
		candidate_form.ptCurrentPos.x = (LONG)data->InputPos.x;
		candidate_form.ptCurrentPos.y = (LONG)data->InputPos.y;
		::ImmSetCandidateWindow(himc, &candidate_form);
		::ImmReleaseContext(hwnd, himc);
	}
}

#else

static void Platform_SetImeDataFn_DefaultImpl(ImGuiContext *, ImGuiViewport *, ImGuiPlatformImeData *) {}

#endif // Default IME handlers

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUGGER WINDOW
//-----------------------------------------------------------------------------
// - DebugRenderViewportThumbnail() [Internal]
// - RenderViewportsThumbnails() [Internal]
// - DebugTextEncoding()
// - MetricsHelpMarker() [Internal]
// - ShowFontAtlas() [Internal]
// - ShowMetricsWindow()
// - DebugNodeColumns() [Internal]
// - DebugNodeDrawList() [Internal]
// - DebugNodeDrawCmdShowMeshAndBoundingBox() [Internal]
// - DebugNodeFont() [Internal]
// - DebugNodeFontGlyph() [Internal]
// - DebugNodeStorage() [Internal]
// - DebugNodeTabBar() [Internal]
// - DebugNodeViewport() [Internal]
// - DebugNodeWindow() [Internal]
// - DebugNodeWindowSettings() [Internal]
// - DebugNodeWindowsList() [Internal]
// - DebugNodeWindowsListByBeginStackParent() [Internal]
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_DEBUG_TOOLS

void ImGui::DebugRenderViewportThumbnail(ImDrawList *draw_list, ImGuiViewportP *viewport, const ImRect &bb) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	ImVec2 scale = bb.GetSize() / viewport->Size;
	ImVec2 off = bb.Min - viewport->Pos * scale;
	float alpha_mul = 1.0f;
	window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Border, alpha_mul * 0.40f));
	for (ImGuiWindow *thumb_window : g.Windows) {
		if (!thumb_window->WasActive || (thumb_window->Flags & ImGuiWindowFlags_ChildWindow))
			continue;

		ImRect thumb_r = thumb_window->Rect();
		ImRect title_r = thumb_window->TitleBarRect();
		thumb_r = ImRect(ImTrunc(off + thumb_r.Min * scale), ImTrunc(off + thumb_r.Max * scale));
		title_r = ImRect(ImTrunc(off + title_r.Min * scale), ImTrunc(off + ImVec2(title_r.Max.x, title_r.Min.y + title_r.GetHeight() * 3.0f) * scale)); // Exaggerate title bar height
		thumb_r.ClipWithFull(bb);
		title_r.ClipWithFull(bb);
		const bool window_is_focused = (g.NavWindow && thumb_window->RootWindowForTitleBarHighlight == g.NavWindow->RootWindowForTitleBarHighlight);
		window->DrawList->AddRectFilled(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_WindowBg, alpha_mul));
		window->DrawList->AddRectFilled(title_r.Min, title_r.Max, GetColorU32(window_is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg, alpha_mul));
		window->DrawList->AddRect(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_Border, alpha_mul));
		window->DrawList->AddText(g.Font, g.FontSize * 1.0f, title_r.Min, GetColorU32(ImGuiCol_Text, alpha_mul), thumb_window->Name, FindRenderedTextEnd(thumb_window->Name));
	}
	draw_list->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_Border, alpha_mul));
	if (viewport->ID == g.DebugMetricsConfig.HighlightViewportID)
		window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
}

static void RenderViewportsThumbnails() {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;

	float SCALE = 1.0f / 8.0f;
	ImRect bb_full(g.Viewports[0]->Pos, g.Viewports[0]->Pos + g.Viewports[0]->Size);
	ImVec2 p = window->DC.CursorPos;
	ImVec2 off = p - bb_full.Min * SCALE;

	// Draw viewports
	for (ImGuiViewportP *viewport : g.Viewports) {
		ImRect viewport_draw_bb(off + (viewport->Pos) * SCALE, off + (viewport->Pos + viewport->Size) * SCALE);
		ImGui::DebugRenderViewportThumbnail(window->DrawList, viewport, viewport_draw_bb);
	}
	ImGui::Dummy(bb_full.GetSize() * SCALE);
}

// Draw an arbitrary US keyboard layout to visualize translated keys
void ImGui::DebugRenderKeyboardPreview(ImDrawList *draw_list) {
	const float scale = ImGui::GetFontSize() / 13.0f;
	const ImVec2 key_size = ImVec2(35.0f, 35.0f) * scale;
	const float key_rounding = 3.0f * scale;
	const ImVec2 key_face_size = ImVec2(25.0f, 25.0f) * scale;
	const ImVec2 key_face_pos = ImVec2(5.0f, 3.0f) * scale;
	const float key_face_rounding = 2.0f * scale;
	const ImVec2 key_label_pos = ImVec2(7.0f, 4.0f) * scale;
	const ImVec2 key_step = ImVec2(key_size.x - 1.0f, key_size.y - 1.0f);
	const float key_row_offset = 9.0f * scale;

	ImVec2 board_min = GetCursorScreenPos();
	ImVec2 board_max = ImVec2(board_min.x + 3 * key_step.x + 2 * key_row_offset + 10.0f, board_min.y + 3 * key_step.y + 10.0f);
	ImVec2 start_pos = ImVec2(board_min.x + 5.0f - key_step.x, board_min.y);

	struct KeyLayoutData {
		int Row, Col;
		const char *Label;
		ImGuiKey Key;
	};
	const KeyLayoutData keys_to_display[] = {
		{ 0, 0, "", ImGuiKey_Tab }, { 0, 1, "Q", ImGuiKey_Q }, { 0, 2, "W", ImGuiKey_W }, { 0, 3, "E", ImGuiKey_E }, { 0, 4, "R", ImGuiKey_R },
		{ 1, 0, "", ImGuiKey_CapsLock }, { 1, 1, "A", ImGuiKey_A }, { 1, 2, "S", ImGuiKey_S }, { 1, 3, "D", ImGuiKey_D }, { 1, 4, "F", ImGuiKey_F },
		{ 2, 0, "", ImGuiKey_LeftShift }, { 2, 1, "Z", ImGuiKey_Z }, { 2, 2, "X", ImGuiKey_X }, { 2, 3, "C", ImGuiKey_C }, { 2, 4, "V", ImGuiKey_V }
	};

	// Elements rendered manually via ImDrawList API are not clipped automatically.
	// While not strictly necessary, here IsItemVisible() is used to avoid rendering these shapes when they are out of view.
	Dummy(board_max - board_min);
	if (!IsItemVisible())
		return;
	draw_list->PushClipRect(board_min, board_max, true);
	for (int n = 0; n < IM_ARRAYSIZE(keys_to_display); n++) {
		const KeyLayoutData *key_data = &keys_to_display[n];
		ImVec2 key_min = ImVec2(start_pos.x + key_data->Col * key_step.x + key_data->Row * key_row_offset, start_pos.y + key_data->Row * key_step.y);
		ImVec2 key_max = key_min + key_size;
		draw_list->AddRectFilled(key_min, key_max, IM_COL32(204, 204, 204, 255), key_rounding);
		draw_list->AddRect(key_min, key_max, IM_COL32(24, 24, 24, 255), key_rounding);
		ImVec2 face_min = ImVec2(key_min.x + key_face_pos.x, key_min.y + key_face_pos.y);
		ImVec2 face_max = ImVec2(face_min.x + key_face_size.x, face_min.y + key_face_size.y);
		draw_list->AddRect(face_min, face_max, IM_COL32(193, 193, 193, 255), key_face_rounding, ImDrawFlags_None, 2.0f);
		draw_list->AddRectFilled(face_min, face_max, IM_COL32(252, 252, 252, 255), key_face_rounding);
		ImVec2 label_min = ImVec2(key_min.x + key_label_pos.x, key_min.y + key_label_pos.y);
		draw_list->AddText(label_min, IM_COL32(64, 64, 64, 255), key_data->Label);
		if (IsKeyDown(key_data->Key))
			draw_list->AddRectFilled(key_min, key_max, IM_COL32(255, 0, 0, 128), key_rounding);
	}
	draw_list->PopClipRect();
}

// Helper tool to diagnose between text encoding issues and font loading issues. Pass your UTF-8 string and verify that there are correct.
void ImGui::DebugTextEncoding(const char *str) {
	Text("Text: \"%s\"", str);
	if (!BeginTable("##DebugTextEncoding", 4, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Resizable))
		return;
	TableSetupColumn("Offset");
	TableSetupColumn("UTF-8");
	TableSetupColumn("Glyph");
	TableSetupColumn("Codepoint");
	TableHeadersRow();
	for (const char *p = str; *p != 0;) {
		unsigned int c;
		const int c_utf8_len = ImTextCharFromUtf8(&c, p, NULL);
		TableNextColumn();
		Text("%d", (int)(p - str));
		TableNextColumn();
		for (int byte_index = 0; byte_index < c_utf8_len; byte_index++) {
			if (byte_index > 0)
				SameLine();
			Text("0x%02X", (int)(unsigned char)p[byte_index]);
		}
		TableNextColumn();
		if (GetFont()->FindGlyphNoFallback((ImWchar)c))
			TextUnformatted(p, p + c_utf8_len);
		else
			TextUnformatted((c == IM_UNICODE_CODEPOINT_INVALID) ? "[invalid]" : "[missing]");
		TableNextColumn();
		Text("U+%04X", (int)c);
		p += c_utf8_len;
	}
	EndTable();
}

static void DebugFlashStyleColorStop() {
	ImGuiContext &g = *GImGui;
	if (g.DebugFlashStyleColorIdx != ImGuiCol_COUNT)
		g.Style.Colors[g.DebugFlashStyleColorIdx] = g.DebugFlashStyleColorBackup;
	g.DebugFlashStyleColorIdx = ImGuiCol_COUNT;
}

// Flash a given style color for some + inhibit modifications of this color via PushStyleColor() calls.
void ImGui::DebugFlashStyleColor(ImGuiCol idx) {
	ImGuiContext &g = *GImGui;
	DebugFlashStyleColorStop();
	g.DebugFlashStyleColorTime = 0.5f;
	g.DebugFlashStyleColorIdx = idx;
	g.DebugFlashStyleColorBackup = g.Style.Colors[idx];
}

void ImGui::UpdateDebugToolFlashStyleColor() {
	ImGuiContext &g = *GImGui;
	if (g.DebugFlashStyleColorTime <= 0.0f)
		return;
	ColorConvertHSVtoRGB(ImCos(g.DebugFlashStyleColorTime * 6.0f) * 0.5f + 0.5f, 0.5f, 0.5f, g.Style.Colors[g.DebugFlashStyleColorIdx].x, g.Style.Colors[g.DebugFlashStyleColorIdx].y, g.Style.Colors[g.DebugFlashStyleColorIdx].z);
	g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0f;
	if ((g.DebugFlashStyleColorTime -= g.IO.DeltaTime) <= 0.0f)
		DebugFlashStyleColorStop();
}

// Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
static void MetricsHelpMarker(const char *desc) {
	ImGui::TextDisabled("(?)");
	if (ImGui::BeginItemTooltip()) {
		ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
		ImGui::TextUnformatted(desc);
		ImGui::PopTextWrapPos();
		ImGui::EndTooltip();
	}
}

// [DEBUG] List fonts in a font atlas and display its texture
void ImGui::ShowFontAtlas(ImFontAtlas *atlas) {
	for (ImFont *font : atlas->Fonts) {
		PushID(font);
		DebugNodeFont(font);
		PopID();
	}
	if (TreeNode("Font Atlas", "Font Atlas (%dx%d pixels)", atlas->TexWidth, atlas->TexHeight)) {
		ImGuiContext &g = *GImGui;
		ImGuiMetricsConfig *cfg = &g.DebugMetricsConfig;
		Checkbox("Tint with Text Color", &cfg->ShowAtlasTintedWithTextColor); // Using text color ensure visibility of core atlas data, but will alter custom colored icons
		ImVec4 tint_col = cfg->ShowAtlasTintedWithTextColor ? GetStyleColorVec4(ImGuiCol_Text) : ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
		ImVec4 border_col = GetStyleColorVec4(ImGuiCol_Border);
		Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f), tint_col, border_col);
		TreePop();
	}
}

void ImGui::ShowMetricsWindow(bool *p_open) {
	ImGuiContext &g = *GImGui;
	ImGuiIO &io = g.IO;
	ImGuiMetricsConfig *cfg = &g.DebugMetricsConfig;
	if (cfg->ShowDebugLog)
		ShowDebugLogWindow(&cfg->ShowDebugLog);
	if (cfg->ShowIDStackTool)
		ShowIDStackToolWindow(&cfg->ShowIDStackTool);

	if (!Begin("Dear ImGui Metrics/Debugger", p_open) || GetCurrentWindow()->BeginCount > 1) {
		End();
		return;
	}

	// [DEBUG] Clear debug breaks hooks after exactly one cycle.
	DebugBreakClearData();

	// Basic info
	Text("Dear ImGui %s", GetVersion());
	if (g.ContextName[0] != 0) {
		SameLine();
		Text("(Context Name: \"%s\")", g.ContextName);
	}
	Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
	Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
	Text("%d visible windows, %d current allocations", io.MetricsRenderWindows, g.DebugAllocInfo.TotalAllocCount - g.DebugAllocInfo.TotalFreeCount);
	//SameLine(); if (SmallButton("GC")) { g.GcCompactAll = true; }

	Separator();

	// Debugging enums
	enum { WRT_OuterRect,
		WRT_OuterRectClipped,
		WRT_InnerRect,
		WRT_InnerClipRect,
		WRT_WorkRect,
		WRT_Content,
		WRT_ContentIdeal,
		WRT_ContentRegionRect,
		WRT_Count }; // Windows Rect Type
	const char *wrt_rects_names[WRT_Count] = { "OuterRect", "OuterRectClipped", "InnerRect", "InnerClipRect", "WorkRect", "Content", "ContentIdeal", "ContentRegionRect" };
	enum { TRT_OuterRect,
		TRT_InnerRect,
		TRT_WorkRect,
		TRT_HostClipRect,
		TRT_InnerClipRect,
		TRT_BackgroundClipRect,
		TRT_ColumnsRect,
		TRT_ColumnsWorkRect,
		TRT_ColumnsClipRect,
		TRT_ColumnsContentHeadersUsed,
		TRT_ColumnsContentHeadersIdeal,
		TRT_ColumnsContentFrozen,
		TRT_ColumnsContentUnfrozen,
		TRT_Count }; // Tables Rect Type
	const char *trt_rects_names[TRT_Count] = { "OuterRect", "InnerRect", "WorkRect", "HostClipRect", "InnerClipRect", "BackgroundClipRect", "ColumnsRect", "ColumnsWorkRect", "ColumnsClipRect", "ColumnsContentHeadersUsed", "ColumnsContentHeadersIdeal", "ColumnsContentFrozen", "ColumnsContentUnfrozen" };
	if (cfg->ShowWindowsRectsType < 0)
		cfg->ShowWindowsRectsType = WRT_WorkRect;
	if (cfg->ShowTablesRectsType < 0)
		cfg->ShowTablesRectsType = TRT_WorkRect;

	struct Funcs {
		static ImRect GetTableRect(ImGuiTable *table, int rect_type, int n) {
			ImGuiTableInstanceData *table_instance = TableGetInstanceData(table, table->InstanceCurrent); // Always using last submitted instance
			if (rect_type == TRT_OuterRect) {
				return table->OuterRect;
			} else if (rect_type == TRT_InnerRect) {
				return table->InnerRect;
			} else if (rect_type == TRT_WorkRect) {
				return table->WorkRect;
			} else if (rect_type == TRT_HostClipRect) {
				return table->HostClipRect;
			} else if (rect_type == TRT_InnerClipRect) {
				return table->InnerClipRect;
			} else if (rect_type == TRT_BackgroundClipRect) {
				return table->BgClipRect;
			} else if (rect_type == TRT_ColumnsRect) {
				ImGuiTableColumn *c = &table->Columns[n];
				return ImRect(c->MinX, table->InnerClipRect.Min.y, c->MaxX, table->InnerClipRect.Min.y + table_instance->LastOuterHeight);
			} else if (rect_type == TRT_ColumnsWorkRect) {
				ImGuiTableColumn *c = &table->Columns[n];
				return ImRect(c->WorkMinX, table->WorkRect.Min.y, c->WorkMaxX, table->WorkRect.Max.y);
			} else if (rect_type == TRT_ColumnsClipRect) {
				ImGuiTableColumn *c = &table->Columns[n];
				return c->ClipRect;
			} else if (rect_type == TRT_ColumnsContentHeadersUsed) {
				ImGuiTableColumn *c = &table->Columns[n];
				return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXHeadersUsed, table->InnerClipRect.Min.y + table_instance->LastTopHeadersRowHeight);
			} // Note: y1/y2 not always accurate
			else if (rect_type == TRT_ColumnsContentHeadersIdeal) {
				ImGuiTableColumn *c = &table->Columns[n];
				return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXHeadersIdeal, table->InnerClipRect.Min.y + table_instance->LastTopHeadersRowHeight);
			} else if (rect_type == TRT_ColumnsContentFrozen) {
				ImGuiTableColumn *c = &table->Columns[n];
				return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXFrozen, table->InnerClipRect.Min.y + table_instance->LastFrozenHeight);
			} else if (rect_type == TRT_ColumnsContentUnfrozen) {
				ImGuiTableColumn *c = &table->Columns[n];
				return ImRect(c->WorkMinX, table->InnerClipRect.Min.y + table_instance->LastFrozenHeight, c->ContentMaxXUnfrozen, table->InnerClipRect.Max.y);
			}
			IM_ASSERT(0);
			return ImRect();
		}

		static ImRect GetWindowRect(ImGuiWindow *window, int rect_type) {
			if (rect_type == WRT_OuterRect) {
				return window->Rect();
			} else if (rect_type == WRT_OuterRectClipped) {
				return window->OuterRectClipped;
			} else if (rect_type == WRT_InnerRect) {
				return window->InnerRect;
			} else if (rect_type == WRT_InnerClipRect) {
				return window->InnerClipRect;
			} else if (rect_type == WRT_WorkRect) {
				return window->WorkRect;
			} else if (rect_type == WRT_Content) {
				ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding;
				return ImRect(min, min + window->ContentSize);
			} else if (rect_type == WRT_ContentIdeal) {
				ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding;
				return ImRect(min, min + window->ContentSizeIdeal);
			} else if (rect_type == WRT_ContentRegionRect) {
				return window->ContentRegionRect;
			}
			IM_ASSERT(0);
			return ImRect();
		}
	};

	// Tools
	if (TreeNode("Tools")) {
		// Debug Break features
		// The Item Picker tool is super useful to visually select an item and break into the call-stack of where it was submitted.
		SeparatorTextEx(0, "Debug breaks", NULL, CalcTextSize("(?)").x + g.Style.SeparatorTextPadding.x);
		SameLine();
		MetricsHelpMarker("Will call the IM_DEBUG_BREAK() macro to break in debugger.\nWarning: If you don't have a debugger attached, this will probably crash.");
		if (Checkbox("Show Item Picker", &g.DebugItemPickerActive) && g.DebugItemPickerActive)
			DebugStartItemPicker();
		Checkbox("Show \"Debug Break\" buttons in other sections (io.ConfigDebugIsDebuggerPresent)", &g.IO.ConfigDebugIsDebuggerPresent);

		SeparatorText("Visualize");

		Checkbox("Show Debug Log", &cfg->ShowDebugLog);
		SameLine();
		MetricsHelpMarker("You can also call ImGui::ShowDebugLogWindow() from your code.");

		Checkbox("Show ID Stack Tool", &cfg->ShowIDStackTool);
		SameLine();
		MetricsHelpMarker("You can also call ImGui::ShowIDStackToolWindow() from your code.");

		Checkbox("Show windows begin order", &cfg->ShowWindowsBeginOrder);
		Checkbox("Show windows rectangles", &cfg->ShowWindowsRects);
		SameLine();
		SetNextItemWidth(GetFontSize() * 12);
		cfg->ShowWindowsRects |= Combo("##show_windows_rect_type", &cfg->ShowWindowsRectsType, wrt_rects_names, WRT_Count, WRT_Count);
		if (cfg->ShowWindowsRects && g.NavWindow != NULL) {
			BulletText("'%s':", g.NavWindow->Name);
			Indent();
			for (int rect_n = 0; rect_n < WRT_Count; rect_n++) {
				ImRect r = Funcs::GetWindowRect(g.NavWindow, rect_n);
				Text("(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), wrt_rects_names[rect_n]);
			}
			Unindent();
		}

		Checkbox("Show tables rectangles", &cfg->ShowTablesRects);
		SameLine();
		SetNextItemWidth(GetFontSize() * 12);
		cfg->ShowTablesRects |= Combo("##show_table_rects_type", &cfg->ShowTablesRectsType, trt_rects_names, TRT_Count, TRT_Count);
		if (cfg->ShowTablesRects && g.NavWindow != NULL) {
			for (int table_n = 0; table_n < g.Tables.GetMapSize(); table_n++) {
				ImGuiTable *table = g.Tables.TryGetMapData(table_n);
				if (table == NULL || table->LastFrameActive < g.FrameCount - 1 || (table->OuterWindow != g.NavWindow && table->InnerWindow != g.NavWindow))
					continue;

				BulletText("Table 0x%08X (%d columns, in '%s')", table->ID, table->ColumnsCount, table->OuterWindow->Name);
				if (IsItemHovered())
					GetForegroundDrawList()->AddRect(table->OuterRect.Min - ImVec2(1, 1), table->OuterRect.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
				Indent();
				char buf[128];
				for (int rect_n = 0; rect_n < TRT_Count; rect_n++) {
					if (rect_n >= TRT_ColumnsRect) {
						if (rect_n != TRT_ColumnsRect && rect_n != TRT_ColumnsClipRect)
							continue;
						for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
							ImRect r = Funcs::GetTableRect(table, rect_n, column_n);
							ImFormatString(buf, IM_ARRAYSIZE(buf), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) Col %d %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), column_n, trt_rects_names[rect_n]);
							Selectable(buf);
							if (IsItemHovered())
								GetForegroundDrawList()->AddRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
						}
					} else {
						ImRect r = Funcs::GetTableRect(table, rect_n, -1);
						ImFormatString(buf, IM_ARRAYSIZE(buf), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), trt_rects_names[rect_n]);
						Selectable(buf);
						if (IsItemHovered())
							GetForegroundDrawList()->AddRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
					}
				}
				Unindent();
			}
		}
		Checkbox("Show groups rectangles", &g.DebugShowGroupRects); // Storing in context as this is used by group code and prefers to be in hot-data

		SeparatorText("Validate");

		Checkbox("Debug Begin/BeginChild return value", &io.ConfigDebugBeginReturnValueLoop);
		SameLine();
		MetricsHelpMarker("Some calls to Begin()/BeginChild() will return false.\n\nWill cycle through window depths then repeat. Windows should be flickering while running.");

		Checkbox("UTF-8 Encoding viewer", &cfg->ShowTextEncodingViewer);
		SameLine();
		MetricsHelpMarker("You can also call ImGui::DebugTextEncoding() from your code with a given string to test that your UTF-8 encoding settings are correct.");
		if (cfg->ShowTextEncodingViewer) {
			static char buf[64] = "";
			SetNextItemWidth(-FLT_MIN);
			InputText("##DebugTextEncodingBuf", buf, IM_ARRAYSIZE(buf));
			if (buf[0] != 0)
				DebugTextEncoding(buf);
		}

		TreePop();
	}

	// Windows
	if (TreeNode("Windows", "Windows (%d)", g.Windows.Size)) {
		//SetNextItemOpen(true, ImGuiCond_Once);
		DebugNodeWindowsList(&g.Windows, "By display order");
		DebugNodeWindowsList(&g.WindowsFocusOrder, "By focus order (root windows)");
		if (TreeNode("By submission order (begin stack)")) {
			// Here we display windows in their submitted order/hierarchy, however note that the Begin stack doesn't constitute a Parent<>Child relationship!
			ImVector<ImGuiWindow *> &temp_buffer = g.WindowsTempSortBuffer;
			temp_buffer.resize(0);
			for (ImGuiWindow *window : g.Windows)
				if (window->LastFrameActive + 1 >= g.FrameCount)
					temp_buffer.push_back(window);
			struct Func {
				static int IMGUI_CDECL WindowComparerByBeginOrder(const void *lhs, const void *rhs) { return ((int)(*(const ImGuiWindow *const *)lhs)->BeginOrderWithinContext - (*(const ImGuiWindow *const *)rhs)->BeginOrderWithinContext); }
			};
			ImQsort(temp_buffer.Data, (size_t)temp_buffer.Size, sizeof(ImGuiWindow *), Func::WindowComparerByBeginOrder);
			DebugNodeWindowsListByBeginStackParent(temp_buffer.Data, temp_buffer.Size, NULL);
			TreePop();
		}

		TreePop();
	}

	// DrawLists
	int drawlist_count = 0;
	for (ImGuiViewportP *viewport : g.Viewports)
		drawlist_count += viewport->DrawDataP.CmdLists.Size;
	if (TreeNode("DrawLists", "DrawLists (%d)", drawlist_count)) {
		Checkbox("Show ImDrawCmd mesh when hovering", &cfg->ShowDrawCmdMesh);
		Checkbox("Show ImDrawCmd bounding boxes when hovering", &cfg->ShowDrawCmdBoundingBoxes);
		for (ImGuiViewportP *viewport : g.Viewports)
			for (ImDrawList *draw_list : viewport->DrawDataP.CmdLists)
				DebugNodeDrawList(NULL, viewport, draw_list, "DrawList");
		TreePop();
	}

	// Viewports
	if (TreeNode("Viewports", "Viewports (%d)", g.Viewports.Size)) {
		SetNextItemOpen(true, ImGuiCond_Once);
		if (TreeNode("Windows Minimap")) {
			RenderViewportsThumbnails();
			TreePop();
		}
		cfg->HighlightViewportID = 0;

		for (ImGuiViewportP *viewport : g.Viewports)
			DebugNodeViewport(viewport);
		TreePop();
	}

	// Details for Popups
	if (TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size)) {
		for (const ImGuiPopupData &popup_data : g.OpenPopupStack) {
			// As it's difficult to interact with tree nodes while popups are open, we display everything inline.
			ImGuiWindow *window = popup_data.Window;
			BulletText("PopupID: %08x, Window: '%s' (%s%s), RestoreNavWindow '%s', ParentWindow '%s'",
					popup_data.PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? "Child;" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? "Menu;" : "",
					popup_data.RestoreNavWindow ? popup_data.RestoreNavWindow->Name : "NULL", window && window->ParentWindow ? window->ParentWindow->Name : "NULL");
		}
		TreePop();
	}

	// Details for TabBars
	if (TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.GetAliveCount())) {
		for (int n = 0; n < g.TabBars.GetMapSize(); n++)
			if (ImGuiTabBar *tab_bar = g.TabBars.TryGetMapData(n)) {
				PushID(tab_bar);
				DebugNodeTabBar(tab_bar, "TabBar");
				PopID();
			}
		TreePop();
	}

	// Details for Tables
	if (TreeNode("Tables", "Tables (%d)", g.Tables.GetAliveCount())) {
		for (int n = 0; n < g.Tables.GetMapSize(); n++)
			if (ImGuiTable *table = g.Tables.TryGetMapData(n))
				DebugNodeTable(table);
		TreePop();
	}

	// Details for Fonts
	ImFontAtlas *atlas = g.IO.Fonts;
	if (TreeNode("Fonts", "Fonts (%d)", atlas->Fonts.Size)) {
		ShowFontAtlas(atlas);
		TreePop();
	}

	// Details for InputText
	if (TreeNode("InputText")) {
		DebugNodeInputTextState(&g.InputTextState);
		TreePop();
	}

	// Details for TypingSelect
	if (TreeNode("TypingSelect", "TypingSelect (%d)", g.TypingSelectState.SearchBuffer[0] != 0 ? 1 : 0)) {
		DebugNodeTypingSelectState(&g.TypingSelectState);
		TreePop();
	}

	// Details for MultiSelect
	if (TreeNode("MultiSelect", "MultiSelect (%d)", g.MultiSelectStorage.GetAliveCount())) {
		ImGuiBoxSelectState *bs = &g.BoxSelectState;
		BulletText("BoxSelect ID=0x%08X, Starting = %d, Active %d", bs->ID, bs->IsStarting, bs->IsActive);
		for (int n = 0; n < g.MultiSelectStorage.GetMapSize(); n++)
			if (ImGuiMultiSelectState *state = g.MultiSelectStorage.TryGetMapData(n))
				DebugNodeMultiSelectState(state);
		TreePop();
	}

	// Details for Docking
#ifdef IMGUI_HAS_DOCK
	if (TreeNode("Docking")) {
		TreePop();
	}
#endif // #ifdef IMGUI_HAS_DOCK

	// Settings
	if (TreeNode("Settings")) {
		if (SmallButton("Clear"))
			ClearIniSettings();
		SameLine();
		if (SmallButton("Save to memory"))
			SaveIniSettingsToMemory();
		SameLine();
		if (SmallButton("Save to disk"))
			SaveIniSettingsToDisk(g.IO.IniFilename);
		SameLine();
		if (g.IO.IniFilename)
			Text("\"%s\"", g.IO.IniFilename);
		else
			TextUnformatted("<NULL>");
		Checkbox("io.ConfigDebugIniSettings", &io.ConfigDebugIniSettings);
		Text("SettingsDirtyTimer %.2f", g.SettingsDirtyTimer);
		if (TreeNode("SettingsHandlers", "Settings handlers: (%d)", g.SettingsHandlers.Size)) {
			for (ImGuiSettingsHandler &handler : g.SettingsHandlers)
				BulletText("\"%s\"", handler.TypeName);
			TreePop();
		}
		if (TreeNode("SettingsWindows", "Settings packed data: Windows: %d bytes", g.SettingsWindows.size())) {
			for (ImGuiWindowSettings *settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
				DebugNodeWindowSettings(settings);
			TreePop();
		}

		if (TreeNode("SettingsTables", "Settings packed data: Tables: %d bytes", g.SettingsTables.size())) {
			for (ImGuiTableSettings *settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
				DebugNodeTableSettings(settings);
			TreePop();
		}

#ifdef IMGUI_HAS_DOCK
#endif // #ifdef IMGUI_HAS_DOCK

		if (TreeNode("SettingsIniData", "Settings unpacked data (.ini): %d bytes", g.SettingsIniData.size())) {
			InputTextMultiline("##Ini", (char *)(void *)g.SettingsIniData.c_str(), g.SettingsIniData.Buf.Size, ImVec2(-FLT_MIN, GetTextLineHeight() * 20), ImGuiInputTextFlags_ReadOnly);
			TreePop();
		}
		TreePop();
	}

	// Settings
	if (TreeNode("Memory allocations")) {
		ImGuiDebugAllocInfo *info = &g.DebugAllocInfo;
		Text("%d current allocations", info->TotalAllocCount - info->TotalFreeCount);
		if (SmallButton("GC now")) {
			g.GcCompactAll = true;
		}
		Text("Recent frames with allocations:");
		int buf_size = IM_ARRAYSIZE(info->LastEntriesBuf);
		for (int n = buf_size - 1; n >= 0; n--) {
			ImGuiDebugAllocEntry *entry = &info->LastEntriesBuf[(info->LastEntriesIdx - n + buf_size) % buf_size];
			BulletText("Frame %06d: %+3d ( %2d alloc, %2d free )", entry->FrameCount, entry->AllocCount - entry->FreeCount, entry->AllocCount, entry->FreeCount);
			if (n == 0) {
				SameLine();
				Text("<- %d frames ago", g.FrameCount - entry->FrameCount);
			}
		}
		TreePop();
	}

	if (TreeNode("Inputs")) {
		Text("KEYBOARD/GAMEPAD/MOUSE KEYS");
		{
			// We iterate both legacy native range and named ImGuiKey ranges, which is a little odd but this allows displaying the data for old/new backends.
			// User code should never have to go through such hoops! You can generally iterate between ImGuiKey_NamedKey_BEGIN and ImGuiKey_NamedKey_END.
			Indent();
#ifdef IMGUI_DISABLE_OBSOLETE_KEYIO
			struct funcs {
				static bool IsLegacyNativeDupe(ImGuiKey) { return false; }
			};
#else
			struct funcs {
				static bool IsLegacyNativeDupe(ImGuiKey key) { return key >= 0 && key < 512 && GetIO().KeyMap[key] != -1; }
			}; // Hide Native<>ImGuiKey duplicates when both exists in the array
			//Text("Legacy raw:");      for (ImGuiKey key = ImGuiKey_KeysData_OFFSET; key < ImGuiKey_COUNT; key++) { if (io.KeysDown[key]) { SameLine(); Text("\"%s\" %d", GetKeyName(key), key); } }
#endif
			Text("Keys down:");
			for (ImGuiKey key = ImGuiKey_KeysData_OFFSET; key < ImGuiKey_COUNT; key = (ImGuiKey)(key + 1)) {
				if (funcs::IsLegacyNativeDupe(key) || !IsKeyDown(key))
					continue;
				SameLine();
				Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key);
				SameLine();
				Text("(%.02f)", GetKeyData(key)->DownDuration);
			}
			Text("Keys pressed:");
			for (ImGuiKey key = ImGuiKey_KeysData_OFFSET; key < ImGuiKey_COUNT; key = (ImGuiKey)(key + 1)) {
				if (funcs::IsLegacyNativeDupe(key) || !IsKeyPressed(key))
					continue;
				SameLine();
				Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key);
			}
			Text("Keys released:");
			for (ImGuiKey key = ImGuiKey_KeysData_OFFSET; key < ImGuiKey_COUNT; key = (ImGuiKey)(key + 1)) {
				if (funcs::IsLegacyNativeDupe(key) || !IsKeyReleased(key))
					continue;
				SameLine();
				Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key);
			}
			Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "");
			Text("Chars queue:");
			for (int i = 0; i < io.InputQueueCharacters.Size; i++) {
				ImWchar c = io.InputQueueCharacters[i];
				SameLine();
				Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? (char)c : '?', c);
			} // FIXME: We should convert 'c' to UTF-8 here but the functions are not public.
			DebugRenderKeyboardPreview(GetWindowDrawList());
			Unindent();
		}

		Text("MOUSE STATE");
		{
			Indent();
			if (IsMousePosValid())
				Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);
			else
				Text("Mouse pos: <INVALID>");
			Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y);
			int count = IM_ARRAYSIZE(io.MouseDown);
			Text("Mouse down:");
			for (int i = 0; i < count; i++)
				if (IsMouseDown(i)) {
					SameLine();
					Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]);
				}
			Text("Mouse clicked:");
			for (int i = 0; i < count; i++)
				if (IsMouseClicked(i)) {
					SameLine();
					Text("b%d (%d)", i, io.MouseClickedCount[i]);
				}
			Text("Mouse released:");
			for (int i = 0; i < count; i++)
				if (IsMouseReleased(i)) {
					SameLine();
					Text("b%d", i);
				}
			Text("Mouse wheel: %.1f", io.MouseWheel);
			Text("MouseStationaryTimer: %.2f", g.MouseStationaryTimer);
			Text("Mouse source: %s", GetMouseSourceName(io.MouseSource));
			Text("Pen Pressure: %.1f", io.PenPressure); // Note: currently unused
			Unindent();
		}

		Text("MOUSE WHEELING");
		{
			Indent();
			Text("WheelingWindow: '%s'", g.WheelingWindow ? g.WheelingWindow->Name : "NULL");
			Text("WheelingWindowReleaseTimer: %.2f", g.WheelingWindowReleaseTimer);
			Text("WheelingAxisAvg[] = { %.3f, %.3f }, Main Axis: %s", g.WheelingAxisAvg.x, g.WheelingAxisAvg.y, (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? "X" : (g.WheelingAxisAvg.x < g.WheelingAxisAvg.y) ? "Y"
																																																				: "<none>");
			Unindent();
		}

		Text("KEY OWNERS");
		{
			Indent();
			if (BeginChild("##owners", ImVec2(-FLT_MIN, GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY, ImGuiWindowFlags_NoSavedSettings))
				for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1)) {
					ImGuiKeyOwnerData *owner_data = GetKeyOwnerData(&g, key);
					if (owner_data->OwnerCurr == ImGuiKeyOwner_NoOwner)
						continue;
					Text("%s: 0x%08X%s", GetKeyName(key), owner_data->OwnerCurr,
							owner_data->LockUntilRelease ? " LockUntilRelease" : owner_data->LockThisFrame ? " LockThisFrame"
																										   : "");
					DebugLocateItemOnHover(owner_data->OwnerCurr);
				}
			EndChild();
			Unindent();
		}
		Text("SHORTCUT ROUTING");
		SameLine();
		MetricsHelpMarker("Declared shortcut routes automatically set key owner when mods matches.");
		{
			Indent();
			if (BeginChild("##routes", ImVec2(-FLT_MIN, GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY, ImGuiWindowFlags_NoSavedSettings))
				for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1)) {
					ImGuiKeyRoutingTable *rt = &g.KeysRoutingTable;
					for (ImGuiKeyRoutingIndex idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; idx != -1;) {
						ImGuiKeyRoutingData *routing_data = &rt->Entries[idx];
						ImGuiKeyChord key_chord = key | routing_data->Mods;
						Text("%s: 0x%08X (scored %d)", GetKeyChordName(key_chord), routing_data->RoutingCurr, routing_data->RoutingCurrScore);
						DebugLocateItemOnHover(routing_data->RoutingCurr);
						if (g.IO.ConfigDebugIsDebuggerPresent) {
							SameLine();
							if (DebugBreakButton("**DebugBreak**", "in SetShortcutRouting() for this KeyChord"))
								g.DebugBreakInShortcutRouting = key_chord;
						}
						idx = routing_data->NextEntryIndex;
					}
				}
			EndChild();
			Text("(ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: 0x%X)", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
			Unindent();
		}
		TreePop();
	}

	if (TreeNode("Internal state")) {
		Text("WINDOWING");
		Indent();
		Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
		Text("HoveredWindow->Root: '%s'", g.HoveredWindow ? g.HoveredWindow->RootWindow->Name : "NULL");
		Text("HoveredWindowUnderMovingWindow: '%s'", g.HoveredWindowUnderMovingWindow ? g.HoveredWindowUnderMovingWindow->Name : "NULL");
		Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
		Unindent();

		Text("ITEMS");
		Indent();
		Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, GetInputSourceName(g.ActiveIdSource));
		DebugLocateItemOnHover(g.ActiveId);
		Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
		Text("ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: %X", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
		Text("HoveredId: 0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Not displaying g.HoveredId as it is update mid-frame
		Text("HoverItemDelayId: 0x%08X, Timer: %.2f, ClearTimer: %.2f", g.HoverItemDelayId, g.HoverItemDelayTimer, g.HoverItemDelayClearTimer);
		Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
		DebugLocateItemOnHover(g.DragDropPayload.SourceId);
		Unindent();

		Text("NAV,FOCUS");
		Indent();
		Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
		Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
		DebugLocateItemOnHover(g.NavId);
		Text("NavInputSource: %s", GetInputSourceName(g.NavInputSource));
		Text("NavLastValidSelectionUserData = %" IM_PRId64 " (0x%" IM_PRIX64 ")", g.NavLastValidSelectionUserData, g.NavLastValidSelectionUserData);
		Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
		Text("NavActivateId/DownId/PressedId: %08X/%08X/%08X", g.NavActivateId, g.NavActivateDownId, g.NavActivatePressedId);
		Text("NavActivateFlags: %04X", g.NavActivateFlags);
		Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
		Text("NavFocusScopeId = 0x%08X", g.NavFocusScopeId);
		Text("NavFocusRoute[] = ");
		for (int path_n = g.NavFocusRoute.Size - 1; path_n >= 0; path_n--) {
			const ImGuiFocusScopeData &focus_scope = g.NavFocusRoute[path_n];
			SameLine(0.0f, 0.0f);
			Text("0x%08X/", focus_scope.ID);
			SetItemTooltip("In window \"%s\"", FindWindowByID(focus_scope.WindowID)->Name);
		}
		Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
		Unindent();

		TreePop();
	}

	// Overlay: Display windows Rectangles and Begin Order
	if (cfg->ShowWindowsRects || cfg->ShowWindowsBeginOrder) {
		for (ImGuiWindow *window : g.Windows) {
			if (!window->WasActive)
				continue;
			ImDrawList *draw_list = GetForegroundDrawList(window);
			if (cfg->ShowWindowsRects) {
				ImRect r = Funcs::GetWindowRect(window, cfg->ShowWindowsRectsType);
				draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
			}
			if (cfg->ShowWindowsBeginOrder && !(window->Flags & ImGuiWindowFlags_ChildWindow)) {
				char buf[32];
				ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);
				float font_size = GetFontSize();
				draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));
				draw_list->AddText(window->Pos, IM_COL32(255, 255, 255, 255), buf);
			}
		}
	}

	// Overlay: Display Tables Rectangles
	if (cfg->ShowTablesRects) {
		for (int table_n = 0; table_n < g.Tables.GetMapSize(); table_n++) {
			ImGuiTable *table = g.Tables.TryGetMapData(table_n);
			if (table == NULL || table->LastFrameActive < g.FrameCount - 1)
				continue;
			ImDrawList *draw_list = GetForegroundDrawList(table->OuterWindow);
			if (cfg->ShowTablesRectsType >= TRT_ColumnsRect) {
				for (int column_n = 0; column_n < table->ColumnsCount; column_n++) {
					ImRect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, column_n);
					ImU32 col = (table->HoveredColumnBody == column_n) ? IM_COL32(255, 255, 128, 255) : IM_COL32(255, 0, 128, 255);
					float thickness = (table->HoveredColumnBody == column_n) ? 3.0f : 1.0f;
					draw_list->AddRect(r.Min, r.Max, col, 0.0f, 0, thickness);
				}
			} else {
				ImRect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, -1);
				draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
			}
		}
	}

#ifdef IMGUI_HAS_DOCK
	// Overlay: Display Docking info
	if (show_docking_nodes && g.IO.KeyCtrl) {
	}
#endif // #ifdef IMGUI_HAS_DOCK

	End();
}

void ImGui::DebugBreakClearData() {
	// Those fields are scattered in their respective subsystem to stay in hot-data locations
	ImGuiContext &g = *GImGui;
	g.DebugBreakInWindow = 0;
	g.DebugBreakInTable = 0;
	g.DebugBreakInShortcutRouting = ImGuiKey_None;
}

void ImGui::DebugBreakButtonTooltip(bool keyboard_only, const char *description_of_location) {
	if (!BeginItemTooltip())
		return;
	Text("To call IM_DEBUG_BREAK() %s:", description_of_location);
	Separator();
	TextUnformatted(keyboard_only ? "- Press 'Pause/Break' on keyboard." : "- Press 'Pause/Break' on keyboard.\n- or Click (may alter focus/active id).\n- or navigate using keyboard and press space.");
	Separator();
	TextUnformatted("Choose one way that doesn't interfere with what you are trying to debug!\nYou need a debugger attached or this will crash!");
	EndTooltip();
}

// Special button that doesn't take focus, doesn't take input owner, and can be activated without a click etc.
// In order to reduce interferences with the contents we are trying to debug into.
bool ImGui::DebugBreakButton(const char *label, const char *description_of_location) {
	ImGuiWindow *window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext &g = *GImGui;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	ImVec2 pos = window->DC.CursorPos + ImVec2(0.0f, window->DC.CurrLineTextBaseOffset);
	ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x * 2.0f, label_size.y);

	const ImRect bb(pos, pos + size);
	ItemSize(size, 0.0f);
	if (!ItemAdd(bb, id))
		return false;

	// WE DO NOT USE ButtonEx() or ButtonBehavior() in order to reduce our side-effects.
	bool hovered = ItemHoverable(bb, id, g.CurrentItemFlags);
	bool pressed = hovered && (IsKeyChordPressed(g.DebugBreakKeyChord) || IsMouseClicked(0) || g.NavActivateId == id);
	DebugBreakButtonTooltip(false, description_of_location);

	ImVec4 col4f = GetStyleColorVec4(hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
	ImVec4 hsv;
	ColorConvertRGBtoHSV(col4f.x, col4f.y, col4f.z, hsv.x, hsv.y, hsv.z);
	ColorConvertHSVtoRGB(hsv.x + 0.20f, hsv.y, hsv.z, col4f.x, col4f.y, col4f.z);

	RenderNavHighlight(bb, id);
	RenderFrame(bb.Min, bb.Max, GetColorU32(col4f), true, g.Style.FrameRounding);
	RenderTextClipped(bb.Min, bb.Max, label, NULL, &label_size, g.Style.ButtonTextAlign, &bb);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
	return pressed;
}

// [DEBUG] Display contents of Columns
void ImGui::DebugNodeColumns(ImGuiOldColumns *columns) {
	if (!TreeNode((void *)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
		return;
	BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->OffMaxX - columns->OffMinX, columns->OffMinX, columns->OffMaxX);
	for (ImGuiOldColumnData &column : columns->Columns)
		BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", (int)columns->Columns.index_from_ptr(&column), column.OffsetNorm, GetColumnOffsetFromNorm(columns, column.OffsetNorm));
	TreePop();
}

static void FormatTextureIDForDebugDisplay(char *buf, int buf_size, ImTextureID tex_id) {
	union {
		void *ptr;
		int integer;
	} tex_id_opaque;
	memcpy(&tex_id_opaque, &tex_id, ImMin(sizeof(void *), sizeof(tex_id)));
	if (sizeof(tex_id) >= sizeof(void *))
		ImFormatString(buf, buf_size, "0x%p", tex_id_opaque.ptr);
	else
		ImFormatString(buf, buf_size, "0x%04X", tex_id_opaque.integer);
}

// [DEBUG] Display contents of ImDrawList
void ImGui::DebugNodeDrawList(ImGuiWindow *window, ImGuiViewportP *viewport, const ImDrawList *draw_list, const char *label) {
	ImGuiContext &g = *GImGui;
	IM_UNUSED(viewport); // Used in docking branch
	ImGuiMetricsConfig *cfg = &g.DebugMetricsConfig;
	int cmd_count = draw_list->CmdBuffer.Size;
	if (cmd_count > 0 && draw_list->CmdBuffer.back().ElemCount == 0 && draw_list->CmdBuffer.back().UserCallback == NULL)
		cmd_count--;
	bool node_open = TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, cmd_count);
	if (draw_list == GetWindowDrawList()) {
		SameLine();
		TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
		if (node_open)
			TreePop();
		return;
	}

	ImDrawList *fg_draw_list = GetForegroundDrawList(window); // Render additional visuals into the top-most draw list
	if (window && IsItemHovered() && fg_draw_list)
		fg_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
	if (!node_open)
		return;

	if (window && !window->WasActive)
		TextDisabled("Warning: owning Window is inactive. This DrawList is not being rendered!");

	for (const ImDrawCmd *pcmd = draw_list->CmdBuffer.Data; pcmd < draw_list->CmdBuffer.Data + cmd_count; pcmd++) {
		if (pcmd->UserCallback) {
			BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
			continue;
		}

		char texid_desc[20];
		FormatTextureIDForDebugDisplay(texid_desc, IM_ARRAYSIZE(texid_desc), pcmd->TextureId);
		char buf[300];
		ImFormatString(buf, IM_ARRAYSIZE(buf), "DrawCmd:%5d tris, Tex %s, ClipRect (%4.0f,%4.0f)-(%4.0f,%4.0f)",
				pcmd->ElemCount / 3, texid_desc, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
		bool pcmd_node_open = TreeNode((void *)(pcmd - draw_list->CmdBuffer.begin()), "%s", buf);
		if (IsItemHovered() && (cfg->ShowDrawCmdMesh || cfg->ShowDrawCmdBoundingBoxes) && fg_draw_list)
			DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, cfg->ShowDrawCmdMesh, cfg->ShowDrawCmdBoundingBoxes);
		if (!pcmd_node_open)
			continue;

		// Calculate approximate coverage area (touched pixel count)
		// This will be in pixels squared as long there's no post-scaling happening to the renderer output.
		const ImDrawIdx *idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
		const ImDrawVert *vtx_buffer = draw_list->VtxBuffer.Data + pcmd->VtxOffset;
		float total_area = 0.0f;
		for (unsigned int idx_n = pcmd->IdxOffset; idx_n < pcmd->IdxOffset + pcmd->ElemCount;) {
			ImVec2 triangle[3];
			for (int n = 0; n < 3; n++, idx_n++)
				triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos;
			total_area += ImTriangleArea(triangle[0], triangle[1], triangle[2]);
		}

		// Display vertex information summary. Hover to get all triangles drawn in wire-frame
		ImFormatString(buf, IM_ARRAYSIZE(buf), "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px", pcmd->ElemCount, pcmd->VtxOffset, pcmd->IdxOffset, total_area);
		Selectable(buf);
		if (IsItemHovered() && fg_draw_list)
			DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, true, false);

		// Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
		ImGuiListClipper clipper;
		clipper.Begin(pcmd->ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
		while (clipper.Step())
			for (int prim = clipper.DisplayStart, idx_i = pcmd->IdxOffset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++) {
				char *buf_p = buf, *buf_end = buf + IM_ARRAYSIZE(buf);
				ImVec2 triangle[3];
				for (int n = 0; n < 3; n++, idx_i++) {
					const ImDrawVert &v = vtx_buffer[idx_buffer ? idx_buffer[idx_i] : idx_i];
					triangle[n] = v.pos;
					buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",
							(n == 0) ? "Vert:" : "     ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
				}

				Selectable(buf, false);
				if (fg_draw_list && IsItemHovered()) {
					ImDrawListFlags backup_flags = fg_draw_list->Flags;
					fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
					fg_draw_list->AddPolyline(triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_Closed, 1.0f);
					fg_draw_list->Flags = backup_flags;
				}
			}
		TreePop();
	}
	TreePop();
}

// [DEBUG] Display mesh/aabb of a ImDrawCmd
void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList *out_draw_list, const ImDrawList *draw_list, const ImDrawCmd *draw_cmd, bool show_mesh, bool show_aabb) {
	IM_ASSERT(show_mesh || show_aabb);

	// Draw wire-frame version of all triangles
	ImRect clip_rect = draw_cmd->ClipRect;
	ImRect vtxs_rect(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
	ImDrawListFlags backup_flags = out_draw_list->Flags;
	out_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
	for (unsigned int idx_n = draw_cmd->IdxOffset, idx_end = draw_cmd->IdxOffset + draw_cmd->ElemCount; idx_n < idx_end;) {
		ImDrawIdx *idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL; // We don't hold on those pointers past iterations as ->AddPolyline() may invalidate them if out_draw_list==draw_list
		ImDrawVert *vtx_buffer = draw_list->VtxBuffer.Data + draw_cmd->VtxOffset;

		ImVec2 triangle[3];
		for (int n = 0; n < 3; n++, idx_n++)
			vtxs_rect.Add((triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos));
		if (show_mesh)
			out_draw_list->AddPolyline(triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_Closed, 1.0f); // In yellow: mesh triangles
	}
	// Draw bounding boxes
	if (show_aabb) {
		out_draw_list->AddRect(ImTrunc(clip_rect.Min), ImTrunc(clip_rect.Max), IM_COL32(255, 0, 255, 255)); // In pink: clipping rectangle submitted to GPU
		out_draw_list->AddRect(ImTrunc(vtxs_rect.Min), ImTrunc(vtxs_rect.Max), IM_COL32(0, 255, 255, 255)); // In cyan: bounding box of triangles
	}
	out_draw_list->Flags = backup_flags;
}

// [DEBUG] Display details for a single font, called by ShowStyleEditor().
void ImGui::DebugNodeFont(ImFont *font) {
	bool opened = TreeNode(font, "Font: \"%s\"\n%.2f px, %d glyphs, %d file(s)",
			font->ConfigData ? font->ConfigData[0].Name : "", font->FontSize, font->Glyphs.Size, font->ConfigDataCount);
	SameLine();
	if (SmallButton("Set as default"))
		GetIO().FontDefault = font;
	if (!opened)
		return;

	// Display preview text
	PushFont(font);
	Text("The quick brown fox jumps over the lazy dog");
	PopFont();

	// Display details
	SetNextItemWidth(GetFontSize() * 8);
	DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");
	SameLine();
	MetricsHelpMarker(
			"Note that the default embedded font is NOT meant to be scaled.\n\n"
			"Font are currently rendered into bitmaps at a given size at the time of building the atlas. "
			"You may oversample them to get some flexibility with scaling. "
			"You can also render at multiple sizes and select which one to use at runtime.\n\n"
			"(Glimmer of hope: the atlas system will be rewritten in the future to make scaling more flexible.)");
	Text("Ascent: %f, Descent: %f, Height: %f", font->Ascent, font->Descent, font->Ascent - font->Descent);
	char c_str[5];
	Text("Fallback character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font->FallbackChar), font->FallbackChar);
	Text("Ellipsis character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font->EllipsisChar), font->EllipsisChar);
	const int surface_sqrt = (int)ImSqrt((float)font->MetricsTotalSurface);
	Text("Texture Area: about %d px ~%dx%d px", font->MetricsTotalSurface, surface_sqrt, surface_sqrt);
	for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)
		if (font->ConfigData)
			if (const ImFontConfig *cfg = &font->ConfigData[config_i])
				BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d, Offset: (%.1f,%.1f)",
						config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV, cfg->PixelSnapH, cfg->GlyphOffset.x, cfg->GlyphOffset.y);

	// Display all glyphs of the fonts in separate pages of 256 characters
	if (TreeNode("Glyphs", "Glyphs (%d)", font->Glyphs.Size)) {
		ImDrawList *draw_list = GetWindowDrawList();
		const ImU32 glyph_col = GetColorU32(ImGuiCol_Text);
		const float cell_size = font->FontSize * 1;
		const float cell_spacing = GetStyle().ItemSpacing.y;
		for (unsigned int base = 0; base <= IM_UNICODE_CODEPOINT_MAX; base += 256) {
			// Skip ahead if a large bunch of glyphs are not present in the font (test in chunks of 4k)
			// This is only a small optimization to reduce the number of iterations when IM_UNICODE_MAX_CODEPOINT
			// is large // (if ImWchar==ImWchar32 we will do at least about 272 queries here)
			if (!(base & 4095) && font->IsGlyphRangeUnused(base, base + 4095)) {
				base += 4096 - 256;
				continue;
			}

			int count = 0;
			for (unsigned int n = 0; n < 256; n++)
				if (font->FindGlyphNoFallback((ImWchar)(base + n)))
					count++;
			if (count <= 0)
				continue;
			if (!TreeNode((void *)(intptr_t)base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph"))
				continue;

			// Draw a 16x16 grid of glyphs
			ImVec2 base_pos = GetCursorScreenPos();
			for (unsigned int n = 0; n < 256; n++) {
				// We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions
				// available here and thus cannot easily generate a zero-terminated UTF-8 encoded string.
				ImVec2 cell_p1(base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing));
				ImVec2 cell_p2(cell_p1.x + cell_size, cell_p1.y + cell_size);
				const ImFontGlyph *glyph = font->FindGlyphNoFallback((ImWchar)(base + n));
				draw_list->AddRect(cell_p1, cell_p2, glyph ? IM_COL32(255, 255, 255, 100) : IM_COL32(255, 255, 255, 50));
				if (!glyph)
					continue;
				font->RenderChar(draw_list, cell_size, cell_p1, glyph_col, (ImWchar)(base + n));
				if (IsMouseHoveringRect(cell_p1, cell_p2) && BeginTooltip()) {
					DebugNodeFontGlyph(font, glyph);
					EndTooltip();
				}
			}
			Dummy(ImVec2((cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16));
			TreePop();
		}
		TreePop();
	}
	TreePop();
}

void ImGui::DebugNodeFontGlyph(ImFont *, const ImFontGlyph *glyph) {
	Text("Codepoint: U+%04X", glyph->Codepoint);
	Separator();
	Text("Visible: %d", glyph->Visible);
	Text("AdvanceX: %.1f", glyph->AdvanceX);
	Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph->X0, glyph->Y0, glyph->X1, glyph->Y1);
	Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph->U0, glyph->V0, glyph->U1, glyph->V1);
}

// [DEBUG] Display contents of ImGuiStorage
void ImGui::DebugNodeStorage(ImGuiStorage *storage, const char *label) {
	if (!TreeNode(label, "%s: %d entries, %d bytes", label, storage->Data.Size, storage->Data.size_in_bytes()))
		return;
	for (const ImGuiStoragePair &p : storage->Data) {
		BulletText("Key 0x%08X Value { i: %d }", p.key, p.val_i); // Important: we currently don't store a type, real value may not be integer.
		DebugLocateItemOnHover(p.key);
	}
	TreePop();
}

// [DEBUG] Display contents of ImGuiTabBar
void ImGui::DebugNodeTabBar(ImGuiTabBar *tab_bar, const char *label) {
	// Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
	char buf[256];
	char *p = buf;
	const char *buf_end = buf + IM_ARRAYSIZE(buf);
	const bool is_active = (tab_bar->PrevFrameVisible >= GetFrameCount() - 2);
	p += ImFormatString(p, buf_end - p, "%s 0x%08X (%d tabs)%s  {", label, tab_bar->ID, tab_bar->Tabs.Size, is_active ? "" : " *Inactive*");
	for (int tab_n = 0; tab_n < ImMin(tab_bar->Tabs.Size, 3); tab_n++) {
		ImGuiTabItem *tab = &tab_bar->Tabs[tab_n];
		p += ImFormatString(p, buf_end - p, "%s'%s'", tab_n > 0 ? ", " : "", TabBarGetTabName(tab_bar, tab));
	}
	p += ImFormatString(p, buf_end - p, (tab_bar->Tabs.Size > 3) ? " ... }" : " } ");
	if (!is_active) {
		PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled));
	}
	bool open = TreeNode(label, "%s", buf);
	if (!is_active) {
		PopStyleColor();
	}
	if (is_active && IsItemHovered()) {
		ImDrawList *draw_list = GetForegroundDrawList();
		draw_list->AddRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, IM_COL32(255, 255, 0, 255));
		draw_list->AddLine(ImVec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Min.y), ImVec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Max.y), IM_COL32(0, 255, 0, 255));
		draw_list->AddLine(ImVec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Min.y), ImVec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Max.y), IM_COL32(0, 255, 0, 255));
	}
	if (open) {
		for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++) {
			ImGuiTabItem *tab = &tab_bar->Tabs[tab_n];
			PushID(tab);
			if (SmallButton("<")) {
				TabBarQueueReorder(tab_bar, tab, -1);
			}
			SameLine(0, 2);
			if (SmallButton(">")) {
				TabBarQueueReorder(tab_bar, tab, +1);
			}
			SameLine();
			Text("%02d%c Tab 0x%08X '%s' Offset: %.2f, Width: %.2f/%.2f",
					tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID, TabBarGetTabName(tab_bar, tab), tab->Offset, tab->Width, tab->ContentWidth);
			PopID();
		}
		TreePop();
	}
}

void ImGui::DebugNodeViewport(ImGuiViewportP *viewport) {
	ImGuiContext &g = *GImGui;
	SetNextItemOpen(true, ImGuiCond_Once);
	bool open = TreeNode("viewport0", "Viewport #%d", 0);
	if (IsItemHovered())
		g.DebugMetricsConfig.HighlightViewportID = viewport->ID;
	if (open) {
		ImGuiWindowFlags flags = viewport->Flags;
		BulletText("Main Pos: (%.0f,%.0f), Size: (%.0f,%.0f)\nWorkArea Inset Left: %.0f Top: %.0f, Right: %.0f, Bottom: %.0f",
				viewport->Pos.x, viewport->Pos.y, viewport->Size.x, viewport->Size.y,
				viewport->WorkInsetMin.x, viewport->WorkInsetMin.y, viewport->WorkInsetMax.x, viewport->WorkInsetMax.y);
		BulletText("Flags: 0x%04X =%s%s%s", viewport->Flags,
				(flags & ImGuiViewportFlags_IsPlatformWindow) ? " IsPlatformWindow" : "",
				(flags & ImGuiViewportFlags_IsPlatformMonitor) ? " IsPlatformMonitor" : "",
				(flags & ImGuiViewportFlags_OwnedByApp) ? " OwnedByApp" : "");
		for (ImDrawList *draw_list : viewport->DrawDataP.CmdLists)
			DebugNodeDrawList(NULL, viewport, draw_list, "DrawList");
		TreePop();
	}
}

void ImGui::DebugNodeWindow(ImGuiWindow *window, const char *label) {
	if (window == NULL) {
		BulletText("%s: NULL", label);
		return;
	}

	ImGuiContext &g = *GImGui;
	const bool is_active = window->WasActive;
	ImGuiTreeNodeFlags tree_node_flags = (window == g.NavWindow) ? ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_None;
	if (!is_active) {
		PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled));
	}
	const bool open = TreeNodeEx(label, tree_node_flags, "%s '%s'%s", label, window->Name, is_active ? "" : " *Inactive*");
	if (!is_active) {
		PopStyleColor();
	}
	if (IsItemHovered() && is_active)
		GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
	if (!open)
		return;

	if (window->MemoryCompacted)
		TextDisabled("Note: some memory buffers have been compacted/freed.");

	if (g.IO.ConfigDebugIsDebuggerPresent && DebugBreakButton("**DebugBreak**", "in Begin()"))
		g.DebugBreakInWindow = window->ID;

	ImGuiWindowFlags flags = window->Flags;
	DebugNodeDrawList(window, window->Viewport, window->DrawList, "DrawList");
	BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), ContentSize (%.1f,%.1f) Ideal (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->ContentSize.x, window->ContentSize.y, window->ContentSizeIdeal.x, window->ContentSizeIdeal.y);
	BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
			(flags & ImGuiWindowFlags_ChildWindow) ? "Child " : "", (flags & ImGuiWindowFlags_Tooltip) ? "Tooltip " : "", (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
			(flags & ImGuiWindowFlags_Modal) ? "Modal " : "", (flags & ImGuiWindowFlags_ChildMenu) ? "ChildMenu " : "", (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
			(flags & ImGuiWindowFlags_NoMouseInputs) ? "NoMouseInputs" : "", (flags & ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
	if (flags & ImGuiWindowFlags_ChildWindow)
		BulletText("ChildFlags: 0x%08X (%s%s%s%s..)", window->ChildFlags,
				(window->ChildFlags & ImGuiChildFlags_Borders) ? "Borders " : "",
				(window->ChildFlags & ImGuiChildFlags_ResizeX) ? "ResizeX " : "",
				(window->ChildFlags & ImGuiChildFlags_ResizeY) ? "ResizeY " : "",
				(window->ChildFlags & ImGuiChildFlags_NavFlattened) ? "NavFlattened " : "");
	BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f) Scrollbar:%s%s", window->Scroll.x, window->ScrollMax.x, window->Scroll.y, window->ScrollMax.y, window->ScrollbarX ? "X" : "", window->ScrollbarY ? "Y" : "");
	BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
	BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesCanSkipItems, window->HiddenFramesCannotSkipItems, window->SkipItems);
	for (int layer = 0; layer < ImGuiNavLayer_COUNT; layer++) {
		ImRect r = window->NavRectRel[layer];
		if (r.Min.x >= r.Max.y && r.Min.y >= r.Max.y)
			BulletText("NavLastIds[%d]: 0x%08X", layer, window->NavLastIds[layer]);
		else
			BulletText("NavLastIds[%d]: 0x%08X at +(%.1f,%.1f)(%.1f,%.1f)", layer, window->NavLastIds[layer], r.Min.x, r.Min.y, r.Max.x, r.Max.y);
		DebugLocateItemOnHover(window->NavLastIds[layer]);
	}
	const ImVec2 *pr = window->NavPreferredScoringPosRel;
	for (int layer = 0; layer < ImGuiNavLayer_COUNT; layer++)
		BulletText("NavPreferredScoringPosRel[%d] = {%.1f,%.1f)", layer, (pr[layer].x == FLT_MAX ? -99999.0f : pr[layer].x), (pr[layer].y == FLT_MAX ? -99999.0f : pr[layer].y)); // Display as 99999.0f so it looks neater.
	BulletText("NavLayersActiveMask: %X, NavLastChildNavWindow: %s", window->DC.NavLayersActiveMask, window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
	if (window->RootWindow != window) {
		DebugNodeWindow(window->RootWindow, "RootWindow");
	}
	if (window->ParentWindow != NULL) {
		DebugNodeWindow(window->ParentWindow, "ParentWindow");
	}
	if (window->ParentWindowForFocusRoute != NULL) {
		DebugNodeWindow(window->ParentWindowForFocusRoute, "ParentWindowForFocusRoute");
	}
	if (window->DC.ChildWindows.Size > 0) {
		DebugNodeWindowsList(&window->DC.ChildWindows, "ChildWindows");
	}
	if (window->ColumnsStorage.Size > 0 && TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size)) {
		for (ImGuiOldColumns &columns : window->ColumnsStorage)
			DebugNodeColumns(&columns);
		TreePop();
	}
	DebugNodeStorage(&window->StateStorage, "Storage");
	TreePop();
}

void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings *settings) {
	if (settings->WantDelete)
		BeginDisabled();
	Text("0x%08X \"%s\" Pos (%d,%d) Size (%d,%d) Collapsed=%d",
			settings->ID, settings->GetName(), settings->Pos.x, settings->Pos.y, settings->Size.x, settings->Size.y, settings->Collapsed);
	if (settings->WantDelete)
		EndDisabled();
}

void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow *> *windows, const char *label) {
	if (!TreeNode(label, "%s (%d)", label, windows->Size))
		return;
	for (int i = windows->Size - 1; i >= 0; i--) // Iterate front to back
	{
		PushID((*windows)[i]);
		DebugNodeWindow((*windows)[i], "Window");
		PopID();
	}
	TreePop();
}

// FIXME-OPT: This is technically suboptimal, but it is simpler this way.
void ImGui::DebugNodeWindowsListByBeginStackParent(ImGuiWindow **windows, int windows_size, ImGuiWindow *parent_in_begin_stack) {
	for (int i = 0; i < windows_size; i++) {
		ImGuiWindow *window = windows[i];
		if (window->ParentWindowInBeginStack != parent_in_begin_stack)
			continue;
		char buf[20];
		ImFormatString(buf, IM_ARRAYSIZE(buf), "[%04d] Window", window->BeginOrderWithinContext);
		//BulletText("[%04d] Window '%s'", window->BeginOrderWithinContext, window->Name);
		DebugNodeWindow(window, buf);
		Indent();
		DebugNodeWindowsListByBeginStackParent(windows + i + 1, windows_size - i - 1, window);
		Unindent();
	}
}

//-----------------------------------------------------------------------------
// [SECTION] DEBUG LOG WINDOW
//-----------------------------------------------------------------------------

void ImGui::DebugLog(const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	DebugLogV(fmt, args);
	va_end(args);
}

void ImGui::DebugLogV(const char *fmt, va_list args) {
	ImGuiContext &g = *GImGui;
	const int old_size = g.DebugLogBuf.size();
	if (g.ContextName[0] != 0)
		g.DebugLogBuf.appendf("[%s] [%05d] ", g.ContextName, g.FrameCount);
	else
		g.DebugLogBuf.appendf("[%05d] ", g.FrameCount);
	g.DebugLogBuf.appendfv(fmt, args);
	g.DebugLogIndex.append(g.DebugLogBuf.c_str(), old_size, g.DebugLogBuf.size());
	if (g.DebugLogFlags & ImGuiDebugLogFlags_OutputToTTY)
		IMGUI_DEBUG_PRINTF("%s", g.DebugLogBuf.begin() + old_size);
#ifdef IMGUI_ENABLE_TEST_ENGINE
	// IMGUI_TEST_ENGINE_LOG() adds a trailing \n automatically
	const int new_size = g.DebugLogBuf.size();
	const bool trailing_carriage_return = (g.DebugLogBuf[new_size - 1] == '\n');
	if (g.DebugLogFlags & ImGuiDebugLogFlags_OutputToTestEngine)
		IMGUI_TEST_ENGINE_LOG("%.*s", new_size - old_size - (trailing_carriage_return ? 1 : 0), g.DebugLogBuf.begin() + old_size);
#endif
}

// FIXME-LAYOUT: To be done automatically via layout mode once we rework ItemSize/ItemAdd into ItemLayout.
static void SameLineOrWrap(const ImVec2 &size) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImVec2 pos(window->DC.CursorPosPrevLine.x + g.Style.ItemSpacing.x, window->DC.CursorPosPrevLine.y);
	if (window->WorkRect.Contains(ImRect(pos, pos + size)))
		ImGui::SameLine();
}

static void ShowDebugLogFlag(const char *name, ImGuiDebugLogFlags flags) {
	ImGuiContext &g = *GImGui;
	ImVec2 size(ImGui::GetFrameHeight() + g.Style.ItemInnerSpacing.x + ImGui::CalcTextSize(name).x, ImGui::GetFrameHeight());
	SameLineOrWrap(size); // FIXME-LAYOUT: To be done automatically once we rework ItemSize/ItemAdd into ItemLayout.
	if (ImGui::CheckboxFlags(name, &g.DebugLogFlags, flags) && g.IO.KeyShift && (g.DebugLogFlags & flags) != 0) {
		g.DebugLogAutoDisableFrames = 2;
		g.DebugLogAutoDisableFlags |= flags;
	}
	ImGui::SetItemTooltip("Hold SHIFT when clicking to enable for 2 frames only (useful for spammy log entries)");
}

void ImGui::ShowDebugLogWindow(bool *p_open) {
	ImGuiContext &g = *GImGui;
	if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0)
		SetNextWindowSize(ImVec2(0.0f, GetFontSize() * 12.0f), ImGuiCond_FirstUseEver);
	if (!Begin("Dear ImGui Debug Log", p_open) || GetCurrentWindow()->BeginCount > 1) {
		End();
		return;
	}

	ImGuiDebugLogFlags all_enable_flags = ImGuiDebugLogFlags_EventMask_ & ~ImGuiDebugLogFlags_EventInputRouting;
	CheckboxFlags("All", &g.DebugLogFlags, all_enable_flags);
	SetItemTooltip("(except InputRouting which is spammy)");

	ShowDebugLogFlag("ActiveId", ImGuiDebugLogFlags_EventActiveId);
	ShowDebugLogFlag("Clipper", ImGuiDebugLogFlags_EventClipper);
	ShowDebugLogFlag("Focus", ImGuiDebugLogFlags_EventFocus);
	ShowDebugLogFlag("IO", ImGuiDebugLogFlags_EventIO);
	ShowDebugLogFlag("Nav", ImGuiDebugLogFlags_EventNav);
	ShowDebugLogFlag("Popup", ImGuiDebugLogFlags_EventPopup);
	ShowDebugLogFlag("Selection", ImGuiDebugLogFlags_EventSelection);
	ShowDebugLogFlag("InputRouting", ImGuiDebugLogFlags_EventInputRouting);

	if (SmallButton("Clear")) {
		g.DebugLogBuf.clear();
		g.DebugLogIndex.clear();
	}
	SameLine();
	if (SmallButton("Copy"))
		SetClipboardText(g.DebugLogBuf.c_str());
	SameLine();
	if (SmallButton("Configure Outputs.."))
		OpenPopup("Outputs");
	if (BeginPopup("Outputs")) {
		CheckboxFlags("OutputToTTY", &g.DebugLogFlags, ImGuiDebugLogFlags_OutputToTTY);
#ifndef IMGUI_ENABLE_TEST_ENGINE
		BeginDisabled();
#endif
		CheckboxFlags("OutputToTestEngine", &g.DebugLogFlags, ImGuiDebugLogFlags_OutputToTestEngine);
#ifndef IMGUI_ENABLE_TEST_ENGINE
		EndDisabled();
#endif
		EndPopup();
	}

	BeginChild("##log", ImVec2(0.0f, 0.0f), ImGuiChildFlags_Borders, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);

	const ImGuiDebugLogFlags backup_log_flags = g.DebugLogFlags;
	g.DebugLogFlags &= ~ImGuiDebugLogFlags_EventClipper;

	ImGuiListClipper clipper;
	clipper.Begin(g.DebugLogIndex.size());
	while (clipper.Step())
		for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no++)
			DebugTextUnformattedWithLocateItem(g.DebugLogIndex.get_line_begin(g.DebugLogBuf.c_str(), line_no), g.DebugLogIndex.get_line_end(g.DebugLogBuf.c_str(), line_no));
	g.DebugLogFlags = backup_log_flags;
	if (GetScrollY() >= GetScrollMaxY())
		SetScrollHereY(1.0f);
	EndChild();

	End();
}

// Display line, search for 0xXXXXXXXX identifiers and call DebugLocateItemOnHover() when hovered.
void ImGui::DebugTextUnformattedWithLocateItem(const char *line_begin, const char *line_end) {
	TextUnformatted(line_begin, line_end);
	if (!IsItemHovered())
		return;
	ImGuiContext &g = *GImGui;
	ImRect text_rect = g.LastItemData.Rect;
	for (const char *p = line_begin; p <= line_end - 10; p++) {
		ImGuiID id = 0;
		if (p[0] != '0' || (p[1] != 'x' && p[1] != 'X') || sscanf(p + 2, "%X", &id) != 1 || ImCharIsXdigitA(p[10]))
			continue;
		ImVec2 p0 = CalcTextSize(line_begin, p);
		ImVec2 p1 = CalcTextSize(p, p + 10);
		g.LastItemData.Rect = ImRect(text_rect.Min + ImVec2(p0.x, 0.0f), text_rect.Min + ImVec2(p0.x + p1.x, p1.y));
		if (IsMouseHoveringRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, true))
			DebugLocateItemOnHover(id);
		p += 10;
	}
}

//-----------------------------------------------------------------------------
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)
//-----------------------------------------------------------------------------

// Draw a small cross at current CursorPos in current window's DrawList
void ImGui::DebugDrawCursorPos(ImU32 col) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImVec2 pos = window->DC.CursorPos;
	window->DrawList->AddLine(ImVec2(pos.x, pos.y - 3.0f), ImVec2(pos.x, pos.y + 4.0f), col, 1.0f);
	window->DrawList->AddLine(ImVec2(pos.x - 3.0f, pos.y), ImVec2(pos.x + 4.0f, pos.y), col, 1.0f);
}

// Draw a 10px wide rectangle around CurposPos.x using Line Y1/Y2 in current window's DrawList
void ImGui::DebugDrawLineExtents(ImU32 col) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	float curr_x = window->DC.CursorPos.x;
	float line_y1 = (window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y);
	float line_y2 = line_y1 + (window->DC.IsSameLine ? window->DC.PrevLineSize.y : window->DC.CurrLineSize.y);
	window->DrawList->AddLine(ImVec2(curr_x - 5.0f, line_y1), ImVec2(curr_x + 5.0f, line_y1), col, 1.0f);
	window->DrawList->AddLine(ImVec2(curr_x - 0.5f, line_y1), ImVec2(curr_x - 0.5f, line_y2), col, 1.0f);
	window->DrawList->AddLine(ImVec2(curr_x - 5.0f, line_y2), ImVec2(curr_x + 5.0f, line_y2), col, 1.0f);
}

// Draw last item rect in ForegroundDrawList (so it is always visible)
void ImGui::DebugDrawItemRect(ImU32 col) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	GetForegroundDrawList(window)->AddRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, col);
}

// [DEBUG] Locate item position/rectangle given an ID.
static const ImU32 DEBUG_LOCATE_ITEM_COLOR = IM_COL32(0, 255, 0, 255); // Green

void ImGui::DebugLocateItem(ImGuiID target_id) {
	ImGuiContext &g = *GImGui;
	g.DebugLocateId = target_id;
	g.DebugLocateFrames = 2;
	g.DebugBreakInLocateId = false;
}

// FIXME: Doesn't work over through a modal window, because they clear HoveredWindow.
void ImGui::DebugLocateItemOnHover(ImGuiID target_id) {
	if (target_id == 0 || !IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenBlockedByPopup))
		return;
	ImGuiContext &g = *GImGui;
	DebugLocateItem(target_id);
	GetForegroundDrawList(g.CurrentWindow)->AddRect(g.LastItemData.Rect.Min - ImVec2(3.0f, 3.0f), g.LastItemData.Rect.Max + ImVec2(3.0f, 3.0f), DEBUG_LOCATE_ITEM_COLOR);

	// Can't easily use a context menu here because it will mess with focus, active id etc.
	if (g.IO.ConfigDebugIsDebuggerPresent && g.MouseStationaryTimer > 1.0f) {
		DebugBreakButtonTooltip(false, "in ItemAdd()");
		if (IsKeyChordPressed(g.DebugBreakKeyChord))
			g.DebugBreakInLocateId = true;
	}
}

void ImGui::DebugLocateItemResolveWithLastItem() {
	ImGuiContext &g = *GImGui;

	// [DEBUG] Debug break requested by user
	if (g.DebugBreakInLocateId)
		IM_DEBUG_BREAK();

	ImGuiLastItemData item_data = g.LastItemData;
	g.DebugLocateId = 0;
	ImDrawList *draw_list = GetForegroundDrawList(g.CurrentWindow);
	ImRect r = item_data.Rect;
	r.Expand(3.0f);
	ImVec2 p1 = g.IO.MousePos;
	ImVec2 p2 = ImVec2((p1.x < r.Min.x) ? r.Min.x : (p1.x > r.Max.x) ? r.Max.x
																	 : p1.x,
			(p1.y < r.Min.y) ? r.Min.y : (p1.y > r.Max.y) ? r.Max.y
														  : p1.y);
	draw_list->AddRect(r.Min, r.Max, DEBUG_LOCATE_ITEM_COLOR);
	draw_list->AddLine(p1, p2, DEBUG_LOCATE_ITEM_COLOR);
}

void ImGui::DebugStartItemPicker() {
	ImGuiContext &g = *GImGui;
	g.DebugItemPickerActive = true;
}

// [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
void ImGui::UpdateDebugToolItemPicker() {
	ImGuiContext &g = *GImGui;
	g.DebugItemPickerBreakId = 0;
	if (!g.DebugItemPickerActive)
		return;

	const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
	SetMouseCursor(ImGuiMouseCursor_Hand);
	if (IsKeyPressed(ImGuiKey_Escape))
		g.DebugItemPickerActive = false;
	const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
	if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id) {
		g.DebugItemPickerBreakId = hovered_id;
		g.DebugItemPickerActive = false;
	}
	for (int mouse_button = 0; mouse_button < 3; mouse_button++)
		if (change_mapping && IsMouseClicked(mouse_button))
			g.DebugItemPickerMouseButton = (ImU8)mouse_button;
	SetNextWindowBgAlpha(0.70f);
	if (!BeginTooltip())
		return;
	Text("HoveredId: 0x%08X", hovered_id);
	Text("Press ESC to abort picking.");
	const char *mouse_button_names[] = { "Left", "Right", "Middle" };
	if (change_mapping)
		Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
	else
		TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
	EndTooltip();
}

// [DEBUG] ID Stack Tool: update queries. Called by NewFrame()
void ImGui::UpdateDebugToolStackQueries() {
	ImGuiContext &g = *GImGui;
	ImGuiIDStackTool *tool = &g.DebugIDStackTool;

	// Clear hook when id stack tool is not visible
	g.DebugHookIdInfo = 0;
	if (g.FrameCount != tool->LastActiveFrame + 1)
		return;

	// Update queries. The steps are: -1: query Stack, >= 0: query each stack item
	// We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
	const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
	if (tool->QueryId != query_id) {
		tool->QueryId = query_id;
		tool->StackLevel = -1;
		tool->Results.resize(0);
	}
	if (query_id == 0)
		return;

	// Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
	int stack_level = tool->StackLevel;
	if (stack_level >= 0 && stack_level < tool->Results.Size)
		if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
			tool->StackLevel++;

	// Update hook
	stack_level = tool->StackLevel;
	if (stack_level == -1)
		g.DebugHookIdInfo = query_id;
	if (stack_level >= 0 && stack_level < tool->Results.Size) {
		g.DebugHookIdInfo = tool->Results[stack_level].ID;
		tool->Results[stack_level].QueryFrameCount++;
	}
}

// [DEBUG] ID Stack tool: hooks called by GetID() family functions
void ImGui::DebugHookIdInfo(ImGuiID id, ImGuiDataType data_type, const void *data_id, const void *data_id_end) {
	ImGuiContext &g = *GImGui;
	ImGuiWindow *window = g.CurrentWindow;
	ImGuiIDStackTool *tool = &g.DebugIDStackTool;

	// Step 0: stack query
	// This assumes that the ID was computed with the current ID stack, which tends to be the case for our widget.
	if (tool->StackLevel == -1) {
		tool->StackLevel++;
		tool->Results.resize(window->IDStack.Size + 1, ImGuiStackLevelInfo());
		for (int n = 0; n < window->IDStack.Size + 1; n++)
			tool->Results[n].ID = (n < window->IDStack.Size) ? window->IDStack[n] : id;
		return;
	}

	// Step 1+: query for individual level
	IM_ASSERT(tool->StackLevel >= 0);
	if (tool->StackLevel != window->IDStack.Size)
		return;
	ImGuiStackLevelInfo *info = &tool->Results[tool->StackLevel];
	IM_ASSERT(info->ID == id && info->QueryFrameCount > 0);

	switch (data_type) {
		case ImGuiDataType_S32:
			ImFormatString(info->Desc, IM_ARRAYSIZE(info->Desc), "%d", (int)(intptr_t)data_id);
			break;
		case ImGuiDataType_String:
			ImFormatString(info->Desc, IM_ARRAYSIZE(info->Desc), "%.*s", data_id_end ? (int)((const char *)data_id_end - (const char *)data_id) : (int)strlen((const char *)data_id), (const char *)data_id);
			break;
		case ImGuiDataType_Pointer:
			ImFormatString(info->Desc, IM_ARRAYSIZE(info->Desc), "(void*)0x%p", data_id);
			break;
		case ImGuiDataType_ID:
			if (info->Desc[0] != 0) // PushOverrideID() is often used to avoid hashing twice, which would lead to 2 calls to DebugHookIdInfo(). We prioritize the first one.
				return;
			ImFormatString(info->Desc, IM_ARRAYSIZE(info->Desc), "0x%08X [override]", id);
			break;
		default:
			IM_ASSERT(0);
	}
	info->QuerySuccess = true;
	info->DataType = data_type;
}

static int StackToolFormatLevelInfo(ImGuiIDStackTool *tool, int n, bool format_for_ui, char *buf, size_t buf_size) {
	ImGuiStackLevelInfo *info = &tool->Results[n];
	ImGuiWindow *window = (info->Desc[0] == 0 && n == 0) ? ImGui::FindWindowByID(info->ID) : NULL;
	if (window) // Source: window name (because the root ID don't call GetID() and so doesn't get hooked)
		return ImFormatString(buf, buf_size, format_for_ui ? "\"%s\" [window]" : "%s", window->Name);
	if (info->QuerySuccess) // Source: GetID() hooks (prioritize over ItemInfo() because we frequently use patterns like: PushID(str), Button("") where they both have same id)
		return ImFormatString(buf, buf_size, (format_for_ui && info->DataType == ImGuiDataType_String) ? "\"%s\"" : "%s", info->Desc);
	if (tool->StackLevel < tool->Results.Size) // Only start using fallback below when all queries are done, so during queries we don't flickering ??? markers.
		return (*buf = 0);
#ifdef IMGUI_ENABLE_TEST_ENGINE
	if (const char *label = ImGuiTestEngine_FindItemDebugLabel(GImGui, info->ID)) // Source: ImGuiTestEngine's ItemInfo()
		return ImFormatString(buf, buf_size, format_for_ui ? "??? \"%s\"" : "%s", label);
#endif
	return ImFormatString(buf, buf_size, "???");
}

// ID Stack Tool: Display UI
void ImGui::ShowIDStackToolWindow(bool *p_open) {
	ImGuiContext &g = *GImGui;
	if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0)
		SetNextWindowSize(ImVec2(0.0f, GetFontSize() * 8.0f), ImGuiCond_FirstUseEver);
	if (!Begin("Dear ImGui ID Stack Tool", p_open) || GetCurrentWindow()->BeginCount > 1) {
		End();
		return;
	}

	// Display hovered/active status
	ImGuiIDStackTool *tool = &g.DebugIDStackTool;
	const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
	const ImGuiID active_id = g.ActiveId;
#ifdef IMGUI_ENABLE_TEST_ENGINE
	Text("HoveredId: 0x%08X (\"%s\"), ActiveId:  0x%08X (\"%s\")", hovered_id, hovered_id ? ImGuiTestEngine_FindItemDebugLabel(&g, hovered_id) : "", active_id, active_id ? ImGuiTestEngine_FindItemDebugLabel(&g, active_id) : "");
#else
	Text("HoveredId: 0x%08X, ActiveId:  0x%08X", hovered_id, active_id);
#endif
	SameLine();
	MetricsHelpMarker("Hover an item with the mouse to display elements of the ID Stack leading to the item's final ID.\nEach level of the stack correspond to a PushID() call.\nAll levels of the stack are hashed together to make the final ID of a widget (ID displayed at the bottom level of the stack).\nRead FAQ entry about the ID stack for details.");

	// CTRL+C to copy path
	const float time_since_copy = (float)g.Time - tool->CopyToClipboardLastTime;
	Checkbox("Ctrl+C: copy path to clipboard", &tool->CopyToClipboardOnCtrlC);
	SameLine();
	TextColored((time_since_copy >= 0.0f && time_since_copy < 0.75f && ImFmod(time_since_copy, 0.25f) < 0.25f * 0.5f) ? ImVec4(1.f, 1.f, 0.3f, 1.f) : ImVec4(), "*COPIED*");
	if (tool->CopyToClipboardOnCtrlC && Shortcut(ImGuiMod_Ctrl | ImGuiKey_C, ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused)) {
		tool->CopyToClipboardLastTime = (float)g.Time;
		char *p = g.TempBuffer.Data;
		char *p_end = p + g.TempBuffer.Size;
		for (int stack_n = 0; stack_n < tool->Results.Size && p + 3 < p_end; stack_n++) {
			*p++ = '/';
			char level_desc[256];
			StackToolFormatLevelInfo(tool, stack_n, false, level_desc, IM_ARRAYSIZE(level_desc));
			for (int n = 0; level_desc[n] && p + 2 < p_end; n++) {
				if (level_desc[n] == '/')
					*p++ = '\\';
				*p++ = level_desc[n];
			}
		}
		*p = '\0';
		SetClipboardText(g.TempBuffer.Data);
	}

	// Display decorated stack
	tool->LastActiveFrame = g.FrameCount;
	if (tool->Results.Size > 0 && BeginTable("##table", 3, ImGuiTableFlags_Borders)) {
		const float id_width = CalcTextSize("0xDDDDDDDD").x;
		TableSetupColumn("Seed", ImGuiTableColumnFlags_WidthFixed, id_width);
		TableSetupColumn("PushID", ImGuiTableColumnFlags_WidthStretch);
		TableSetupColumn("Result", ImGuiTableColumnFlags_WidthFixed, id_width);
		TableHeadersRow();
		for (int n = 0; n < tool->Results.Size; n++) {
			ImGuiStackLevelInfo *info = &tool->Results[n];
			TableNextColumn();
			Text("0x%08X", (n > 0) ? tool->Results[n - 1].ID : 0);
			TableNextColumn();
			StackToolFormatLevelInfo(tool, n, true, g.TempBuffer.Data, g.TempBuffer.Size);
			TextUnformatted(g.TempBuffer.Data);
			TableNextColumn();
			Text("0x%08X", info->ID);
			if (n == tool->Results.Size - 1)
				TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_Header));
		}
		EndTable();
	}
	End();
}

#else

void ImGui::ShowMetricsWindow(bool *) {}
void ImGui::ShowFontAtlas(ImFontAtlas *) {}
void ImGui::DebugNodeColumns(ImGuiOldColumns *) {}
void ImGui::DebugNodeDrawList(ImGuiWindow *, ImGuiViewportP *, const ImDrawList *, const char *) {}
void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList *, const ImDrawList *, const ImDrawCmd *, bool, bool) {}
void ImGui::DebugNodeFont(ImFont *) {}
void ImGui::DebugNodeStorage(ImGuiStorage *, const char *) {}
void ImGui::DebugNodeTabBar(ImGuiTabBar *, const char *) {}
void ImGui::DebugNodeWindow(ImGuiWindow *, const char *) {}
void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings *) {}
void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow *> *, const char *) {}
void ImGui::DebugNodeViewport(ImGuiViewportP *) {}

void ImGui::ShowDebugLogWindow(bool *) {}
void ImGui::ShowIDStackToolWindow(bool *) {}
void ImGui::DebugStartItemPicker() {}
void ImGui::DebugHookIdInfo(ImGuiID, ImGuiDataType, const void *, const void *) {}

#endif // #ifndef IMGUI_DISABLE_DEBUG_TOOLS

//-----------------------------------------------------------------------------

// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
#include "imgui_user.inl"
#endif

//-----------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE
#line 0

#define IMGUI_IMPL_OPENGL_LOADER_CUSTOM
//#define IMGL3W_IMPL
//{{F I LE:sfw/render_gui/imgui_impl_opengl3_loader.h}}

#line 1 "sfw/render_gui/imgui_impl_opengl3.cpp"
// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline
// - Desktop GL: 2.x 3.x 4.x
// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)
// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!
//  [x] Renderer: Large meshes support (64k+ vertices) with 16-bit indices (Desktop OpenGL only).

// About WebGL/ES:
// - You need to '#define IMGUI_IMPL_OPENGL_ES2' or '#define IMGUI_IMPL_OPENGL_ES3' to use WebGL or OpenGL ES.
// - This is done automatically on iOS, Android and Emscripten targets.
// - For other targets, the define needs to be visible from the imgui_impl_opengl3.cpp compilation unit. If unsure, define globally or in imconfig.h.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// Learn about Dear ImGui:
// - FAQ                  https://dearimgui.com/faq
// - Getting Started      https://dearimgui.com/getting-started
// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
// - Introduction, links and more at the top of imgui.cpp

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2024-06-28: OpenGL: ImGui_ImplOpenGL3_NewFrame() recreates font texture if it has been destroyed by ImGui_ImplOpenGL3_DestroyFontsTexture(). (#7748)
//  2024-05-07: OpenGL: Update loader for Linux to support EGL/GLVND. (#7562)
//  2024-04-16: OpenGL: Detect ES3 contexts on desktop based on version string, to e.g. avoid calling glPolygonMode() on them. (#7447)
//  2024-01-09: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load "libGL.so" and variants, fixing regression on distros missing a symlink.
//  2023-11-08: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load "libGL.so" instead of "libGL.so.1", accommodating for NetBSD systems having only "libGL.so.3" available. (#6983)
//  2023-10-05: OpenGL: Rename symbols in our internal loader so that LTO compilation with another copy of gl3w is possible. (#6875, #6668, #4445)
//  2023-06-20: OpenGL: Fixed erroneous use glGetIntegerv(GL_CONTEXT_PROFILE_MASK) on contexts lower than 3.2. (#6539, #6333)
//  2023-05-09: OpenGL: Support for glBindSampler() backup/restore on ES3. (#6375)
//  2023-04-18: OpenGL: Restore front and back polygon mode separately when supported by context. (#6333)
//  2023-03-23: OpenGL: Properly restoring "no shader program bound" if it was the case prior to running the rendering function. (#6267, #6220, #6224)
//  2023-03-15: OpenGL: Fixed GL loader crash when GL_VERSION returns NULL. (#6154, #4445, #3530)
//  2023-03-06: OpenGL: Fixed restoration of a potentially deleted OpenGL program, by calling glIsProgram(). (#6220, #6224)
//  2022-11-09: OpenGL: Reverted use of glBufferSubData(), too many corruptions issues + old issues seemingly can't be reproed with Intel drivers nowadays (revert 2021-12-15 and 2022-05-23 changes).
//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.
//  2022-09-27: OpenGL: Added ability to '#define IMGUI_IMPL_OPENGL_DEBUG'.
//  2022-05-23: OpenGL: Reworking 2021-12-15 "Using buffer orphaning" so it only happens on Intel GPU, seems to cause problems otherwise. (#4468, #4825, #4832, #5127).
//  2022-05-13: OpenGL: Fixed state corruption on OpenGL ES 2.0 due to not preserving GL_ELEMENT_ARRAY_BUFFER_BINDING and vertex attribute states.
//  2021-12-15: OpenGL: Using buffer orphaning + glBufferSubData(), seems to fix leaks with multi-viewports with some Intel HD drivers.
//  2021-08-23: OpenGL: Fixed ES 3.0 shader ("#version 300 es") use normal precision floats to avoid wobbly rendering at HD resolutions.
//  2021-08-19: OpenGL: Embed and use our own minimal GL loader (imgui_impl_opengl3_loader.h), removing requirement and support for third-party loader.
//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).
//  2021-06-25: OpenGL: Use OES_vertex_array extension on Emscripten + backup/restore current state.
//  2021-06-21: OpenGL: Destroy individual vertex/fragment shader objects right after they are linked into the main shader.
//  2021-05-24: OpenGL: Access GL_CLIP_ORIGIN when "GL_ARB_clip_control" extension is detected, inside of just OpenGL 4.5 version.
//  2021-05-19: OpenGL: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)
//  2021-04-06: OpenGL: Don't try to read GL_CLIP_ORIGIN unless we're OpenGL 4.5 or greater.
//  2021-02-18: OpenGL: Change blending equation to preserve alpha in output buffer.
//  2021-01-03: OpenGL: Backup, setup and restore GL_STENCIL_TEST state.
//  2020-10-23: OpenGL: Backup, setup and restore GL_PRIMITIVE_RESTART state.
//  2020-10-15: OpenGL: Use glGetString(GL_VERSION) instead of glGetIntegerv(GL_MAJOR_VERSION, ...) when the later returns zero (e.g. Desktop GL 2.x)
//  2020-09-17: OpenGL: Fix to avoid compiling/calling glBindSampler() on ES or pre 3.3 context which have the defines set by a loader.
//  2020-07-10: OpenGL: Added support for glad2 OpenGL loader.
//  2020-05-08: OpenGL: Made default GLSL version 150 (instead of 130) on OSX.
//  2020-04-21: OpenGL: Fixed handling of glClipControl(GL_UPPER_LEFT) by inverting projection matrix.
//  2020-04-12: OpenGL: Fixed context version check mistakenly testing for 4.0+ instead of 3.2+ to enable ImGuiBackendFlags_RendererHasVtxOffset.
//  2020-03-24: OpenGL: Added support for glbinding 2.x OpenGL loader.
//  2020-01-07: OpenGL: Added support for glbinding 3.x OpenGL loader.
//  2019-10-25: OpenGL: Using a combination of GL define and runtime GL version to decide whether to use glDrawElementsBaseVertex(). Fix building with pre-3.2 GL loaders.
//  2019-09-22: OpenGL: Detect default GL loader using __has_include compiler facility.
//  2019-09-16: OpenGL: Tweak initialization code to allow application calling ImGui_ImplOpenGL3_CreateFontsTexture() before the first NewFrame() call.
//  2019-05-29: OpenGL: Desktop GL only: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.
//  2019-04-30: OpenGL: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.
//  2019-03-29: OpenGL: Not calling glBindBuffer more than necessary in the render loop.
//  2019-03-15: OpenGL: Added a GL call + comments in ImGui_ImplOpenGL3_Init() to detect uninitialized GL function loaders early.
//  2019-03-03: OpenGL: Fix support for ES 2.0 (WebGL 1.0).
//  2019-02-20: OpenGL: Fix for OSX not supporting OpenGL 4.5, we don't try to read GL_CLIP_ORIGIN even if defined by the headers/loader.
//  2019-02-11: OpenGL: Projecting clipping rectangles correctly using draw_data->FramebufferScale to allow multi-viewports for retina display.
//  2019-02-01: OpenGL: Using GLSL 410 shaders for any version over 410 (e.g. 430, 450).
//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
//  2018-11-13: OpenGL: Support for GL 4.5's glClipControl(GL_UPPER_LEFT) / GL_CLIP_ORIGIN.
//  2018-08-29: OpenGL: Added support for more OpenGL loaders: glew and glad, with comments indicative that any loader can be used.
//  2018-08-09: OpenGL: Default to OpenGL ES 3 on iOS and Android. GLSL version default to "#version 300 ES".
//  2018-07-30: OpenGL: Support for GLSL 300 ES and 410 core. Fixes for Emscripten compilation.
//  2018-07-10: OpenGL: Support for more GLSL versions (based on the GLSL version string). Added error output when shaders fail to compile/link.
//  2018-06-08: Misc: Extracted imgui_impl_opengl3.cpp/.h away from the old combined GLFW/SDL+OpenGL3 examples.
//  2018-06-08: OpenGL: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
//  2018-05-25: OpenGL: Removed unnecessary backup/restore of GL_ELEMENT_ARRAY_BUFFER_BINDING since this is part of the VAO state.
//  2018-05-14: OpenGL: Making the call to glBindSampler() optional so 3.2 context won't fail if the function is a nullptr pointer.
//  2018-03-06: OpenGL: Added const char* glsl_version parameter to ImGui_ImplOpenGL3_Init() so user can override the GLSL version e.g. "#version 150".
//  2018-02-23: OpenGL: Create the VAO in the render function so the setup can more easily be used with multiple shared GL context.
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplSdlGL3_RenderDrawData() in the .h file so you can call it yourself.
//  2018-01-07: OpenGL: Changed GLSL shader version from 330 to 150.
//  2017-09-01: OpenGL: Save and restore current bound sampler. Save and restore current polygon mode.
//  2017-05-01: OpenGL: Fixed save and restore of current blend func state.
//  2017-05-01: OpenGL: Fixed save and restore of current GL_ACTIVE_TEXTURE.
//  2016-09-05: OpenGL: Fixed save and restore of current scissor rectangle.
//  2016-07-29: OpenGL: Explicitly setting GL_UNPACK_ROW_LENGTH to reduce issues because SDL changes it. (#752)

//----------------------------------------
// OpenGL    GLSL      GLSL
// version   version   string
//----------------------------------------
//  2.0       110       "#version 110"
//  2.1       120       "#version 120"
//  3.0       130       "#version 130"
//  3.1       140       "#version 140"
//  3.2       150       "#version 150"
//  3.3       330       "#version 330 core"
//  4.0       400       "#version 400 core"
//  4.1       410       "#version 410 core"
//  4.2       420       "#version 410 core"
//  4.3       430       "#version 430 core"
//  ES 2.0    100       "#version 100"      = WebGL 1.0
//  ES 3.0    300       "#version 300 es"   = WebGL 2.0
//----------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef IMGUI_DISABLE

#include <stdint.h> // intptr_t
#include <stdio.h>
#if defined(__APPLE__)
#include <TargetConditionals.h>
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunknown-warning-option" // warning: ignore unknown flags
#pragma clang diagnostic ignored "-Wold-style-cast" // warning: use of old-style cast
#pragma clang diagnostic ignored "-Wsign-conversion" // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wunused-macros" // warning: macro is not used
#pragma clang diagnostic ignored "-Wnonportable-system-include-path"
#pragma clang diagnostic ignored "-Wcast-function-type" // warning: cast between incompatible function types (for loader)
#endif
#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas" // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wunknown-warning-option" // warning: unknown warning group 'xxx'
#pragma GCC diagnostic ignored "-Wcast-function-type" // warning: cast between incompatible function types (for loader)
#endif

// GL includes
#if defined(IMGUI_IMPL_OPENGL_ES2)
#if (defined(__APPLE__) && (TARGET_OS_IOS || TARGET_OS_TV))
#include <OpenGLES/ES2/gl.h> // Use GL ES 2
#else
#include <GLES2/gl2.h> // Use GL ES 2
#endif
#if defined(__EMSCRIPTEN__)
#ifndef GL_GLEXT_PROTOTYPES
#define GL_GLEXT_PROTOTYPES
#endif
#include <GLES2/gl2ext.h>
#endif
#elif defined(IMGUI_IMPL_OPENGL_ES3)
#if (defined(__APPLE__) && (TARGET_OS_IOS || TARGET_OS_TV))
#include <OpenGLES/ES3/gl.h> // Use GL ES 3
#else
#include <GLES3/gl3.h> // Use GL ES 3
#endif
#elif !defined(IMGUI_IMPL_OPENGL_LOADER_CUSTOM)
// Modern desktop OpenGL doesn't have a standard portable header file to load OpenGL function pointers.
// Helper libraries are often used for this purpose! Here we are using our own minimal custom loader based on gl3w.
// In the rest of your app/engine, you can use another loader of your choice (gl3w, glew, glad, glbinding, glext, glLoadGen, etc.).
// If you happen to be developing a new feature for this backend (imgui_impl_opengl3.cpp):
// - You may need to regenerate imgui_impl_opengl3_loader.h to add new symbols. See https://github.com/dearimgui/gl3w_stripped
// - You can temporarily use an unstripped version. See https://github.com/dearimgui/gl3w_stripped/releases
// Changes to this backend using new APIs should be accompanied by a regenerated stripped loader version.

#endif

// Vertex arrays are not supported on ES2/WebGL1 unless Emscripten which uses an extension
#ifndef IMGUI_IMPL_OPENGL_ES2

#ifndef __APPLE__
#define IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
#endif

#elif defined(__EMSCRIPTEN__)
#define IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
#define glBindVertexArray glBindVertexArrayOES
#define glGenVertexArrays glGenVertexArraysOES
#define glDeleteVertexArrays glDeleteVertexArraysOES
#define GL_VERTEX_ARRAY_BINDING GL_VERTEX_ARRAY_BINDING_OES
#endif

// Desktop GL 2.0+ has extension and glPolygonMode() which GL ES and WebGL don't have..
// A desktop ES context can technically compile fine with our loader, so we also perform a runtime checks
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3)
#define IMGUI_IMPL_OPENGL_HAS_EXTENSIONS // has glGetIntegerv(GL_NUM_EXTENSIONS)
#define IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE // may have glPolygonMode()
#endif

// Desktop GL 2.1+ and GL ES 3.0+ have glBindBuffer() with GL_PIXEL_UNPACK_BUFFER target.
#if !defined(IMGUI_IMPL_OPENGL_ES2)
#define IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_BUFFER_PIXEL_UNPACK
#endif

// Desktop GL 3.1+ has GL_PRIMITIVE_RESTART state
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && defined(GL_VERSION_3_1)
#define IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
#endif

// Desktop GL 3.2+ has glDrawElementsBaseVertex() which GL ES and WebGL don't have.
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && defined(GL_VERSION_3_2)
#define IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
#endif

// Desktop GL 3.3+ and GL ES 3.0+ have glBindSampler()
//#if !defined(IMGUI_IMPL_OPENGL_ES2) && (defined(IMGUI_IMPL_OPENGL_ES3) || defined(GL_VERSION_3_3))
//#define IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
//#endif

// [Debugging]
//#define IMGUI_IMPL_OPENGL_DEBUG
#ifdef IMGUI_IMPL_OPENGL_DEBUG
#include <stdio.h>
#define GL_CALL(_CALL)                                                              \
	do {                                                                            \
		_CALL;                                                                      \
		GLenum gl_err = glGetError();                                               \
		if (gl_err != 0)                                                            \
			fprintf(stderr, "GL error 0x%x returned from '%s'.\n", gl_err, #_CALL); \
	} while (0) // Call with error check
#else
#define GL_CALL(_CALL) _CALL // Call without error check
#endif

// OpenGL Data
struct ImGui_ImplOpenGL3_Data {
	GLuint GlVersion; // Extracted at runtime using GL_MAJOR_VERSION, GL_MINOR_VERSION queries (e.g. 320 for GL 3.2)
	char GlslVersionString[32]; // Specified by user or detected based on compile time GL settings.
	bool GlProfileIsES2;
	bool GlProfileIsES3;
	bool GlProfileIsCompat;
	GLint GlProfileMask;
	GLuint FontTexture;
	GLuint ShaderHandle;
	GLint AttribLocationTex; // Uniforms location
	GLint AttribLocationProjMtx;
	GLuint AttribLocationVtxPos; // Vertex attributes location
	GLuint AttribLocationVtxUV;
	GLuint AttribLocationVtxColor;
	unsigned int VboHandle, ElementsHandle;
	GLsizeiptr VertexBufferSize;
	GLsizeiptr IndexBufferSize;
	bool HasPolygonMode;
	bool HasClipOrigin;
	bool UseBufferSubData;

	ImGui_ImplOpenGL3_Data() { memset((void *)this, 0, sizeof(*this)); }
};

// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts
// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
static ImGui_ImplOpenGL3_Data *ImGui_ImplOpenGL3_GetBackendData() {
	return ImGui::GetCurrentContext() ? (ImGui_ImplOpenGL3_Data *)ImGui::GetIO().BackendRendererUserData : nullptr;
}

// OpenGL vertex attribute state (for ES 1.0 and ES 2.0 only)
#ifndef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
struct ImGui_ImplOpenGL3_VtxAttribState {
	GLint Enabled, Size, Type, Normalized, Stride;
	GLvoid *Ptr;

	void GetState(GLint index) {
		glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_ENABLED, &Enabled);
		glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_SIZE, &Size);
		glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_TYPE, &Type);
		glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, &Normalized);
		glGetVertexAttribiv(index, GL_VERTEX_ATTRIB_ARRAY_STRIDE, &Stride);
		glGetVertexAttribPointerv(index, GL_VERTEX_ATTRIB_ARRAY_POINTER, &Ptr);
	}
	void SetState(GLint index) {
		glVertexAttribPointer(index, Size, Type, (GLboolean)Normalized, Stride, Ptr);
		if (Enabled)
			glEnableVertexAttribArray(index);
		else
			glDisableVertexAttribArray(index);
	}
};
#endif

// Functions
bool ImGui_ImplOpenGL3_Init(const char *glsl_version) {
	ImGuiIO &io = ImGui::GetIO();
	IMGUI_CHECKVERSION();
	IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");

	// Initialize our loader
#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3) && !defined(IMGUI_IMPL_OPENGL_LOADER_CUSTOM)
	if (imgl3wInit() != 0) {
		fprintf(stderr, "Failed to initialize OpenGL loader!\n");
		return false;
	}
#endif

	// Setup backend capabilities flags
	ImGui_ImplOpenGL3_Data *bd = IM_NEW(ImGui_ImplOpenGL3_Data)();
	io.BackendRendererUserData = (void *)bd;
	io.BackendRendererName = "imgui_impl_opengl3";

	// Query for GL version (e.g. 320 for GL 3.2)
#if defined(IMGUI_IMPL_OPENGL_ES2)
	// GLES 2
	bd->GlVersion = 200;
	bd->GlProfileIsES2 = true;
#else
	// Desktop or GLES 3
	const char *gl_version_str = (const char *)glGetString(GL_VERSION);
	GLint major = 0;
	GLint minor = 0;
	glGetIntegerv(GL_MAJOR_VERSION, &major);
	glGetIntegerv(GL_MINOR_VERSION, &minor);
	if (major == 0 && minor == 0)
		sscanf(gl_version_str, "%d.%d", &major, &minor); // Query GL_VERSION in desktop GL 2.x, the string will start with "<major>.<minor>"
	bd->GlVersion = (GLuint)(major * 100 + minor * 10);
#if defined(GL_CONTEXT_PROFILE_MASK)
	if (bd->GlVersion >= 320)
		glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &bd->GlProfileMask);
	bd->GlProfileIsCompat = (bd->GlProfileMask & GL_CONTEXT_COMPATIBILITY_PROFILE_BIT) != 0;
#endif

#if defined(IMGUI_IMPL_OPENGL_ES3)
	bd->GlProfileIsES3 = true;
#else
	if (strncmp(gl_version_str, "OpenGL ES 3", 11) == 0)
		bd->GlProfileIsES3 = true;
#endif

	bd->UseBufferSubData = false;
	/*
	// Query vendor to enable glBufferSubData kludge
#ifdef _WIN32
	if (const char* vendor = (const char*)glGetString(GL_VENDOR))
		if (strncmp(vendor, "Intel", 5) == 0)
			bd->UseBufferSubData = true;
#endif
	*/
#endif

#ifdef IMGUI_IMPL_OPENGL_DEBUG
	printf("GlVersion = %d, \"%s\"\nGlProfileIsCompat = %d\nGlProfileMask = 0x%X\nGlProfileIsES2 = %d, GlProfileIsES3 = %d\nGL_VENDOR = '%s'\nGL_RENDERER = '%s'\n", bd->GlVersion, gl_version_str, bd->GlProfileIsCompat, bd->GlProfileMask, bd->GlProfileIsES2, bd->GlProfileIsES3, (const char *)glGetString(GL_VENDOR), (const char *)glGetString(GL_RENDERER)); // [DEBUG]
#endif

#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
	if (bd->GlVersion >= 320)
		io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset; // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.
#endif

	// Store GLSL version string so we can refer to it later in case we recreate shaders.
	// Note: GLSL version is NOT the same as GL version. Leave this to nullptr if unsure.
	if (glsl_version == nullptr) {
#if defined(IMGUI_IMPL_OPENGL_ES2)
		glsl_version = "#version 100";
#elif defined(IMGUI_IMPL_OPENGL_ES3)
		glsl_version = "#version 300 es";
#elif defined(__APPLE__)
		glsl_version = "#version 150";
#else
		glsl_version = "#version 130";
#endif
	}
	IM_ASSERT((int)strlen(glsl_version) + 2 < IM_ARRAYSIZE(bd->GlslVersionString));
	strcpy(bd->GlslVersionString, glsl_version);
	strcat(bd->GlslVersionString, "\n");

	// Make an arbitrary GL call (we don't actually need the result)
	// IF YOU GET A CRASH HERE: it probably means the OpenGL function loader didn't do its job. Let us know!
	GLint current_texture;
	glGetIntegerv(GL_TEXTURE_BINDING_2D, &current_texture);

	// Detect extensions we support
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
	bd->HasPolygonMode = (!bd->GlProfileIsES2 && !bd->GlProfileIsES3);
#endif
	bd->HasClipOrigin = (bd->GlVersion >= 450);
#ifdef IMGUI_IMPL_OPENGL_HAS_EXTENSIONS
	GLint num_extensions = 0;
	glGetIntegerv(GL_NUM_EXTENSIONS, &num_extensions);
	for (GLint i = 0; i < num_extensions; i++) {
		const char *extension = (const char *)glGetStringi(GL_EXTENSIONS, i);
		if (extension != nullptr && strcmp(extension, "GL_ARB_clip_control") == 0)
			bd->HasClipOrigin = true;
	}
#endif

	return true;
}

void ImGui_ImplOpenGL3_Shutdown() {
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();
	IM_ASSERT(bd != nullptr && "No renderer backend to shutdown, or already shutdown?");
	ImGuiIO &io = ImGui::GetIO();

	ImGui_ImplOpenGL3_DestroyDeviceObjects();
	io.BackendRendererName = nullptr;
	io.BackendRendererUserData = nullptr;
	io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;
	IM_DELETE(bd);
}

void ImGui_ImplOpenGL3_NewFrame() {
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();
	IM_ASSERT(bd != nullptr && "Context or backend not initialized! Did you call ImGui_ImplOpenGL3_Init()?");

	if (!bd->ShaderHandle)
		ImGui_ImplOpenGL3_CreateDeviceObjects();
	if (!bd->FontTexture)
		ImGui_ImplOpenGL3_CreateFontsTexture();
}

static void ImGui_ImplOpenGL3_SetupRenderState(ImDrawData *draw_data, int fb_width, int fb_height, GLuint vertex_array_object) {
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();

	// Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled, polygon fill
	glEnable(GL_BLEND);
	glBlendEquation(GL_FUNC_ADD);
	glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	glDisable(GL_CULL_FACE);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_STENCIL_TEST);
	glEnable(GL_SCISSOR_TEST);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
	if (bd->GlVersion >= 310)
		glDisable(GL_PRIMITIVE_RESTART);
#endif
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
	if (bd->HasPolygonMode)
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
#endif

	// Support for GL 4.5 rarely used glClipControl(GL_UPPER_LEFT)
#if defined(GL_CLIP_ORIGIN)
	bool clip_origin_lower_left = true;
	if (bd->HasClipOrigin) {
		GLenum current_clip_origin = 0;
		glGetIntegerv(GL_CLIP_ORIGIN, (GLint *)&current_clip_origin);
		if (current_clip_origin == GL_UPPER_LEFT)
			clip_origin_lower_left = false;
	}
#endif

	// Setup viewport, orthographic projection matrix
	// Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
	GL_CALL(glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height));
	float L = draw_data->DisplayPos.x;
	float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;
	float T = draw_data->DisplayPos.y;
	float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;
#if defined(GL_CLIP_ORIGIN)
	if (!clip_origin_lower_left) {
		float tmp = T;
		T = B;
		B = tmp;
	} // Swap top and bottom if origin is upper left
#endif
	const float ortho_projection[4][4] = {
		{ 2.0f / (R - L), 0.0f, 0.0f, 0.0f },
		{ 0.0f, 2.0f / (T - B), 0.0f, 0.0f },
		{ 0.0f, 0.0f, -1.0f, 0.0f },
		{ (R + L) / (L - R), (T + B) / (B - T), 0.0f, 1.0f },
	};
	glUseProgram(bd->ShaderHandle);
	glUniform1i(bd->AttribLocationTex, 0);
	glUniformMatrix4fv(bd->AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);

#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
	if (bd->GlVersion >= 330 || bd->GlProfileIsES3)
		glBindSampler(0, 0); // We use combined texture/sampler state. Applications using GL 3.3 and GL ES 3.0 may set that otherwise.
#endif

	(void)vertex_array_object;
#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	glBindVertexArray(vertex_array_object);
#endif

	// Bind vertex/index buffers and setup attributes for ImDrawVert
	GL_CALL(glBindBuffer(GL_ARRAY_BUFFER, bd->VboHandle));
	GL_CALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bd->ElementsHandle));
	GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxPos));
	GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxUV));
	GL_CALL(glEnableVertexAttribArray(bd->AttribLocationVtxColor));
	GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxPos, 2, GL_FLOAT, GL_FALSE, sizeof(ImDrawVert), (GLvoid *)offsetof(ImDrawVert, pos)));
	GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxUV, 2, GL_FLOAT, GL_FALSE, sizeof(ImDrawVert), (GLvoid *)offsetof(ImDrawVert, uv)));
	GL_CALL(glVertexAttribPointer(bd->AttribLocationVtxColor, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(ImDrawVert), (GLvoid *)offsetof(ImDrawVert, col)));
}

// OpenGL3 Render function.
// Note that this implementation is little overcomplicated because we are saving/setting up/restoring every OpenGL state explicitly.
// This is in order to be able to run within an OpenGL engine that doesn't do so.
void ImGui_ImplOpenGL3_RenderDrawData(ImDrawData *draw_data) {
	// Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
	int fb_width = (int)(draw_data->DisplaySize.x * draw_data->FramebufferScale.x);
	int fb_height = (int)(draw_data->DisplaySize.y * draw_data->FramebufferScale.y);
	if (fb_width <= 0 || fb_height <= 0)
		return;

	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();

	// Backup GL state
	GLenum last_active_texture;
	glGetIntegerv(GL_ACTIVE_TEXTURE, (GLint *)&last_active_texture);
	glActiveTexture(GL_TEXTURE0);
	GLuint last_program;
	glGetIntegerv(GL_CURRENT_PROGRAM, (GLint *)&last_program);
	GLuint last_texture;
	glGetIntegerv(GL_TEXTURE_BINDING_2D, (GLint *)&last_texture);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
	GLuint last_sampler;
	if (bd->GlVersion >= 330 || bd->GlProfileIsES3) {
		glGetIntegerv(GL_SAMPLER_BINDING, (GLint *)&last_sampler);
	} else {
		last_sampler = 0;
	}
#endif
	GLuint last_array_buffer;
	glGetIntegerv(GL_ARRAY_BUFFER_BINDING, (GLint *)&last_array_buffer);
#ifndef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	// This is part of VAO on OpenGL 3.0+ and OpenGL ES 3.0+.
	GLint last_element_array_buffer;
	glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &last_element_array_buffer);
	ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_pos;
	last_vtx_attrib_state_pos.GetState(bd->AttribLocationVtxPos);
	ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_uv;
	last_vtx_attrib_state_uv.GetState(bd->AttribLocationVtxUV);
	ImGui_ImplOpenGL3_VtxAttribState last_vtx_attrib_state_color;
	last_vtx_attrib_state_color.GetState(bd->AttribLocationVtxColor);
#endif
#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	GLuint last_vertex_array_object;
	glGetIntegerv(GL_VERTEX_ARRAY_BINDING, (GLint *)&last_vertex_array_object);
#endif
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
	GLint last_polygon_mode[2];
	if (bd->HasPolygonMode) {
		glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode);
	}
#endif
	GLint last_viewport[4];
	glGetIntegerv(GL_VIEWPORT, last_viewport);
	GLint last_scissor_box[4];
	glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);
	GLenum last_blend_src_rgb;
	glGetIntegerv(GL_BLEND_SRC_RGB, (GLint *)&last_blend_src_rgb);
	GLenum last_blend_dst_rgb;
	glGetIntegerv(GL_BLEND_DST_RGB, (GLint *)&last_blend_dst_rgb);
	GLenum last_blend_src_alpha;
	glGetIntegerv(GL_BLEND_SRC_ALPHA, (GLint *)&last_blend_src_alpha);
	GLenum last_blend_dst_alpha;
	glGetIntegerv(GL_BLEND_DST_ALPHA, (GLint *)&last_blend_dst_alpha);
	GLenum last_blend_equation_rgb;
	glGetIntegerv(GL_BLEND_EQUATION_RGB, (GLint *)&last_blend_equation_rgb);
	GLenum last_blend_equation_alpha;
	glGetIntegerv(GL_BLEND_EQUATION_ALPHA, (GLint *)&last_blend_equation_alpha);
	GLboolean last_enable_blend = glIsEnabled(GL_BLEND);
	GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);
	GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);
	GLboolean last_enable_stencil_test = glIsEnabled(GL_STENCIL_TEST);
	GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
	GLboolean last_enable_primitive_restart = (bd->GlVersion >= 310) ? glIsEnabled(GL_PRIMITIVE_RESTART) : GL_FALSE;
#endif

	// Setup desired GL state
	// Recreate the VAO every time (this is to easily allow multiple GL contexts to be rendered to. VAO are not shared among GL contexts)
	// The renderer would actually work without any VAO bound, but then our VertexAttrib calls would overwrite the default one currently bound.
	GLuint vertex_array_object = 0;
#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	GL_CALL(glGenVertexArrays(1, &vertex_array_object));
#endif
	ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);

	// Will project scissor/clipping rectangles into framebuffer space
	ImVec2 clip_off = draw_data->DisplayPos; // (0,0) unless using multi-viewports
	ImVec2 clip_scale = draw_data->FramebufferScale; // (1,1) unless using retina display which are often (2,2)

	// Render command lists
	for (int n = 0; n < draw_data->CmdListsCount; n++) {
		const ImDrawList *cmd_list = draw_data->CmdLists[n];

		// Upload vertex/index buffers
		// - OpenGL drivers are in a very sorry state nowadays....
		//   During 2021 we attempted to switch from glBufferData() to orphaning+glBufferSubData() following reports
		//   of leaks on Intel GPU when using multi-viewports on Windows.
		// - After this we kept hearing of various display corruptions issues. We started disabling on non-Intel GPU, but issues still got reported on Intel.
		// - We are now back to using exclusively glBufferData(). So bd->UseBufferSubData IS ALWAYS FALSE in this code.
		//   We are keeping the old code path for a while in case people finding new issues may want to test the bd->UseBufferSubData path.
		// - See https://github.com/ocornut/imgui/issues/4468 and please report any corruption issues.
		const GLsizeiptr vtx_buffer_size = (GLsizeiptr)cmd_list->VtxBuffer.Size * (int)sizeof(ImDrawVert);
		const GLsizeiptr idx_buffer_size = (GLsizeiptr)cmd_list->IdxBuffer.Size * (int)sizeof(ImDrawIdx);
		if (bd->UseBufferSubData) {
			if (bd->VertexBufferSize < vtx_buffer_size) {
				bd->VertexBufferSize = vtx_buffer_size;
				GL_CALL(glBufferData(GL_ARRAY_BUFFER, bd->VertexBufferSize, nullptr, GL_STREAM_DRAW));
			}
			if (bd->IndexBufferSize < idx_buffer_size) {
				bd->IndexBufferSize = idx_buffer_size;
				GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, bd->IndexBufferSize, nullptr, GL_STREAM_DRAW));
			}
			GL_CALL(glBufferSubData(GL_ARRAY_BUFFER, 0, vtx_buffer_size, (const GLvoid *)cmd_list->VtxBuffer.Data));
			GL_CALL(glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, idx_buffer_size, (const GLvoid *)cmd_list->IdxBuffer.Data));
		} else {
			GL_CALL(glBufferData(GL_ARRAY_BUFFER, vtx_buffer_size, (const GLvoid *)cmd_list->VtxBuffer.Data, GL_STREAM_DRAW));
			GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, idx_buffer_size, (const GLvoid *)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW));
		}

		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++) {
			const ImDrawCmd *pcmd = &cmd_list->CmdBuffer[cmd_i];
			if (pcmd->UserCallback != nullptr) {
				// User callback, registered via ImDrawList::AddCallback()
				// (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
				if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
					ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);
				else
					pcmd->UserCallback(cmd_list, pcmd);
			} else {
				// Project scissor/clipping rectangles into framebuffer space
				ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
				ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);
				if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
					continue;

				// Apply scissor/clipping rectangle (Y is inverted in OpenGL)
				GL_CALL(glScissor((int)clip_min.x, (int)((float)fb_height - clip_max.y), (int)(clip_max.x - clip_min.x), (int)(clip_max.y - clip_min.y)));

				// Bind texture, Draw
				GL_CALL(glBindTexture(GL_TEXTURE_2D, (GLuint)(intptr_t)pcmd->GetTexID()));
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_VTX_OFFSET
				if (bd->GlVersion >= 320)
					GL_CALL(glDrawElementsBaseVertex(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void *)(intptr_t)(pcmd->IdxOffset * sizeof(ImDrawIdx)), (GLint)pcmd->VtxOffset));
				else
#endif
					GL_CALL(glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void *)(intptr_t)(pcmd->IdxOffset * sizeof(ImDrawIdx))));
			}
		}
	}

	// Destroy the temporary VAO
#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	GL_CALL(glDeleteVertexArrays(1, &vertex_array_object));
#endif

	// Restore modified GL state
	// This "glIsProgram()" check is required because if the program is "pending deletion" at the time of binding backup, it will have been deleted by now and will cause an OpenGL error. See #6220.
	if (last_program == 0 || glIsProgram(last_program))
		glUseProgram(last_program);
	glBindTexture(GL_TEXTURE_2D, last_texture);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_SAMPLER
	if (bd->GlVersion >= 330 || bd->GlProfileIsES3)
		glBindSampler(0, last_sampler);
#endif
	glActiveTexture(last_active_texture);
#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	glBindVertexArray(last_vertex_array_object);
#endif
	glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
#ifndef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, last_element_array_buffer);
	last_vtx_attrib_state_pos.SetState(bd->AttribLocationVtxPos);
	last_vtx_attrib_state_uv.SetState(bd->AttribLocationVtxUV);
	last_vtx_attrib_state_color.SetState(bd->AttribLocationVtxColor);
#endif
	glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
	glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);
	if (last_enable_blend)
		glEnable(GL_BLEND);
	else
		glDisable(GL_BLEND);
	if (last_enable_cull_face)
		glEnable(GL_CULL_FACE);
	else
		glDisable(GL_CULL_FACE);
	if (last_enable_depth_test)
		glEnable(GL_DEPTH_TEST);
	else
		glDisable(GL_DEPTH_TEST);
	if (last_enable_stencil_test)
		glEnable(GL_STENCIL_TEST);
	else
		glDisable(GL_STENCIL_TEST);
	if (last_enable_scissor_test)
		glEnable(GL_SCISSOR_TEST);
	else
		glDisable(GL_SCISSOR_TEST);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_PRIMITIVE_RESTART
	if (bd->GlVersion >= 310) {
		if (last_enable_primitive_restart)
			glEnable(GL_PRIMITIVE_RESTART);
		else
			glDisable(GL_PRIMITIVE_RESTART);
	}
#endif

#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE
	// Desktop OpenGL 3.0 and OpenGL 3.1 had separate polygon draw modes for front-facing and back-facing faces of polygons
	if (bd->HasPolygonMode) {
		if (bd->GlVersion <= 310 || bd->GlProfileIsCompat) {
			glPolygonMode(GL_FRONT, (GLenum)last_polygon_mode[0]);
			glPolygonMode(GL_BACK, (GLenum)last_polygon_mode[1]);
		} else {
			glPolygonMode(GL_FRONT_AND_BACK, (GLenum)last_polygon_mode[0]);
		}
	}
#endif // IMGUI_IMPL_OPENGL_MAY_HAVE_POLYGON_MODE

	glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
	glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);
	(void)bd; // Not all compilation paths use this
}

bool ImGui_ImplOpenGL3_CreateFontsTexture() {
	ImGuiIO &io = ImGui::GetIO();
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();

	// Build texture atlas
	unsigned char *pixels;
	int width, height;
	io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); // Load as RGBA 32-bit (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.

	// Upload texture to graphics system
	// (Bilinear sampling is required by default. Set 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest sampling)
	GLint last_texture;
	GL_CALL(glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture));
	GL_CALL(glGenTextures(1, &bd->FontTexture));
	GL_CALL(glBindTexture(GL_TEXTURE_2D, bd->FontTexture));
	GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
	GL_CALL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
#ifdef GL_UNPACK_ROW_LENGTH // Not on WebGL/ES
	GL_CALL(glPixelStorei(GL_UNPACK_ROW_LENGTH, 0));
#endif
	GL_CALL(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels));

	// Store our identifier
	io.Fonts->SetTexID((ImTextureID)(intptr_t)bd->FontTexture);

	// Restore state
	GL_CALL(glBindTexture(GL_TEXTURE_2D, last_texture));

	return true;
}

void ImGui_ImplOpenGL3_DestroyFontsTexture() {
	ImGuiIO &io = ImGui::GetIO();
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();
	if (bd->FontTexture) {
		glDeleteTextures(1, &bd->FontTexture);
		io.Fonts->SetTexID(0);
		bd->FontTexture = 0;
	}
}

// If you get an error please report on github. You may try different GL context version or GLSL version. See GL<>GLSL version table at the top of this file.
static bool CheckShader(GLuint handle, const char *desc) {
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();
	GLint status = 0, log_length = 0;
	glGetShaderiv(handle, GL_COMPILE_STATUS, &status);
	glGetShaderiv(handle, GL_INFO_LOG_LENGTH, &log_length);
	if ((GLboolean)status == GL_FALSE)
		fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to compile %s! With GLSL: %s\n", desc, bd->GlslVersionString);
	if (log_length > 1) {
		ImVector<char> buf;
		buf.resize((int)(log_length + 1));
		glGetShaderInfoLog(handle, log_length, nullptr, (GLchar *)buf.begin());
		fprintf(stderr, "%s\n", buf.begin());
	}
	return (GLboolean)status == GL_TRUE;
}

// If you get an error please report on GitHub. You may try different GL context version or GLSL version.
static bool CheckProgram(GLuint handle, const char *desc) {
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();
	GLint status = 0, log_length = 0;
	glGetProgramiv(handle, GL_LINK_STATUS, &status);
	glGetProgramiv(handle, GL_INFO_LOG_LENGTH, &log_length);
	if ((GLboolean)status == GL_FALSE)
		fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to link %s! With GLSL %s\n", desc, bd->GlslVersionString);
	if (log_length > 1) {
		ImVector<char> buf;
		buf.resize((int)(log_length + 1));
		glGetProgramInfoLog(handle, log_length, nullptr, (GLchar *)buf.begin());
		fprintf(stderr, "%s\n", buf.begin());
	}
	return (GLboolean)status == GL_TRUE;
}

bool ImGui_ImplOpenGL3_CreateDeviceObjects() {
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();

	// Backup GL state
	GLint last_texture, last_array_buffer;
	glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
	glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_BUFFER_PIXEL_UNPACK
	GLint last_pixel_unpack_buffer = 0;
	if (bd->GlVersion >= 210) {
		glGetIntegerv(GL_PIXEL_UNPACK_BUFFER_BINDING, &last_pixel_unpack_buffer);
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
	}
#endif
#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	GLint last_vertex_array;
	glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);
#endif

	// Parse GLSL version string
	int glsl_version = 130;
	sscanf(bd->GlslVersionString, "#version %d", &glsl_version);

	const GLchar *vertex_shader_glsl_120 =
			"uniform mat4 ProjMtx;\n"
			"attribute vec2 Position;\n"
			"attribute vec2 UV;\n"
			"attribute vec4 Color;\n"
			"varying vec2 Frag_UV;\n"
			"varying vec4 Frag_Color;\n"
			"void main()\n"
			"{\n"
			"    Frag_UV = UV;\n"
			"    Frag_Color = Color;\n"
			"    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
			"}\n";

	const GLchar *vertex_shader_glsl_130 =
			"uniform mat4 ProjMtx;\n"
			"in vec2 Position;\n"
			"in vec2 UV;\n"
			"in vec4 Color;\n"
			"out vec2 Frag_UV;\n"
			"out vec4 Frag_Color;\n"
			"void main()\n"
			"{\n"
			"    Frag_UV = UV;\n"
			"    Frag_Color = Color;\n"
			"    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
			"}\n";

	const GLchar *vertex_shader_glsl_300_es =
			"precision highp float;\n"
			"layout (location = 0) in vec2 Position;\n"
			"layout (location = 1) in vec2 UV;\n"
			"layout (location = 2) in vec4 Color;\n"
			"uniform mat4 ProjMtx;\n"
			"out vec2 Frag_UV;\n"
			"out vec4 Frag_Color;\n"
			"void main()\n"
			"{\n"
			"    Frag_UV = UV;\n"
			"    Frag_Color = Color;\n"
			"    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
			"}\n";

	const GLchar *vertex_shader_glsl_410_core =
			"layout (location = 0) in vec2 Position;\n"
			"layout (location = 1) in vec2 UV;\n"
			"layout (location = 2) in vec4 Color;\n"
			"uniform mat4 ProjMtx;\n"
			"out vec2 Frag_UV;\n"
			"out vec4 Frag_Color;\n"
			"void main()\n"
			"{\n"
			"    Frag_UV = UV;\n"
			"    Frag_Color = Color;\n"
			"    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
			"}\n";

	const GLchar *fragment_shader_glsl_120 =
			"#ifdef GL_ES\n"
			"    precision mediump float;\n"
			"#endif\n"
			"uniform sampler2D Texture;\n"
			"varying vec2 Frag_UV;\n"
			"varying vec4 Frag_Color;\n"
			"void main()\n"
			"{\n"
			"    gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV.st);\n"
			"}\n";

	const GLchar *fragment_shader_glsl_130 =
			"uniform sampler2D Texture;\n"
			"in vec2 Frag_UV;\n"
			"in vec4 Frag_Color;\n"
			"out vec4 Out_Color;\n"
			"void main()\n"
			"{\n"
			"    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
			"}\n";

	const GLchar *fragment_shader_glsl_300_es =
			"precision mediump float;\n"
			"uniform sampler2D Texture;\n"
			"in vec2 Frag_UV;\n"
			"in vec4 Frag_Color;\n"
			"layout (location = 0) out vec4 Out_Color;\n"
			"void main()\n"
			"{\n"
			"    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
			"}\n";

	const GLchar *fragment_shader_glsl_410_core =
			"in vec2 Frag_UV;\n"
			"in vec4 Frag_Color;\n"
			"uniform sampler2D Texture;\n"
			"layout (location = 0) out vec4 Out_Color;\n"
			"void main()\n"
			"{\n"
			"    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"
			"}\n";

	// Select shaders matching our GLSL versions
	const GLchar *vertex_shader = nullptr;
	const GLchar *fragment_shader = nullptr;
	if (glsl_version < 130) {
		vertex_shader = vertex_shader_glsl_120;
		fragment_shader = fragment_shader_glsl_120;
	} else if (glsl_version >= 410) {
		vertex_shader = vertex_shader_glsl_410_core;
		fragment_shader = fragment_shader_glsl_410_core;
	} else if (glsl_version == 300) {
		vertex_shader = vertex_shader_glsl_300_es;
		fragment_shader = fragment_shader_glsl_300_es;
	} else {
		vertex_shader = vertex_shader_glsl_130;
		fragment_shader = fragment_shader_glsl_130;
	}

	// Create shaders
	const GLchar *vertex_shader_with_version[2] = { bd->GlslVersionString, vertex_shader };
	GLuint vert_handle = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vert_handle, 2, vertex_shader_with_version, nullptr);
	glCompileShader(vert_handle);
	CheckShader(vert_handle, "vertex shader");

	const GLchar *fragment_shader_with_version[2] = { bd->GlslVersionString, fragment_shader };
	GLuint frag_handle = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(frag_handle, 2, fragment_shader_with_version, nullptr);
	glCompileShader(frag_handle);
	CheckShader(frag_handle, "fragment shader");

	// Link
	bd->ShaderHandle = glCreateProgram();
	glAttachShader(bd->ShaderHandle, vert_handle);
	glAttachShader(bd->ShaderHandle, frag_handle);
	glLinkProgram(bd->ShaderHandle);
	CheckProgram(bd->ShaderHandle, "shader program");

	glDetachShader(bd->ShaderHandle, vert_handle);
	glDetachShader(bd->ShaderHandle, frag_handle);
	glDeleteShader(vert_handle);
	glDeleteShader(frag_handle);

	bd->AttribLocationTex = glGetUniformLocation(bd->ShaderHandle, "Texture");
	bd->AttribLocationProjMtx = glGetUniformLocation(bd->ShaderHandle, "ProjMtx");
	bd->AttribLocationVtxPos = (GLuint)glGetAttribLocation(bd->ShaderHandle, "Position");
	bd->AttribLocationVtxUV = (GLuint)glGetAttribLocation(bd->ShaderHandle, "UV");
	bd->AttribLocationVtxColor = (GLuint)glGetAttribLocation(bd->ShaderHandle, "Color");

	// Create buffers
	glGenBuffers(1, &bd->VboHandle);
	glGenBuffers(1, &bd->ElementsHandle);

	ImGui_ImplOpenGL3_CreateFontsTexture();

	// Restore modified GL state
	glBindTexture(GL_TEXTURE_2D, last_texture);
	glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
#ifdef IMGUI_IMPL_OPENGL_MAY_HAVE_BIND_BUFFER_PIXEL_UNPACK
	if (bd->GlVersion >= 210) {
		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, last_pixel_unpack_buffer);
	}
#endif
#ifdef IMGUI_IMPL_OPENGL_USE_VERTEX_ARRAY
	glBindVertexArray(last_vertex_array);
#endif

	return true;
}

void ImGui_ImplOpenGL3_DestroyDeviceObjects() {
	ImGui_ImplOpenGL3_Data *bd = ImGui_ImplOpenGL3_GetBackendData();
	if (bd->VboHandle) {
		glDeleteBuffers(1, &bd->VboHandle);
		bd->VboHandle = 0;
	}
	if (bd->ElementsHandle) {
		glDeleteBuffers(1, &bd->ElementsHandle);
		bd->ElementsHandle = 0;
	}
	if (bd->ShaderHandle) {
		glDeleteProgram(bd->ShaderHandle);
		bd->ShaderHandle = 0;
	}
	ImGui_ImplOpenGL3_DestroyFontsTexture();
}

//-----------------------------------------------------------------------------

#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#endif // #ifndef IMGUI_DISABLE
#line 0

#line 1 "sfw/render_gui/gui.cpp"

void GUI::test() {
	ImGuiIO &io = ImGui::GetIO();
	(void)io;

	// Our state
	static bool show_another_window = false;
	static ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

	// 2. Show a simple window that we create ourselves. We use a Begin/End pair to create a named window.
	{
		static float f = 0.0f;
		static int counter = 0;

		ImGui::Begin("Hello, world!"); // Create a window called "Hello, world!" and append into it.

		ImGui::Text("This is some useful text."); // Display some text (you can use a format strings too)
		ImGui::Checkbox("Another Window", &show_another_window);

		ImGui::SliderFloat("float", &f, 0.0f, 1.0f); // Edit 1 float using a slider from 0.0f to 1.0f
		ImGui::ColorEdit3("clear color", (float *)&clear_color); // Edit 3 floats representing a color

		if (ImGui::Button("Button")) // Buttons return true when clicked (most widgets return true when edited/activated)
			counter++;
		ImGui::SameLine();
		ImGui::Text("counter = %d", counter);

		ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
		ImGui::End();
	}

	// 3. Show another simple window.
	if (show_another_window) {
		ImGui::Begin("Another Window", &show_another_window); // Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)
		ImGui::Text("Hello from another window!");
		if (ImGui::Button("Close Me"))
			show_another_window = false;
		ImGui::End();
	}
}

void GUI::initialize() {
	ERR_FAIL_COND(_singleton);

	memnew(GUI);

	// Decide GL+GLSL versions
#if defined(__APPLE__)
	const char *glsl_version = "#version 120";
#else
	// GL ES 2.0 + GLSL 100
	const char *glsl_version = "#version 100";
#endif

	// Setup Dear ImGui context
	IMGUI_CHECKVERSION();
	ImGui::CreateContext();
	ImGuiIO &io = ImGui::GetIO();
	(void)io;
	io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
	io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; // Enable Gamepad Controls

	// Setup Dear ImGui style
	ImGui::StyleColorsDark();
	//ImGui::StyleColorsLight();

	GLFWwindow *window = (GLFWwindow *)AppWindow::get_singleton()->get_window_handle();

	// Setup Platform/Renderer backends
	ImGui_ImplGlfw_InitForOpenGL(window, true);
#ifdef __EMSCRIPTEN__
	ImGui_ImplGlfw_InstallEmscriptenCallbacks(window, "#canvas");
#endif
	ImGui_ImplOpenGL3_Init(glsl_version);

	// Load Fonts
	// - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.
	// - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.
	// - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).
	// - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.
	// - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.
	// - Read 'docs/FONTS.md' for more instructions and details.
	// - Remember that in C/C++ if you want to include a backslash \ in a string literal you need to write a double backslash \\ !
	// - Our Emscripten build process allows embedding fonts to be accessible at runtime from the "fonts/" folder. See Makefile.emscripten for details.
	//io.Fonts->AddFontDefault();
	//io.Fonts->AddFontFromFileTTF("c:\\Windows\\Fonts\\segoeui.ttf", 18.0f);
	//io.Fonts->AddFontFromFileTTF("../../misc/fonts/DroidSans.ttf", 16.0f);
	//io.Fonts->AddFontFromFileTTF("../../misc/fonts/Roboto-Medium.ttf", 16.0f);
	//io.Fonts->AddFontFromFileTTF("../../misc/fonts/Cousine-Regular.ttf", 15.0f);
	//ImFont* font = io.Fonts->AddFontFromFileTTF("c:\\Windows\\Fonts\\ArialUni.ttf", 18.0f, nullptr, io.Fonts->GetGlyphRangesJapanese());
	//IM_ASSERT(font != nullptr);
}

void GUI::destroy() {
	// Cleanup
	ImGui_ImplOpenGL3_Shutdown();
	ImGui_ImplGlfw_Shutdown();
	ImGui::DestroyContext();

	ERR_FAIL_COND(!_singleton);
	memdelete(_singleton);
}

void GUI::new_frame() {
	// Start the Dear ImGui frame
	ImGui_ImplOpenGL3_NewFrame();
	ImGui_ImplGlfw_NewFrame();
	ImGui::NewFrame();
}

void GUI::render() {
	// Rendering
	ImGui::Render();
	ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
}

GUI::GUI() {
	_singleton = this;
}

GUI::~GUI() {
	_singleton = NULL;
}

GUI *GUI::get_singleton() {
	return _singleton;
}

GUI *GUI::_singleton = NULL;
#line 0
